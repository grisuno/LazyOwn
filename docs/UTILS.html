<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>LazyOwn Framework Doc: UTILS.md</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">LazyOwn Framework Doc: UTILS.md</h1>
</header>
<h1 id="utils.md-documentation-by-readmeneitor.py">UTILS.md
Documentation by readmeneitor.py</h1>
<h2 id="check_go_tool_installed">check_go_tool_installed</h2>
<p>No description available.</p>
<h2 id="parse_ip_mac">parse_ip_mac</h2>
<p>Extracts IP and MAC addresses from a formatted input string using a
regular expression.</p>
<p>The input string is expected to be in the format: ‘IP:
(192.168.1.222) MAC: ec:c3:02:b0:4c:96’. The function uses a regular
expression to match and extract the IP address and MAC address from the
input.</p>
<p>Args: input_string (str): The formatted string containing the IP and
MAC addresses.</p>
<p>Returns: tuple: A tuple containing the extracted IP address and MAC
address. If the format is incorrect, returns (None, None).</p>
<h2 id="strip_ansi">strip_ansi</h2>
<p>No description available.</p>
<h2 id="create_arp_packet">create_arp_packet</h2>
<p>Constructs an ARP packet with the given source and destination IP and
MAC addresses.</p>
<p>The function creates both Ethernet and ARP headers, combining them
into a complete ARP packet.</p>
<p>Args: src_mac (str): Source MAC address in the format
‘xx:xx:xx:xx:xx:xx’. src_ip (str): Source IP address in dotted decimal
format (e.g., ‘192.168.1.1’). dst_ip (str): Destination IP address in
dotted decimal format (e.g., ‘192.168.1.2’). dst_mac (str): Destination
MAC address in the format ‘xx:xx:xx:xx:xx:xx’.</p>
<p>Returns: bytes: The constructed ARP packet containing the Ethernet
and ARP headers.</p>
<h2 id="send_packet">send_packet</h2>
<p>Sends a raw ARP packet over the specified network interface.</p>
<p>The function creates a raw socket, binds it to the specified network
interface, and sends the given packet.</p>
<p>Args: packet (bytes): The ARP packet to be sent. iface (str): The
name of the network interface to use for sending the packet (e.g.,
‘eth0’).</p>
<p>Raises: OSError: If an error occurs while creating the socket or
sending the packet.</p>
<h2 id="load_version">load_version</h2>
<p>Load the version number from the ‘version.json’ file.</p>
<p>This function attempts to open the ‘version.json’ file and load its
contents. If the file is found, it retrieves the version number from the
JSON data. If the version key does not exist, it returns a default
version ‘release/v0.0.14’. If the file is not found, it also returns the
default version.</p>
<p>Returns: - str: The version number from the file or the default
version if the file is not found or the version key is missing.</p>
<h2 id="print_error">print_error</h2>
<p>Prints an error message to the console.</p>
<p>This function takes an error message as input and prints it to the
console with a specific format to indicate that it is an error.</p>
<p>:param error: The error message to be printed. :type error: str
:return: None</p>
<h2 id="print_msg">print_msg</h2>
<p>Prints a message to the console.</p>
<p>This function takes a message as input and prints it to the console
with a specific format to indicate that it is an informational
message.</p>
<p>:param msg: The message to be printed. :type msg: str :return:
None</p>
<h2 id="print_warn">print_warn</h2>
<p>Prints a warning message to the console.</p>
<p>This function takes a warning message as input and prints it to the
console with a specific format to indicate that it is a warning.</p>
<p>:param warn: The warning message to be printed. :type warn: str
:return: None</p>
<h2 id="signal_handler">signal_handler</h2>
<p>Handles signals such as Control + C and shows a message on how to
exit.</p>
<p>This function is used to handle signals like Control + C (SIGINT) and
prints a warning message instructing the user on how to exit the program
using the commands ‘exit’, ‘q’, or ‘qa’.</p>
<p>:param sig: The signal number. :type sig: int :param frame: The
current stack frame. :type frame: frame :return: None</p>
<h2 id="check_rhost">check_rhost</h2>
<p>Checks if the remote host (rhost) is defined and shows an error
message if it is not.</p>
<p>This function verifies if the <code>rhost</code> parameter is set. If
it is not defined, an error message is printed, providing an example and
directing the user to additional help.</p>
<p>:param rhost: The remote host to be checked. :type rhost: str
:return: True if rhost is defined, False otherwise. :rtype: bool</p>
<h2 id="check_lhost">check_lhost</h2>
<p>Checks if the local host (lhost) is defined and shows an error
message if it is not.</p>
<p>This function verifies if the <code>lhost</code> parameter is set. If
it is not defined, an error message is printed, providing an example and
directing the user to additional help.</p>
<p>:param lhost: The local host to be checked. :type lhost: str :return:
True if lhost is defined, False otherwise. :rtype: bool</p>
<h2 id="check_lport">check_lport</h2>
<p>Checks if the local port (lport) is defined and shows an error
message if it is not.</p>
<p>This function verifies if the <code>lport</code> parameter is set. If
it is not defined, an error message is printed, providing an example and
directing the user to additional help.</p>
<p>:param lport: The local port to be checked. :type lport: int or str
:return: True if lport is defined, False otherwise. :rtype: bool</p>
<h2 id="is_binary_present">is_binary_present</h2>
<p>Internal function to verify if a binary is present on the operating
system.</p>
<p>This function checks if a specified binary is available in the
system’s PATH by using the <code>which</code> command. It returns True
if the binary is found and False otherwise.</p>
<p>:param binary_name: The name of the binary to be checked. :type
binary_name: str :return: True if the binary is present, False
otherwise. :rtype: bool</p>
<h2 id="handle_multiple_rhosts">handle_multiple_rhosts</h2>
<p>Internal function to handle multiple remote hosts (rhost) for
operations.</p>
<p>This function is a decorator that allows an operation to be performed
across multiple remote hosts specified in
<code>self.params["rhost"]</code>. It converts a single remote host into
a list if necessary, and then iterates over each host, performing the
given function with each host. After the operation, it restores the
original remote host value.</p>
<p>:param func: The function to be decorated and executed for each
remote host. :type func: function :return: The decorated function.
:rtype: function</p>
<h2 id="check_sudo">check_sudo</h2>
<p>Checks if the script is running with superuser (sudo) privileges, and
if not, restarts the script with sudo privileges.</p>
<p>This function verifies if the script is being executed with root
privileges by checking the effective user ID. If the script is not
running as root, it prints a warning message and restarts the script
using sudo.</p>
<p>:return: None</p>
<h2 id="activate_virtualenv">activate_virtualenv</h2>
<p>Activates a virtual environment and starts an interactive shell.</p>
<p>This function activates a virtual environment located at
<code>venv_path</code> and then launches an interactive bash shell with
the virtual environment activated.</p>
<p>:param venv_path: The path to the virtual environment directory.
:type venv_path: str :return: None</p>
<h2 id="parse_proc_net_file">parse_proc_net_file</h2>
<p>Internal function to parse a /proc/net file and extract network
ports.</p>
<p>This function reads a file specified by <code>file_path</code>,
processes each line to extract local addresses and ports, and converts
them from hexadecimal to decimal. The IP addresses are converted from
hexadecimal format to standard dot-decimal notation. The function
returns a list of tuples, each containing an IP address and a port
number.</p>
<p>:param file_path: The path to the /proc/net file to be parsed. :type
file_path: str :return: A list of tuples, each containing an IP address
and a port number. :rtype: list of tuple</p>
<h2 id="get_open_ports">get_open_ports</h2>
<p>Internal function to get open TCP and UDP ports on the operating
system.</p>
<p>This function uses the <code>parse_proc_net_file</code> function to
extract open TCP and UDP ports from the corresponding /proc/net files.
It returns two lists: one for TCP ports and one for UDP ports.</p>
<p>:return: A tuple containing two lists: the first list with open TCP
ports and the second list with open UDP ports. :rtype: tuple of (list of
tuple, list of tuple)</p>
<h2 id="find_credentials">find_credentials</h2>
<p>Searches for potential credentials in files within the specified
directory.</p>
<p>This function uses a regular expression to find possible credentials
such as passwords, secrets, API keys, and tokens in files within the
given directory. It iterates through all files in the directory and
prints any matches found.</p>
<p>:param directory: The directory to search for files containing
credentials. :type directory: str :return: None</p>
<h2 id="rotate_char">rotate_char</h2>
<p>Internal function to rotate characters for ROT cipher.</p>
<p>This function takes a character and a shift value, and rotates the
character by the specified shift amount. It only affects alphabetical
characters, leaving non-alphabetical characters unchanged.</p>
<p>:param c: The character to be rotated. :type c: str :param shift: The
number of positions to shift the character. :type shift: int :return:
The rotated character. :rtype: str</p>
<h2 id="get_network_info">get_network_info</h2>
<p>Retrieves network interface information with their associated IP
addresses.</p>
<p>This function executes a shell command to gather network interface
details, parses the output to extract interface names and their
corresponding IP addresses, and returns this information in a dictionary
format. The dictionary keys are interface names, and the values are IP
addresses.</p>
<p>:return: A dictionary where the keys are network interface names and
the values are their associated IP addresses. :rtype: dict</p>
<h2 id="get_git_info">get_git_info</h2>
<p>No description available.</p>
<h2 id="get_venv_info">get_venv_info</h2>
<p>No description available.</p>
<h2 id="getprompt">getprompt</h2>
<p>Generate a command prompt string with network information, user
status, and icons.</p>
<h2 id="copy2clip">copy2clip</h2>
<p>Copia el texto proporcionado al portapapeles usando xclip.</p>
<p>Args: text (str): El texto que se desea copiar al portapapeles.</p>
<p>Example: copy2clip(“Hello, World!”)</p>
<h2 id="clean_output">clean_output</h2>
<p>Elimina secuencias de escape de color y otros caracteres no
imprimibles.</p>
<h2 id="teclado_usuario">teclado_usuario</h2>
<p>Procesa un archivo para extraer y mostrar caracteres desde secuencias
de escritura específicas.</p>
<p>Args: filename (str): El nombre del archivo a leer.</p>
<p>Raises: FileNotFoundError: Si el archivo no se encuentra. Exception:
Para otros errores que puedan ocurrir.</p>
<h2 id="salida_strace">salida_strace</h2>
<p>Lee un archivo, extrae texto desde secuencias de escritura y muestra
el contenido reconstruido.</p>
<p>Args: filename (str): El nombre del archivo a leer.</p>
<p>Raises: FileNotFoundError: Si el archivo no se encuentra. Exception:
Para otros errores que puedan ocurrir.</p>
<h2 id="exploitalert">exploitalert</h2>
<p>Process and display results from ExploitAlert.</p>
<p>This function checks if the provided content contains any results. If
results are present, it prints the title and link for each exploit
found, and appends the results to a predata list. If no results are
found, it prints an error message.</p>
<p>Parameters: - content (list): A list of dictionaries containing
exploit information.</p>
<p>Returns: None Thanks to Sicat 🐈 An excellent tool for CVE detection,
I implemented only the keyword search as I had to change some libraries.
Soon also for XML generated by nmap :) Total thanks to justakazh.
https://github.com/justakazh/sicat/</p>
<h2 id="packetstormsecurity">packetstormsecurity</h2>
<p>Process and display results from PacketStorm Security.</p>
<p>This function extracts exploit data from the provided content using
regex. If any results are found, it prints the title and link for each
exploit, and appends the results to a predata list. If no results are
found, it prints an error message.</p>
<p>Parameters: - content (str): The HTML content from PacketStorm
Security.</p>
<p>Returns: None Thanks to Sicat 🐈 An excellent tool for CVE detection,
I implemented only the keyword search as I had to change some libraries.
Soon also for XML generated by nmap :) Total thanks to justakazh.
https://github.com/justakazh/sicat/</p>
<h2 id="nvddb">nvddb</h2>
<p>Process and display results from the National Vulnerability
Database.</p>
<p>This function checks if there are any vulnerabilities in the provided
content. If vulnerabilities are present, it prints the ID, description,
and link for each CVE found, and appends the results to a predata list.
If no results are found, it prints an error message.</p>
<p>Parameters: - content (dict): A dictionary containing vulnerability
data.</p>
<p>Returns: None Thanks to Sicat 🐈 An excellent tool for CVE detection,
I implemented only the keyword search as I had to change some libraries.
Soon also for XML generated by nmap :) Total thanks to justakazh.
https://github.com/justakazh/sicat/</p>
<h2 id="find_ss">find_ss</h2>
<p>Find CVEs in the National Vulnerability Database based on a
keyword.</p>
<p>This function takes a keyword, formats it for the API request, and
sends a GET request to the NVD API. If the request is successful, it
returns the JSON response containing CVE data; otherwise, it returns
False.</p>
<p>Parameters: - keyword (str): The keyword to search for in CVEs.</p>
<p>Returns: - dict or bool: The JSON response containing CVE data or
False on failure. Thanks to Sicat 🐈 An excellent tool for CVE
detection, I implemented only the keyword search as I had to change some
libraries. Soon also for XML generated by nmap :) Total thanks to
justakazh. https://github.com/justakazh/sicat/</p>
<h2 id="find_ea">find_ea</h2>
<p>Find exploits in ExploitAlert based on a keyword.</p>
<p>This function takes a keyword, formats it for the API request, and
sends a GET request to the ExploitAlert API. If the request is
successful, it returns the JSON response containing exploit data;
otherwise, it returns False.</p>
<p>Parameters: - keyword (str): The keyword to search for exploits.</p>
<p>Returns: - dict or bool: The JSON response containing exploit data or
False on failure. Thanks to Sicat 🐈 An excellent tool for CVE
detection, I implemented only the keyword search as I had to change some
libraries. Soon also for XML generated by nmap :) Total thanks to
justakazh. https://github.com/justakazh/sicat/</p>
<h2 id="find_ps">find_ps</h2>
<p>Find exploits in PacketStorm Security based on a keyword.</p>
<p>This function takes a keyword, formats it for the search request, and
sends a GET request to the PacketStorm Security website. If the request
is successful, it returns the HTML response; otherwise, it returns
False.</p>
<p>Parameters: - keyword (str): The keyword to search for exploits.</p>
<p>Returns: - str or bool: The HTML response containing exploit data or
False on failure. Thanks to Sicat 🐈 An excellent tool for CVE
detection, I implemented only the keyword search as I had to change some
libraries. Soon also for XML generated by nmap :) Total thanks to
justakazh. https://github.com/justakazh/sicat/</p>
<h2 id="xor_encrypt_decrypt">xor_encrypt_decrypt</h2>
<p>Encrypts or decrypts data using XOR encryption with the provided
key.</p>
<p>Parameters: data (bytes or bytearray): The input data to be encrypted
or decrypted. key (str): The encryption key as a string.</p>
<p>Returns: bytearray: The result of the XOR operation, which can be
either the encrypted or decrypted data.</p>
<p>Example: encrypted_data = xor_encrypt_decrypt(b”Hello, World!“,”key”)
decrypted_data = xor_encrypt_decrypt(encrypted_data, “key”)
print(decrypted_data.decode(“utf-8”)) # Outputs: Hello, World!</p>
<p>Additional Notes: - XOR encryption is symmetric, meaning that the
same function is used for both encryption and decryption. - The key is
repeated cyclically to match the length of the data if necessary. - This
method is commonly used for simple encryption tasks, but it is not
secure for protecting sensitive information.</p>
<h2 id="run">run</h2>
<p>Executes a shell command using the subprocess module, capturing its
output.</p>
<p>Parameters: command (str): The command to execute.</p>
<p>Returns: str: The output of the command if successful, or an error
message if an exception occurs.</p>
<p>Exceptions: - FileNotFoundError: Raised if the command is not found.
- subprocess.CalledProcessError: Raised if the command exits with a
non-zero status. - subprocess.TimeoutExpired: Raised if the command
times out. - Exception: Catches any other unexpected exceptions.</p>
<p>Example: output = run(“ls -la”) print(output)</p>
<p>Additional Notes: The function attempts to execute the provided
command, capturing its output. It also handles common exceptions that
may occur during command execution.</p>
<h2 id="is_exist">is_exist</h2>
<p>Check if a file exists.</p>
<p>This function checks whether a given file exists on the filesystem.
If the file does not exist, it prints an error message and returns
False. Otherwise, it returns True.</p>
<p>Arguments: file (str): The path to the file that needs to be
checked.</p>
<p>Returns: bool: Returns True if the file exists, False otherwise.</p>
<p>Example: &gt;&gt;&gt; is_exist(‘/path/to/file.txt’) True &gt;&gt;&gt;
is_exist(‘/non/existent/file.txt’) False</p>
<p>Notes: This function uses os.path.isfile to determine the existence
of the file. Ensure that the provided path is correct and
accessible.</p>
<h2 id="get_domain">get_domain</h2>
<p>Extracts the domain from a given URL.</p>
<p>Parameters: url (str): The full URL from which to extract the
domain.</p>
<p>Returns: str: The extracted domain from the URL, or None if it cannot
be extracted.</p>
<h2 id="generate_certificates">generate_certificates</h2>
<p>Generates a certificate authority (CA), client certificate, and
client key.</p>
<p>Returns: str: Paths to the generated CA certificate, client
certificate, and client key.</p>
<h2 id="generate_emails">generate_emails</h2>
<p>Generate email permutations based on the provided full name and
domain.</p>
<p>This function takes a full name and domain as input, splits the full
name into components, and creates a list of potential email
addresses.</p>
<p>Parameters: full_name (str): The full name to base the email
addresses on. domain (str): The domain to use for the generated email
addresses.</p>
<p>Internal Variables: names (list): A list of the name components
extracted from the full name. first_name (str): The first name
component. last_name (str): The last name component. first_initial
(str): The first initial of the first name. last_initial (str): The
first initial of the last name.</p>
<p>Returns: list: A list of generated email permutations.</p>
<p>Note: - At least two parts of the name are required to generate valid
email addresses.</p>
<h2 id="clean_url">clean_url</h2>
<p>Verifica si el último carácter es una barra y, de ser así, la
elimina</p>
<h2 id="random_string">random_string</h2>
<p>Generates a random alphanumeric string.</p>
<h2 id="generate_http_req">generate_http_req</h2>
<p>Generates an HTTP request with the Shellshock payload.</p>
<h2 id="format_openssh_key">format_openssh_key</h2>
<p>Formats a raw OpenSSH private key string to the correct OpenSSH
format.</p>
<p>This function takes a raw OpenSSH private key string, cleans it by
removing any unnecessary characters (such as newlines, spaces, and
headers/footers), splits the key content into lines of 64 characters,
and then reassembles the key with the standard OpenSSH header and
footer. It ensures the key follows the correct OpenSSH format.</p>
<p>Parameters: raw_key (str): The raw OpenSSH private key string to
format.</p>
<p>Returns: str: The formatted OpenSSH private key with proper headers,
footers, and 64-character lines.</p>
<h2 id="format_rsa_key">format_rsa_key</h2>
<p>Formats a raw RSA private key string to the correct PEM format.</p>
<p>This function takes a raw RSA private key string, cleans it by
removing any unnecessary characters (such as newlines, spaces, and
headers/footers), splits the key content into lines of 64 characters,
and then reassembles the key with the standard PEM header and footer. It
ensures the key follows the correct RSA format.</p>
<p>Parameters: raw_key (str): The raw RSA private key string to
format.</p>
<p>Returns: str: The formatted RSA private key with proper headers,
footers, and 64-character lines.</p>
<h2 id="is_package_installed">is_package_installed</h2>
<p>Check if a Python package is installed.</p>
<p>:param package_name: Name of the package to check. :returns: True if
installed, False otherwise.</p>
<h2 id="extract">extract</h2>
<p>Extracts and processes specific hexadecimal sequences from a string
based on a flag.</p>
<p>If the <code>extract_flag</code> is set to True, the function
extracts all sequences of the form ‘x[a-f0-9][a-f0-9]’ (where ‘x’ is
followed by two hexadecimal digits), removes the ‘x’ from the extracted
sequences, and returns the processed string. If
<code>extract_flag</code> is False, the function returns the original
string.</p>
<p>Parameters: string (str): The input string from which hexadecimal
sequences are to be extracted. extract_flag (bool): A flag indicating
whether to perform the extraction (True) or not (False).</p>
<p>Returns: str: The processed string with the extracted hexadecimal
sequences if <code>extract_flag</code> is True, or the original string
if <code>extract_flag</code> is False.</p>
<h2 id="clean_html">clean_html</h2>
<p>Remove HTML tags from a string.</p>
<p>This function uses a regular expression to strip HTML tags and return
plain text.</p>
<p>:param html_string: A string containing HTML content. :returns: A
cleaned string with HTML tags removed.</p>
<h2 id="command">command</h2>
<p>Run a command, print output in real-time, and store the output in a
variable.</p>
<p>This method executes a given command using
<code>subprocess.Popen</code>, streams both the standard output and
standard error to the console in real-time, and stores the full output
(stdout and stderr) in a variable. If interrupted, the process is
terminated gracefully.</p>
<p>:param command: The command to be executed as a string. :type
command: str</p>
<p>:returns: The full output of the command (stdout and stderr). :rtype:
str</p>
<p>Example: To execute a command, call
<code>run_command("ls -l")</code>.</p>
<h2 id="generate_random_cve_id">generate_random_cve_id</h2>
<p>Generates a random CVE (Common Vulnerabilities and Exposures) ID.</p>
<p>This function creates a random CVE ID by selecting a random year
between 2020 and 2024, and a random code between 1000 and 9999. The CVE
ID is returned in the format ‘CVE-{year}-{code}’.</p>
<p>Returns: str: A randomly generated CVE ID in the format
‘CVE-{year}-{code}’.</p>
<h2 id="get_credentials">get_credentials</h2>
<p>Searches for credential files with the pattern ’credentials*.txt’ and
allows the user to select one.</p>
<p>The function lists all matching files and prompts the user to select
one. It then reads the selected file and returns a list of tuples with
the format (username, password) for each line in the file.</p>
<p>Parameters: ncred (int, optional): If provided, automatically selects
the credential file with the given number.</p>
<p>Returns: list of tuples: A list containing tuples with (username,
password) for each credential found in the file. If no files are found
or an invalid selection is made, an empty list is returned.</p>
<h2 id="load_payload">load_payload</h2>
<p>No description available.</p>
<h2 id="obfuscate_payload">obfuscate_payload</h2>
<p>Obfuscates a payload string by converting its characters into
hexadecimal format, with additional comments for every third
character.</p>
<p>For every character in the payload, the function converts it to its
hexadecimal representation. Every third character (after the first) is
enclosed in a comment <code>/*hex_value*/</code>, while the rest are
prefixed with <code>\x</code>.</p>
<p>Parameters: payload (str): The input string that needs to be
obfuscated.</p>
<p>Returns: str: The obfuscated string where characters are replaced by
their hexadecimal representations, with every third character wrapped in
a comment.</p>
<h2 id="read_payloads">read_payloads</h2>
<p>Reads a file containing payloads and returns a list of properly
formatted strings.</p>
<p>This function opens a specified file, reads each line, and checks if
the line starts with a double quote. If it does not, it adds double
quotes around the line. Each line is stripped of leading and trailing
whitespace before being added to the list.</p>
<p>Parameters: file_path (str): The path to the file containing
payloads.</p>
<p>Returns: list: A list of strings, each representing a payload from
the file, formatted with leading and trailing double quotes if
necessary.</p>
<h2 id="inject_payloads">inject_payloads</h2>
<p>Sends HTTP requests to a list of URLs with injected payloads for
testing XSS vulnerabilities.</p>
<p>This function reads payloads from a specified file and sends GET
requests to the provided URLs, injecting obfuscated payloads into the
query parameters or form fields to test for cross-site scripting (XSS)
vulnerabilities. It handles both URLs with existing query parameters and
those without. If forms are found in the response, it submits them with
the payloads as well.</p>
<p>Parameters: urls (list): A list of URLs to test for XSS
vulnerabilities. payload_url (str): A placeholder string within the
payloads that will be replaced with the actual URL for testing.
request_timeout (int, optional): The timeout for each request in
seconds. Defaults to 15.</p>
<p>Returns: None: This function does not return any value but prints the
status of each request and form submission to the console.</p>
<p>Raises: requests.RequestException: Raises an exception if any HTTP
request fails, which is handled by printing a warning message.</p>
<h2 id="prompt">prompt</h2>
<p>Return the prompt in the function do_xss</p>
<h2 id="is_lower">is_lower</h2>
<p>Checks if a character is lowercase.</p>
<p>Parameters: char (str): The character to check.</p>
<p>Returns: bool: True if the character is lowercase, False
otherwise.</p>
<h2 id="is_upper">is_upper</h2>
<p>Checks if a character is uppercase.</p>
<p>Parameters: char (str): The character to check.</p>
<p>Returns: bool: True if the character is uppercase, False
otherwise.</p>
<h2 id="is_mixed">is_mixed</h2>
<p>Determines if a string contains both lowercase and uppercase
characters.</p>
<p>Parameters: s (str): The string to check.</p>
<p>Returns: bool: True if the string has mixed casing, False
otherwise.</p>
<h2 id="add">add</h2>
<p>Adds a delimiter between string parts if it’s not the first part.</p>
<p>Parameters: str_part (str): The string part to add. delimiter (str):
The delimiter to insert between parts. i (int): The index of the
part.</p>
<p>Returns: str: The string part with delimiter if applicable.</p>
<h2 id="detect_delimiter">detect_delimiter</h2>
<p>Detects the delimiter used in the input string (e.g., “-”,
“_“,”.”).</p>
<p>Parameters: foo_bar (str): The input string.</p>
<p>Returns: str: The detected delimiter.</p>
<h2 id="transform">transform</h2>
<p>Transforms a list of string parts based on the chosen casing
style.</p>
<p>Parameters: parts (list): List of string parts. delimiter (str):
Delimiter to use between parts. casing (str): Casing style (‘l’, ‘u’,
‘c’, ‘p’).</p>
<p>Returns: str: The transformed string.</p>
<h2 id="handle">handle</h2>
<p>Splits the input string into parts based on delimiters or mixed
casing.</p>
<p>Parameters: input_str (str): The input string to split.</p>
<p>Returns: list: A list of string parts.</p>
<h2 id="get_users_dic">get_users_dic</h2>
<p>List all .txt files in the ‘sessions/’ directory and prompt the user
to select one by number.</p>
<p>:returns: The path of the selected .txt file.</p>
<h2 id="get_hash">get_hash</h2>
<p>Searches for hash files with the pattern ’hash*.txt’ and allows the
user to select one.</p>
<p>The function lists all matching files and prompts the user to select
one. It then reads the selected file and returns the hash content as a
single string, without any newline characters or extra formatting.</p>
<p>Returns: str: The hash content from the selected file as a single
string. If no files are found or an invalid selection is made, an empty
string is returned.</p>
<h2 id="is_digit">is_digit</h2>
<p>Check if the given character is a digit.</p>
<p>Args: the_digit (str): The character to check.</p>
<p>Returns: bool: True if the character is a digit, False otherwise.</p>
<h2 id="crack_password">crack_password</h2>
<p>Crack a Cisco Type 7 password.</p>
<p>Args: crypttext (str): The encrypted password in Type 7 format.</p>
<p>Returns: str: The cracked plaintext password or an empty string if
invalid.</p>
<h2 id="get_terminal_size">get_terminal_size</h2>
<p>No description available.</p>
<h2 id="halp">halp</h2>
<p>Display the help panel for the LazyOwn RedTeam Framework.</p>
<p>This function prints usage instructions, options, and descriptions
for running the LazyOwn framework. It provides users with an overview of
command-line options that can be used when executing the
<code>./run</code> command.</p>
<p>The output includes the current version of the framework and various
options available for users, along with a brief description of each
option.</p>
<p>Options include: - <code>--help</code>: Displays the help panel. -
<code>-v</code>: Shows the version of the framework. -
<code>-p &lt;payloadN.json&gt;</code>: Executes the framework with a
specified payload JSON file. This option is particularly useful for Red
Teams. - <code>-c &lt;command&gt;</code>: Executes a specific command
using LazyOwn, for example, <code>ping</code>. -
<code>--no-banner</code>: Runs the framework without displaying the
banner. - <code>-s</code>: Runs the framework with root privileges. -
<code>--old-banner</code>: Displays the old banner.</p>
<p>Example: To see the help panel, call the function as follows:</p>
<pre><code>&gt;&gt;&gt; halp()</code></pre>
<p>Note: - This function exits the program after displaying the help
information, using <code>sys.exit(0)</code>.</p>
<h2 id="ensure_tmux_session">ensure_tmux_session</h2>
<p>Ensure that a tmux session is active.</p>
<p>This function checks whether a specified tmux session is currently
running. If the session does not exist, it creates a new tmux session
with the specified name and executes the command to run the LazyOwn
RedTeam Framework script.</p>
<p>The function uses the <code>tmux has-session</code> command to check
for the existence of the session. If the session is not found (i.e., the
return code is not zero), it will create a new tmux session in detached
mode and run the command <code>./run --no-banner</code> within that
session.</p>
<p>Args: session_name (str): The name of the tmux session to check or
create.</p>
<p>Example: To ensure that a tmux session named ‘lazyown_sessions’ is
active, call the function as follows:</p>
<pre><code>&gt;&gt;&gt; ensure_tmux_session(&#39;lazyown_sessions&#39;)</code></pre>
<p>Note: - Ensure that tmux is installed and properly configured on the
system. - The command executed within the tmux session must be valid and
accessible in the current environment.</p>
<h2 id="get_xml">get_xml</h2>
<p>Retrieves a list of XML files from the specified directory.</p>
<p>Args: directory (str): The directory to search for XML files.</p>
<p>Returns: list: A list of XML filenames found in the specified
directory.</p>
<h2 id="get_domain_from_xml">get_domain_from_xml</h2>
<p>Extrae el primer dominio o dirección IP de un archivo XML de un
escaneo Nmap.</p>
<h2 id="shellcode_to_sylk">shellcode_to_sylk</h2>
<p>No description available.</p>
<h2 id="get_banner">get_banner</h2>
<p>No description available.</p>
<h2 id="list_binaries">list_binaries</h2>
<p>List all executable binaries in the specified directory.</p>
<p>Parameters: directory (str): The directory to search for binaries.
Defaults to ‘sessions’.</p>
<p>Returns: list: A list of paths to executable binaries.</p>
<h2 id="select_binary">select_binary</h2>
<p>Prompt the user to select a binary from a list.</p>
<p>Parameters: binaries (list): A list of binary paths.</p>
<p>Returns: str: The path of the selected binary.</p>
<h2 id="decode">decode</h2>
<p>Decodes base64 data received from the server output.</p>
<p>Parameters: data (str): Encoded base64 data from the server.</p>
<p>Returns: str: Decoded string output, or an error message if decoding
fails.</p>
<h2 id="get_command">get_command</h2>
<p>Reads a command from standard input and initiates a thread to send
the command to the target server.</p>
<h2 id="send_command">send_command</h2>
<p>Constructs and sends an SQL payload with xp_cmdshell and certutil for
command execution and exfiltration.</p>
<p>Parameters: cmd (str): Command to be executed on the remote MSSQL
server.</p>
<h2 id="activate_server">activate_server</h2>
<p>Activates the HTTP server and fetches the first command from the
user.</p>
<p>Parameters: httpd (HTTPServer): The server instance to activate.</p>
<h2 id="spray">Spray</h2>
<p>No description available.</p>
<h2 id="processresults">ProcessResults</h2>
<p>No description available.</p>
<h2 id="generate_index">generate_index</h2>
<p>Generates an APT repository structure and index files for proper
compatibility.</p>
<p>Parameters: repo_dir (str): Path to the repository directory.</p>
<p>Returns: None</p>
<h2 id="replace_variables">replace_variables</h2>
<p>Replace variables in a command string with their corresponding
values.</p>
<p>This function takes a command string and a dictionary of variables
and their values. It replaces each occurrence of a variable in the
command string with its corresponding value.</p>
<p>Args: command (str): The command string containing variables to be
replaced. variables (dict): A dictionary where the keys are the
variables to be replaced and the values are the corresponding values to
replace them with.</p>
<p>Returns: str: The command string with all variables replaced by their
corresponding values.</p>
<h2 id="create_caldera_config">create_caldera_config</h2>
<p>Creates a Caldera configuration file with the specified content at
the given file path.</p>
<p>Parameters: file_path (str): The path where the configuration file
will be created.</p>
<p>Returns: None</p>
<h2 id="extract_banners">extract_banners</h2>
<p>Extract banner information from an XML file.</p>
<p>This function parses an XML file and extracts banner information for
each host and port. The banner information includes the hostname, port,
protocol, extra details, and service.</p>
<p>Args: xml_file (str): The path to the XML file to be parsed.</p>
<p>Returns: list: A list of dictionaries, where each dictionary contains
banner information for a specific host and port. Each dictionary has the
following keys: - hostname (str): The hostname of the host. - port
(str): The port number. - protocol (str): The protocol used (e.g., tcp,
udp). - banner (str): Extra information about the service. - service
(str): The name of the service running on the port.</p>
<p>Example: banners = extract_banners(‘path/to/file.xml’)</p>
<h2 id="generate_xor_key">generate_xor_key</h2>
<p>Generate key XOR long specifyed</p>
<p>:param length: Lenght of XOR key :return: Key XOR in hex.</p>
<h2 id="scrape_news">scrape_news</h2>
<p>Realiza una solicitud a la página de noticias de Hacker News y extrae
los títulos, enlaces y puntuaciones de las noticias.</p>
<p>Returns: tuple: Tres listas conteniendo los títulos, enlaces y
puntuaciones de las noticias respectivamente.</p>
<h2 id="display_news">display_news</h2>
<p>Crea un DataFrame de pandas y lo imprime, mostrando los títulos,
enlaces y puntuaciones de las noticias.</p>
<p>Args: titles (list): Lista de títulos de las noticias. links (list):
Lista de enlaces de las noticias. scores (list): Lista de puntuaciones
de las noticias.</p>
<h2 id="htmlify">htmlify</h2>
<p>Wrap C2 comms in html and html2 code to make requests look more
legitimate</p>
<h2 id="de_htmlify">de_htmlify</h2>
<p>Cleant wrap C2 comms of html and html2 code to get the command from
request</p>
<h2 id="is_port_in_use">is_port_in_use</h2>
<p>No description available.</p>
<h2 id="return_creds">return_creds</h2>
<p>No description available.</p>
<h2 id="query_arin_ip">query_arin_ip</h2>
<p>Queries ARIN whois API for organization information of an IP
address.</p>
<p>Args: ip: The IP address to query.</p>
<p>Returns: A dictionary containing IP information or None on
failure.</p>
<h2 id="get_org">get_org</h2>
<p>Extracts organization name from ARIN whois response data.</p>
<p>Args: data: The JSON data from the ARIN whois API response.</p>
<p>Returns: The organization name or “null” if not found.</p>
<h2 id="load_payload-1">load_payload</h2>
<p>No description available.</p>
<h2 id="load_adversary">load_adversary</h2>
<p>No description available.</p>
<h2 id="replace_placeholders">replace_placeholders</h2>
<p>Replace placeholders in a template string with values from a
dictionary.</p>
<p>Parameters: template (str): The template string containing
placeholders. replacements (dict): A dictionary where keys are
placeholders and values are replacements.</p>
<p>Returns: str: The template string with placeholders replaced.</p>
<h2 id="replace_command_placeholders">replace_command_placeholders</h2>
<p>Replace placeholders in a command string with values from a params
dictionary, handling spaces within placeholders.</p>
<p>The function looks for placeholders in curly braces (e.g., {url} or {
url }) within the command string and replaces them with corresponding
values from the params dictionary, ignoring any spaces inside the curly
braces.</p>
<p>Args: command (str): The command string containing placeholders.
params (dict): A dictionary containing key-value pairs for
replacement.</p>
<p>Returns: str: The command string with placeholders replaced by their
corresponding values.</p>
<h2 id="parse_nmap_csv">parse_nmap_csv</h2>
<p>No description available.</p>
<h2 id="query_ollama">query_ollama</h2>
<p>Envía consulta a Ollama y retorna respuesta del modelo</p>
<h2 id="preprocess_llm_response">preprocess_llm_response</h2>
<p>Pre-process LLM response to handle common issues before YAML
parsing</p>
<h2 id="manual_yaml_extraction">manual_yaml_extraction</h2>
<p>Fallback method to manually extract YAML data from malformed
content</p>
<h2 id="create_synthetic_yaml">create_synthetic_yaml</h2>
<p>Create a basic synthetic YAML playbook when all else fails</p>
<h2 id="parse_yaml_response">parse_yaml_response</h2>
<p>Improved function to extract and parse YAML content from LLM response
with better error handling and recovery attempts</p>
<h2 id="fix_common_yaml_issues">fix_common_yaml_issues</h2>
<p>Fixes common YAML formatting issues</p>
<h2 id="aggressive_yaml_fix">aggressive_yaml_fix</h2>
<p>More aggressive YAML fixing for recovery attempts</p>
<h2 id="save_playbook">save_playbook</h2>
<p>Guarda el playbook generado en disco</p>
<h2 id="load_knowledge_base">load_knowledge_base</h2>
<p>Carga la base de conocimientos personalizada.</p>
<h2 id="anti_debug">anti_debug</h2>
<p>No description available.</p>
<h2 id="create_msfshellcoder_parser">create_msfshellcoder_parser</h2>
<p>No description available.</p>
<h2 id="load_user_aliases">load_user_aliases</h2>
<p>Carga los aliases del archivo JSON si existe.</p>
<h2 id="aesencrypt">AESencrypt</h2>
<p>No description available.</p>
<h2 id="dropfile">dropFile</h2>
<p>No description available.</p>
<h2 id="wrapper">wrapper</h2>
<p>internal wrapper of internal function to implement multiples rhost to
operate.</p>
<h2 id="send_request">send_request</h2>
<p>No description available.</p>
<h2 id="handle_forms">handle_forms</h2>
<p>No description available.</p>
<h2 id="replace_match">replace_match</h2>
<p>No description available.</p>
<h2 id="log_request">log_request</h2>
<p>No description available.</p>
<h2 id="log_message">log_message</h2>
<p>No description available.</p>
<h2 id="get">GET</h2>
<p>No description available.</p>
<h2 id="init"><strong>init</strong></h2>
<p>No description available.</p>
<h2 id="open_file">open_file</h2>
<p>Open and parse the IP-to-ASN file.</p>
<h2 id="open_reader">open_reader</h2>
<p>Parse the reader stream, handling both regular and gzipped files.</p>
<h2 id="parse_file">_parse_file</h2>
<p>Parse the TSV data and load it into memory.</p>
<h2 id="as_of_ip">as_of_ip</h2>
<p>Return the ASN associated with the given IP address.</p>
<h2 id="rec_index_has_ip">_rec_index_has_ip</h2>
<p>Check if the given index contains the IP.</p>
<h2 id="as_name">as_name</h2>
<p>Get the AS name by ASN.</p>
<h2 id="as_country">as_country</h2>
<p>Get the country by ASN.</p>
<h2 id="init-1"><strong>init</strong></h2>
<p>No description available.</p>
<h2 id="getitem"><strong>getitem</strong></h2>
<p>No description available.</p>
<h2 id="init-2"><strong>init</strong></h2>
<p>Inicializa el escáner con las cabeceras HTTP predefinidas.</p>
<h2 id="search_cves">search_cves</h2>
<p>Busca CVEs basados en un servicio específico.</p>
<p>Args: service (str): El servicio para buscar vulnerabilidades
relacionadas.</p>
<p>Returns: list: Lista de diccionarios con información sobre cada CVE o
mensaje de error.</p>
<h2 id="search_cve_details">search_cve_details</h2>
<p>Añade detalles adicionales a la información del CVE.</p>
<p>Args: cve_info (dict): Información básica del CVE incluyendo id y
descripción.</p>
<h2 id="pretty_print">pretty_print</h2>
<p>Imprime una tabla bonita con detalles de CVEs.</p>
<p>Args: cves_details (list): Lista de CVEs con toda la información
recopilada.</p>
<h2 id="init-3"><strong>init</strong></h2>
<p>No description available.</p>
<h2 id="getitem-1"><strong>getitem</strong></h2>
<p>No description available.</p>
</body>
</html>
